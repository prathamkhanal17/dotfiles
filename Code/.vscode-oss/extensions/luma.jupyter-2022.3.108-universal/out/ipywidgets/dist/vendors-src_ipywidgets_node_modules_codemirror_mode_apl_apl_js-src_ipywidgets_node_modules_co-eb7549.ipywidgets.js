(self["webpackChunkjupyter"] = self["webpackChunkjupyter"] || []).push([["vendors-src_ipywidgets_node_modules_codemirror_mode_apl_apl_js-src_ipywidgets_node_modules_co-eb7549"],{

/***/ "./src/ipywidgets/node_modules/codemirror/mode/apl/apl.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("apl", function() {
  var builtInOps = {
    ".": "innerProduct",
    "\\": "scan",
    "/": "reduce",
    "⌿": "reduce1Axis",
    "⍀": "scan1Axis",
    "¨": "each",
    "⍣": "power"
  };
  var builtInFuncs = {
    "+": ["conjugate", "add"],
    "−": ["negate", "subtract"],
    "×": ["signOf", "multiply"],
    "÷": ["reciprocal", "divide"],
    "⌈": ["ceiling", "greaterOf"],
    "⌊": ["floor", "lesserOf"],
    "∣": ["absolute", "residue"],
    "⍳": ["indexGenerate", "indexOf"],
    "?": ["roll", "deal"],
    "⋆": ["exponentiate", "toThePowerOf"],
    "⍟": ["naturalLog", "logToTheBase"],
    "○": ["piTimes", "circularFuncs"],
    "!": ["factorial", "binomial"],
    "⌹": ["matrixInverse", "matrixDivide"],
    "<": [null, "lessThan"],
    "≤": [null, "lessThanOrEqual"],
    "=": [null, "equals"],
    ">": [null, "greaterThan"],
    "≥": [null, "greaterThanOrEqual"],
    "≠": [null, "notEqual"],
    "≡": ["depth", "match"],
    "≢": [null, "notMatch"],
    "∈": ["enlist", "membership"],
    "⍷": [null, "find"],
    "∪": ["unique", "union"],
    "∩": [null, "intersection"],
    "∼": ["not", "without"],
    "∨": [null, "or"],
    "∧": [null, "and"],
    "⍱": [null, "nor"],
    "⍲": [null, "nand"],
    "⍴": ["shapeOf", "reshape"],
    ",": ["ravel", "catenate"],
    "⍪": [null, "firstAxisCatenate"],
    "⌽": ["reverse", "rotate"],
    "⊖": ["axis1Reverse", "axis1Rotate"],
    "⍉": ["transpose", null],
    "↑": ["first", "take"],
    "↓": [null, "drop"],
    "⊂": ["enclose", "partitionWithAxis"],
    "⊃": ["diclose", "pick"],
    "⌷": [null, "index"],
    "⍋": ["gradeUp", null],
    "⍒": ["gradeDown", null],
    "⊤": ["encode", null],
    "⊥": ["decode", null],
    "⍕": ["format", "formatByExample"],
    "⍎": ["execute", null],
    "⊣": ["stop", "left"],
    "⊢": ["pass", "right"]
  };

  var isOperator = /[\.\/⌿⍀¨⍣]/;
  var isNiladic = /⍬/;
  var isFunction = /[\+−×÷⌈⌊∣⍳\?⋆⍟○!⌹<≤=>≥≠≡≢∈⍷∪∩∼∨∧⍱⍲⍴,⍪⌽⊖⍉↑↓⊂⊃⌷⍋⍒⊤⊥⍕⍎⊣⊢]/;
  var isArrow = /←/;
  var isComment = /[⍝#].*$/;

  var stringEater = function(type) {
    var prev;
    prev = false;
    return function(c) {
      prev = c;
      if (c === type) {
        return prev === "\\";
      }
      return true;
    };
  };
  return {
    startState: function() {
      return {
        prev: false,
        func: false,
        op: false,
        string: false,
        escape: false
      };
    },
    token: function(stream, state) {
      var ch, funcName;
      if (stream.eatSpace()) {
        return null;
      }
      ch = stream.next();
      if (ch === '"' || ch === "'") {
        stream.eatWhile(stringEater(ch));
        stream.next();
        state.prev = true;
        return "string";
      }
      if (/[\[{\(]/.test(ch)) {
        state.prev = false;
        return null;
      }
      if (/[\]}\)]/.test(ch)) {
        state.prev = true;
        return null;
      }
      if (isNiladic.test(ch)) {
        state.prev = false;
        return "niladic";
      }
      if (/[¯\d]/.test(ch)) {
        if (state.func) {
          state.func = false;
          state.prev = false;
        } else {
          state.prev = true;
        }
        stream.eatWhile(/[\w\.]/);
        return "number";
      }
      if (isOperator.test(ch)) {
        return "operator apl-" + builtInOps[ch];
      }
      if (isArrow.test(ch)) {
        return "apl-arrow";
      }
      if (isFunction.test(ch)) {
        funcName = "apl-";
        if (builtInFuncs[ch] != null) {
          if (state.prev) {
            funcName += builtInFuncs[ch][1];
          } else {
            funcName += builtInFuncs[ch][0];
          }
        }
        state.func = true;
        state.prev = false;
        return "function " + funcName;
      }
      if (isComment.test(ch)) {
        stream.skipToEnd();
        return "comment";
      }
      if (ch === "∘" && stream.peek() === ".") {
        stream.next();
        return "function jot-dot";
      }
      stream.eatWhile(/[\w\$_]/);
      state.prev = true;
      return "keyword";
    }
  };
});

CodeMirror.defineMIME("text/apl", "apl");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/asciiarmor/asciiarmor.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
  "use strict";

  function errorIfNotEmpty(stream) {
    var nonWS = stream.match(/^\s*\S/);
    stream.skipToEnd();
    return nonWS ? "error" : null;
  }

  CodeMirror.defineMode("asciiarmor", function() {
    return {
      token: function(stream, state) {
        var m;
        if (state.state == "top") {
          if (stream.sol() && (m = stream.match(/^-----BEGIN (.*)?-----\s*$/))) {
            state.state = "headers";
            state.type = m[1];
            return "tag";
          }
          return errorIfNotEmpty(stream);
        } else if (state.state == "headers") {
          if (stream.sol() && stream.match(/^\w+:/)) {
            state.state = "header";
            return "atom";
          } else {
            var result = errorIfNotEmpty(stream);
            if (result) state.state = "body";
            return result;
          }
        } else if (state.state == "header") {
          stream.skipToEnd();
          state.state = "headers";
          return "string";
        } else if (state.state == "body") {
          if (stream.sol() && (m = stream.match(/^-----END (.*)?-----\s*$/))) {
            if (m[1] != state.type) return "error";
            state.state = "end";
            return "tag";
          } else {
            if (stream.eatWhile(/[A-Za-z0-9+\/=]/)) {
              return null;
            } else {
              stream.next();
              return "error";
            }
          }
        } else if (state.state == "end") {
          return errorIfNotEmpty(stream);
        }
      },
      blankLine: function(state) {
        if (state.state == "headers") state.state = "body";
      },
      startState: function() {
        return {state: "top", type: null};
      }
    };
  });

  CodeMirror.defineMIME("application/pgp", "asciiarmor");
  CodeMirror.defineMIME("application/pgp-encrypted", "asciiarmor");
  CodeMirror.defineMIME("application/pgp-keys", "asciiarmor");
  CodeMirror.defineMIME("application/pgp-signature", "asciiarmor");
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/asn.1/asn.1.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
  "use strict";

  CodeMirror.defineMode("asn.1", function(config, parserConfig) {
    var indentUnit = config.indentUnit,
        keywords = parserConfig.keywords || {},
        cmipVerbs = parserConfig.cmipVerbs || {},
        compareTypes = parserConfig.compareTypes || {},
        status = parserConfig.status || {},
        tags = parserConfig.tags || {},
        storage = parserConfig.storage || {},
        modifier = parserConfig.modifier || {},
        accessTypes = parserConfig.accessTypes|| {},
        multiLineStrings = parserConfig.multiLineStrings,
        indentStatements = parserConfig.indentStatements !== false;
    var isOperatorChar = /[\|\^]/;
    var curPunc;

    function tokenBase(stream, state) {
      var ch = stream.next();
      if (ch == '"' || ch == "'") {
        state.tokenize = tokenString(ch);
        return state.tokenize(stream, state);
      }
      if (/[\[\]\(\){}:=,;]/.test(ch)) {
        curPunc = ch;
        return "punctuation";
      }
      if (ch == "-"){
        if (stream.eat("-")) {
          stream.skipToEnd();
          return "comment";
        }
      }
      if (/\d/.test(ch)) {
        stream.eatWhile(/[\w\.]/);
        return "number";
      }
      if (isOperatorChar.test(ch)) {
        stream.eatWhile(isOperatorChar);
        return "operator";
      }

      stream.eatWhile(/[\w\-]/);
      var cur = stream.current();
      if (keywords.propertyIsEnumerable(cur)) return "keyword";
      if (cmipVerbs.propertyIsEnumerable(cur)) return "variable cmipVerbs";
      if (compareTypes.propertyIsEnumerable(cur)) return "atom compareTypes";
      if (status.propertyIsEnumerable(cur)) return "comment status";
      if (tags.propertyIsEnumerable(cur)) return "variable-3 tags";
      if (storage.propertyIsEnumerable(cur)) return "builtin storage";
      if (modifier.propertyIsEnumerable(cur)) return "string-2 modifier";
      if (accessTypes.propertyIsEnumerable(cur)) return "atom accessTypes";

      return "variable";
    }

    function tokenString(quote) {
      return function(stream, state) {
        var escaped = false, next, end = false;
        while ((next = stream.next()) != null) {
          if (next == quote && !escaped){
            var afterNext = stream.peek();
            //look if the character if the quote is like the B in '10100010'B
            if (afterNext){
              afterNext = afterNext.toLowerCase();
              if(afterNext == "b" || afterNext == "h" || afterNext == "o")
                stream.next();
            }
            end = true; break;
          }
          escaped = !escaped && next == "\\";
        }
        if (end || !(escaped || multiLineStrings))
          state.tokenize = null;
        return "string";
      };
    }

    function Context(indented, column, type, align, prev) {
      this.indented = indented;
      this.column = column;
      this.type = type;
      this.align = align;
      this.prev = prev;
    }
    function pushContext(state, col, type) {
      var indent = state.indented;
      if (state.context && state.context.type == "statement")
        indent = state.context.indented;
      return state.context = new Context(indent, col, type, null, state.context);
    }
    function popContext(state) {
      var t = state.context.type;
      if (t == ")" || t == "]" || t == "}")
        state.indented = state.context.indented;
      return state.context = state.context.prev;
    }

    //Interface
    return {
      startState: function(basecolumn) {
        return {
          tokenize: null,
          context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),
          indented: 0,
          startOfLine: true
        };
      },

      token: function(stream, state) {
        var ctx = state.context;
        if (stream.sol()) {
          if (ctx.align == null) ctx.align = false;
          state.indented = stream.indentation();
          state.startOfLine = true;
        }
        if (stream.eatSpace()) return null;
        curPunc = null;
        var style = (state.tokenize || tokenBase)(stream, state);
        if (style == "comment") return style;
        if (ctx.align == null) ctx.align = true;

        if ((curPunc == ";" || curPunc == ":" || curPunc == ",")
            && ctx.type == "statement"){
          popContext(state);
        }
        else if (curPunc == "{") pushContext(state, stream.column(), "}");
        else if (curPunc == "[") pushContext(state, stream.column(), "]");
        else if (curPunc == "(") pushContext(state, stream.column(), ")");
        else if (curPunc == "}") {
          while (ctx.type == "statement") ctx = popContext(state);
          if (ctx.type == "}") ctx = popContext(state);
          while (ctx.type == "statement") ctx = popContext(state);
        }
        else if (curPunc == ctx.type) popContext(state);
        else if (indentStatements && (((ctx.type == "}" || ctx.type == "top")
            && curPunc != ';') || (ctx.type == "statement"
            && curPunc == "newstatement")))
          pushContext(state, stream.column(), "statement");

        state.startOfLine = false;
        return style;
      },

      electricChars: "{}",
      lineComment: "--",
      fold: "brace"
    };
  });

  function words(str) {
    var obj = {}, words = str.split(" ");
    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
    return obj;
  }

  CodeMirror.defineMIME("text/x-ttcn-asn", {
    name: "asn.1",
    keywords: words("DEFINITIONS OBJECTS IF DERIVED INFORMATION ACTION" +
    " REPLY ANY NAMED CHARACTERIZED BEHAVIOUR REGISTERED" +
    " WITH AS IDENTIFIED CONSTRAINED BY PRESENT BEGIN" +
    " IMPORTS FROM UNITS SYNTAX MIN-ACCESS MAX-ACCESS" +
    " MINACCESS MAXACCESS REVISION STATUS DESCRIPTION" +
    " SEQUENCE SET COMPONENTS OF CHOICE DistinguishedName" +
    " ENUMERATED SIZE MODULE END INDEX AUGMENTS EXTENSIBILITY" +
    " IMPLIED EXPORTS"),
    cmipVerbs: words("ACTIONS ADD GET NOTIFICATIONS REPLACE REMOVE"),
    compareTypes: words("OPTIONAL DEFAULT MANAGED MODULE-TYPE MODULE_IDENTITY" +
    " MODULE-COMPLIANCE OBJECT-TYPE OBJECT-IDENTITY" +
    " OBJECT-COMPLIANCE MODE CONFIRMED CONDITIONAL" +
    " SUBORDINATE SUPERIOR CLASS TRUE FALSE NULL" +
    " TEXTUAL-CONVENTION"),
    status: words("current deprecated mandatory obsolete"),
    tags: words("APPLICATION AUTOMATIC EXPLICIT IMPLICIT PRIVATE TAGS" +
    " UNIVERSAL"),
    storage: words("BOOLEAN INTEGER OBJECT IDENTIFIER BIT OCTET STRING" +
    " UTCTime InterfaceIndex IANAifType CMIP-Attribute" +
    " REAL PACKAGE PACKAGES IpAddress PhysAddress" +
    " NetworkAddress BITS BMPString TimeStamp TimeTicks" +
    " TruthValue RowStatus DisplayString GeneralString" +
    " GraphicString IA5String NumericString" +
    " PrintableString SnmpAdminString TeletexString" +
    " UTF8String VideotexString VisibleString StringStore" +
    " ISO646String T61String UniversalString Unsigned32" +
    " Integer32 Gauge Gauge32 Counter Counter32 Counter64"),
    modifier: words("ATTRIBUTE ATTRIBUTES MANDATORY-GROUP MANDATORY-GROUPS" +
    " GROUP GROUPS ELEMENTS EQUALITY ORDERING SUBSTRINGS" +
    " DEFINED"),
    accessTypes: words("not-accessible accessible-for-notify read-only" +
    " read-create read-write"),
    multiLineStrings: true
  });
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/asterisk/asterisk.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

/*
 * =====================================================================================
 *
 *       Filename:  mode/asterisk/asterisk.js
 *
 *    Description:  CodeMirror mode for Asterisk dialplan
 *
 *        Created:  05/17/2012 09:20:25 PM
 *       Revision:  08/05/2019 AstLinux Project: Support block-comments
 *
 *         Author:  Stas Kobzar (stas@modulis.ca),
 *        Company:  Modulis.ca Inc.
 *
 * =====================================================================================
 */

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("asterisk", function() {
  var atoms    = ["exten", "same", "include","ignorepat","switch"],
      dpcmd    = ["#include","#exec"],
      apps     = [
                  "addqueuemember","adsiprog","aelsub","agentlogin","agentmonitoroutgoing","agi",
                  "alarmreceiver","amd","answer","authenticate","background","backgrounddetect",
                  "bridge","busy","callcompletioncancel","callcompletionrequest","celgenuserevent",
                  "changemonitor","chanisavail","channelredirect","chanspy","clearhash","confbridge",
                  "congestion","continuewhile","controlplayback","dahdiacceptr2call","dahdibarge",
                  "dahdiras","dahdiscan","dahdisendcallreroutingfacility","dahdisendkeypadfacility",
                  "datetime","dbdel","dbdeltree","deadagi","dial","dictate","directory","disa",
                  "dumpchan","eagi","echo","endwhile","exec","execif","execiftime","exitwhile","extenspy",
                  "externalivr","festival","flash","followme","forkcdr","getcpeid","gosub","gosubif",
                  "goto","gotoif","gotoiftime","hangup","iax2provision","ices","importvar","incomplete",
                  "ivrdemo","jabberjoin","jabberleave","jabbersend","jabbersendgroup","jabberstatus",
                  "jack","log","macro","macroexclusive","macroexit","macroif","mailboxexists","meetme",
                  "meetmeadmin","meetmechanneladmin","meetmecount","milliwatt","minivmaccmess","minivmdelete",
                  "minivmgreet","minivmmwi","minivmnotify","minivmrecord","mixmonitor","monitor","morsecode",
                  "mp3player","mset","musiconhold","nbscat","nocdr","noop","odbc","odbc","odbcfinish",
                  "originate","ospauth","ospfinish","osplookup","ospnext","page","park","parkandannounce",
                  "parkedcall","pausemonitor","pausequeuemember","pickup","pickupchan","playback","playtones",
                  "privacymanager","proceeding","progress","queue","queuelog","raiseexception","read","readexten",
                  "readfile","receivefax","receivefax","receivefax","record","removequeuemember",
                  "resetcdr","retrydial","return","ringing","sayalpha","saycountedadj","saycountednoun",
                  "saycountpl","saydigits","saynumber","sayphonetic","sayunixtime","senddtmf","sendfax",
                  "sendfax","sendfax","sendimage","sendtext","sendurl","set","setamaflags",
                  "setcallerpres","setmusiconhold","sipaddheader","sipdtmfmode","sipremoveheader","skel",
                  "slastation","slatrunk","sms","softhangup","speechactivategrammar","speechbackground",
                  "speechcreate","speechdeactivategrammar","speechdestroy","speechloadgrammar","speechprocessingsound",
                  "speechstart","speechunloadgrammar","stackpop","startmusiconhold","stopmixmonitor","stopmonitor",
                  "stopmusiconhold","stopplaytones","system","testclient","testserver","transfer","tryexec",
                  "trysystem","unpausemonitor","unpausequeuemember","userevent","verbose","vmauthenticate",
                  "vmsayname","voicemail","voicemailmain","wait","waitexten","waitfornoise","waitforring",
                  "waitforsilence","waitmusiconhold","waituntil","while","zapateller"
                 ];

  function basicToken(stream,state){
    var cur = '';
    var ch = stream.next();
    // comment
    if (state.blockComment) {
      if (ch == "-" && stream.match("-;", true)) {
        state.blockComment = false;
      } else if (stream.skipTo("--;")) {
        stream.next();
        stream.next();
        stream.next();
        state.blockComment = false;
      } else {
        stream.skipToEnd();
      }
      return "comment";
    }
    if(ch == ";") {
      if (stream.match("--", true)) {
        if (!stream.match("-", false)) {  // Except ;--- is not a block comment
          state.blockComment = true;
          return "comment";
        }
      }
      stream.skipToEnd();
      return "comment";
    }
    // context
    if(ch == '[') {
      stream.skipTo(']');
      stream.eat(']');
      return "header";
    }
    // string
    if(ch == '"') {
      stream.skipTo('"');
      return "string";
    }
    if(ch == "'") {
      stream.skipTo("'");
      return "string-2";
    }
    // dialplan commands
    if(ch == '#') {
      stream.eatWhile(/\w/);
      cur = stream.current();
      if(dpcmd.indexOf(cur) !== -1) {
        stream.skipToEnd();
        return "strong";
      }
    }
    // application args
    if(ch == '$'){
      var ch1 = stream.peek();
      if(ch1 == '{'){
        stream.skipTo('}');
        stream.eat('}');
        return "variable-3";
      }
    }
    // extension
    stream.eatWhile(/\w/);
    cur = stream.current();
    if(atoms.indexOf(cur) !== -1) {
      state.extenStart = true;
      switch(cur) {
        case 'same': state.extenSame = true; break;
        case 'include':
        case 'switch':
        case 'ignorepat':
          state.extenInclude = true;break;
        default:break;
      }
      return "atom";
    }
  }

  return {
    startState: function() {
      return {
        blockComment: false,
        extenStart: false,
        extenSame:  false,
        extenInclude: false,
        extenExten: false,
        extenPriority: false,
        extenApplication: false
      };
    },
    token: function(stream, state) {

      var cur = '';
      if(stream.eatSpace()) return null;
      // extension started
      if(state.extenStart){
        stream.eatWhile(/[^\s]/);
        cur = stream.current();
        if(/^=>?$/.test(cur)){
          state.extenExten = true;
          state.extenStart = false;
          return "strong";
        } else {
          state.extenStart = false;
          stream.skipToEnd();
          return "error";
        }
      } else if(state.extenExten) {
        // set exten and priority
        state.extenExten = false;
        state.extenPriority = true;
        stream.eatWhile(/[^,]/);
        if(state.extenInclude) {
          stream.skipToEnd();
          state.extenPriority = false;
          state.extenInclude = false;
        }
        if(state.extenSame) {
          state.extenPriority = false;
          state.extenSame = false;
          state.extenApplication = true;
        }
        return "tag";
      } else if(state.extenPriority) {
        state.extenPriority = false;
        state.extenApplication = true;
        stream.next(); // get comma
        if(state.extenSame) return null;
        stream.eatWhile(/[^,]/);
        return "number";
      } else if(state.extenApplication) {
        stream.eatWhile(/,/);
        cur = stream.current();
        if(cur === ',') return null;
        stream.eatWhile(/\w/);
        cur = stream.current().toLowerCase();
        state.extenApplication = false;
        if(apps.indexOf(cur) !== -1){
          return "def strong";
        }
      } else{
        return basicToken(stream,state);
      }

      return null;
    },

    blockCommentStart: ";--",
    blockCommentEnd: "--;",
    lineComment: ";"
  };
});

CodeMirror.defineMIME("text/x-asterisk", "asterisk");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/brainfuck/brainfuck.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// Brainfuck mode created by Michael Kaminsky https://github.com/mkaminsky11

(function(mod) {
  if (true)
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"))
  else {}
})(function(CodeMirror) {
  "use strict"
  var reserve = "><+-.,[]".split("");
  /*
  comments can be either:
  placed behind lines

        +++    this is a comment

  where reserved characters cannot be used
  or in a loop
  [
    this is ok to use [ ] and stuff
  ]
  or preceded by #
  */
  CodeMirror.defineMode("brainfuck", function() {
    return {
      startState: function() {
        return {
          commentLine: false,
          left: 0,
          right: 0,
          commentLoop: false
        }
      },
      token: function(stream, state) {
        if (stream.eatSpace()) return null
        if(stream.sol()){
          state.commentLine = false;
        }
        var ch = stream.next().toString();
        if(reserve.indexOf(ch) !== -1){
          if(state.commentLine === true){
            if(stream.eol()){
              state.commentLine = false;
            }
            return "comment";
          }
          if(ch === "]" || ch === "["){
            if(ch === "["){
              state.left++;
            }
            else{
              state.right++;
            }
            return "bracket";
          }
          else if(ch === "+" || ch === "-"){
            return "keyword";
          }
          else if(ch === "<" || ch === ">"){
            return "atom";
          }
          else if(ch === "." || ch === ","){
            return "def";
          }
        }
        else{
          state.commentLine = true;
          if(stream.eol()){
            state.commentLine = false;
          }
          return "comment";
        }
        if(stream.eol()){
          state.commentLine = false;
        }
      }
    };
  });
CodeMirror.defineMIME("text/x-brainfuck","brainfuck")
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/clojure/clojure.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("clojure", function (options) {
  var atoms = ["false", "nil", "true"];
  var specialForms = [".", "catch", "def", "do", "if", "monitor-enter",
      "monitor-exit", "new", "quote", "recur", "set!", "throw", "try", "var"];
  var coreSymbols = ["*", "*'", "*1", "*2", "*3", "*agent*",
      "*allow-unresolved-vars*", "*assert*", "*clojure-version*",
      "*command-line-args*", "*compile-files*", "*compile-path*",
      "*compiler-options*", "*data-readers*", "*default-data-reader-fn*", "*e",
      "*err*", "*file*", "*flush-on-newline*", "*fn-loader*", "*in*",
      "*math-context*", "*ns*", "*out*", "*print-dup*", "*print-length*",
      "*print-level*", "*print-meta*", "*print-namespace-maps*",
      "*print-readably*", "*read-eval*", "*reader-resolver*", "*source-path*",
      "*suppress-read*", "*unchecked-math*", "*use-context-classloader*",
      "*verbose-defrecords*", "*warn-on-reflection*", "+", "+'", "-", "-'",
      "->", "->>", "->ArrayChunk", "->Eduction", "->Vec", "->VecNode",
      "->VecSeq", "-cache-protocol-fn", "-reset-methods", "..", "/", "<", "<=",
      "=", "==", ">", ">=", "EMPTY-NODE", "Inst", "StackTraceElement->vec",
      "Throwable->map", "accessor", "aclone", "add-classpath", "add-watch",
      "agent", "agent-error", "agent-errors", "aget", "alength", "alias",
      "all-ns", "alter", "alter-meta!", "alter-var-root", "amap", "ancestors",
      "and", "any?", "apply", "areduce", "array-map", "as->", "aset",
      "aset-boolean", "aset-byte", "aset-char", "aset-double", "aset-float",
      "aset-int", "aset-long", "aset-short", "assert", "assoc", "assoc!",
      "assoc-in", "associative?", "atom", "await", "await-for", "await1",
      "bases", "bean", "bigdec", "bigint", "biginteger", "binding", "bit-and",
      "bit-and-not", "bit-clear", "bit-flip", "bit-not", "bit-or", "bit-set",
      "bit-shift-left", "bit-shift-right", "bit-test", "bit-xor", "boolean",
      "boolean-array", "boolean?", "booleans", "bound-fn", "bound-fn*",
      "bound?", "bounded-count", "butlast", "byte", "byte-array", "bytes",
      "bytes?", "case", "cast", "cat", "char", "char-array",
      "char-escape-string", "char-name-string", "char?", "chars", "chunk",
      "chunk-append", "chunk-buffer", "chunk-cons", "chunk-first", "chunk-next",
      "chunk-rest", "chunked-seq?", "class", "class?", "clear-agent-errors",
      "clojure-version", "coll?", "comment", "commute", "comp", "comparator",
      "compare", "compare-and-set!", "compile", "complement", "completing",
      "concat", "cond", "cond->", "cond->>", "condp", "conj", "conj!", "cons",
      "constantly", "construct-proxy", "contains?", "count", "counted?",
      "create-ns", "create-struct", "cycle", "dec", "dec'", "decimal?",
      "declare", "dedupe", "default-data-readers", "definline", "definterface",
      "defmacro", "defmethod", "defmulti", "defn", "defn-", "defonce",
      "defprotocol", "defrecord", "defstruct", "deftype", "delay", "delay?",
      "deliver", "denominator", "deref", "derive", "descendants", "destructure",
      "disj", "disj!", "dissoc", "dissoc!", "distinct", "distinct?", "doall",
      "dorun", "doseq", "dosync", "dotimes", "doto", "double", "double-array",
      "double?", "doubles", "drop", "drop-last", "drop-while", "eduction",
      "empty", "empty?", "ensure", "ensure-reduced", "enumeration-seq",
      "error-handler", "error-mode", "eval", "even?", "every-pred", "every?",
      "ex-data", "ex-info", "extend", "extend-protocol", "extend-type",
      "extenders", "extends?", "false?", "ffirst", "file-seq", "filter",
      "filterv", "find", "find-keyword", "find-ns", "find-protocol-impl",
      "find-protocol-method", "find-var", "first", "flatten", "float",
      "float-array", "float?", "floats", "flush", "fn", "fn?", "fnext", "fnil",
      "for", "force", "format", "frequencies", "future", "future-call",
      "future-cancel", "future-cancelled?", "future-done?", "future?",
      "gen-class", "gen-interface", "gensym", "get", "get-in", "get-method",
      "get-proxy-class", "get-thread-bindings", "get-validator", "group-by",
      "halt-when", "hash", "hash-combine", "hash-map", "hash-ordered-coll",
      "hash-set", "hash-unordered-coll", "ident?", "identical?", "identity",
      "if-let", "if-not", "if-some", "ifn?", "import", "in-ns", "inc", "inc'",
      "indexed?", "init-proxy", "inst-ms", "inst-ms*", "inst?", "instance?",
      "int", "int-array", "int?", "integer?", "interleave", "intern",
      "interpose", "into", "into-array", "ints", "io!", "isa?", "iterate",
      "iterator-seq", "juxt", "keep", "keep-indexed", "key", "keys", "keyword",
      "keyword?", "last", "lazy-cat", "lazy-seq", "let", "letfn", "line-seq",
      "list", "list*", "list?", "load", "load-file", "load-reader",
      "load-string", "loaded-libs", "locking", "long", "long-array", "longs",
      "loop", "macroexpand", "macroexpand-1", "make-array", "make-hierarchy",
      "map", "map-entry?", "map-indexed", "map?", "mapcat", "mapv", "max",
      "max-key", "memfn", "memoize", "merge", "merge-with", "meta",
      "method-sig", "methods", "min", "min-key", "mix-collection-hash", "mod",
      "munge", "name", "namespace", "namespace-munge", "nat-int?", "neg-int?",
      "neg?", "newline", "next", "nfirst", "nil?", "nnext", "not", "not-any?",
      "not-empty", "not-every?", "not=", "ns", "ns-aliases", "ns-imports",
      "ns-interns", "ns-map", "ns-name", "ns-publics", "ns-refers",
      "ns-resolve", "ns-unalias", "ns-unmap", "nth", "nthnext", "nthrest",
      "num", "number?", "numerator", "object-array", "odd?", "or", "parents",
      "partial", "partition", "partition-all", "partition-by", "pcalls", "peek",
      "persistent!", "pmap", "pop", "pop!", "pop-thread-bindings", "pos-int?",
      "pos?", "pr", "pr-str", "prefer-method", "prefers",
      "primitives-classnames", "print", "print-ctor", "print-dup",
      "print-method", "print-simple", "print-str", "printf", "println",
      "println-str", "prn", "prn-str", "promise", "proxy",
      "proxy-call-with-super", "proxy-mappings", "proxy-name", "proxy-super",
      "push-thread-bindings", "pvalues", "qualified-ident?",
      "qualified-keyword?", "qualified-symbol?", "quot", "rand", "rand-int",
      "rand-nth", "random-sample", "range", "ratio?", "rational?",
      "rationalize", "re-find", "re-groups", "re-matcher", "re-matches",
      "re-pattern", "re-seq", "read", "read-line", "read-string",
      "reader-conditional", "reader-conditional?", "realized?", "record?",
      "reduce", "reduce-kv", "reduced", "reduced?", "reductions", "ref",
      "ref-history-count", "ref-max-history", "ref-min-history", "ref-set",
      "refer", "refer-clojure", "reify", "release-pending-sends", "rem",
      "remove", "remove-all-methods", "remove-method", "remove-ns",
      "remove-watch", "repeat", "repeatedly", "replace", "replicate", "require",
      "reset!", "reset-meta!", "reset-vals!", "resolve", "rest",
      "restart-agent", "resultset-seq", "reverse", "reversible?", "rseq",
      "rsubseq", "run!", "satisfies?", "second", "select-keys", "send",
      "send-off", "send-via", "seq", "seq?", "seqable?", "seque", "sequence",
      "sequential?", "set", "set-agent-send-executor!",
      "set-agent-send-off-executor!", "set-error-handler!", "set-error-mode!",
      "set-validator!", "set?", "short", "short-array", "shorts", "shuffle",
      "shutdown-agents", "simple-ident?", "simple-keyword?", "simple-symbol?",
      "slurp", "some", "some->", "some->>", "some-fn", "some?", "sort",
      "sort-by", "sorted-map", "sorted-map-by", "sorted-set", "sorted-set-by",
      "sorted?", "special-symbol?", "spit", "split-at", "split-with", "str",
      "string?", "struct", "struct-map", "subs", "subseq", "subvec", "supers",
      "swap!", "swap-vals!", "symbol", "symbol?", "sync", "tagged-literal",
      "tagged-literal?", "take", "take-last", "take-nth", "take-while", "test",
      "the-ns", "thread-bound?", "time", "to-array", "to-array-2d",
      "trampoline", "transduce", "transient", "tree-seq", "true?", "type",
      "unchecked-add", "unchecked-add-int", "unchecked-byte", "unchecked-char",
      "unchecked-dec", "unchecked-dec-int", "unchecked-divide-int",
      "unchecked-double", "unchecked-float", "unchecked-inc",
      "unchecked-inc-int", "unchecked-int", "unchecked-long",
      "unchecked-multiply", "unchecked-multiply-int", "unchecked-negate",
      "unchecked-negate-int", "unchecked-remainder-int", "unchecked-short",
      "unchecked-subtract", "unchecked-subtract-int", "underive", "unquote",
      "unquote-splicing", "unreduced", "unsigned-bit-shift-right", "update",
      "update-in", "update-proxy", "uri?", "use", "uuid?", "val", "vals",
      "var-get", "var-set", "var?", "vary-meta", "vec", "vector", "vector-of",
      "vector?", "volatile!", "volatile?", "vreset!", "vswap!", "when",
      "when-first", "when-let", "when-not", "when-some", "while",
      "with-bindings", "with-bindings*", "with-in-str", "with-loading-context",
      "with-local-vars", "with-meta", "with-open", "with-out-str",
      "with-precision", "with-redefs", "with-redefs-fn", "xml-seq", "zero?",
      "zipmap"];
  var haveBodyParameter = [
      "->", "->>", "as->", "binding", "bound-fn", "case", "catch", "comment",
      "cond", "cond->", "cond->>", "condp", "def", "definterface", "defmethod",
      "defn", "defmacro", "defprotocol", "defrecord", "defstruct", "deftype",
      "do", "doseq", "dotimes", "doto", "extend", "extend-protocol",
      "extend-type", "fn", "for", "future", "if", "if-let", "if-not", "if-some",
      "let", "letfn", "locking", "loop", "ns", "proxy", "reify", "struct-map",
      "some->", "some->>", "try", "when", "when-first", "when-let", "when-not",
      "when-some", "while", "with-bindings", "with-bindings*", "with-in-str",
      "with-loading-context", "with-local-vars", "with-meta", "with-open",
      "with-out-str", "with-precision", "with-redefs", "with-redefs-fn"];

  CodeMirror.registerHelper("hintWords", "clojure",
    [].concat(atoms, specialForms, coreSymbols));

  var atom = createLookupMap(atoms);
  var specialForm = createLookupMap(specialForms);
  var coreSymbol = createLookupMap(coreSymbols);
  var hasBodyParameter = createLookupMap(haveBodyParameter);
  var delimiter = /^(?:[\\\[\]\s"(),;@^`{}~]|$)/;
  var numberLiteral = /^(?:[+\-]?\d+(?:(?:N|(?:[eE][+\-]?\d+))|(?:\.?\d*(?:M|(?:[eE][+\-]?\d+))?)|\/\d+|[xX][0-9a-fA-F]+|r[0-9a-zA-Z]+)?(?=[\\\[\]\s"#'(),;@^`{}~]|$))/;
  var characterLiteral = /^(?:\\(?:backspace|formfeed|newline|return|space|tab|o[0-7]{3}|u[0-9A-Fa-f]{4}|x[0-9A-Fa-f]{4}|.)?(?=[\\\[\]\s"(),;@^`{}~]|$))/;

  // simple-namespace := /^[^\\\/\[\]\d\s"#'(),;@^`{}~.][^\\\[\]\s"(),;@^`{}~.\/]*/
  // simple-symbol    := /^(?:\/|[^\\\/\[\]\d\s"#'(),;@^`{}~][^\\\[\]\s"(),;@^`{}~]*)/
  // qualified-symbol := (<simple-namespace>(<.><simple-namespace>)*</>)?<simple-symbol>
  var qualifiedSymbol = /^(?:(?:[^\\\/\[\]\d\s"#'(),;@^`{}~.][^\\\[\]\s"(),;@^`{}~.\/]*(?:\.[^\\\/\[\]\d\s"#'(),;@^`{}~.][^\\\[\]\s"(),;@^`{}~.\/]*)*\/)?(?:\/|[^\\\/\[\]\d\s"#'(),;@^`{}~][^\\\[\]\s"(),;@^`{}~]*)*(?=[\\\[\]\s"(),;@^`{}~]|$))/;

  function base(stream, state) {
    if (stream.eatSpace() || stream.eat(",")) return ["space", null];
    if (stream.match(numberLiteral)) return [null, "number"];
    if (stream.match(characterLiteral)) return [null, "string-2"];
    if (stream.eat(/^"/)) return (state.tokenize = inString)(stream, state);
    if (stream.eat(/^[(\[{]/)) return ["open", "bracket"];
    if (stream.eat(/^[)\]}]/)) return ["close", "bracket"];
    if (stream.eat(/^;/)) {stream.skipToEnd(); return ["space", "comment"];}
    if (stream.eat(/^[#'@^`~]/)) return [null, "meta"];

    var matches = stream.match(qualifiedSymbol);
    var symbol = matches && matches[0];

    if (!symbol) {
      // advance stream by at least one character so we don't get stuck.
      stream.next();
      stream.eatWhile(function (c) {return !is(c, delimiter);});
      return [null, "error"];
    }

    if (symbol === "comment" && state.lastToken === "(")
      return (state.tokenize = inComment)(stream, state);
    if (is(symbol, atom) || symbol.charAt(0) === ":") return ["symbol", "atom"];
    if (is(symbol, specialForm) || is(symbol, coreSymbol)) return ["symbol", "keyword"];
    if (state.lastToken === "(") return ["symbol", "builtin"]; // other operator

    return ["symbol", "variable"];
  }

  function inString(stream, state) {
    var escaped = false, next;

    while (next = stream.next()) {
      if (next === "\"" && !escaped) {state.tokenize = base; break;}
      escaped = !escaped && next === "\\";
    }

    return [null, "string"];
  }

  function inComment(stream, state) {
    var parenthesisCount = 1;
    var next;

    while (next = stream.next()) {
      if (next === ")") parenthesisCount--;
      if (next === "(") parenthesisCount++;
      if (parenthesisCount === 0) {
        stream.backUp(1);
        state.tokenize = base;
        break;
      }
    }

    return ["space", "comment"];
  }

  function createLookupMap(words) {
    var obj = {};

    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;

    return obj;
  }

  function is(value, test) {
    if (test instanceof RegExp) return test.test(value);
    if (test instanceof Object) return test.propertyIsEnumerable(value);
  }

  return {
    startState: function () {
      return {
        ctx: {prev: null, start: 0, indentTo: 0},
        lastToken: null,
        tokenize: base
      };
    },

    token: function (stream, state) {
      if (stream.sol() && (typeof state.ctx.indentTo !== "number"))
        state.ctx.indentTo = state.ctx.start + 1;

      var typeStylePair = state.tokenize(stream, state);
      var type = typeStylePair[0];
      var style = typeStylePair[1];
      var current = stream.current();

      if (type !== "space") {
        if (state.lastToken === "(" && state.ctx.indentTo === null) {
          if (type === "symbol" && is(current, hasBodyParameter))
            state.ctx.indentTo = state.ctx.start + options.indentUnit;
          else state.ctx.indentTo = "next";
        } else if (state.ctx.indentTo === "next") {
          state.ctx.indentTo = stream.column();
        }

        state.lastToken = current;
      }

      if (type === "open")
        state.ctx = {prev: state.ctx, start: stream.column(), indentTo: null};
      else if (type === "close") state.ctx = state.ctx.prev || state.ctx;

      return style;
    },

    indent: function (state) {
      var i = state.ctx.indentTo;

      return (typeof i === "number") ?
        i :
        state.ctx.start + 1;
    },

    closeBrackets: {pairs: "()[]{}\"\""},
    lineComment: ";;"
  };
});

CodeMirror.defineMIME("text/x-clojure", "clojure");
CodeMirror.defineMIME("text/x-clojurescript", "clojure");
CodeMirror.defineMIME("application/edn", "clojure");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/cmake/cmake.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true)
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("cmake", function () {
  var variable_regex = /({)?[a-zA-Z0-9_]+(})?/;

  function tokenString(stream, state) {
    var current, prev, found_var = false;
    while (!stream.eol() && (current = stream.next()) != state.pending) {
      if (current === '$' && prev != '\\' && state.pending == '"') {
        found_var = true;
        break;
      }
      prev = current;
    }
    if (found_var) {
      stream.backUp(1);
    }
    if (current == state.pending) {
      state.continueString = false;
    } else {
      state.continueString = true;
    }
    return "string";
  }

  function tokenize(stream, state) {
    var ch = stream.next();

    // Have we found a variable?
    if (ch === '$') {
      if (stream.match(variable_regex)) {
        return 'variable-2';
      }
      return 'variable';
    }
    // Should we still be looking for the end of a string?
    if (state.continueString) {
      // If so, go through the loop again
      stream.backUp(1);
      return tokenString(stream, state);
    }
    // Do we just have a function on our hands?
    // In 'cmake_minimum_required (VERSION 2.8.8)', 'cmake_minimum_required' is matched
    if (stream.match(/(\s+)?\w+\(/) || stream.match(/(\s+)?\w+\ \(/)) {
      stream.backUp(1);
      return 'def';
    }
    if (ch == "#") {
      stream.skipToEnd();
      return "comment";
    }
    // Have we found a string?
    if (ch == "'" || ch == '"') {
      // Store the type (single or double)
      state.pending = ch;
      // Perform the looping function to find the end
      return tokenString(stream, state);
    }
    if (ch == '(' || ch == ')') {
      return 'bracket';
    }
    if (ch.match(/[0-9]/)) {
      return 'number';
    }
    stream.eatWhile(/[\w-]/);
    return null;
  }
  return {
    startState: function () {
      var state = {};
      state.inDefinition = false;
      state.inInclude = false;
      state.continueString = false;
      state.pending = false;
      return state;
    },
    token: function (stream, state) {
      if (stream.eatSpace()) return null;
      return tokenize(stream, state);
    }
  };
});

CodeMirror.defineMIME("text/x-cmake", "cmake");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/cobol/cobol.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

/**
 * Author: Gautam Mehta
 * Branched from CodeMirror's Scheme mode
 */
(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("cobol", function () {
  var BUILTIN = "builtin", COMMENT = "comment", STRING = "string",
      ATOM = "atom", NUMBER = "number", KEYWORD = "keyword", MODTAG = "header",
      COBOLLINENUM = "def", PERIOD = "link";
  function makeKeywords(str) {
    var obj = {}, words = str.split(" ");
    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
    return obj;
  }
  var atoms = makeKeywords("TRUE FALSE ZEROES ZEROS ZERO SPACES SPACE LOW-VALUE LOW-VALUES ");
  var keywords = makeKeywords(
      "ACCEPT ACCESS ACQUIRE ADD ADDRESS " +
      "ADVANCING AFTER ALIAS ALL ALPHABET " +
      "ALPHABETIC ALPHABETIC-LOWER ALPHABETIC-UPPER ALPHANUMERIC ALPHANUMERIC-EDITED " +
      "ALSO ALTER ALTERNATE AND ANY " +
      "ARE AREA AREAS ARITHMETIC ASCENDING " +
      "ASSIGN AT ATTRIBUTE AUTHOR AUTO " +
      "AUTO-SKIP AUTOMATIC B-AND B-EXOR B-LESS " +
      "B-NOT B-OR BACKGROUND-COLOR BACKGROUND-COLOUR BEEP " +
      "BEFORE BELL BINARY BIT BITS " +
      "BLANK BLINK BLOCK BOOLEAN BOTTOM " +
      "BY CALL CANCEL CD CF " +
      "CH CHARACTER CHARACTERS CLASS CLOCK-UNITS " +
      "CLOSE COBOL CODE CODE-SET COL " +
      "COLLATING COLUMN COMMA COMMIT COMMITMENT " +
      "COMMON COMMUNICATION COMP COMP-0 COMP-1 " +
      "COMP-2 COMP-3 COMP-4 COMP-5 COMP-6 " +
      "COMP-7 COMP-8 COMP-9 COMPUTATIONAL COMPUTATIONAL-0 " +
      "COMPUTATIONAL-1 COMPUTATIONAL-2 COMPUTATIONAL-3 COMPUTATIONAL-4 COMPUTATIONAL-5 " +
      "COMPUTATIONAL-6 COMPUTATIONAL-7 COMPUTATIONAL-8 COMPUTATIONAL-9 COMPUTE " +
      "CONFIGURATION CONNECT CONSOLE CONTAINED CONTAINS " +
      "CONTENT CONTINUE CONTROL CONTROL-AREA CONTROLS " +
      "CONVERTING COPY CORR CORRESPONDING COUNT " +
      "CRT CRT-UNDER CURRENCY CURRENT CURSOR " +
      "DATA DATE DATE-COMPILED DATE-WRITTEN DAY " +
      "DAY-OF-WEEK DB DB-ACCESS-CONTROL-KEY DB-DATA-NAME DB-EXCEPTION " +
      "DB-FORMAT-NAME DB-RECORD-NAME DB-SET-NAME DB-STATUS DBCS " +
      "DBCS-EDITED DE DEBUG-CONTENTS DEBUG-ITEM DEBUG-LINE " +
      "DEBUG-NAME DEBUG-SUB-1 DEBUG-SUB-2 DEBUG-SUB-3 DEBUGGING " +
      "DECIMAL-POINT DECLARATIVES DEFAULT DELETE DELIMITED " +
      "DELIMITER DEPENDING DESCENDING DESCRIBED DESTINATION " +
      "DETAIL DISABLE DISCONNECT DISPLAY DISPLAY-1 " +
      "DISPLAY-2 DISPLAY-3 DISPLAY-4 DISPLAY-5 DISPLAY-6 " +
      "DISPLAY-7 DISPLAY-8 DISPLAY-9 DIVIDE DIVISION " +
      "DOWN DROP DUPLICATE DUPLICATES DYNAMIC " +
      "EBCDIC EGI EJECT ELSE EMI " +
      "EMPTY EMPTY-CHECK ENABLE END END. END-ACCEPT END-ACCEPT. " +
      "END-ADD END-CALL END-COMPUTE END-DELETE END-DISPLAY " +
      "END-DIVIDE END-EVALUATE END-IF END-INVOKE END-MULTIPLY " +
      "END-OF-PAGE END-PERFORM END-READ END-RECEIVE END-RETURN " +
      "END-REWRITE END-SEARCH END-START END-STRING END-SUBTRACT " +
      "END-UNSTRING END-WRITE END-XML ENTER ENTRY " +
      "ENVIRONMENT EOP EQUAL EQUALS ERASE " +
      "ERROR ESI EVALUATE EVERY EXCEEDS " +
      "EXCEPTION EXCLUSIVE EXIT EXTEND EXTERNAL " +
      "EXTERNALLY-DESCRIBED-KEY FD FETCH FILE FILE-CONTROL " +
      "FILE-STREAM FILES FILLER FINAL FIND " +
      "FINISH FIRST FOOTING FOR FOREGROUND-COLOR " +
      "FOREGROUND-COLOUR FORMAT FREE FROM FULL " +
      "FUNCTION GENERATE GET GIVING GLOBAL " +
      "GO GOBACK GREATER GROUP HEADING " +
      "HIGH-VALUE HIGH-VALUES HIGHLIGHT I-O I-O-CONTROL " +
      "ID IDENTIFICATION IF IN INDEX " +
      "INDEX-1 INDEX-2 INDEX-3 INDEX-4 INDEX-5 " +
      "INDEX-6 INDEX-7 INDEX-8 INDEX-9 INDEXED " +
      "INDIC INDICATE INDICATOR INDICATORS INITIAL " +
      "INITIALIZE INITIATE INPUT INPUT-OUTPUT INSPECT " +
      "INSTALLATION INTO INVALID INVOKE IS " +
      "JUST JUSTIFIED KANJI KEEP KEY " +
      "LABEL LAST LD LEADING LEFT " +
      "LEFT-JUSTIFY LENGTH LENGTH-CHECK LESS LIBRARY " +
      "LIKE LIMIT LIMITS LINAGE LINAGE-COUNTER " +
      "LINE LINE-COUNTER LINES LINKAGE LOCAL-STORAGE " +
      "LOCALE LOCALLY LOCK " +
      "MEMBER MEMORY MERGE MESSAGE METACLASS " +
      "MODE MODIFIED MODIFY MODULES MOVE " +
      "MULTIPLE MULTIPLY NATIONAL NATIVE NEGATIVE " +
      "NEXT NO NO-ECHO NONE NOT " +
      "NULL NULL-KEY-MAP NULL-MAP NULLS NUMBER " +
      "NUMERIC NUMERIC-EDITED OBJECT OBJECT-COMPUTER OCCURS " +
      "OF OFF OMITTED ON ONLY " +
      "OPEN OPTIONAL OR ORDER ORGANIZATION " +
      "OTHER OUTPUT OVERFLOW OWNER PACKED-DECIMAL " +
      "PADDING PAGE PAGE-COUNTER PARSE PERFORM " +
      "PF PH PIC PICTURE PLUS " +
      "POINTER POSITION POSITIVE PREFIX PRESENT " +
      "PRINTING PRIOR PROCEDURE PROCEDURE-POINTER PROCEDURES " +
      "PROCEED PROCESS PROCESSING PROGRAM PROGRAM-ID " +
      "PROMPT PROTECTED PURGE QUEUE QUOTE " +
      "QUOTES RANDOM RD READ READY " +
      "REALM RECEIVE RECONNECT RECORD RECORD-NAME " +
      "RECORDS RECURSIVE REDEFINES REEL REFERENCE " +
      "REFERENCE-MONITOR REFERENCES RELATION RELATIVE RELEASE " +
      "REMAINDER REMOVAL RENAMES REPEATED REPLACE " +
      "REPLACING REPORT REPORTING REPORTS REPOSITORY " +
      "REQUIRED RERUN RESERVE RESET RETAINING " +
      "RETRIEVAL RETURN RETURN-CODE RETURNING REVERSE-VIDEO " +
      "REVERSED REWIND REWRITE RF RH " +
      "RIGHT RIGHT-JUSTIFY ROLLBACK ROLLING ROUNDED " +
      "RUN SAME SCREEN SD SEARCH " +
      "SECTION SECURE SECURITY SEGMENT SEGMENT-LIMIT " +
      "SELECT SEND SENTENCE SEPARATE SEQUENCE " +
      "SEQUENTIAL SET SHARED SIGN SIZE " +
      "SKIP1 SKIP2 SKIP3 SORT SORT-MERGE " +
      "SORT-RETURN SOURCE SOURCE-COMPUTER SPACE-FILL " +
      "SPECIAL-NAMES STANDARD STANDARD-1 STANDARD-2 " +
      "START STARTING STATUS STOP STORE " +
      "STRING SUB-QUEUE-1 SUB-QUEUE-2 SUB-QUEUE-3 SUB-SCHEMA " +
      "SUBFILE SUBSTITUTE SUBTRACT SUM SUPPRESS " +
      "SYMBOLIC SYNC SYNCHRONIZED SYSIN SYSOUT " +
      "TABLE TALLYING TAPE TENANT TERMINAL " +
      "TERMINATE TEST TEXT THAN THEN " +
      "THROUGH THRU TIME TIMES TITLE " +
      "TO TOP TRAILING TRAILING-SIGN TRANSACTION " +
      "TYPE TYPEDEF UNDERLINE UNEQUAL UNIT " +
      "UNSTRING UNTIL UP UPDATE UPON " +
      "USAGE USAGE-MODE USE USING VALID " +
      "VALIDATE VALUE VALUES VARYING VLR " +
      "WAIT WHEN WHEN-COMPILED WITH WITHIN " +
      "WORDS WORKING-STORAGE WRITE XML XML-CODE " +
      "XML-EVENT XML-NTEXT XML-TEXT ZERO ZERO-FILL " );

  var builtins = makeKeywords("- * ** / + < <= = > >= ");
  var tests = {
    digit: /\d/,
    digit_or_colon: /[\d:]/,
    hex: /[0-9a-f]/i,
    sign: /[+-]/,
    exponent: /e/i,
    keyword_char: /[^\s\(\[\;\)\]]/,
    symbol: /[\w*+\-]/
  };
  function isNumber(ch, stream){
    // hex
    if ( ch === '0' && stream.eat(/x/i) ) {
      stream.eatWhile(tests.hex);
      return true;
    }
    // leading sign
    if ( ( ch == '+' || ch == '-' ) && ( tests.digit.test(stream.peek()) ) ) {
      stream.eat(tests.sign);
      ch = stream.next();
    }
    if ( tests.digit.test(ch) ) {
      stream.eat(ch);
      stream.eatWhile(tests.digit);
      if ( '.' == stream.peek()) {
        stream.eat('.');
        stream.eatWhile(tests.digit);
      }
      if ( stream.eat(tests.exponent) ) {
        stream.eat(tests.sign);
        stream.eatWhile(tests.digit);
      }
      return true;
    }
    return false;
  }
  return {
    startState: function () {
      return {
        indentStack: null,
        indentation: 0,
        mode: false
      };
    },
    token: function (stream, state) {
      if (state.indentStack == null && stream.sol()) {
        // update indentation, but only if indentStack is empty
        state.indentation = 6 ; //stream.indentation();
      }
      // skip spaces
      if (stream.eatSpace()) {
        return null;
      }
      var returnType = null;
      switch(state.mode){
      case "string": // multi-line string parsing mode
        var next = false;
        while ((next = stream.next()) != null) {
          if (next == "\"" || next == "\'") {
            state.mode = false;
            break;
          }
        }
        returnType = STRING; // continue on in string mode
        break;
      default: // default parsing mode
        var ch = stream.next();
        var col = stream.column();
        if (col >= 0 && col <= 5) {
          returnType = COBOLLINENUM;
        } else if (col >= 72 && col <= 79) {
          stream.skipToEnd();
          returnType = MODTAG;
        } else if (ch == "*" && col == 6) { // comment
          stream.skipToEnd(); // rest of the line is a comment
          returnType = COMMENT;
        } else if (ch == "\"" || ch == "\'") {
          state.mode = "string";
          returnType = STRING;
        } else if (ch == "'" && !( tests.digit_or_colon.test(stream.peek()) )) {
          returnType = ATOM;
        } else if (ch == ".") {
          returnType = PERIOD;
        } else if (isNumber(ch,stream)){
          returnType = NUMBER;
        } else {
          if (stream.current().match(tests.symbol)) {
            while (col < 71) {
              if (stream.eat(tests.symbol) === undefined) {
                break;
              } else {
                col++;
              }
            }
          }
          if (keywords && keywords.propertyIsEnumerable(stream.current().toUpperCase())) {
            returnType = KEYWORD;
          } else if (builtins && builtins.propertyIsEnumerable(stream.current().toUpperCase())) {
            returnType = BUILTIN;
          } else if (atoms && atoms.propertyIsEnumerable(stream.current().toUpperCase())) {
            returnType = ATOM;
          } else returnType = null;
        }
      }
      return returnType;
    },
    indent: function (state) {
      if (state.indentStack == null) return state.indentation;
      return state.indentStack.indent;
    }
  };
});

CodeMirror.defineMIME("text/x-cobol", "cobol");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/coffeescript/coffeescript.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

/**
 * Link to the project's GitHub page:
 * https://github.com/pickhardt/coffeescript-codemirror-mode
 */
(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("coffeescript", function(conf, parserConf) {
  var ERRORCLASS = "error";

  function wordRegexp(words) {
    return new RegExp("^((" + words.join(")|(") + "))\\b");
  }

  var operators = /^(?:->|=>|\+[+=]?|-[\-=]?|\*[\*=]?|\/[\/=]?|[=!]=|<[><]?=?|>>?=?|%=?|&=?|\|=?|\^=?|\~|!|\?|(or|and|\|\||&&|\?)=)/;
  var delimiters = /^(?:[()\[\]{},:`=;]|\.\.?\.?)/;
  var identifiers = /^[_A-Za-z$][_A-Za-z$0-9]*/;
  var atProp = /^@[_A-Za-z$][_A-Za-z$0-9]*/;

  var wordOperators = wordRegexp(["and", "or", "not",
                                  "is", "isnt", "in",
                                  "instanceof", "typeof"]);
  var indentKeywords = ["for", "while", "loop", "if", "unless", "else",
                        "switch", "try", "catch", "finally", "class"];
  var commonKeywords = ["break", "by", "continue", "debugger", "delete",
                        "do", "in", "of", "new", "return", "then",
                        "this", "@", "throw", "when", "until", "extends"];

  var keywords = wordRegexp(indentKeywords.concat(commonKeywords));

  indentKeywords = wordRegexp(indentKeywords);


  var stringPrefixes = /^('{3}|\"{3}|['\"])/;
  var regexPrefixes = /^(\/{3}|\/)/;
  var commonConstants = ["Infinity", "NaN", "undefined", "null", "true", "false", "on", "off", "yes", "no"];
  var constants = wordRegexp(commonConstants);

  // Tokenizers
  function tokenBase(stream, state) {
    // Handle scope changes
    if (stream.sol()) {
      if (state.scope.align === null) state.scope.align = false;
      var scopeOffset = state.scope.offset;
      if (stream.eatSpace()) {
        var lineOffset = stream.indentation();
        if (lineOffset > scopeOffset && state.scope.type == "coffee") {
          return "indent";
        } else if (lineOffset < scopeOffset) {
          return "dedent";
        }
        return null;
      } else {
        if (scopeOffset > 0) {
          dedent(stream, state);
        }
      }
    }
    if (stream.eatSpace()) {
      return null;
    }

    var ch = stream.peek();

    // Handle docco title comment (single line)
    if (stream.match("####")) {
      stream.skipToEnd();
      return "comment";
    }

    // Handle multi line comments
    if (stream.match("###")) {
      state.tokenize = longComment;
      return state.tokenize(stream, state);
    }

    // Single line comment
    if (ch === "#") {
      stream.skipToEnd();
      return "comment";
    }

    // Handle number literals
    if (stream.match(/^-?[0-9\.]/, false)) {
      var floatLiteral = false;
      // Floats
      if (stream.match(/^-?\d*\.\d+(e[\+\-]?\d+)?/i)) {
        floatLiteral = true;
      }
      if (stream.match(/^-?\d+\.\d*/)) {
        floatLiteral = true;
      }
      if (stream.match(/^-?\.\d+/)) {
        floatLiteral = true;
      }

      if (floatLiteral) {
        // prevent from getting extra . on 1..
        if (stream.peek() == "."){
          stream.backUp(1);
        }
        return "number";
      }
      // Integers
      var intLiteral = false;
      // Hex
      if (stream.match(/^-?0x[0-9a-f]+/i)) {
        intLiteral = true;
      }
      // Decimal
      if (stream.match(/^-?[1-9]\d*(e[\+\-]?\d+)?/)) {
        intLiteral = true;
      }
      // Zero by itself with no other piece of number.
      if (stream.match(/^-?0(?![\dx])/i)) {
        intLiteral = true;
      }
      if (intLiteral) {
        return "number";
      }
    }

    // Handle strings
    if (stream.match(stringPrefixes)) {
      state.tokenize = tokenFactory(stream.current(), false, "string");
      return state.tokenize(stream, state);
    }
    // Handle regex literals
    if (stream.match(regexPrefixes)) {
      if (stream.current() != "/" || stream.match(/^.*\//, false)) { // prevent highlight of division
        state.tokenize = tokenFactory(stream.current(), true, "string-2");
        return state.tokenize(stream, state);
      } else {
        stream.backUp(1);
      }
    }



    // Handle operators and delimiters
    if (stream.match(operators) || stream.match(wordOperators)) {
      return "operator";
    }
    if (stream.match(delimiters)) {
      return "punctuation";
    }

    if (stream.match(constants)) {
      return "atom";
    }

    if (stream.match(atProp) || state.prop && stream.match(identifiers)) {
      return "property";
    }

    if (stream.match(keywords)) {
      return "keyword";
    }

    if (stream.match(identifiers)) {
      return "variable";
    }

    // Handle non-detected items
    stream.next();
    return ERRORCLASS;
  }

  function tokenFactory(delimiter, singleline, outclass) {
    return function(stream, state) {
      while (!stream.eol()) {
        stream.eatWhile(/[^'"\/\\]/);
        if (stream.eat("\\")) {
          stream.next();
          if (singleline && stream.eol()) {
            return outclass;
          }
        } else if (stream.match(delimiter)) {
          state.tokenize = tokenBase;
          return outclass;
        } else {
          stream.eat(/['"\/]/);
        }
      }
      if (singleline) {
        if (parserConf.singleLineStringErrors) {
          outclass = ERRORCLASS;
        } else {
          state.tokenize = tokenBase;
        }
      }
      return outclass;
    };
  }

  function longComment(stream, state) {
    while (!stream.eol()) {
      stream.eatWhile(/[^#]/);
      if (stream.match("###")) {
        state.tokenize = tokenBase;
        break;
      }
      stream.eatWhile("#");
    }
    return "comment";
  }

  function indent(stream, state, type) {
    type = type || "coffee";
    var offset = 0, align = false, alignOffset = null;
    for (var scope = state.scope; scope; scope = scope.prev) {
      if (scope.type === "coffee" || scope.type == "}") {
        offset = scope.offset + conf.indentUnit;
        break;
      }
    }
    if (type !== "coffee") {
      align = null;
      alignOffset = stream.column() + stream.current().length;
    } else if (state.scope.align) {
      state.scope.align = false;
    }
    state.scope = {
      offset: offset,
      type: type,
      prev: state.scope,
      align: align,
      alignOffset: alignOffset
    };
  }

  function dedent(stream, state) {
    if (!state.scope.prev) return;
    if (state.scope.type === "coffee") {
      var _indent = stream.indentation();
      var matched = false;
      for (var scope = state.scope; scope; scope = scope.prev) {
        if (_indent === scope.offset) {
          matched = true;
          break;
        }
      }
      if (!matched) {
        return true;
      }
      while (state.scope.prev && state.scope.offset !== _indent) {
        state.scope = state.scope.prev;
      }
      return false;
    } else {
      state.scope = state.scope.prev;
      return false;
    }
  }

  function tokenLexer(stream, state) {
    var style = state.tokenize(stream, state);
    var current = stream.current();

    // Handle scope changes.
    if (current === "return") {
      state.dedent = true;
    }
    if (((current === "->" || current === "=>") && stream.eol())
        || style === "indent") {
      indent(stream, state);
    }
    var delimiter_index = "[({".indexOf(current);
    if (delimiter_index !== -1) {
      indent(stream, state, "])}".slice(delimiter_index, delimiter_index+1));
    }
    if (indentKeywords.exec(current)){
      indent(stream, state);
    }
    if (current == "then"){
      dedent(stream, state);
    }


    if (style === "dedent") {
      if (dedent(stream, state)) {
        return ERRORCLASS;
      }
    }
    delimiter_index = "])}".indexOf(current);
    if (delimiter_index !== -1) {
      while (state.scope.type == "coffee" && state.scope.prev)
        state.scope = state.scope.prev;
      if (state.scope.type == current)
        state.scope = state.scope.prev;
    }
    if (state.dedent && stream.eol()) {
      if (state.scope.type == "coffee" && state.scope.prev)
        state.scope = state.scope.prev;
      state.dedent = false;
    }

    return style;
  }

  var external = {
    startState: function(basecolumn) {
      return {
        tokenize: tokenBase,
        scope: {offset:basecolumn || 0, type:"coffee", prev: null, align: false},
        prop: false,
        dedent: 0
      };
    },

    token: function(stream, state) {
      var fillAlign = state.scope.align === null && state.scope;
      if (fillAlign && stream.sol()) fillAlign.align = false;

      var style = tokenLexer(stream, state);
      if (style && style != "comment") {
        if (fillAlign) fillAlign.align = true;
        state.prop = style == "punctuation" && stream.current() == "."
      }

      return style;
    },

    indent: function(state, text) {
      if (state.tokenize != tokenBase) return 0;
      var scope = state.scope;
      var closer = text && "])}".indexOf(text.charAt(0)) > -1;
      if (closer) while (scope.type == "coffee" && scope.prev) scope = scope.prev;
      var closes = closer && scope.type === text.charAt(0);
      if (scope.align)
        return scope.alignOffset - (closes ? 1 : 0);
      else
        return (closes ? scope.prev : scope).offset;
    },

    lineComment: "#",
    fold: "indent"
  };
  return external;
});

// IANA registered media type
// https://www.iana.org/assignments/media-types/
CodeMirror.defineMIME("application/vnd.coffeescript", "coffeescript");

CodeMirror.defineMIME("text/x-coffeescript", "coffeescript");
CodeMirror.defineMIME("text/coffeescript", "coffeescript");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/commonlisp/commonlisp.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("commonlisp", function (config) {
  var specialForm = /^(block|let*|return-from|catch|load-time-value|setq|eval-when|locally|symbol-macrolet|flet|macrolet|tagbody|function|multiple-value-call|the|go|multiple-value-prog1|throw|if|progn|unwind-protect|labels|progv|let|quote)$/;
  var assumeBody = /^with|^def|^do|^prog|case$|^cond$|bind$|when$|unless$/;
  var numLiteral = /^(?:[+\-]?(?:\d+|\d*\.\d+)(?:[efd][+\-]?\d+)?|[+\-]?\d+(?:\/[+\-]?\d+)?|#b[+\-]?[01]+|#o[+\-]?[0-7]+|#x[+\-]?[\da-f]+)/;
  var symbol = /[^\s'`,@()\[\]";]/;
  var type;

  function readSym(stream) {
    var ch;
    while (ch = stream.next()) {
      if (ch == "\\") stream.next();
      else if (!symbol.test(ch)) { stream.backUp(1); break; }
    }
    return stream.current();
  }

  function base(stream, state) {
    if (stream.eatSpace()) {type = "ws"; return null;}
    if (stream.match(numLiteral)) return "number";
    var ch = stream.next();
    if (ch == "\\") ch = stream.next();

    if (ch == '"') return (state.tokenize = inString)(stream, state);
    else if (ch == "(") { type = "open"; return "bracket"; }
    else if (ch == ")" || ch == "]") { type = "close"; return "bracket"; }
    else if (ch == ";") { stream.skipToEnd(); type = "ws"; return "comment"; }
    else if (/['`,@]/.test(ch)) return null;
    else if (ch == "|") {
      if (stream.skipTo("|")) { stream.next(); return "symbol"; }
      else { stream.skipToEnd(); return "error"; }
    } else if (ch == "#") {
      var ch = stream.next();
      if (ch == "(") { type = "open"; return "bracket"; }
      else if (/[+\-=\.']/.test(ch)) return null;
      else if (/\d/.test(ch) && stream.match(/^\d*#/)) return null;
      else if (ch == "|") return (state.tokenize = inComment)(stream, state);
      else if (ch == ":") { readSym(stream); return "meta"; }
      else if (ch == "\\") { stream.next(); readSym(stream); return "string-2" }
      else return "error";
    } else {
      var name = readSym(stream);
      if (name == ".") return null;
      type = "symbol";
      if (name == "nil" || name == "t" || name.charAt(0) == ":") return "atom";
      if (state.lastType == "open" && (specialForm.test(name) || assumeBody.test(name))) return "keyword";
      if (name.charAt(0) == "&") return "variable-2";
      return "variable";
    }
  }

  function inString(stream, state) {
    var escaped = false, next;
    while (next = stream.next()) {
      if (next == '"' && !escaped) { state.tokenize = base; break; }
      escaped = !escaped && next == "\\";
    }
    return "string";
  }

  function inComment(stream, state) {
    var next, last;
    while (next = stream.next()) {
      if (next == "#" && last == "|") { state.tokenize = base; break; }
      last = next;
    }
    type = "ws";
    return "comment";
  }

  return {
    startState: function () {
      return {ctx: {prev: null, start: 0, indentTo: 0}, lastType: null, tokenize: base};
    },

    token: function (stream, state) {
      if (stream.sol() && typeof state.ctx.indentTo != "number")
        state.ctx.indentTo = state.ctx.start + 1;

      type = null;
      var style = state.tokenize(stream, state);
      if (type != "ws") {
        if (state.ctx.indentTo == null) {
          if (type == "symbol" && assumeBody.test(stream.current()))
            state.ctx.indentTo = state.ctx.start + config.indentUnit;
          else
            state.ctx.indentTo = "next";
        } else if (state.ctx.indentTo == "next") {
          state.ctx.indentTo = stream.column();
        }
        state.lastType = type;
      }
      if (type == "open") state.ctx = {prev: state.ctx, start: stream.column(), indentTo: null};
      else if (type == "close") state.ctx = state.ctx.prev || state.ctx;
      return style;
    },

    indent: function (state, _textAfter) {
      var i = state.ctx.indentTo;
      return typeof i == "number" ? i : state.ctx.start + 1;
    },

    closeBrackets: {pairs: "()[]{}\"\""},
    lineComment: ";;",
    blockCommentStart: "#|",
    blockCommentEnd: "|#"
  };
});

CodeMirror.defineMIME("text/x-common-lisp", "commonlisp");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/crystal/crystal.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
  "use strict";

  CodeMirror.defineMode("crystal", function(config) {
    function wordRegExp(words, end) {
      return new RegExp((end ? "" : "^") + "(?:" + words.join("|") + ")" + (end ? "$" : "\\b"));
    }

    function chain(tokenize, stream, state) {
      state.tokenize.push(tokenize);
      return tokenize(stream, state);
    }

    var operators = /^(?:[-+/%|&^]|\*\*?|[<>]{2})/;
    var conditionalOperators = /^(?:[=!]~|===|<=>|[<>=!]=?|[|&]{2}|~)/;
    var indexingOperators = /^(?:\[\][?=]?)/;
    var anotherOperators = /^(?:\.(?:\.{2})?|->|[?:])/;
    var idents = /^[a-z_\u009F-\uFFFF][a-zA-Z0-9_\u009F-\uFFFF]*/;
    var types = /^[A-Z_\u009F-\uFFFF][a-zA-Z0-9_\u009F-\uFFFF]*/;
    var keywords = wordRegExp([
      "abstract", "alias", "as", "asm", "begin", "break", "case", "class", "def", "do",
      "else", "elsif", "end", "ensure", "enum", "extend", "for", "fun", "if",
      "include", "instance_sizeof", "lib", "macro", "module", "next", "of", "out", "pointerof",
      "private", "protected", "rescue", "return", "require", "select", "sizeof", "struct",
      "super", "then", "type", "typeof", "uninitialized", "union", "unless", "until", "when", "while", "with",
      "yield", "__DIR__", "__END_LINE__", "__FILE__", "__LINE__"
    ]);
    var atomWords = wordRegExp(["true", "false", "nil", "self"]);
    var indentKeywordsArray = [
      "def", "fun", "macro",
      "class", "module", "struct", "lib", "enum", "union",
      "do", "for"
    ];
    var indentKeywords = wordRegExp(indentKeywordsArray);
    var indentExpressionKeywordsArray = ["if", "unless", "case", "while", "until", "begin", "then"];
    var indentExpressionKeywords = wordRegExp(indentExpressionKeywordsArray);
    var dedentKeywordsArray = ["end", "else", "elsif", "rescue", "ensure"];
    var dedentKeywords = wordRegExp(dedentKeywordsArray);
    var dedentPunctualsArray = ["\\)", "\\}", "\\]"];
    var dedentPunctuals = new RegExp("^(?:" + dedentPunctualsArray.join("|") + ")$");
    var nextTokenizer = {
      "def": tokenFollowIdent, "fun": tokenFollowIdent, "macro": tokenMacroDef,
      "class": tokenFollowType, "module": tokenFollowType, "struct": tokenFollowType,
      "lib": tokenFollowType, "enum": tokenFollowType, "union": tokenFollowType
    };
    var matching = {"[": "]", "{": "}", "(": ")", "<": ">"};

    function tokenBase(stream, state) {
      if (stream.eatSpace()) {
        return null;
      }

      // Macros
      if (state.lastToken != "\\" && stream.match("{%", false)) {
        return chain(tokenMacro("%", "%"), stream, state);
      }

      if (state.lastToken != "\\" && stream.match("{{", false)) {
        return chain(tokenMacro("{", "}"), stream, state);
      }

      // Comments
      if (stream.peek() == "#") {
        stream.skipToEnd();
        return "comment";
      }

      // Variables and keywords
      var matched;
      if (stream.match(idents)) {
        stream.eat(/[?!]/);

        matched = stream.current();
        if (stream.eat(":")) {
          return "atom";
        } else if (state.lastToken == ".") {
          return "property";
        } else if (keywords.test(matched)) {
          if (indentKeywords.test(matched)) {
            if (!(matched == "fun" && state.blocks.indexOf("lib") >= 0) && !(matched == "def" && state.lastToken == "abstract")) {
              state.blocks.push(matched);
              state.currentIndent += 1;
            }
          } else if ((state.lastStyle == "operator" || !state.lastStyle) && indentExpressionKeywords.test(matched)) {
            state.blocks.push(matched);
            state.currentIndent += 1;
          } else if (matched == "end") {
            state.blocks.pop();
            state.currentIndent -= 1;
          }

          if (nextTokenizer.hasOwnProperty(matched)) {
            state.tokenize.push(nextTokenizer[matched]);
          }

          return "keyword";
        } else if (atomWords.test(matched)) {
          return "atom";
        }

        return "variable";
      }

      // Class variables and instance variables
      // or attributes
      if (stream.eat("@")) {
        if (stream.peek() == "[") {
          return chain(tokenNest("[", "]", "meta"), stream, state);
        }

        stream.eat("@");
        stream.match(idents) || stream.match(types);
        return "variable-2";
      }

      // Constants and types
      if (stream.match(types)) {
        return "tag";
      }

      // Symbols or ':' operator
      if (stream.eat(":")) {
        if (stream.eat("\"")) {
          return chain(tokenQuote("\"", "atom", false), stream, state);
        } else if (stream.match(idents) || stream.match(types) ||
                   stream.match(operators) || stream.match(conditionalOperators) || stream.match(indexingOperators)) {
          return "atom";
        }
        stream.eat(":");
        return "operator";
      }

      // Strings
      if (stream.eat("\"")) {
        return chain(tokenQuote("\"", "string", true), stream, state);
      }

      // Strings or regexps or macro variables or '%' operator
      if (stream.peek() == "%") {
        var style = "string";
        var embed = true;
        var delim;

        if (stream.match("%r")) {
          // Regexps
          style = "string-2";
          delim = stream.next();
        } else if (stream.match("%w")) {
          embed = false;
          delim = stream.next();
        } else if (stream.match("%q")) {
          embed = false;
          delim = stream.next();
        } else {
          if(delim = stream.match(/^%([^\w\s=])/)) {
            delim = delim[1];
          } else if (stream.match(/^%[a-zA-Z_\u009F-\uFFFF][\w\u009F-\uFFFF]*/)) {
            // Macro variables
            return "meta";
          } else if (stream.eat('%')) {
            // '%' operator
            return "operator";
          }
        }

        if (matching.hasOwnProperty(delim)) {
          delim = matching[delim];
        }
        return chain(tokenQuote(delim, style, embed), stream, state);
      }

      // Here Docs
      if (matched = stream.match(/^<<-('?)([A-Z]\w*)\1/)) {
        return chain(tokenHereDoc(matched[2], !matched[1]), stream, state)
      }

      // Characters
      if (stream.eat("'")) {
        stream.match(/^(?:[^']|\\(?:[befnrtv0'"]|[0-7]{3}|u(?:[0-9a-fA-F]{4}|\{[0-9a-fA-F]{1,6}\})))/);
        stream.eat("'");
        return "atom";
      }

      // Numbers
      if (stream.eat("0")) {
        if (stream.eat("x")) {
          stream.match(/^[0-9a-fA-F_]+/);
        } else if (stream.eat("o")) {
          stream.match(/^[0-7_]+/);
        } else if (stream.eat("b")) {
          stream.match(/^[01_]+/);
        }
        return "number";
      }

      if (stream.eat(/^\d/)) {
        stream.match(/^[\d_]*(?:\.[\d_]+)?(?:[eE][+-]?\d+)?/);
        return "number";
      }

      // Operators
      if (stream.match(operators)) {
        stream.eat("="); // Operators can follow assign symbol.
        return "operator";
      }

      if (stream.match(conditionalOperators) || stream.match(anotherOperators)) {
        return "operator";
      }

      // Parens and braces
      if (matched = stream.match(/[({[]/, false)) {
        matched = matched[0];
        return chain(tokenNest(matched, matching[matched], null), stream, state);
      }

      // Escapes
      if (stream.eat("\\")) {
        stream.next();
        return "meta";
      }

      stream.next();
      return null;
    }

    function tokenNest(begin, end, style, started) {
      return function (stream, state) {
        if (!started && stream.match(begin)) {
          state.tokenize[state.tokenize.length - 1] = tokenNest(begin, end, style, true);
          state.currentIndent += 1;
          return style;
        }

        var nextStyle = tokenBase(stream, state);
        if (stream.current() === end) {
          state.tokenize.pop();
          state.currentIndent -= 1;
          nextStyle = style;
        }

        return nextStyle;
      };
    }

    function tokenMacro(begin, end, started) {
      return function (stream, state) {
        if (!started && stream.match("{" + begin)) {
          state.currentIndent += 1;
          state.tokenize[state.tokenize.length - 1] = tokenMacro(begin, end, true);
          return "meta";
        }

        if (stream.match(end + "}")) {
          state.currentIndent -= 1;
          state.tokenize.pop();
          return "meta";
        }

        return tokenBase(stream, state);
      };
    }

    function tokenMacroDef(stream, state) {
      if (stream.eatSpace()) {
        return null;
      }

      var matched;
      if (matched = stream.match(idents)) {
        if (matched == "def") {
          return "keyword";
        }
        stream.eat(/[?!]/);
      }

      state.tokenize.pop();
      return "def";
    }

    function tokenFollowIdent(stream, state) {
      if (stream.eatSpace()) {
        return null;
      }

      if (stream.match(idents)) {
        stream.eat(/[!?]/);
      } else {
        stream.match(operators) || stream.match(conditionalOperators) || stream.match(indexingOperators);
      }
      state.tokenize.pop();
      return "def";
    }

    function tokenFollowType(stream, state) {
      if (stream.eatSpace()) {
        return null;
      }

      stream.match(types);
      state.tokenize.pop();
      return "def";
    }

    function tokenQuote(end, style, embed) {
      return function (stream, state) {
        var escaped = false;

        while (stream.peek()) {
          if (!escaped) {
            if (stream.match("{%", false)) {
              state.tokenize.push(tokenMacro("%", "%"));
              return style;
            }

            if (stream.match("{{", false)) {
              state.tokenize.push(tokenMacro("{", "}"));
              return style;
            }

            if (embed && stream.match("#{", false)) {
              state.tokenize.push(tokenNest("#{", "}", "meta"));
              return style;
            }

            var ch = stream.next();

            if (ch == end) {
              state.tokenize.pop();
              return style;
            }

            escaped = embed && ch == "\\";
          } else {
            stream.next();
            escaped = false;
          }
        }

        return style;
      };
    }

    function tokenHereDoc(phrase, embed) {
      return function (stream, state) {
        if (stream.sol()) {
          stream.eatSpace()
          if (stream.match(phrase)) {
            state.tokenize.pop();
            return "string";
          }
        }

        var escaped = false;
        while (stream.peek()) {
          if (!escaped) {
            if (stream.match("{%", false)) {
              state.tokenize.push(tokenMacro("%", "%"));
              return "string";
            }

            if (stream.match("{{", false)) {
              state.tokenize.push(tokenMacro("{", "}"));
              return "string";
            }

            if (embed && stream.match("#{", false)) {
              state.tokenize.push(tokenNest("#{", "}", "meta"));
              return "string";
            }

            escaped = embed && stream.next() == "\\";
          } else {
            stream.next();
            escaped = false;
          }
        }

        return "string";
      }
    }

    return {
      startState: function () {
        return {
          tokenize: [tokenBase],
          currentIndent: 0,
          lastToken: null,
          lastStyle: null,
          blocks: []
        };
      },

      token: function (stream, state) {
        var style = state.tokenize[state.tokenize.length - 1](stream, state);
        var token = stream.current();

        if (style && style != "comment") {
          state.lastToken = token;
          state.lastStyle = style;
        }

        return style;
      },

      indent: function (state, textAfter) {
        textAfter = textAfter.replace(/^\s*(?:\{%)?\s*|\s*(?:%\})?\s*$/g, "");

        if (dedentKeywords.test(textAfter) || dedentPunctuals.test(textAfter)) {
          return config.indentUnit * (state.currentIndent - 1);
        }

        return config.indentUnit * state.currentIndent;
      },

      fold: "indent",
      electricInput: wordRegExp(dedentPunctualsArray.concat(dedentKeywordsArray), true),
      lineComment: '#'
    };
  });

  CodeMirror.defineMIME("text/x-crystal", "crystal");
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/cypher/cypher.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// By the Neo4j Team and contributors.
// https://github.com/neo4j-contrib/CodeMirror

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
  "use strict";
  var wordRegexp = function(words) {
    return new RegExp("^(?:" + words.join("|") + ")$", "i");
  };

  CodeMirror.defineMode("cypher", function(config) {
    var tokenBase = function(stream/*, state*/) {
      var ch = stream.next();
      if (ch ==='"') {
        stream.match(/^[^"]*"/);
        return "string";
      }
      if (ch === "'") {
        stream.match(/^[^']*'/);
        return "string";
      }
      if (/[{}\(\),\.;\[\]]/.test(ch)) {
        curPunc = ch;
        return "node";
      } else if (ch === "/" && stream.eat("/")) {
        stream.skipToEnd();
        return "comment";
      } else if (operatorChars.test(ch)) {
        stream.eatWhile(operatorChars);
        return null;
      } else {
        stream.eatWhile(/[_\w\d]/);
        if (stream.eat(":")) {
          stream.eatWhile(/[\w\d_\-]/);
          return "atom";
        }
        var word = stream.current();
        if (funcs.test(word)) return "builtin";
        if (preds.test(word)) return "def";
        if (keywords.test(word) || systemKeywords.test(word)) return "keyword";
        return "variable";
      }
    };
    var pushContext = function(state, type, col) {
      return state.context = {
        prev: state.context,
        indent: state.indent,
        col: col,
        type: type
      };
    };
    var popContext = function(state) {
      state.indent = state.context.indent;
      return state.context = state.context.prev;
    };
    var indentUnit = config.indentUnit;
    var curPunc;
    var funcs = wordRegexp(["abs", "acos", "allShortestPaths", "asin", "atan", "atan2", "avg", "ceil", "coalesce", "collect", "cos", "cot", "count", "degrees", "e", "endnode", "exp", "extract", "filter", "floor", "haversin", "head", "id", "keys", "labels", "last", "left", "length", "log", "log10", "lower", "ltrim", "max", "min", "node", "nodes", "percentileCont", "percentileDisc", "pi", "radians", "rand", "range", "reduce", "rel", "relationship", "relationships", "replace", "reverse", "right", "round", "rtrim", "shortestPath", "sign", "sin", "size", "split", "sqrt", "startnode", "stdev", "stdevp", "str", "substring", "sum", "tail", "tan", "timestamp", "toFloat", "toInt", "toString", "trim", "type", "upper"]);
    var preds = wordRegexp(["all", "and", "any", "contains", "exists", "has", "in", "none", "not", "or", "single", "xor"]);
    var keywords = wordRegexp(["as", "asc", "ascending", "assert", "by", "case", "commit", "constraint", "create", "csv", "cypher", "delete", "desc", "descending", "detach", "distinct", "drop", "else", "end", "ends", "explain", "false", "fieldterminator", "foreach", "from", "headers", "in", "index", "is", "join", "limit", "load", "match", "merge", "null", "on", "optional", "order", "periodic", "profile", "remove", "return", "scan", "set", "skip", "start", "starts", "then", "true", "union", "unique", "unwind", "using", "when", "where", "with", "call", "yield"]);
    var systemKeywords = wordRegexp(["access", "active", "assign", "all", "alter", "as", "catalog", "change", "copy", "create", "constraint", "constraints", "current", "database", "databases", "dbms", "default", "deny", "drop", "element", "elements", "exists", "from", "grant", "graph", "graphs", "if", "index", "indexes", "label", "labels", "management", "match", "name", "names", "new", "node", "nodes", "not", "of", "on", "or", "password", "populated", "privileges", "property", "read", "relationship", "relationships", "remove", "replace", "required", "revoke", "role", "roles", "set", "show", "start", "status", "stop", "suspended", "to", "traverse", "type", "types", "user", "users", "with", "write"]);
    var operatorChars = /[*+\-<>=&|~%^]/;

    return {
      startState: function(/*base*/) {
        return {
          tokenize: tokenBase,
          context: null,
          indent: 0,
          col: 0
        };
      },
      token: function(stream, state) {
        if (stream.sol()) {
          if (state.context && (state.context.align == null)) {
            state.context.align = false;
          }
          state.indent = stream.indentation();
        }
        if (stream.eatSpace()) {
          return null;
        }
        var style = state.tokenize(stream, state);
        if (style !== "comment" && state.context && (state.context.align == null) && state.context.type !== "pattern") {
          state.context.align = true;
        }
        if (curPunc === "(") {
          pushContext(state, ")", stream.column());
        } else if (curPunc === "[") {
          pushContext(state, "]", stream.column());
        } else if (curPunc === "{") {
          pushContext(state, "}", stream.column());
        } else if (/[\]\}\)]/.test(curPunc)) {
          while (state.context && state.context.type === "pattern") {
            popContext(state);
          }
          if (state.context && curPunc === state.context.type) {
            popContext(state);
          }
        } else if (curPunc === "." && state.context && state.context.type === "pattern") {
          popContext(state);
        } else if (/atom|string|variable/.test(style) && state.context) {
          if (/[\}\]]/.test(state.context.type)) {
            pushContext(state, "pattern", stream.column());
          } else if (state.context.type === "pattern" && !state.context.align) {
            state.context.align = true;
            state.context.col = stream.column();
          }
        }
        return style;
      },
      indent: function(state, textAfter) {
        var firstChar = textAfter && textAfter.charAt(0);
        var context = state.context;
        if (/[\]\}]/.test(firstChar)) {
          while (context && context.type === "pattern") {
            context = context.prev;
          }
        }
        var closing = context && firstChar === context.type;
        if (!context) return 0;
        if (context.type === "keywords") return CodeMirror.commands.newlineAndIndent;
        if (context.align) return context.col + (closing ? 0 : 1);
        return context.indent + (closing ? 0 : indentUnit);
      }
    };
  });

  CodeMirror.modeExtensions["cypher"] = {
    autoFormatLineBreaks: function(text) {
      var i, lines, reProcessedPortion;
      var lines = text.split("\n");
      var reProcessedPortion = /\s+\b(return|where|order by|match|with|skip|limit|create|delete|set)\b\s/g;
      for (var i = 0; i < lines.length; i++)
        lines[i] = lines[i].replace(reProcessedPortion, " \n$1 ").trim();
      return lines.join("\n");
    }
  };

  CodeMirror.defineMIME("application/x-cypher-query", "cypher");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/d/d.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("d", function(config, parserConfig) {
  var indentUnit = config.indentUnit,
      statementIndentUnit = parserConfig.statementIndentUnit || indentUnit,
      keywords = parserConfig.keywords || {},
      builtin = parserConfig.builtin || {},
      blockKeywords = parserConfig.blockKeywords || {},
      atoms = parserConfig.atoms || {},
      hooks = parserConfig.hooks || {},
      multiLineStrings = parserConfig.multiLineStrings;
  var isOperatorChar = /[+\-*&%=<>!?|\/]/;

  var curPunc;

  function tokenBase(stream, state) {
    var ch = stream.next();
    if (hooks[ch]) {
      var result = hooks[ch](stream, state);
      if (result !== false) return result;
    }
    if (ch == '"' || ch == "'" || ch == "`") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    }
    if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
      curPunc = ch;
      return null;
    }
    if (/\d/.test(ch)) {
      stream.eatWhile(/[\w\.]/);
      return "number";
    }
    if (ch == "/") {
      if (stream.eat("+")) {
        state.tokenize = tokenNestedComment;
        return tokenNestedComment(stream, state);
      }
      if (stream.eat("*")) {
        state.tokenize = tokenComment;
        return tokenComment(stream, state);
      }
      if (stream.eat("/")) {
        stream.skipToEnd();
        return "comment";
      }
    }
    if (isOperatorChar.test(ch)) {
      stream.eatWhile(isOperatorChar);
      return "operator";
    }
    stream.eatWhile(/[\w\$_\xa1-\uffff]/);
    var cur = stream.current();
    if (keywords.propertyIsEnumerable(cur)) {
      if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
      return "keyword";
    }
    if (builtin.propertyIsEnumerable(cur)) {
      if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
      return "builtin";
    }
    if (atoms.propertyIsEnumerable(cur)) return "atom";
    return "variable";
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, next, end = false;
      while ((next = stream.next()) != null) {
        if (next == quote && !escaped) {end = true; break;}
        escaped = !escaped && next == "\\";
      }
      if (end || !(escaped || multiLineStrings))
        state.tokenize = null;
      return "string";
    };
  }

  function tokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" && maybeEnd) {
        state.tokenize = null;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return "comment";
  }

  function tokenNestedComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" && maybeEnd) {
        state.tokenize = null;
        break;
      }
      maybeEnd = (ch == "+");
    }
    return "comment";
  }

  function Context(indented, column, type, align, prev) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.align = align;
    this.prev = prev;
  }
  function pushContext(state, col, type) {
    var indent = state.indented;
    if (state.context && state.context.type == "statement")
      indent = state.context.indented;
    return state.context = new Context(indent, col, type, null, state.context);
  }
  function popContext(state) {
    var t = state.context.type;
    if (t == ")" || t == "]" || t == "}")
      state.indented = state.context.indented;
    return state.context = state.context.prev;
  }

  // Interface

  return {
    startState: function(basecolumn) {
      return {
        tokenize: null,
        context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),
        indented: 0,
        startOfLine: true
      };
    },

    token: function(stream, state) {
      var ctx = state.context;
      if (stream.sol()) {
        if (ctx.align == null) ctx.align = false;
        state.indented = stream.indentation();
        state.startOfLine = true;
      }
      if (stream.eatSpace()) return null;
      curPunc = null;
      var style = (state.tokenize || tokenBase)(stream, state);
      if (style == "comment" || style == "meta") return style;
      if (ctx.align == null) ctx.align = true;

      if ((curPunc == ";" || curPunc == ":" || curPunc == ",") && ctx.type == "statement") popContext(state);
      else if (curPunc == "{") pushContext(state, stream.column(), "}");
      else if (curPunc == "[") pushContext(state, stream.column(), "]");
      else if (curPunc == "(") pushContext(state, stream.column(), ")");
      else if (curPunc == "}") {
        while (ctx.type == "statement") ctx = popContext(state);
        if (ctx.type == "}") ctx = popContext(state);
        while (ctx.type == "statement") ctx = popContext(state);
      }
      else if (curPunc == ctx.type) popContext(state);
      else if (((ctx.type == "}" || ctx.type == "top") && curPunc != ';') || (ctx.type == "statement" && curPunc == "newstatement"))
        pushContext(state, stream.column(), "statement");
      state.startOfLine = false;
      return style;
    },

    indent: function(state, textAfter) {
      if (state.tokenize != tokenBase && state.tokenize != null) return CodeMirror.Pass;
      var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);
      if (ctx.type == "statement" && firstChar == "}") ctx = ctx.prev;
      var closing = firstChar == ctx.type;
      if (ctx.type == "statement") return ctx.indented + (firstChar == "{" ? 0 : statementIndentUnit);
      else if (ctx.align) return ctx.column + (closing ? 0 : 1);
      else return ctx.indented + (closing ? 0 : indentUnit);
    },

    electricChars: "{}",
    blockCommentStart: "/*",
    blockCommentEnd: "*/",
    blockCommentContinue: " * ",
    lineComment: "//",
    fold: "brace"
  };
});

  function words(str) {
    var obj = {}, words = str.split(" ");
    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
    return obj;
  }

  var blockKeywords = "body catch class do else enum for foreach foreach_reverse if in interface mixin " +
                      "out scope struct switch try union unittest version while with";

  CodeMirror.defineMIME("text/x-d", {
    name: "d",
    keywords: words("abstract alias align asm assert auto break case cast cdouble cent cfloat const continue " +
                    "debug default delegate delete deprecated export extern final finally function goto immutable " +
                    "import inout invariant is lazy macro module new nothrow override package pragma private " +
                    "protected public pure ref return shared short static super synchronized template this " +
                    "throw typedef typeid typeof volatile __FILE__ __LINE__ __gshared __traits __vector __parameters " +
                    blockKeywords),
    blockKeywords: words(blockKeywords),
    builtin: words("bool byte char creal dchar double float idouble ifloat int ireal long real short ubyte " +
                   "ucent uint ulong ushort wchar wstring void size_t sizediff_t"),
    atoms: words("exit failure success true false null"),
    hooks: {
      "@": function(stream, _state) {
        stream.eatWhile(/[\w\$_]/);
        return "meta";
      }
    }
  });

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/dart/dart.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"), __webpack_require__("./src/ipywidgets/node_modules/codemirror/mode/clike/clike.js"));
  else {}
})(function(CodeMirror) {
  "use strict";

  var keywords = ("this super static final const abstract class extends external factory " +
    "implements mixin get native set typedef with enum throw rethrow " +
    "assert break case continue default in return new deferred async await covariant " +
    "try catch finally do else for if switch while import library export " +
    "part of show hide is as extension on yield late required").split(" ");
  var blockKeywords = "try catch finally do else for if switch while".split(" ");
  var atoms = "true false null".split(" ");
  var builtins = "void bool num int double dynamic var String Null Never".split(" ");

  function set(words) {
    var obj = {};
    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
    return obj;
  }

  function pushInterpolationStack(state) {
    (state.interpolationStack || (state.interpolationStack = [])).push(state.tokenize);
  }

  function popInterpolationStack(state) {
    return (state.interpolationStack || (state.interpolationStack = [])).pop();
  }

  function sizeInterpolationStack(state) {
    return state.interpolationStack ? state.interpolationStack.length : 0;
  }

  CodeMirror.defineMIME("application/dart", {
    name: "clike",
    keywords: set(keywords),
    blockKeywords: set(blockKeywords),
    builtin: set(builtins),
    atoms: set(atoms),
    hooks: {
      "@": function(stream) {
        stream.eatWhile(/[\w\$_\.]/);
        return "meta";
      },

      // custom string handling to deal with triple-quoted strings and string interpolation
      "'": function(stream, state) {
        return tokenString("'", stream, state, false);
      },
      "\"": function(stream, state) {
        return tokenString("\"", stream, state, false);
      },
      "r": function(stream, state) {
        var peek = stream.peek();
        if (peek == "'" || peek == "\"") {
          return tokenString(stream.next(), stream, state, true);
        }
        return false;
      },

      "}": function(_stream, state) {
        // "}" is end of interpolation, if interpolation stack is non-empty
        if (sizeInterpolationStack(state) > 0) {
          state.tokenize = popInterpolationStack(state);
          return null;
        }
        return false;
      },

      "/": function(stream, state) {
        if (!stream.eat("*")) return false
        state.tokenize = tokenNestedComment(1)
        return state.tokenize(stream, state)
      },
      token: function(stream, _, style) {
        if (style == "variable") {
          // Assume uppercase symbols are classes using variable-2
          var isUpper = RegExp('^[_$]*[A-Z][a-zA-Z0-9_$]*$','g');
          if (isUpper.test(stream.current())) {
            return 'variable-2';
          }
        }
      }
    }
  });

  function tokenString(quote, stream, state, raw) {
    var tripleQuoted = false;
    if (stream.eat(quote)) {
      if (stream.eat(quote)) tripleQuoted = true;
      else return "string"; //empty string
    }
    function tokenStringHelper(stream, state) {
      var escaped = false;
      while (!stream.eol()) {
        if (!raw && !escaped && stream.peek() == "$") {
          pushInterpolationStack(state);
          state.tokenize = tokenInterpolation;
          return "string";
        }
        var next = stream.next();
        if (next == quote && !escaped && (!tripleQuoted || stream.match(quote + quote))) {
          state.tokenize = null;
          break;
        }
        escaped = !raw && !escaped && next == "\\";
      }
      return "string";
    }
    state.tokenize = tokenStringHelper;
    return tokenStringHelper(stream, state);
  }

  function tokenInterpolation(stream, state) {
    stream.eat("$");
    if (stream.eat("{")) {
      // let clike handle the content of ${...},
      // we take over again when "}" appears (see hooks).
      state.tokenize = null;
    } else {
      state.tokenize = tokenInterpolationIdentifier;
    }
    return null;
  }

  function tokenInterpolationIdentifier(stream, state) {
    stream.eatWhile(/[\w_]/);
    state.tokenize = popInterpolationStack(state);
    return "variable";
  }

  function tokenNestedComment(depth) {
    return function (stream, state) {
      var ch
      while (ch = stream.next()) {
        if (ch == "*" && stream.eat("/")) {
          if (depth == 1) {
            state.tokenize = null
            break
          } else {
            state.tokenize = tokenNestedComment(depth - 1)
            return state.tokenize(stream, state)
          }
        } else if (ch == "/" && stream.eat("*")) {
          state.tokenize = tokenNestedComment(depth + 1)
          return state.tokenize(stream, state)
        }
      }
      return "comment"
    }
  }

  CodeMirror.registerHelper("hintWords", "application/dart", keywords.concat(atoms).concat(builtins));

  // This is needed to make loading through meta.js work.
  CodeMirror.defineMode("dart", function(conf) {
    return CodeMirror.getMode(conf, "application/dart");
  }, "clike");
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/diff/diff.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("diff", function() {

  var TOKEN_NAMES = {
    '+': 'positive',
    '-': 'negative',
    '@': 'meta'
  };

  return {
    token: function(stream) {
      var tw_pos = stream.string.search(/[\t ]+?$/);

      if (!stream.sol() || tw_pos === 0) {
        stream.skipToEnd();
        return ("error " + (
          TOKEN_NAMES[stream.string.charAt(0)] || '')).replace(/ $/, '');
      }

      var token_name = TOKEN_NAMES[stream.peek()] || stream.skipToEnd();

      if (tw_pos === -1) {
        stream.skipToEnd();
      } else {
        stream.pos = tw_pos;
      }

      return token_name;
    }
  };
});

CodeMirror.defineMIME("text/x-diff", "diff");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/django/django.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"), __webpack_require__("./src/ipywidgets/node_modules/codemirror/mode/htmlmixed/htmlmixed.js"),
        __webpack_require__("./src/ipywidgets/node_modules/codemirror/addon/mode/overlay.js"));
  else {}
})(function(CodeMirror) {
  "use strict";

  CodeMirror.defineMode("django:inner", function() {
    var keywords = ["block", "endblock", "for", "endfor", "true", "false", "filter", "endfilter",
                    "loop", "none", "self", "super", "if", "elif", "endif", "as", "else", "import",
                    "with", "endwith", "without", "context", "ifequal", "endifequal", "ifnotequal",
                    "endifnotequal", "extends", "include", "load", "comment", "endcomment",
                    "empty", "url", "static", "trans", "blocktrans", "endblocktrans", "now",
                    "regroup", "lorem", "ifchanged", "endifchanged", "firstof", "debug", "cycle",
                    "csrf_token", "autoescape", "endautoescape", "spaceless", "endspaceless",
                    "ssi", "templatetag", "verbatim", "endverbatim", "widthratio"],
        filters = ["add", "addslashes", "capfirst", "center", "cut", "date",
                   "default", "default_if_none", "dictsort",
                   "dictsortreversed", "divisibleby", "escape", "escapejs",
                   "filesizeformat", "first", "floatformat", "force_escape",
                   "get_digit", "iriencode", "join", "last", "length",
                   "length_is", "linebreaks", "linebreaksbr", "linenumbers",
                   "ljust", "lower", "make_list", "phone2numeric", "pluralize",
                   "pprint", "random", "removetags", "rjust", "safe",
                   "safeseq", "slice", "slugify", "stringformat", "striptags",
                   "time", "timesince", "timeuntil", "title", "truncatechars",
                   "truncatechars_html", "truncatewords", "truncatewords_html",
                   "unordered_list", "upper", "urlencode", "urlize",
                   "urlizetrunc", "wordcount", "wordwrap", "yesno"],
        operators = ["==", "!=", "<", ">", "<=", ">="],
        wordOperators = ["in", "not", "or", "and"];

    keywords = new RegExp("^\\b(" + keywords.join("|") + ")\\b");
    filters = new RegExp("^\\b(" + filters.join("|") + ")\\b");
    operators = new RegExp("^\\b(" + operators.join("|") + ")\\b");
    wordOperators = new RegExp("^\\b(" + wordOperators.join("|") + ")\\b");

    // We have to return "null" instead of null, in order to avoid string
    // styling as the default, when using Django templates inside HTML
    // element attributes
    function tokenBase (stream, state) {
      // Attempt to identify a variable, template or comment tag respectively
      if (stream.match("{{")) {
        state.tokenize = inVariable;
        return "tag";
      } else if (stream.match("{%")) {
        state.tokenize = inTag;
        return "tag";
      } else if (stream.match("{#")) {
        state.tokenize = inComment;
        return "comment";
      }

      // Ignore completely any stream series that do not match the
      // Django template opening tags.
      while (stream.next() != null && !stream.match(/\{[{%#]/, false)) {}
      return null;
    }

    // A string can be included in either single or double quotes (this is
    // the delimiter). Mark everything as a string until the start delimiter
    // occurs again.
    function inString (delimiter, previousTokenizer) {
      return function (stream, state) {
        if (!state.escapeNext && stream.eat(delimiter)) {
          state.tokenize = previousTokenizer;
        } else {
          if (state.escapeNext) {
            state.escapeNext = false;
          }

          var ch = stream.next();

          // Take into account the backslash for escaping characters, such as
          // the string delimiter.
          if (ch == "\\") {
            state.escapeNext = true;
          }
        }

        return "string";
      };
    }

    // Apply Django template variable syntax highlighting
    function inVariable (stream, state) {
      // Attempt to match a dot that precedes a property
      if (state.waitDot) {
        state.waitDot = false;

        if (stream.peek() != ".") {
          return "null";
        }

        // Dot followed by a non-word character should be considered an error.
        if (stream.match(/\.\W+/)) {
          return "error";
        } else if (stream.eat(".")) {
          state.waitProperty = true;
          return "null";
        } else {
          throw Error ("Unexpected error while waiting for property.");
        }
      }

      // Attempt to match a pipe that precedes a filter
      if (state.waitPipe) {
        state.waitPipe = false;

        if (stream.peek() != "|") {
          return "null";
        }

        // Pipe followed by a non-word character should be considered an error.
        if (stream.match(/\.\W+/)) {
          return "error";
        } else if (stream.eat("|")) {
          state.waitFilter = true;
          return "null";
        } else {
          throw Error ("Unexpected error while waiting for filter.");
        }
      }

      // Highlight properties
      if (state.waitProperty) {
        state.waitProperty = false;
        if (stream.match(/\b(\w+)\b/)) {
          state.waitDot = true;  // A property can be followed by another property
          state.waitPipe = true;  // A property can be followed by a filter
          return "property";
        }
      }

      // Highlight filters
      if (state.waitFilter) {
          state.waitFilter = false;
        if (stream.match(filters)) {
          return "variable-2";
        }
      }

      // Ignore all white spaces
      if (stream.eatSpace()) {
        state.waitProperty = false;
        return "null";
      }

      // Identify numbers
      if (stream.match(/\b\d+(\.\d+)?\b/)) {
        return "number";
      }

      // Identify strings
      if (stream.match("'")) {
        state.tokenize = inString("'", state.tokenize);
        return "string";
      } else if (stream.match('"')) {
        state.tokenize = inString('"', state.tokenize);
        return "string";
      }

      // Attempt to find the variable
      if (stream.match(/\b(\w+)\b/) && !state.foundVariable) {
        state.waitDot = true;
        state.waitPipe = true;  // A property can be followed by a filter
        return "variable";
      }

      // If found closing tag reset
      if (stream.match("}}")) {
        state.waitProperty = null;
        state.waitFilter = null;
        state.waitDot = null;
        state.waitPipe = null;
        state.tokenize = tokenBase;
        return "tag";
      }

      // If nothing was found, advance to the next character
      stream.next();
      return "null";
    }

    function inTag (stream, state) {
      // Attempt to match a dot that precedes a property
      if (state.waitDot) {
        state.waitDot = false;

        if (stream.peek() != ".") {
          return "null";
        }

        // Dot followed by a non-word character should be considered an error.
        if (stream.match(/\.\W+/)) {
          return "error";
        } else if (stream.eat(".")) {
          state.waitProperty = true;
          return "null";
        } else {
          throw Error ("Unexpected error while waiting for property.");
        }
      }

      // Attempt to match a pipe that precedes a filter
      if (state.waitPipe) {
        state.waitPipe = false;

        if (stream.peek() != "|") {
          return "null";
        }

        // Pipe followed by a non-word character should be considered an error.
        if (stream.match(/\.\W+/)) {
          return "error";
        } else if (stream.eat("|")) {
          state.waitFilter = true;
          return "null";
        } else {
          throw Error ("Unexpected error while waiting for filter.");
        }
      }

      // Highlight properties
      if (state.waitProperty) {
        state.waitProperty = false;
        if (stream.match(/\b(\w+)\b/)) {
          state.waitDot = true;  // A property can be followed by another property
          state.waitPipe = true;  // A property can be followed by a filter
          return "property";
        }
      }

      // Highlight filters
      if (state.waitFilter) {
          state.waitFilter = false;
        if (stream.match(filters)) {
          return "variable-2";
        }
      }

      // Ignore all white spaces
      if (stream.eatSpace()) {
        state.waitProperty = false;
        return "null";
      }

      // Identify numbers
      if (stream.match(/\b\d+(\.\d+)?\b/)) {
        return "number";
      }

      // Identify strings
      if (stream.match("'")) {
        state.tokenize = inString("'", state.tokenize);
        return "string";
      } else if (stream.match('"')) {
        state.tokenize = inString('"', state.tokenize);
        return "string";
      }

      // Attempt to match an operator
      if (stream.match(operators)) {
        return "operator";
      }

      // Attempt to match a word operator
      if (stream.match(wordOperators)) {
        return "keyword";
      }

      // Attempt to match a keyword
      var keywordMatch = stream.match(keywords);
      if (keywordMatch) {
        if (keywordMatch[0] == "comment") {
          state.blockCommentTag = true;
        }
        return "keyword";
      }

      // Attempt to match a variable
      if (stream.match(/\b(\w+)\b/)) {
        state.waitDot = true;
        state.waitPipe = true;  // A property can be followed by a filter
        return "variable";
      }

      // If found closing tag reset
      if (stream.match("%}")) {
        state.waitProperty = null;
        state.waitFilter = null;
        state.waitDot = null;
        state.waitPipe = null;
        // If the tag that closes is a block comment tag, we want to mark the
        // following code as comment, until the tag closes.
        if (state.blockCommentTag) {
          state.blockCommentTag = false;  // Release the "lock"
          state.tokenize = inBlockComment;
        } else {
          state.tokenize = tokenBase;
        }
        return "tag";
      }

      // If nothing was found, advance to the next character
      stream.next();
      return "null";
    }

    // Mark everything as comment inside the tag and the tag itself.
    function inComment (stream, state) {
      if (stream.match(/^.*?#\}/)) state.tokenize = tokenBase
      else stream.skipToEnd()
      return "comment";
    }

    // Mark everything as a comment until the `blockcomment` tag closes.
    function inBlockComment (stream, state) {
      if (stream.match(/\{%\s*endcomment\s*%\}/, false)) {
        state.tokenize = inTag;
        stream.match("{%");
        return "tag";
      } else {
        stream.next();
        return "comment";
      }
    }

    return {
      startState: function () {
        return {tokenize: tokenBase};
      },
      token: function (stream, state) {
        return state.tokenize(stream, state);
      },
      blockCommentStart: "{% comment %}",
      blockCommentEnd: "{% endcomment %}"
    };
  });

  CodeMirror.defineMode("django", function(config) {
    var htmlBase = CodeMirror.getMode(config, "text/html");
    var djangoInner = CodeMirror.getMode(config, "django:inner");
    return CodeMirror.overlayMode(htmlBase, djangoInner);
  });

  CodeMirror.defineMIME("text/x-django", "django");
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/dockerfile/dockerfile.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"), __webpack_require__("./src/ipywidgets/node_modules/codemirror/addon/mode/simple.js"));
  else {}
})(function(CodeMirror) {
  "use strict";

  var from = "from";
  var fromRegex = new RegExp("^(\\s*)\\b(" + from + ")\\b", "i");

  var shells = ["run", "cmd", "entrypoint", "shell"];
  var shellsAsArrayRegex = new RegExp("^(\\s*)(" + shells.join('|') + ")(\\s+\\[)", "i");

  var expose = "expose";
  var exposeRegex = new RegExp("^(\\s*)(" + expose + ")(\\s+)", "i");

  var others = [
    "arg", "from", "maintainer", "label", "env",
    "add", "copy", "volume", "user",
    "workdir", "onbuild", "stopsignal", "healthcheck", "shell"
  ];

  // Collect all Dockerfile directives
  var instructions = [from, expose].concat(shells).concat(others),
      instructionRegex = "(" + instructions.join('|') + ")",
      instructionOnlyLine = new RegExp("^(\\s*)" + instructionRegex + "(\\s*)(#.*)?$", "i"),
      instructionWithArguments = new RegExp("^(\\s*)" + instructionRegex + "(\\s+)", "i");

  CodeMirror.defineSimpleMode("dockerfile", {
    start: [
      // Block comment: This is a line starting with a comment
      {
        regex: /^\s*#.*$/,
        sol: true,
        token: "comment"
      },
      {
        regex: fromRegex,
        token: [null, "keyword"],
        sol: true,
        next: "from"
      },
      // Highlight an instruction without any arguments (for convenience)
      {
        regex: instructionOnlyLine,
        token: [null, "keyword", null, "error"],
        sol: true
      },
      {
        regex: shellsAsArrayRegex,
        token: [null, "keyword", null],
        sol: true,
        next: "array"
      },
      {
        regex: exposeRegex,
        token: [null, "keyword", null],
        sol: true,
        next: "expose"
      },
      // Highlight an instruction followed by arguments
      {
        regex: instructionWithArguments,
        token: [null, "keyword", null],
        sol: true,
        next: "arguments"
      },
      {
        regex: /./,
        token: null
      }
    ],
    from: [
      {
        regex: /\s*$/,
        token: null,
        next: "start"
      },
      {
        // Line comment without instruction arguments is an error
        regex: /(\s*)(#.*)$/,
        token: [null, "error"],
        next: "start"
      },
      {
        regex: /(\s*\S+\s+)(as)/i,
        token: [null, "keyword"],
        next: "start"
      },
      // Fail safe return to start
      {
        token: null,
        next: "start"
      }
    ],
    single: [
      {
        regex: /(?:[^\\']|\\.)/,
        token: "string"
      },
      {
        regex: /'/,
        token: "string",
        pop: true
      }
    ],
    double: [
      {
        regex: /(?:[^\\"]|\\.)/,
        token: "string"
      },
      {
        regex: /"/,
        token: "string",
        pop: true
      }
    ],
    array: [
      {
        regex: /\]/,
        token: null,
        next: "start"
      },
      {
        regex: /"(?:[^\\"]|\\.)*"?/,
        token: "string"
      }
    ],
    expose: [
      {
        regex: /\d+$/,
        token: "number",
        next: "start"
      },
      {
        regex: /[^\d]+$/,
        token: null,
        next: "start"
      },
      {
        regex: /\d+/,
        token: "number"
      },
      {
        regex: /[^\d]+/,
        token: null
      },
      // Fail safe return to start
      {
        token: null,
        next: "start"
      }
    ],
    arguments: [
      {
        regex: /^\s*#.*$/,
        sol: true,
        token: "comment"
      },
      {
        regex: /"(?:[^\\"]|\\.)*"?$/,
        token: "string",
        next: "start"
      },
      {
        regex: /"/,
        token: "string",
        push: "double"
      },
      {
        regex: /'(?:[^\\']|\\.)*'?$/,
        token: "string",
        next: "start"
      },
      {
        regex: /'/,
        token: "string",
        push: "single"
      },
      {
        regex: /[^#"']+[\\`]$/,
        token: null
      },
      {
        regex: /[^#"']+$/,
        token: null,
        next: "start"
      },
      {
        regex: /[^#"']+/,
        token: null
      },
      // Fail safe return to start
      {
        token: null,
        next: "start"
      }
    ],
    meta: {
      lineComment: "#"
    }
  });

  CodeMirror.defineMIME("text/x-dockerfile", "dockerfile");
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/dtd/dtd.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

/*
  DTD mode
  Ported to CodeMirror by Peter Kroon <plakroon@gmail.com>
  Report bugs/issues here: https://github.com/codemirror/CodeMirror/issues
  GitHub: @peterkroon
*/

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("dtd", function(config) {
  var indentUnit = config.indentUnit, type;
  function ret(style, tp) {type = tp; return style;}

  function tokenBase(stream, state) {
    var ch = stream.next();

    if (ch == "<" && stream.eat("!") ) {
      if (stream.eatWhile(/[\-]/)) {
        state.tokenize = tokenSGMLComment;
        return tokenSGMLComment(stream, state);
      } else if (stream.eatWhile(/[\w]/)) return ret("keyword", "doindent");
    } else if (ch == "<" && stream.eat("?")) { //xml declaration
      state.tokenize = inBlock("meta", "?>");
      return ret("meta", ch);
    } else if (ch == "#" && stream.eatWhile(/[\w]/)) return ret("atom", "tag");
    else if (ch == "|") return ret("keyword", "separator");
    else if (ch.match(/[\(\)\[\]\-\.,\+\?>]/)) return ret(null, ch);//if(ch === ">") return ret(null, "endtag"); else
    else if (ch.match(/[\[\]]/)) return ret("rule", ch);
    else if (ch == "\"" || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    } else if (stream.eatWhile(/[a-zA-Z\?\+\d]/)) {
      var sc = stream.current();
      if( sc.substr(sc.length-1,sc.length).match(/\?|\+/) !== null )stream.backUp(1);
      return ret("tag", "tag");
    } else if (ch == "%" || ch == "*" ) return ret("number", "number");
    else {
      stream.eatWhile(/[\w\\\-_%.{,]/);
      return ret(null, null);
    }
  }

  function tokenSGMLComment(stream, state) {
    var dashes = 0, ch;
    while ((ch = stream.next()) != null) {
      if (dashes >= 2 && ch == ">") {
        state.tokenize = tokenBase;
        break;
      }
      dashes = (ch == "-") ? dashes + 1 : 0;
    }
    return ret("comment", "comment");
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, ch;
      while ((ch = stream.next()) != null) {
        if (ch == quote && !escaped) {
          state.tokenize = tokenBase;
          break;
        }
        escaped = !escaped && ch == "\\";
      }
      return ret("string", "tag");
    };
  }

  function inBlock(style, terminator) {
    return function(stream, state) {
      while (!stream.eol()) {
        if (stream.match(terminator)) {
          state.tokenize = tokenBase;
          break;
        }
        stream.next();
      }
      return style;
    };
  }

  return {
    startState: function(base) {
      return {tokenize: tokenBase,
              baseIndent: base || 0,
              stack: []};
    },

    token: function(stream, state) {
      if (stream.eatSpace()) return null;
      var style = state.tokenize(stream, state);

      var context = state.stack[state.stack.length-1];
      if (stream.current() == "[" || type === "doindent" || type == "[") state.stack.push("rule");
      else if (type === "endtag") state.stack[state.stack.length-1] = "endtag";
      else if (stream.current() == "]" || type == "]" || (type == ">" && context == "rule")) state.stack.pop();
      else if (type == "[") state.stack.push("[");
      return style;
    },

    indent: function(state, textAfter) {
      var n = state.stack.length;

      if( textAfter.charAt(0) === ']' )n--;
      else if(textAfter.substr(textAfter.length-1, textAfter.length) === ">"){
        if(textAfter.substr(0,1) === "<") {}
        else if( type == "doindent" && textAfter.length > 1 ) {}
        else if( type == "doindent")n--;
        else if( type == ">" && textAfter.length > 1) {}
        else if( type == "tag" && textAfter !== ">") {}
        else if( type == "tag" && state.stack[state.stack.length-1] == "rule")n--;
        else if( type == "tag")n++;
        else if( textAfter === ">" && state.stack[state.stack.length-1] == "rule" && type === ">")n--;
        else if( textAfter === ">" && state.stack[state.stack.length-1] == "rule") {}
        else if( textAfter.substr(0,1) !== "<" && textAfter.substr(0,1) === ">" )n=n-1;
        else if( textAfter === ">") {}
        else n=n-1;
        //over rule them all
        if(type == null || type == "]")n--;
      }

      return state.baseIndent + n * indentUnit;
    },

    electricChars: "]>"
  };
});

CodeMirror.defineMIME("application/xml-dtd", "dtd");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/dylan/dylan.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

function forEach(arr, f) {
  for (var i = 0; i < arr.length; i++) f(arr[i], i)
}
function some(arr, f) {
  for (var i = 0; i < arr.length; i++) if (f(arr[i], i)) return true
  return false
}

CodeMirror.defineMode("dylan", function(_config) {
  // Words
  var words = {
    // Words that introduce unnamed definitions like "define interface"
    unnamedDefinition: ["interface"],

    // Words that introduce simple named definitions like "define library"
    namedDefinition: ["module", "library", "macro",
                      "C-struct", "C-union",
                      "C-function", "C-callable-wrapper"
                     ],

    // Words that introduce type definitions like "define class".
    // These are also parameterized like "define method" and are
    // appended to otherParameterizedDefinitionWords
    typeParameterizedDefinition: ["class", "C-subtype", "C-mapped-subtype"],

    // Words that introduce trickier definitions like "define method".
    // These require special definitions to be added to startExpressions
    otherParameterizedDefinition: ["method", "function",
                                   "C-variable", "C-address"
                                  ],

    // Words that introduce module constant definitions.
    // These must also be simple definitions and are
    // appended to otherSimpleDefinitionWords
    constantSimpleDefinition: ["constant"],

    // Words that introduce module variable definitions.
    // These must also be simple definitions and are
    // appended to otherSimpleDefinitionWords
    variableSimpleDefinition: ["variable"],

    // Other words that introduce simple definitions
    // (without implicit bodies).
    otherSimpleDefinition: ["generic", "domain",
                            "C-pointer-type",
                            "table"
                           ],

    // Words that begin statements with implicit bodies.
    statement: ["if", "block", "begin", "method", "case",
                "for", "select", "when", "unless", "until",
                "while", "iterate", "profiling", "dynamic-bind"
               ],

    // Patterns that act as separators in compound statements.
    // This may include any general pattern that must be indented
    // specially.
    separator: ["finally", "exception", "cleanup", "else",
                "elseif", "afterwards"
               ],

    // Keywords that do not require special indentation handling,
    // but which should be highlighted
    other: ["above", "below", "by", "from", "handler", "in",
            "instance", "let", "local", "otherwise", "slot",
            "subclass", "then", "to", "keyed-by", "virtual"
           ],

    // Condition signaling function calls
    signalingCalls: ["signal", "error", "cerror",
                     "break", "check-type", "abort"
                    ]
  };

  words["otherDefinition"] =
    words["unnamedDefinition"]
    .concat(words["namedDefinition"])
    .concat(words["otherParameterizedDefinition"]);

  words["definition"] =
    words["typeParameterizedDefinition"]
    .concat(words["otherDefinition"]);

  words["parameterizedDefinition"] =
    words["typeParameterizedDefinition"]
    .concat(words["otherParameterizedDefinition"]);

  words["simpleDefinition"] =
    words["constantSimpleDefinition"]
    .concat(words["variableSimpleDefinition"])
    .concat(words["otherSimpleDefinition"]);

  words["keyword"] =
    words["statement"]
    .concat(words["separator"])
    .concat(words["other"]);

  // Patterns
  var symbolPattern = "[-_a-zA-Z?!*@<>$%]+";
  var symbol = new RegExp("^" + symbolPattern);
  var patterns = {
    // Symbols with special syntax
    symbolKeyword: symbolPattern + ":",
    symbolClass: "<" + symbolPattern + ">",
    symbolGlobal: "\\*" + symbolPattern + "\\*",
    symbolConstant: "\\$" + symbolPattern
  };
  var patternStyles = {
    symbolKeyword: "atom",
    symbolClass: "tag",
    symbolGlobal: "variable-2",
    symbolConstant: "variable-3"
  };

  // Compile all patterns to regular expressions
  for (var patternName in patterns)
    if (patterns.hasOwnProperty(patternName))
      patterns[patternName] = new RegExp("^" + patterns[patternName]);

  // Names beginning "with-" and "without-" are commonly
  // used as statement macro
  patterns["keyword"] = [/^with(?:out)?-[-_a-zA-Z?!*@<>$%]+/];

  var styles = {};
  styles["keyword"] = "keyword";
  styles["definition"] = "def";
  styles["simpleDefinition"] = "def";
  styles["signalingCalls"] = "builtin";

  // protected words lookup table
  var wordLookup = {};
  var styleLookup = {};

  forEach([
    "keyword",
    "definition",
    "simpleDefinition",
    "signalingCalls"
  ], function(type) {
    forEach(words[type], function(word) {
      wordLookup[word] = type;
      styleLookup[word] = styles[type];
    });
  });


  function chain(stream, state, f) {
    state.tokenize = f;
    return f(stream, state);
  }

  function tokenBase(stream, state) {
    // String
    var ch = stream.peek();
    if (ch == "'" || ch == '"') {
      stream.next();
      return chain(stream, state, tokenString(ch, "string"));
    }
    // Comment
    else if (ch == "/") {
      stream.next();
      if (stream.eat("*")) {
        return chain(stream, state, tokenComment);
      } else if (stream.eat("/")) {
        stream.skipToEnd();
        return "comment";
      }
      stream.backUp(1);
    }
    // Decimal
    else if (/[+\-\d\.]/.test(ch)) {
      if (stream.match(/^[+-]?[0-9]*\.[0-9]*([esdx][+-]?[0-9]+)?/i) ||
          stream.match(/^[+-]?[0-9]+([esdx][+-]?[0-9]+)/i) ||
          stream.match(/^[+-]?\d+/)) {
        return "number";
      }
    }
    // Hash
    else if (ch == "#") {
      stream.next();
      // Symbol with string syntax
      ch = stream.peek();
      if (ch == '"') {
        stream.next();
        return chain(stream, state, tokenString('"', "string"));
      }
      // Binary number
      else if (ch == "b") {
        stream.next();
        stream.eatWhile(/[01]/);
        return "number";
      }
      // Hex number
      else if (ch == "x") {
        stream.next();
        stream.eatWhile(/[\da-f]/i);
        return "number";
      }
      // Octal number
      else if (ch == "o") {
        stream.next();
        stream.eatWhile(/[0-7]/);
        return "number";
      }
      // Token concatenation in macros
      else if (ch == '#') {
        stream.next();
        return "punctuation";
      }
      // Sequence literals
      else if ((ch == '[') || (ch == '(')) {
        stream.next();
        return "bracket";
      // Hash symbol
      } else if (stream.match(/f|t|all-keys|include|key|next|rest/i)) {
        return "atom";
      } else {
        stream.eatWhile(/[-a-zA-Z]/);
        return "error";
      }
    } else if (ch == "~") {
      stream.next();
      ch = stream.peek();
      if (ch == "=") {
        stream.next();
        ch = stream.peek();
        if (ch == "=") {
          stream.next();
          return "operator";
        }
        return "operator";
      }
      return "operator";
    } else if (ch == ":") {
      stream.next();
      ch = stream.peek();
      if (ch == "=") {
        stream.next();
        return "operator";
      } else if (ch == ":") {
        stream.next();
        return "punctuation";
      }
    } else if ("[](){}".indexOf(ch) != -1) {
      stream.next();
      return "bracket";
    } else if (".,".indexOf(ch) != -1) {
      stream.next();
      return "punctuation";
    } else if (stream.match("end")) {
      return "keyword";
    }
    for (var name in patterns) {
      if (patterns.hasOwnProperty(name)) {
        var pattern = patterns[name];
        if ((pattern instanceof Array && some(pattern, function(p) {
          return stream.match(p);
        })) || stream.match(pattern))
          return patternStyles[name];
      }
    }
    if (/[+\-*\/^=<>&|]/.test(ch)) {
      stream.next();
      return "operator";
    }
    if (stream.match("define")) {
      return "def";
    } else {
      stream.eatWhile(/[\w\-]/);
      // Keyword
      if (wordLookup.hasOwnProperty(stream.current())) {
        return styleLookup[stream.current()];
      } else if (stream.current().match(symbol)) {
        return "variable";
      } else {
        stream.next();
        return "variable-2";
      }
    }
  }

  function tokenComment(stream, state) {
    var maybeEnd = false, maybeNested = false, nestedCount = 0, ch;
    while ((ch = stream.next())) {
      if (ch == "/" && maybeEnd) {
        if (nestedCount > 0) {
          nestedCount--;
        } else {
          state.tokenize = tokenBase;
          break;
        }
      } else if (ch == "*" && maybeNested) {
        nestedCount++;
      }
      maybeEnd = (ch == "*");
      maybeNested = (ch == "/");
    }
    return "comment";
  }

  function tokenString(quote, style) {
    return function(stream, state) {
      var escaped = false, next, end = false;
      while ((next = stream.next()) != null) {
        if (next == quote && !escaped) {
          end = true;
          break;
        }
        escaped = !escaped && next == "\\";
      }
      if (end || !escaped) {
        state.tokenize = tokenBase;
      }
      return style;
    };
  }

  // Interface
  return {
    startState: function() {
      return {
        tokenize: tokenBase,
        currentIndent: 0
      };
    },
    token: function(stream, state) {
      if (stream.eatSpace())
        return null;
      var style = state.tokenize(stream, state);
      return style;
    },
    blockCommentStart: "/*",
    blockCommentEnd: "*/"
  };
});

CodeMirror.defineMIME("text/x-dylan", "dylan");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/ebnf/ebnf.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
  "use strict";

  CodeMirror.defineMode("ebnf", function (config) {
    var commentType = {slash: 0, parenthesis: 1};
    var stateType = {comment: 0, _string: 1, characterClass: 2};
    var bracesMode = null;

    if (config.bracesMode)
      bracesMode = CodeMirror.getMode(config, config.bracesMode);

    return {
      startState: function () {
        return {
          stringType: null,
          commentType: null,
          braced: 0,
          lhs: true,
          localState: null,
          stack: [],
          inDefinition: false
        };
      },
      token: function (stream, state) {
        if (!stream) return;

        //check for state changes
        if (state.stack.length === 0) {
          //strings
          if ((stream.peek() == '"') || (stream.peek() == "'")) {
            state.stringType = stream.peek();
            stream.next(); // Skip quote
            state.stack.unshift(stateType._string);
          } else if (stream.match('/*')) { //comments starting with /*
            state.stack.unshift(stateType.comment);
            state.commentType = commentType.slash;
          } else if (stream.match('(*')) { //comments starting with (*
            state.stack.unshift(stateType.comment);
            state.commentType = commentType.parenthesis;
          }
        }

        //return state
        //stack has
        switch (state.stack[0]) {
        case stateType._string:
          while (state.stack[0] === stateType._string && !stream.eol()) {
            if (stream.peek() === state.stringType) {
              stream.next(); // Skip quote
              state.stack.shift(); // Clear flag
            } else if (stream.peek() === "\\") {
              stream.next();
              stream.next();
            } else {
              stream.match(/^.[^\\\"\']*/);
            }
          }
          return state.lhs ? "property string" : "string"; // Token style

        case stateType.comment:
          while (state.stack[0] === stateType.comment && !stream.eol()) {
            if (state.commentType === commentType.slash && stream.match('*/')) {
              state.stack.shift(); // Clear flag
              state.commentType = null;
            } else if (state.commentType === commentType.parenthesis && stream.match('*)')) {
              state.stack.shift(); // Clear flag
              state.commentType = null;
            } else {
              stream.match(/^.[^\*]*/);
            }
          }
          return "comment";

        case stateType.characterClass:
          while (state.stack[0] === stateType.characterClass && !stream.eol()) {
            if (!(stream.match(/^[^\]\\]+/) || stream.match('.'))) {
              state.stack.shift();
            }
          }
          return "operator";
        }

        var peek = stream.peek();

        if (bracesMode !== null && (state.braced || peek === "{")) {
          if (state.localState === null)
            state.localState = CodeMirror.startState(bracesMode);

          var token = bracesMode.token(stream, state.localState),
          text = stream.current();

          if (!token) {
            for (var i = 0; i < text.length; i++) {
              if (text[i] === "{") {
                if (state.braced === 0) {
                  token = "matchingbracket";
                }
                state.braced++;
              } else if (text[i] === "}") {
                state.braced--;
                if (state.braced === 0) {
                  token = "matchingbracket";
                }
              }
            }
          }
          return token;
        }

        //no stack
        switch (peek) {
        case "[":
          stream.next();
          state.stack.unshift(stateType.characterClass);
          return "bracket";
        case ":":
        case "|":
        case ";":
          stream.next();
          return "operator";
        case "%":
          if (stream.match("%%")) {
            return "header";
          } else if (stream.match(/[%][A-Za-z]+/)) {
            return "keyword";
          } else if (stream.match(/[%][}]/)) {
            return "matchingbracket";
          }
          break;
        case "/":
          if (stream.match(/[\/][A-Za-z]+/)) {
          return "keyword";
        }
        case "\\":
          if (stream.match(/[\][a-z]+/)) {
            return "string-2";
          }
        case ".":
          if (stream.match(".")) {
            return "atom";
          }
        case "*":
        case "-":
        case "+":
        case "^":
          if (stream.match(peek)) {
            return "atom";
          }
        case "$":
          if (stream.match("$$")) {
            return "builtin";
          } else if (stream.match(/[$][0-9]+/)) {
            return "variable-3";
          }
        case "<":
          if (stream.match(/<<[a-zA-Z_]+>>/)) {
            return "builtin";
          }
        }

        if (stream.match('//')) {
          stream.skipToEnd();
          return "comment";
        } else if (stream.match('return')) {
          return "operator";
        } else if (stream.match(/^[a-zA-Z_][a-zA-Z0-9_]*/)) {
          if (stream.match(/(?=[\(.])/)) {
            return "variable";
          } else if (stream.match(/(?=[\s\n]*[:=])/)) {
            return "def";
          }
          return "variable-2";
        } else if (["[", "]", "(", ")"].indexOf(stream.peek()) != -1) {
          stream.next();
          return "bracket";
        } else if (!stream.eatSpace()) {
          stream.next();
        }
        return null;
      }
    };
  });

  CodeMirror.defineMIME("text/x-ebnf", "ebnf");
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/ecl/ecl.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("ecl", function(config) {

  function words(str) {
    var obj = {}, words = str.split(" ");
    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
    return obj;
  }

  function metaHook(stream, state) {
    if (!state.startOfLine) return false;
    stream.skipToEnd();
    return "meta";
  }

  var indentUnit = config.indentUnit;
  var keyword = words("abs acos allnodes ascii asin asstring atan atan2 ave case choose choosen choosesets clustersize combine correlation cos cosh count covariance cron dataset dedup define denormalize distribute distributed distribution ebcdic enth error evaluate event eventextra eventname exists exp failcode failmessage fetch fromunicode getisvalid global graph group hash hash32 hash64 hashcrc hashmd5 having if index intformat isvalid iterate join keyunicode length library limit ln local log loop map matched matchlength matchposition matchtext matchunicode max merge mergejoin min nolocal nonempty normalize parse pipe power preload process project pull random range rank ranked realformat recordof regexfind regexreplace regroup rejected rollup round roundup row rowdiff sample set sin sinh sizeof soapcall sort sorted sqrt stepped stored sum table tan tanh thisnode topn tounicode transfer trim truncate typeof ungroup unicodeorder variance which workunit xmldecode xmlencode xmltext xmlunicode");
  var variable = words("apply assert build buildindex evaluate fail keydiff keypatch loadxml nothor notify output parallel sequential soapcall wait");
  var variable_2 = words("__compressed__ all and any as atmost before beginc++ best between case const counter csv descend encrypt end endc++ endmacro except exclusive expire export extend false few first flat from full function group header heading hole ifblock import in interface joined keep keyed last left limit load local locale lookup macro many maxcount maxlength min skew module named nocase noroot noscan nosort not of only opt or outer overwrite packed partition penalty physicallength pipe quote record relationship repeat return right scan self separator service shared skew skip sql store terminator thor threshold token transform trim true type unicodeorder unsorted validate virtual whole wild within xml xpath");
  var variable_3 = words("ascii big_endian boolean data decimal ebcdic integer pattern qstring real record rule set of string token udecimal unicode unsigned varstring varunicode");
  var builtin = words("checkpoint deprecated failcode failmessage failure global independent onwarning persist priority recovery stored success wait when");
  var blockKeywords = words("catch class do else finally for if switch try while");
  var atoms = words("true false null");
  var hooks = {"#": metaHook};
  var isOperatorChar = /[+\-*&%=<>!?|\/]/;

  var curPunc;

  function tokenBase(stream, state) {
    var ch = stream.next();
    if (hooks[ch]) {
      var result = hooks[ch](stream, state);
      if (result !== false) return result;
    }
    if (ch == '"' || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    }
    if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
      curPunc = ch;
      return null;
    }
    if (/\d/.test(ch)) {
      stream.eatWhile(/[\w\.]/);
      return "number";
    }
    if (ch == "/") {
      if (stream.eat("*")) {
        state.tokenize = tokenComment;
        return tokenComment(stream, state);
      }
      if (stream.eat("/")) {
        stream.skipToEnd();
        return "comment";
      }
    }
    if (isOperatorChar.test(ch)) {
      stream.eatWhile(isOperatorChar);
      return "operator";
    }
    stream.eatWhile(/[\w\$_]/);
    var cur = stream.current().toLowerCase();
    if (keyword.propertyIsEnumerable(cur)) {
      if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
      return "keyword";
    } else if (variable.propertyIsEnumerable(cur)) {
      if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
      return "variable";
    } else if (variable_2.propertyIsEnumerable(cur)) {
      if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
      return "variable-2";
    } else if (variable_3.propertyIsEnumerable(cur)) {
      if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
      return "variable-3";
    } else if (builtin.propertyIsEnumerable(cur)) {
      if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
      return "builtin";
    } else { //Data types are of from KEYWORD##
                var i = cur.length - 1;
                while(i >= 0 && (!isNaN(cur[i]) || cur[i] == '_'))
                        --i;

                if (i > 0) {
                        var cur2 = cur.substr(0, i + 1);
                if (variable_3.propertyIsEnumerable(cur2)) {
                        if (blockKeywords.propertyIsEnumerable(cur2)) curPunc = "newstatement";
                        return "variable-3";
                }
            }
    }
    if (atoms.propertyIsEnumerable(cur)) return "atom";
    return null;
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, next, end = false;
      while ((next = stream.next()) != null) {
        if (next == quote && !escaped) {end = true; break;}
        escaped = !escaped && next == "\\";
      }
      if (end || !escaped)
        state.tokenize = tokenBase;
      return "string";
    };
  }

  function tokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" && maybeEnd) {
        state.tokenize = tokenBase;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return "comment";
  }

  function Context(indented, column, type, align, prev) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.align = align;
    this.prev = prev;
  }
  function pushContext(state, col, type) {
    return state.context = new Context(state.indented, col, type, null, state.context);
  }
  function popContext(state) {
    var t = state.context.type;
    if (t == ")" || t == "]" || t == "}")
      state.indented = state.context.indented;
    return state.context = state.context.prev;
  }

  // Interface

  return {
    startState: function(basecolumn) {
      return {
        tokenize: null,
        context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),
        indented: 0,
        startOfLine: true
      };
    },

    token: function(stream, state) {
      var ctx = state.context;
      if (stream.sol()) {
        if (ctx.align == null) ctx.align = false;
        state.indented = stream.indentation();
        state.startOfLine = true;
      }
      if (stream.eatSpace()) return null;
      curPunc = null;
      var style = (state.tokenize || tokenBase)(stream, state);
      if (style == "comment" || style == "meta") return style;
      if (ctx.align == null) ctx.align = true;

      if ((curPunc == ";" || curPunc == ":") && ctx.type == "statement") popContext(state);
      else if (curPunc == "{") pushContext(state, stream.column(), "}");
      else if (curPunc == "[") pushContext(state, stream.column(), "]");
      else if (curPunc == "(") pushContext(state, stream.column(), ")");
      else if (curPunc == "}") {
        while (ctx.type == "statement") ctx = popContext(state);
        if (ctx.type == "}") ctx = popContext(state);
        while (ctx.type == "statement") ctx = popContext(state);
      }
      else if (curPunc == ctx.type) popContext(state);
      else if (ctx.type == "}" || ctx.type == "top" || (ctx.type == "statement" && curPunc == "newstatement"))
        pushContext(state, stream.column(), "statement");
      state.startOfLine = false;
      return style;
    },

    indent: function(state, textAfter) {
      if (state.tokenize != tokenBase && state.tokenize != null) return 0;
      var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);
      if (ctx.type == "statement" && firstChar == "}") ctx = ctx.prev;
      var closing = firstChar == ctx.type;
      if (ctx.type == "statement") return ctx.indented + (firstChar == "{" ? 0 : indentUnit);
      else if (ctx.align) return ctx.column + (closing ? 0 : 1);
      else return ctx.indented + (closing ? 0 : indentUnit);
    },

    electricChars: "{}"
  };
});

CodeMirror.defineMIME("text/x-ecl", "ecl");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/eiffel/eiffel.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("eiffel", function() {
  function wordObj(words) {
    var o = {};
    for (var i = 0, e = words.length; i < e; ++i) o[words[i]] = true;
    return o;
  }
  var keywords = wordObj([
    'note',
    'across',
    'when',
    'variant',
    'until',
    'unique',
    'undefine',
    'then',
    'strip',
    'select',
    'retry',
    'rescue',
    'require',
    'rename',
    'reference',
    'redefine',
    'prefix',
    'once',
    'old',
    'obsolete',
    'loop',
    'local',
    'like',
    'is',
    'inspect',
    'infix',
    'include',
    'if',
    'frozen',
    'from',
    'external',
    'export',
    'ensure',
    'end',
    'elseif',
    'else',
    'do',
    'creation',
    'create',
    'check',
    'alias',
    'agent',
    'separate',
    'invariant',
    'inherit',
    'indexing',
    'feature',
    'expanded',
    'deferred',
    'class',
    'Void',
    'True',
    'Result',
    'Precursor',
    'False',
    'Current',
    'create',
    'attached',
    'detachable',
    'as',
    'and',
    'implies',
    'not',
    'or'
  ]);
  var operators = wordObj([":=", "and then","and", "or","<<",">>"]);

  function chain(newtok, stream, state) {
    state.tokenize.push(newtok);
    return newtok(stream, state);
  }

  function tokenBase(stream, state) {
    if (stream.eatSpace()) return null;
    var ch = stream.next();
    if (ch == '"'||ch == "'") {
      return chain(readQuoted(ch, "string"), stream, state);
    } else if (ch == "-"&&stream.eat("-")) {
      stream.skipToEnd();
      return "comment";
    } else if (ch == ":"&&stream.eat("=")) {
      return "operator";
    } else if (/[0-9]/.test(ch)) {
      stream.eatWhile(/[xXbBCc0-9\.]/);
      stream.eat(/[\?\!]/);
      return "ident";
    } else if (/[a-zA-Z_0-9]/.test(ch)) {
      stream.eatWhile(/[a-zA-Z_0-9]/);
      stream.eat(/[\?\!]/);
      return "ident";
    } else if (/[=+\-\/*^%<>~]/.test(ch)) {
      stream.eatWhile(/[=+\-\/*^%<>~]/);
      return "operator";
    } else {
      return null;
    }
  }

  function readQuoted(quote, style,  unescaped) {
    return function(stream, state) {
      var escaped = false, ch;
      while ((ch = stream.next()) != null) {
        if (ch == quote && (unescaped || !escaped)) {
          state.tokenize.pop();
          break;
        }
        escaped = !escaped && ch == "%";
      }
      return style;
    };
  }

  return {
    startState: function() {
      return {tokenize: [tokenBase]};
    },

    token: function(stream, state) {
      var style = state.tokenize[state.tokenize.length-1](stream, state);
      if (style == "ident") {
        var word = stream.current();
        style = keywords.propertyIsEnumerable(stream.current()) ? "keyword"
          : operators.propertyIsEnumerable(stream.current()) ? "operator"
          : /^[A-Z][A-Z_0-9]*$/g.test(word) ? "tag"
          : /^0[bB][0-1]+$/g.test(word) ? "number"
          : /^0[cC][0-7]+$/g.test(word) ? "number"
          : /^0[xX][a-fA-F0-9]+$/g.test(word) ? "number"
          : /^([0-9]+\.[0-9]*)|([0-9]*\.[0-9]+)$/g.test(word) ? "number"
          : /^[0-9]+$/g.test(word) ? "number"
          : "variable";
      }
      return style;
    },
    lineComment: "--"
  };
});

CodeMirror.defineMIME("text/x-eiffel", "eiffel");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/elm/elm.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
  "use strict";

  CodeMirror.defineMode("elm", function() {

    function switchState(source, setState, f)
    {
      setState(f);
      return f(source, setState);
    }

    var lowerRE = /[a-z]/;
    var upperRE = /[A-Z]/;
    var innerRE = /[a-zA-Z0-9_]/;

    var digitRE = /[0-9]/;
    var hexRE = /[0-9A-Fa-f]/;
    var symbolRE = /[-&*+.\\/<>=?^|:]/;
    var specialRE = /[(),[\]{}]/;
    var spacesRE = /[ \v\f]/; // newlines are handled in tokenizer

    function normal()
    {
      return function(source, setState)
      {
        if (source.eatWhile(spacesRE))
        {
          return null;
        }

        var char = source.next();

        if (specialRE.test(char))
        {
          return (char === '{' && source.eat('-'))
            ? switchState(source, setState, chompMultiComment(1))
            : (char === '[' && source.match('glsl|'))
                ? switchState(source, setState, chompGlsl)
                : 'builtin';
        }

        if (char === '\'')
        {
          return switchState(source, setState, chompChar);
        }

        if (char === '"')
        {
          return source.eat('"')
            ? source.eat('"')
                ? switchState(source, setState, chompMultiString)
                : 'string'
            : switchState(source, setState, chompSingleString);
        }

        if (upperRE.test(char))
        {
          source.eatWhile(innerRE);
          return 'variable-2';
        }

        if (lowerRE.test(char))
        {
          var isDef = source.pos === 1;
          source.eatWhile(innerRE);
          return isDef ? "def" : "variable";
        }

        if (digitRE.test(char))
        {
          if (char === '0')
          {
            if (source.eat(/[xX]/))
            {
              source.eatWhile(hexRE); // should require at least 1
              return "number";
            }
          }
          else
          {
            source.eatWhile(digitRE);
          }
          if (source.eat('.'))
          {
            source.eatWhile(digitRE); // should require at least 1
          }
          if (source.eat(/[eE]/))
          {
            source.eat(/[-+]/);
            source.eatWhile(digitRE); // should require at least 1
          }
          return "number";
        }

        if (symbolRE.test(char))
        {
          if (char === '-' && source.eat('-'))
          {
            source.skipToEnd();
            return "comment";
          }
          source.eatWhile(symbolRE);
          return "keyword";
        }

        if (char === '_')
        {
          return "keyword";
        }

        return "error";
      }
    }

    function chompMultiComment(nest)
    {
      if (nest == 0)
      {
        return normal();
      }
      return function(source, setState)
      {
        while (!source.eol())
        {
          var char = source.next();
          if (char == '{' && source.eat('-'))
          {
            ++nest;
          }
          else if (char == '-' && source.eat('}'))
          {
            --nest;
            if (nest === 0)
            {
              setState(normal());
              return 'comment';
            }
          }
        }
        setState(chompMultiComment(nest));
        return 'comment';
      }
    }

    function chompMultiString(source, setState)
    {
      while (!source.eol())
      {
        var char = source.next();
        if (char === '"' && source.eat('"') && source.eat('"'))
        {
          setState(normal());
          return 'string';
        }
      }
      return 'string';
    }

    function chompSingleString(source, setState)
    {
      while (source.skipTo('\\"')) { source.next(); source.next(); }
      if (source.skipTo('"'))
      {
        source.next();
        setState(normal());
        return 'string';
      }
      source.skipToEnd();
      setState(normal());
      return 'error';
    }

    function chompChar(source, setState)
    {
      while (source.skipTo("\\'")) { source.next(); source.next(); }
      if (source.skipTo("'"))
      {
        source.next();
        setState(normal());
        return 'string';
      }
      source.skipToEnd();
      setState(normal());
      return 'error';
    }

    function chompGlsl(source, setState)
    {
      while (!source.eol())
      {
        var char = source.next();
        if (char === '|' && source.eat(']'))
        {
          setState(normal());
          return 'string';
        }
      }
      return 'string';
    }

    var wellKnownWords = {
      case: 1,
      of: 1,
      as: 1,
      if: 1,
      then: 1,
      else: 1,
      let: 1,
      in: 1,
      type: 1,
      alias: 1,
      module: 1,
      where: 1,
      import: 1,
      exposing: 1,
      port: 1
    };

    return {
      startState: function ()  { return { f: normal() }; },
      copyState:  function (s) { return { f: s.f }; },

      token: function(stream, state) {
        var type = state.f(stream, function(s) { state.f = s; });
        var word = stream.current();
        return (wellKnownWords.hasOwnProperty(word)) ? 'keyword' : type;
      }
    };

  });

  CodeMirror.defineMIME("text/x-elm", "elm");
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/erlang/erlang.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

/*jshint unused:true, eqnull:true, curly:true, bitwise:true */
/*jshint undef:true, latedef:true, trailing:true */
/*global CodeMirror:true */

// erlang mode.
// tokenizer -> token types -> CodeMirror styles
// tokenizer maintains a parse stack
// indenter uses the parse stack

// TODO indenter:
//   bit syntax
//   old guard/bif/conversion clashes (e.g. "float/1")
//   type/spec/opaque

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMIME("text/x-erlang", "erlang");

CodeMirror.defineMode("erlang", function(cmCfg) {
  "use strict";

/////////////////////////////////////////////////////////////////////////////
// constants

  var typeWords = [
    "-type", "-spec", "-export_type", "-opaque"];

  var keywordWords = [
    "after","begin","catch","case","cond","end","fun","if",
    "let","of","query","receive","try","when"];

  var separatorRE    = /[\->,;]/;
  var separatorWords = [
    "->",";",","];

  var operatorAtomWords = [
    "and","andalso","band","bnot","bor","bsl","bsr","bxor",
    "div","not","or","orelse","rem","xor"];

  var operatorSymbolRE    = /[\+\-\*\/<>=\|:!]/;
  var operatorSymbolWords = [
    "=","+","-","*","/",">",">=","<","=<","=:=","==","=/=","/=","||","<-","!"];

  var openParenRE    = /[<\(\[\{]/;
  var openParenWords = [
    "<<","(","[","{"];

  var closeParenRE    = /[>\)\]\}]/;
  var closeParenWords = [
    "}","]",")",">>"];

  var guardWords = [
    "is_atom","is_binary","is_bitstring","is_boolean","is_float",
    "is_function","is_integer","is_list","is_number","is_pid",
    "is_port","is_record","is_reference","is_tuple",
    "atom","binary","bitstring","boolean","function","integer","list",
    "number","pid","port","record","reference","tuple"];

  var bifWords = [
    "abs","adler32","adler32_combine","alive","apply","atom_to_binary",
    "atom_to_list","binary_to_atom","binary_to_existing_atom",
    "binary_to_list","binary_to_term","bit_size","bitstring_to_list",
    "byte_size","check_process_code","contact_binary","crc32",
    "crc32_combine","date","decode_packet","delete_module",
    "disconnect_node","element","erase","exit","float","float_to_list",
    "garbage_collect","get","get_keys","group_leader","halt","hd",
    "integer_to_list","internal_bif","iolist_size","iolist_to_binary",
    "is_alive","is_atom","is_binary","is_bitstring","is_boolean",
    "is_float","is_function","is_integer","is_list","is_number","is_pid",
    "is_port","is_process_alive","is_record","is_reference","is_tuple",
    "length","link","list_to_atom","list_to_binary","list_to_bitstring",
    "list_to_existing_atom","list_to_float","list_to_integer",
    "list_to_pid","list_to_tuple","load_module","make_ref","module_loaded",
    "monitor_node","node","node_link","node_unlink","nodes","notalive",
    "now","open_port","pid_to_list","port_close","port_command",
    "port_connect","port_control","pre_loaded","process_flag",
    "process_info","processes","purge_module","put","register",
    "registered","round","self","setelement","size","spawn","spawn_link",
    "spawn_monitor","spawn_opt","split_binary","statistics",
    "term_to_binary","time","throw","tl","trunc","tuple_size",
    "tuple_to_list","unlink","unregister","whereis"];

// upper case: [A-Z] [Ø-Þ] [À-Ö]
// lower case: [a-z] [ß-ö] [ø-ÿ]
  var anumRE       = /[\w@Ø-ÞÀ-Öß-öø-ÿ]/;
  var escapesRE    =
    /[0-7]{1,3}|[bdefnrstv\\"']|\^[a-zA-Z]|x[0-9a-zA-Z]{2}|x{[0-9a-zA-Z]+}/;

/////////////////////////////////////////////////////////////////////////////
// tokenizer

  function tokenizer(stream,state) {
    // in multi-line string
    if (state.in_string) {
      state.in_string = (!doubleQuote(stream));
      return rval(state,stream,"string");
    }

    // in multi-line atom
    if (state.in_atom) {
      state.in_atom = (!singleQuote(stream));
      return rval(state,stream,"atom");
    }

    // whitespace
    if (stream.eatSpace()) {
      return rval(state,stream,"whitespace");
    }

    // attributes and type specs
    if (!peekToken(state) &&
        stream.match(/-\s*[a-zß-öø-ÿ][\wØ-ÞÀ-Öß-öø-ÿ]*/)) {
      if (is_member(stream.current(),typeWords)) {
        return rval(state,stream,"type");
      }else{
        return rval(state,stream,"attribute");
      }
    }

    var ch = stream.next();

    // comment
    if (ch == '%') {
      stream.skipToEnd();
      return rval(state,stream,"comment");
    }

    // colon
    if (ch == ":") {
      return rval(state,stream,"colon");
    }

    // macro
    if (ch == '?') {
      stream.eatSpace();
      stream.eatWhile(anumRE);
      return rval(state,stream,"macro");
    }

    // record
    if (ch == "#") {
      stream.eatSpace();
      stream.eatWhile(anumRE);
      return rval(state,stream,"record");
    }

    // dollar escape
    if (ch == "$") {
      if (stream.next() == "\\" && !stream.match(escapesRE)) {
        return rval(state,stream,"error");
      }
      return rval(state,stream,"number");
    }

    // dot
    if (ch == ".") {
      return rval(state,stream,"dot");
    }

    // quoted atom
    if (ch == '\'') {
      if (!(state.in_atom = (!singleQuote(stream)))) {
        if (stream.match(/\s*\/\s*[0-9]/,false)) {
          stream.match(/\s*\/\s*[0-9]/,true);
          return rval(state,stream,"fun");      // 'f'/0 style fun
        }
        if (stream.match(/\s*\(/,false) || stream.match(/\s*:/,false)) {
          return rval(state,stream,"function");
        }
      }
      return rval(state,stream,"atom");
    }

    // string
    if (ch == '"') {
      state.in_string = (!doubleQuote(stream));
      return rval(state,stream,"string");
    }

    // variable
    if (/[A-Z_Ø-ÞÀ-Ö]/.test(ch)) {
      stream.eatWhile(anumRE);
      return rval(state,stream,"variable");
    }

    // atom/keyword/BIF/function
    if (/[a-z_ß-öø-ÿ]/.test(ch)) {
      stream.eatWhile(anumRE);

      if (stream.match(/\s*\/\s*[0-9]/,false)) {
        stream.match(/\s*\/\s*[0-9]/,true);
        return rval(state,stream,"fun");      // f/0 style fun
      }

      var w = stream.current();

      if (is_member(w,keywordWords)) {
        return rval(state,stream,"keyword");
      }else if (is_member(w,operatorAtomWords)) {
        return rval(state,stream,"operator");
      }else if (stream.match(/\s*\(/,false)) {
        // 'put' and 'erlang:put' are bifs, 'foo:put' is not
        if (is_member(w,bifWords) &&
            ((peekToken(state).token != ":") ||
             (peekToken(state,2).token == "erlang"))) {
          return rval(state,stream,"builtin");
        }else if (is_member(w,guardWords)) {
          return rval(state,stream,"guard");
        }else{
          return rval(state,stream,"function");
        }
      }else if (lookahead(stream) == ":") {
        if (w == "erlang") {
          return rval(state,stream,"builtin");
        } else {
          return rval(state,stream,"function");
        }
      }else if (is_member(w,["true","false"])) {
        return rval(state,stream,"boolean");
      }else{
        return rval(state,stream,"atom");
      }
    }

    // number
    var digitRE      = /[0-9]/;
    var radixRE      = /[0-9a-zA-Z]/;         // 36#zZ style int
    if (digitRE.test(ch)) {
      stream.eatWhile(digitRE);
      if (stream.eat('#')) {                // 36#aZ  style integer
        if (!stream.eatWhile(radixRE)) {
          stream.backUp(1);                 //"36#" - syntax error
        }
      } else if (stream.eat('.')) {       // float
        if (!stream.eatWhile(digitRE)) {
          stream.backUp(1);        // "3." - probably end of function
        } else {
          if (stream.eat(/[eE]/)) {        // float with exponent
            if (stream.eat(/[-+]/)) {
              if (!stream.eatWhile(digitRE)) {
                stream.backUp(2);            // "2e-" - syntax error
              }
            } else {
              if (!stream.eatWhile(digitRE)) {
                stream.backUp(1);            // "2e" - syntax error
              }
            }
          }
        }
      }
      return rval(state,stream,"number");   // normal integer
    }

    // open parens
    if (nongreedy(stream,openParenRE,openParenWords)) {
      return rval(state,stream,"open_paren");
    }

    // close parens
    if (nongreedy(stream,closeParenRE,closeParenWords)) {
      return rval(state,stream,"close_paren");
    }

    // separators
    if (greedy(stream,separatorRE,separatorWords)) {
      return rval(state,stream,"separator");
    }

    // operators
    if (greedy(stream,operatorSymbolRE,operatorSymbolWords)) {
      return rval(state,stream,"operator");
    }

    return rval(state,stream,null);
  }

/////////////////////////////////////////////////////////////////////////////
// utilities
  function nongreedy(stream,re,words) {
    if (stream.current().length == 1 && re.test(stream.current())) {
      stream.backUp(1);
      while (re.test(stream.peek())) {
        stream.next();
        if (is_member(stream.current(),words)) {
          return true;
        }
      }
      stream.backUp(stream.current().length-1);
    }
    return false;
  }

  function greedy(stream,re,words) {
    if (stream.current().length == 1 && re.test(stream.current())) {
      while (re.test(stream.peek())) {
        stream.next();
      }
      while (0 < stream.current().length) {
        if (is_member(stream.current(),words)) {
          return true;
        }else{
          stream.backUp(1);
        }
      }
      stream.next();
    }
    return false;
  }

  function doubleQuote(stream) {
    return quote(stream, '"', '\\');
  }

  function singleQuote(stream) {
    return quote(stream,'\'','\\');
  }

  function quote(stream,quoteChar,escapeChar) {
    while (!stream.eol()) {
      var ch = stream.next();
      if (ch == quoteChar) {
        return true;
      }else if (ch == escapeChar) {
        stream.next();
      }
    }
    return false;
  }

  function lookahead(stream) {
    var m = stream.match(/^\s*([^\s%])/, false)
    return m ? m[1] : "";
  }

  function is_member(element,list) {
    return (-1 < list.indexOf(element));
  }

  function rval(state,stream,type) {

    // parse stack
    pushToken(state,realToken(type,stream));

    // map erlang token type to CodeMirror style class
    //     erlang             -> CodeMirror tag
    switch (type) {
      case "atom":        return "atom";
      case "attribute":   return "attribute";
      case "boolean":     return "atom";
      case "builtin":     return "builtin";
      case "close_paren": return null;
      case "colon":       return null;
      case "comment":     return "comment";
      case "dot":         return null;
      case "error":       return "error";
      case "fun":         return "meta";
      case "function":    return "tag";
      case "guard":       return "property";
      case "keyword":     return "keyword";
      case "macro":       return "variable-2";
      case "number":      return "number";
      case "open_paren":  return null;
      case "operator":    return "operator";
      case "record":      return "bracket";
      case "separator":   return null;
      case "string":      return "string";
      case "type":        return "def";
      case "variable":    return "variable";
      default:            return null;
    }
  }

  function aToken(tok,col,ind,typ) {
    return {token:  tok,
            column: col,
            indent: ind,
            type:   typ};
  }

  function realToken(type,stream) {
    return aToken(stream.current(),
                 stream.column(),
                 stream.indentation(),
                 type);
  }

  function fakeToken(type) {
    return aToken(type,0,0,type);
  }

  function peekToken(state,depth) {
    var len = state.tokenStack.length;
    var dep = (depth ? depth : 1);

    if (len < dep) {
      return false;
    }else{
      return state.tokenStack[len-dep];
    }
  }

  function pushToken(state,token) {

    if (!(token.type == "comment" || token.type == "whitespace")) {
      state.tokenStack = maybe_drop_pre(state.tokenStack,token);
      state.tokenStack = maybe_drop_post(state.tokenStack);
    }
  }

  function maybe_drop_pre(s,token) {
    var last = s.length-1;

    if (0 < last && s[last].type === "record" && token.type === "dot") {
      s.pop();
    }else if (0 < last && s[last].type === "group") {
      s.pop();
      s.push(token);
    }else{
      s.push(token);
    }
    return s;
  }

  function maybe_drop_post(s) {
    if (!s.length) return s
    var last = s.length-1;

    if (s[last].type === "dot") {
      return [];
    }
    if (last > 1 && s[last].type === "fun" && s[last-1].token === "fun") {
      return s.slice(0,last-1);
    }
    switch (s[last].token) {
      case "}":    return d(s,{g:["{"]});
      case "]":    return d(s,{i:["["]});
      case ")":    return d(s,{i:["("]});
      case ">>":   return d(s,{i:["<<"]});
      case "end":  return d(s,{i:["begin","case","fun","if","receive","try"]});
      case ",":    return d(s,{e:["begin","try","when","->",
                                  ",","(","[","{","<<"]});
      case "->":   return d(s,{r:["when"],
                               m:["try","if","case","receive"]});
      case ";":    return d(s,{E:["case","fun","if","receive","try","when"]});
      case "catch":return d(s,{e:["try"]});
      case "of":   return d(s,{e:["case"]});
      case "after":return d(s,{e:["receive","try"]});
      default:     return s;
    }
  }

  function d(stack,tt) {
    // stack is a stack of Token objects.
    // tt is an object; {type:tokens}
    // type is a char, tokens is a list of token strings.
    // The function returns (possibly truncated) stack.
    // It will descend the stack, looking for a Token such that Token.token
    //  is a member of tokens. If it does not find that, it will normally (but
    //  see "E" below) return stack. If it does find a match, it will remove
    //  all the Tokens between the top and the matched Token.
    // If type is "m", that is all it does.
    // If type is "i", it will also remove the matched Token and the top Token.
    // If type is "g", like "i", but add a fake "group" token at the top.
    // If type is "r", it will remove the matched Token, but not the top Token.
    // If type is "e", it will keep the matched Token but not the top Token.
    // If type is "E", it behaves as for type "e", except if there is no match,
    //  in which case it will return an empty stack.

    for (var type in tt) {
      var len = stack.length-1;
      var tokens = tt[type];
      for (var i = len-1; -1 < i ; i--) {
        if (is_member(stack[i].token,tokens)) {
          var ss = stack.slice(0,i);
          switch (type) {
              case "m": return ss.concat(stack[i]).concat(stack[len]);
              case "r": return ss.concat(stack[len]);
              case "i": return ss;
              case "g": return ss.concat(fakeToken("group"));
              case "E": return ss.concat(stack[i]);
              case "e": return ss.concat(stack[i]);
          }
        }
      }
    }
    return (type == "E" ? [] : stack);
  }

/////////////////////////////////////////////////////////////////////////////
// indenter

  function indenter(state,textAfter) {
    var t;
    var unit = cmCfg.indentUnit;
    var wordAfter = wordafter(textAfter);
    var currT = peekToken(state,1);
    var prevT = peekToken(state,2);

    if (state.in_string || state.in_atom) {
      return CodeMirror.Pass;
    }else if (!prevT) {
      return 0;
    }else if (currT.token == "when") {
      return currT.column+unit;
    }else if (wordAfter === "when" && prevT.type === "function") {
      return prevT.indent+unit;
    }else if (wordAfter === "(" && currT.token === "fun") {
      return  currT.column+3;
    }else if (wordAfter === "catch" && (t = getToken(state,["try"]))) {
      return t.column;
    }else if (is_member(wordAfter,["end","after","of"])) {
      t = getToken(state,["begin","case","fun","if","receive","try"]);
      return t ? t.column : CodeMirror.Pass;
    }else if (is_member(wordAfter,closeParenWords)) {
      t = getToken(state,openParenWords);
      return t ? t.column : CodeMirror.Pass;
    }else if (is_member(currT.token,[",","|","||"]) ||
              is_member(wordAfter,[",","|","||"])) {
      t = postcommaToken(state);
      return t ? t.column+t.token.length : unit;
    }else if (currT.token == "->") {
      if (is_member(prevT.token, ["receive","case","if","try"])) {
        return prevT.column+unit+unit;
      }else{
        return prevT.column+unit;
      }
    }else if (is_member(currT.token,openParenWords)) {
      return currT.column+currT.token.length;
    }else{
      t = defaultToken(state);
      return truthy(t) ? t.column+unit : 0;
    }
  }

  function wordafter(str) {
    var m = str.match(/,|[a-z]+|\}|\]|\)|>>|\|+|\(/);

    return truthy(m) && (m.index === 0) ? m[0] : "";
  }

  function postcommaToken(state) {
    var objs = state.tokenStack.slice(0,-1);
    var i = getTokenIndex(objs,"type",["open_paren"]);

    return truthy(objs[i]) ? objs[i] : false;
  }

  function defaultToken(state) {
    var objs = state.tokenStack;
    var stop = getTokenIndex(objs,"type",["open_paren","separator","keyword"]);
    var oper = getTokenIndex(objs,"type",["operator"]);

    if (truthy(stop) && truthy(oper) && stop < oper) {
      return objs[stop+1];
    } else if (truthy(stop)) {
      return objs[stop];
    } else {
      return false;
    }
  }

  function getToken(state,tokens) {
    var objs = state.tokenStack;
    var i = getTokenIndex(objs,"token",tokens);

    return truthy(objs[i]) ? objs[i] : false;
  }

  function getTokenIndex(objs,propname,propvals) {

    for (var i = objs.length-1; -1 < i ; i--) {
      if (is_member(objs[i][propname],propvals)) {
        return i;
      }
    }
    return false;
  }

  function truthy(x) {
    return (x !== false) && (x != null);
  }

/////////////////////////////////////////////////////////////////////////////
// this object defines the mode

  return {
    startState:
      function() {
        return {tokenStack: [],
                in_string:  false,
                in_atom:    false};
      },

    token:
      function(stream, state) {
        return tokenizer(stream, state);
      },

    indent:
      function(state, textAfter) {
        return indenter(state,textAfter);
      },

    lineComment: "%"
  };
});

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/factor/factor.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// Factor syntax highlight - simple mode
//
// by Dimage Sapelkin (https://github.com/kerabromsmu)

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"), __webpack_require__("./src/ipywidgets/node_modules/codemirror/addon/mode/simple.js"));
  else {}
})(function(CodeMirror) {
  "use strict";

  CodeMirror.defineSimpleMode("factor", {
    // The start state contains the rules that are initially used
    start: [
      // comments
      {regex: /#?!.*/, token: "comment"},
      // strings """, multiline --> state
      {regex: /"""/, token: "string", next: "string3"},
      {regex: /(STRING:)(\s)/, token: ["keyword", null], next: "string2"},
      {regex: /\S*?"/, token: "string", next: "string"},
      // numbers: dec, hex, unicode, bin, fractional, complex
      {regex: /(?:0x[\d,a-f]+)|(?:0o[0-7]+)|(?:0b[0,1]+)|(?:\-?\d+.?\d*)(?=\s)/, token: "number"},
      //{regex: /[+-]?/} //fractional
      // definition: defining word, defined word, etc
      {regex: /((?:GENERIC)|\:?\:)(\s+)(\S+)(\s+)(\()/, token: ["keyword", null, "def", null, "bracket"], next: "stack"},
      // method definition: defining word, type, defined word, etc
      {regex: /(M\:)(\s+)(\S+)(\s+)(\S+)/, token: ["keyword", null, "def", null, "tag"]},
      // vocabulary using --> state
      {regex: /USING\:/, token: "keyword", next: "vocabulary"},
      // vocabulary definition/use
      {regex: /(USE\:|IN\:)(\s+)(\S+)(?=\s|$)/, token: ["keyword", null, "tag"]},
      // definition: a defining word, defined word
      {regex: /(\S+\:)(\s+)(\S+)(?=\s|$)/, token: ["keyword", null, "def"]},
      // "keywords", incl. ; t f . [ ] { } defining words
      {regex: /(?:;|\\|t|f|if|loop|while|until|do|PRIVATE>|<PRIVATE|\.|\S*\[|\]|\S*\{|\})(?=\s|$)/, token: "keyword"},
      // <constructors> and the like
      {regex: /\S+[\)>\.\*\?]+(?=\s|$)/, token: "builtin"},
      {regex: /[\)><]+\S+(?=\s|$)/, token: "builtin"},
      // operators
      {regex: /(?:[\+\-\=\/\*<>])(?=\s|$)/, token: "keyword"},
      // any id (?)
      {regex: /\S+/, token: "variable"},
      {regex: /\s+|./, token: null}
    ],
    vocabulary: [
      {regex: /;/, token: "keyword", next: "start"},
      {regex: /\S+/, token: "tag"},
      {regex: /\s+|./, token: null}
    ],
    string: [
      {regex: /(?:[^\\]|\\.)*?"/, token: "string", next: "start"},
      {regex: /.*/, token: "string"}
    ],
    string2: [
      {regex: /^;/, token: "keyword", next: "start"},
      {regex: /.*/, token: "string"}
    ],
    string3: [
      {regex: /(?:[^\\]|\\.)*?"""/, token: "string", next: "start"},
      {regex: /.*/, token: "string"}
    ],
    stack: [
      {regex: /\)/, token: "bracket", next: "start"},
      {regex: /--/, token: "bracket"},
      {regex: /\S+/, token: "meta"},
      {regex: /\s+|./, token: null}
    ],
    // The meta property contains global information about the mode. It
    // can contain properties like lineComment, which are supported by
    // all modes, and also directives like dontIndentStates, which are
    // specific to simple modes.
    meta: {
      dontIndentStates: ["start", "vocabulary", "string", "string3", "stack"],
      lineComment: [ "!", "#!" ]
    }
  });

  CodeMirror.defineMIME("text/x-factor", "factor");
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/fcl/fcl.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("fcl", function(config) {
  var indentUnit = config.indentUnit;

  var keywords = {
      "term": true,
      "method": true, "accu": true,
      "rule": true, "then": true, "is": true, "and": true, "or": true,
      "if": true, "default": true
  };

  var start_blocks = {
      "var_input": true,
      "var_output": true,
      "fuzzify": true,
      "defuzzify": true,
      "function_block": true,
      "ruleblock": true
  };

  var end_blocks = {
      "end_ruleblock": true,
      "end_defuzzify": true,
      "end_function_block": true,
      "end_fuzzify": true,
      "end_var": true
  };

  var atoms = {
      "true": true, "false": true, "nan": true,
      "real": true, "min": true, "max": true, "cog": true, "cogs": true
  };

  var isOperatorChar = /[+\-*&^%:=<>!|\/]/;

  function tokenBase(stream, state) {
    var ch = stream.next();

    if (/[\d\.]/.test(ch)) {
      if (ch == ".") {
        stream.match(/^[0-9]+([eE][\-+]?[0-9]+)?/);
      } else if (ch == "0") {
        stream.match(/^[xX][0-9a-fA-F]+/) || stream.match(/^0[0-7]+/);
      } else {
        stream.match(/^[0-9]*\.?[0-9]*([eE][\-+]?[0-9]+)?/);
      }
      return "number";
    }

    if (ch == "/" || ch == "(") {
      if (stream.eat("*")) {
        state.tokenize = tokenComment;
        return tokenComment(stream, state);
      }
      if (stream.eat("/")) {
        stream.skipToEnd();
        return "comment";
      }
    }
    if (isOperatorChar.test(ch)) {
      stream.eatWhile(isOperatorChar);
      return "operator";
    }
    stream.eatWhile(/[\w\$_\xa1-\uffff]/);

    var cur = stream.current().toLowerCase();
    if (keywords.propertyIsEnumerable(cur) ||
        start_blocks.propertyIsEnumerable(cur) ||
        end_blocks.propertyIsEnumerable(cur)) {
      return "keyword";
    }
    if (atoms.propertyIsEnumerable(cur)) return "atom";
    return "variable";
  }


  function tokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if ((ch == "/" || ch == ")") && maybeEnd) {
        state.tokenize = tokenBase;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return "comment";
  }

  function Context(indented, column, type, align, prev) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.align = align;
    this.prev = prev;
  }

  function pushContext(state, col, type) {
    return state.context = new Context(state.indented, col, type, null, state.context);
  }

  function popContext(state) {
    if (!state.context.prev) return;
    var t = state.context.type;
    if (t == "end_block")
      state.indented = state.context.indented;
    return state.context = state.context.prev;
  }

  // Interface

  return {
    startState: function(basecolumn) {
      return {
        tokenize: null,
        context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),
        indented: 0,
        startOfLine: true
      };
    },

    token: function(stream, state) {
        var ctx = state.context;
        if (stream.sol()) {
            if (ctx.align == null) ctx.align = false;
            state.indented = stream.indentation();
            state.startOfLine = true;
        }
        if (stream.eatSpace()) return null;

        var style = (state.tokenize || tokenBase)(stream, state);
        if (style == "comment") return style;
        if (ctx.align == null) ctx.align = true;

        var cur = stream.current().toLowerCase();

        if (start_blocks.propertyIsEnumerable(cur)) pushContext(state, stream.column(), "end_block");
        else if (end_blocks.propertyIsEnumerable(cur))  popContext(state);

        state.startOfLine = false;
        return style;
    },

    indent: function(state, textAfter) {
      if (state.tokenize != tokenBase && state.tokenize != null) return 0;
      var ctx = state.context;

      var closing = end_blocks.propertyIsEnumerable(textAfter);
      if (ctx.align) return ctx.column + (closing ? 0 : 1);
      else return ctx.indented + (closing ? 0 : indentUnit);
    },

    electricChars: "ryk",
    fold: "brace",
    blockCommentStart: "(*",
    blockCommentEnd: "*)",
    lineComment: "//"
  };
});

CodeMirror.defineMIME("text/x-fcl", "fcl");
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/forth/forth.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// Author: Aliaksei Chapyzhenka

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
  "use strict";

  function toWordList(words) {
    var ret = [];
    words.split(' ').forEach(function(e){
      ret.push({name: e});
    });
    return ret;
  }

  var coreWordList = toWordList(
'INVERT AND OR XOR\
 2* 2/ LSHIFT RSHIFT\
 0= = 0< < > U< MIN MAX\
 2DROP 2DUP 2OVER 2SWAP ?DUP DEPTH DROP DUP OVER ROT SWAP\
 >R R> R@\
 + - 1+ 1- ABS NEGATE\
 S>D * M* UM*\
 FM/MOD SM/REM UM/MOD */ */MOD / /MOD MOD\
 HERE , @ ! CELL+ CELLS C, C@ C! CHARS 2@ 2!\
 ALIGN ALIGNED +! ALLOT\
 CHAR [CHAR] [ ] BL\
 FIND EXECUTE IMMEDIATE COUNT LITERAL STATE\
 ; DOES> >BODY\
 EVALUATE\
 SOURCE >IN\
 <# # #S #> HOLD SIGN BASE >NUMBER HEX DECIMAL\
 FILL MOVE\
 . CR EMIT SPACE SPACES TYPE U. .R U.R\
 ACCEPT\
 TRUE FALSE\
 <> U> 0<> 0>\
 NIP TUCK ROLL PICK\
 2>R 2R@ 2R>\
 WITHIN UNUSED MARKER\
 I J\
 TO\
 COMPILE, [COMPILE]\
 SAVE-INPUT RESTORE-INPUT\
 PAD ERASE\
 2LITERAL DNEGATE\
 D- D+ D0< D0= D2* D2/ D< D= DMAX DMIN D>S DABS\
 M+ M*/ D. D.R 2ROT DU<\
 CATCH THROW\
 FREE RESIZE ALLOCATE\
 CS-PICK CS-ROLL\
 GET-CURRENT SET-CURRENT FORTH-WORDLIST GET-ORDER SET-ORDER\
 PREVIOUS SEARCH-WORDLIST WORDLIST FIND ALSO ONLY FORTH DEFINITIONS ORDER\
 -TRAILING /STRING SEARCH COMPARE CMOVE CMOVE> BLANK SLITERAL');

  var immediateWordList = toWordList('IF ELSE THEN BEGIN WHILE REPEAT UNTIL RECURSE [IF] [ELSE] [THEN] ?DO DO LOOP +LOOP UNLOOP LEAVE EXIT AGAIN CASE OF ENDOF ENDCASE');

  CodeMirror.defineMode('forth', function() {
    function searchWordList (wordList, word) {
      var i;
      for (i = wordList.length - 1; i >= 0; i--) {
        if (wordList[i].name === word.toUpperCase()) {
          return wordList[i];
        }
      }
      return undefined;
    }
  return {
    startState: function() {
      return {
        state: '',
        base: 10,
        coreWordList: coreWordList,
        immediateWordList: immediateWordList,
        wordList: []
      };
    },
    token: function (stream, stt) {
      var mat;
      if (stream.eatSpace()) {
        return null;
      }
      if (stt.state === '') { // interpretation
        if (stream.match(/^(\]|:NONAME)(\s|$)/i)) {
          stt.state = ' compilation';
          return 'builtin compilation';
        }
        mat = stream.match(/^(\:)\s+(\S+)(\s|$)+/);
        if (mat) {
          stt.wordList.push({name: mat[2].toUpperCase()});
          stt.state = ' compilation';
          return 'def' + stt.state;
        }
        mat = stream.match(/^(VARIABLE|2VARIABLE|CONSTANT|2CONSTANT|CREATE|POSTPONE|VALUE|WORD)\s+(\S+)(\s|$)+/i);
        if (mat) {
          stt.wordList.push({name: mat[2].toUpperCase()});
          return 'def' + stt.state;
        }
        mat = stream.match(/^(\'|\[\'\])\s+(\S+)(\s|$)+/);
        if (mat) {
          return 'builtin' + stt.state;
        }
        } else { // compilation
        // ; [
        if (stream.match(/^(\;|\[)(\s)/)) {
          stt.state = '';
          stream.backUp(1);
          return 'builtin compilation';
        }
        if (stream.match(/^(\;|\[)($)/)) {
          stt.state = '';
          return 'builtin compilation';
        }
        if (stream.match(/^(POSTPONE)\s+\S+(\s|$)+/)) {
          return 'builtin';
        }
      }

      // dynamic wordlist
      mat = stream.match(/^(\S+)(\s+|$)/);
      if (mat) {
        if (searchWordList(stt.wordList, mat[1]) !== undefined) {
          return 'variable' + stt.state;
        }

        // comments
        if (mat[1] === '\\') {
          stream.skipToEnd();
            return 'comment' + stt.state;
          }

          // core words
          if (searchWordList(stt.coreWordList, mat[1]) !== undefined) {
            return 'builtin' + stt.state;
          }
          if (searchWordList(stt.immediateWordList, mat[1]) !== undefined) {
            return 'keyword' + stt.state;
          }

          if (mat[1] === '(') {
            stream.eatWhile(function (s) { return s !== ')'; });
            stream.eat(')');
            return 'comment' + stt.state;
          }

          // // strings
          if (mat[1] === '.(') {
            stream.eatWhile(function (s) { return s !== ')'; });
            stream.eat(')');
            return 'string' + stt.state;
          }
          if (mat[1] === 'S"' || mat[1] === '."' || mat[1] === 'C"') {
            stream.eatWhile(function (s) { return s !== '"'; });
            stream.eat('"');
            return 'string' + stt.state;
          }

          // numbers
          if (mat[1] - 0xfffffffff) {
            return 'number' + stt.state;
          }
          // if (mat[1].match(/^[-+]?[0-9]+\.[0-9]*/)) {
          //     return 'number' + stt.state;
          // }

          return 'atom' + stt.state;
        }
      }
    };
  });
  CodeMirror.defineMIME("text/x-forth", "forth");
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/fortran/fortran.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("fortran", function() {
  function words(array) {
    var keys = {};
    for (var i = 0; i < array.length; ++i) {
      keys[array[i]] = true;
    }
    return keys;
  }

  var keywords = words([
                  "abstract", "accept", "allocatable", "allocate",
                  "array", "assign", "asynchronous", "backspace",
                  "bind", "block", "byte", "call", "case",
                  "class", "close", "common", "contains",
                  "continue", "cycle", "data", "deallocate",
                  "decode", "deferred", "dimension", "do",
                  "elemental", "else", "encode", "end",
                  "endif", "entry", "enumerator", "equivalence",
                  "exit", "external", "extrinsic", "final",
                  "forall", "format", "function", "generic",
                  "go", "goto", "if", "implicit", "import", "include",
                  "inquire", "intent", "interface", "intrinsic",
                  "module", "namelist", "non_intrinsic",
                  "non_overridable", "none", "nopass",
                  "nullify", "open", "optional", "options",
                  "parameter", "pass", "pause", "pointer",
                  "print", "private", "program", "protected",
                  "public", "pure", "read", "recursive", "result",
                  "return", "rewind", "save", "select", "sequence",
                  "stop", "subroutine", "target", "then", "to", "type",
                  "use", "value", "volatile", "where", "while",
                  "write"]);
  var builtins = words(["abort", "abs", "access", "achar", "acos",
                          "adjustl", "adjustr", "aimag", "aint", "alarm",
                          "all", "allocated", "alog", "amax", "amin",
                          "amod", "and", "anint", "any", "asin",
                          "associated", "atan", "besj", "besjn", "besy",
                          "besyn", "bit_size", "btest", "cabs", "ccos",
                          "ceiling", "cexp", "char", "chdir", "chmod",
                          "clog", "cmplx", "command_argument_count",
                          "complex", "conjg", "cos", "cosh", "count",
                          "cpu_time", "cshift", "csin", "csqrt", "ctime",
                          "c_funloc", "c_loc", "c_associated", "c_null_ptr",
                          "c_null_funptr", "c_f_pointer", "c_null_char",
                          "c_alert", "c_backspace", "c_form_feed",
                          "c_new_line", "c_carriage_return",
                          "c_horizontal_tab", "c_vertical_tab", "dabs",
                          "dacos", "dasin", "datan", "date_and_time",
                          "dbesj", "dbesj", "dbesjn", "dbesy", "dbesy",
                          "dbesyn", "dble", "dcos", "dcosh", "ddim", "derf",
                          "derfc", "dexp", "digits", "dim", "dint", "dlog",
                          "dlog", "dmax", "dmin", "dmod", "dnint",
                          "dot_product", "dprod", "dsign", "dsinh",
                          "dsin", "dsqrt", "dtanh", "dtan", "dtime",
                          "eoshift", "epsilon", "erf", "erfc", "etime",
                          "exit", "exp", "exponent", "extends_type_of",
                          "fdate", "fget", "fgetc", "float", "floor",
                          "flush", "fnum", "fputc", "fput", "fraction",
                          "fseek", "fstat", "ftell", "gerror", "getarg",
                          "get_command", "get_command_argument",
                          "get_environment_variable", "getcwd",
                          "getenv", "getgid", "getlog", "getpid",
                          "getuid", "gmtime", "hostnm", "huge", "iabs",
                          "iachar", "iand", "iargc", "ibclr", "ibits",
                          "ibset", "ichar", "idate", "idim", "idint",
                          "idnint", "ieor", "ierrno", "ifix", "imag",
                          "imagpart", "index", "int", "ior", "irand",
                          "isatty", "ishft", "ishftc", "isign",
                          "iso_c_binding", "is_iostat_end", "is_iostat_eor",
                          "itime", "kill", "kind", "lbound", "len", "len_trim",
                          "lge", "lgt", "link", "lle", "llt", "lnblnk", "loc",
                          "log", "logical", "long", "lshift", "lstat", "ltime",
                          "matmul", "max", "maxexponent", "maxloc", "maxval",
                          "mclock", "merge", "move_alloc", "min", "minexponent",
                          "minloc", "minval", "mod", "modulo", "mvbits",
                          "nearest", "new_line", "nint", "not", "or", "pack",
                          "perror", "precision", "present", "product", "radix",
                          "rand", "random_number", "random_seed", "range",
                          "real", "realpart", "rename", "repeat", "reshape",
                          "rrspacing", "rshift", "same_type_as", "scale",
                          "scan", "second", "selected_int_kind",
                          "selected_real_kind", "set_exponent", "shape",
                          "short", "sign", "signal", "sinh", "sin", "sleep",
                          "sngl", "spacing", "spread", "sqrt", "srand", "stat",
                          "sum", "symlnk", "system", "system_clock", "tan",
                          "tanh", "time", "tiny", "transfer", "transpose",
                          "trim", "ttynam", "ubound", "umask", "unlink",
                          "unpack", "verify", "xor", "zabs", "zcos", "zexp",
                          "zlog", "zsin", "zsqrt"]);

    var dataTypes =  words(["c_bool", "c_char", "c_double", "c_double_complex",
                     "c_float", "c_float_complex", "c_funptr", "c_int",
                     "c_int16_t", "c_int32_t", "c_int64_t", "c_int8_t",
                     "c_int_fast16_t", "c_int_fast32_t", "c_int_fast64_t",
                     "c_int_fast8_t", "c_int_least16_t", "c_int_least32_t",
                     "c_int_least64_t", "c_int_least8_t", "c_intmax_t",
                     "c_intptr_t", "c_long", "c_long_double",
                     "c_long_double_complex", "c_long_long", "c_ptr",
                     "c_short", "c_signed_char", "c_size_t", "character",
                     "complex", "double", "integer", "logical", "real"]);
  var isOperatorChar = /[+\-*&=<>\/\:]/;
  var litOperator = new RegExp("(\.and\.|\.or\.|\.eq\.|\.lt\.|\.le\.|\.gt\.|\.ge\.|\.ne\.|\.not\.|\.eqv\.|\.neqv\.)", "i");

  function tokenBase(stream, state) {

    if (stream.match(litOperator)){
        return 'operator';
    }

    var ch = stream.next();
    if (ch == "!") {
      stream.skipToEnd();
      return "comment";
    }
    if (ch == '"' || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    }
    if (/[\[\]\(\),]/.test(ch)) {
      return null;
    }
    if (/\d/.test(ch)) {
      stream.eatWhile(/[\w\.]/);
      return "number";
    }
    if (isOperatorChar.test(ch)) {
      stream.eatWhile(isOperatorChar);
      return "operator";
    }
    stream.eatWhile(/[\w\$_]/);
    var word = stream.current().toLowerCase();

    if (keywords.hasOwnProperty(word)){
            return 'keyword';
    }
    if (builtins.hasOwnProperty(word) || dataTypes.hasOwnProperty(word)) {
            return 'builtin';
    }
    return "variable";
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, next, end = false;
      while ((next = stream.next()) != null) {
        if (next == quote && !escaped) {
            end = true;
            break;
        }
        escaped = !escaped && next == "\\";
      }
      if (end || !escaped) state.tokenize = null;
      return "string";
    };
  }

  // Interface

  return {
    startState: function() {
      return {tokenize: null};
    },

    token: function(stream, state) {
      if (stream.eatSpace()) return null;
      var style = (state.tokenize || tokenBase)(stream, state);
      if (style == "comment" || style == "meta") return style;
      return style;
    }
  };
});

CodeMirror.defineMIME("text/x-fortran", "fortran");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/gas/gas.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("gas", function(_config, parserConfig) {
  'use strict';

  // If an architecture is specified, its initialization function may
  // populate this array with custom parsing functions which will be
  // tried in the event that the standard functions do not find a match.
  var custom = [];

  // The symbol used to start a line comment changes based on the target
  // architecture.
  // If no architecture is pased in "parserConfig" then only multiline
  // comments will have syntax support.
  var lineCommentStartSymbol = "";

  // These directives are architecture independent.
  // Machine specific directives should go in their respective
  // architecture initialization function.
  // Reference:
  // http://sourceware.org/binutils/docs/as/Pseudo-Ops.html#Pseudo-Ops
  var directives = {
    ".abort" : "builtin",
    ".align" : "builtin",
    ".altmacro" : "builtin",
    ".ascii" : "builtin",
    ".asciz" : "builtin",
    ".balign" : "builtin",
    ".balignw" : "builtin",
    ".balignl" : "builtin",
    ".bundle_align_mode" : "builtin",
    ".bundle_lock" : "builtin",
    ".bundle_unlock" : "builtin",
    ".byte" : "builtin",
    ".cfi_startproc" : "builtin",
    ".comm" : "builtin",
    ".data" : "builtin",
    ".def" : "builtin",
    ".desc" : "builtin",
    ".dim" : "builtin",
    ".double" : "builtin",
    ".eject" : "builtin",
    ".else" : "builtin",
    ".elseif" : "builtin",
    ".end" : "builtin",
    ".endef" : "builtin",
    ".endfunc" : "builtin",
    ".endif" : "builtin",
    ".equ" : "builtin",
    ".equiv" : "builtin",
    ".eqv" : "builtin",
    ".err" : "builtin",
    ".error" : "builtin",
    ".exitm" : "builtin",
    ".extern" : "builtin",
    ".fail" : "builtin",
    ".file" : "builtin",
    ".fill" : "builtin",
    ".float" : "builtin",
    ".func" : "builtin",
    ".global" : "builtin",
    ".gnu_attribute" : "builtin",
    ".hidden" : "builtin",
    ".hword" : "builtin",
    ".ident" : "builtin",
    ".if" : "builtin",
    ".incbin" : "builtin",
    ".include" : "builtin",
    ".int" : "builtin",
    ".internal" : "builtin",
    ".irp" : "builtin",
    ".irpc" : "builtin",
    ".lcomm" : "builtin",
    ".lflags" : "builtin",
    ".line" : "builtin",
    ".linkonce" : "builtin",
    ".list" : "builtin",
    ".ln" : "builtin",
    ".loc" : "builtin",
    ".loc_mark_labels" : "builtin",
    ".local" : "builtin",
    ".long" : "builtin",
    ".macro" : "builtin",
    ".mri" : "builtin",
    ".noaltmacro" : "builtin",
    ".nolist" : "builtin",
    ".octa" : "builtin",
    ".offset" : "builtin",
    ".org" : "builtin",
    ".p2align" : "builtin",
    ".popsection" : "builtin",
    ".previous" : "builtin",
    ".print" : "builtin",
    ".protected" : "builtin",
    ".psize" : "builtin",
    ".purgem" : "builtin",
    ".pushsection" : "builtin",
    ".quad" : "builtin",
    ".reloc" : "builtin",
    ".rept" : "builtin",
    ".sbttl" : "builtin",
    ".scl" : "builtin",
    ".section" : "builtin",
    ".set" : "builtin",
    ".short" : "builtin",
    ".single" : "builtin",
    ".size" : "builtin",
    ".skip" : "builtin",
    ".sleb128" : "builtin",
    ".space" : "builtin",
    ".stab" : "builtin",
    ".string" : "builtin",
    ".struct" : "builtin",
    ".subsection" : "builtin",
    ".symver" : "builtin",
    ".tag" : "builtin",
    ".text" : "builtin",
    ".title" : "builtin",
    ".type" : "builtin",
    ".uleb128" : "builtin",
    ".val" : "builtin",
    ".version" : "builtin",
    ".vtable_entry" : "builtin",
    ".vtable_inherit" : "builtin",
    ".warning" : "builtin",
    ".weak" : "builtin",
    ".weakref" : "builtin",
    ".word" : "builtin"
  };

  var registers = {};

  function x86(_parserConfig) {
    lineCommentStartSymbol = "#";

    registers.ax  = "variable";
    registers.eax = "variable-2";
    registers.rax = "variable-3";

    registers.bx  = "variable";
    registers.ebx = "variable-2";
    registers.rbx = "variable-3";

    registers.cx  = "variable";
    registers.ecx = "variable-2";
    registers.rcx = "variable-3";

    registers.dx  = "variable";
    registers.edx = "variable-2";
    registers.rdx = "variable-3";

    registers.si  = "variable";
    registers.esi = "variable-2";
    registers.rsi = "variable-3";

    registers.di  = "variable";
    registers.edi = "variable-2";
    registers.rdi = "variable-3";

    registers.sp  = "variable";
    registers.esp = "variable-2";
    registers.rsp = "variable-3";

    registers.bp  = "variable";
    registers.ebp = "variable-2";
    registers.rbp = "variable-3";

    registers.ip  = "variable";
    registers.eip = "variable-2";
    registers.rip = "variable-3";

    registers.cs  = "keyword";
    registers.ds  = "keyword";
    registers.ss  = "keyword";
    registers.es  = "keyword";
    registers.fs  = "keyword";
    registers.gs  = "keyword";
  }

  function armv6(_parserConfig) {
    // Reference:
    // http://infocenter.arm.com/help/topic/com.arm.doc.qrc0001l/QRC0001_UAL.pdf
    // http://infocenter.arm.com/help/topic/com.arm.doc.ddi0301h/DDI0301H_arm1176jzfs_r0p7_trm.pdf
    lineCommentStartSymbol = "@";
    directives.syntax = "builtin";

    registers.r0  = "variable";
    registers.r1  = "variable";
    registers.r2  = "variable";
    registers.r3  = "variable";
    registers.r4  = "variable";
    registers.r5  = "variable";
    registers.r6  = "variable";
    registers.r7  = "variable";
    registers.r8  = "variable";
    registers.r9  = "variable";
    registers.r10 = "variable";
    registers.r11 = "variable";
    registers.r12 = "variable";

    registers.sp  = "variable-2";
    registers.lr  = "variable-2";
    registers.pc  = "variable-2";
    registers.r13 = registers.sp;
    registers.r14 = registers.lr;
    registers.r15 = registers.pc;

    custom.push(function(ch, stream) {
      if (ch === '#') {
        stream.eatWhile(/\w/);
        return "number";
      }
    });
  }

  var arch = (parserConfig.architecture || "x86").toLowerCase();
  if (arch === "x86") {
    x86(parserConfig);
  } else if (arch === "arm" || arch === "armv6") {
    armv6(parserConfig);
  }

  function nextUntilUnescaped(stream, end) {
    var escaped = false, next;
    while ((next = stream.next()) != null) {
      if (next === end && !escaped) {
        return false;
      }
      escaped = !escaped && next === "\\";
    }
    return escaped;
  }

  function clikeComment(stream, state) {
    var maybeEnd = false, ch;
    while ((ch = stream.next()) != null) {
      if (ch === "/" && maybeEnd) {
        state.tokenize = null;
        break;
      }
      maybeEnd = (ch === "*");
    }
    return "comment";
  }

  return {
    startState: function() {
      return {
        tokenize: null
      };
    },

    token: function(stream, state) {
      if (state.tokenize) {
        return state.tokenize(stream, state);
      }

      if (stream.eatSpace()) {
        return null;
      }

      var style, cur, ch = stream.next();

      if (ch === "/") {
        if (stream.eat("*")) {
          state.tokenize = clikeComment;
          return clikeComment(stream, state);
        }
      }

      if (ch === lineCommentStartSymbol) {
        stream.skipToEnd();
        return "comment";
      }

      if (ch === '"') {
        nextUntilUnescaped(stream, '"');
        return "string";
      }

      if (ch === '.') {
        stream.eatWhile(/\w/);
        cur = stream.current().toLowerCase();
        style = directives[cur];
        return style || null;
      }

      if (ch === '=') {
        stream.eatWhile(/\w/);
        return "tag";
      }

      if (ch === '{') {
        return "bracket";
      }

      if (ch === '}') {
        return "bracket";
      }

      if (/\d/.test(ch)) {
        if (ch === "0" && stream.eat("x")) {
          stream.eatWhile(/[0-9a-fA-F]/);
          return "number";
        }
        stream.eatWhile(/\d/);
        return "number";
      }

      if (/\w/.test(ch)) {
        stream.eatWhile(/\w/);
        if (stream.eat(":")) {
          return 'tag';
        }
        cur = stream.current().toLowerCase();
        style = registers[cur];
        return style || null;
      }

      for (var i = 0; i < custom.length; i++) {
        style = custom[i](ch, stream, state);
        if (style) {
          return style;
        }
      }
    },

    lineComment: lineCommentStartSymbol,
    blockCommentStart: "/*",
    blockCommentEnd: "*/"
  };
});

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/gherkin/gherkin.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

/*
Gherkin mode - http://www.cukes.info/
Report bugs/issues here: https://github.com/codemirror/CodeMirror/issues
*/

// Following Objs from Brackets implementation: https://github.com/tregusti/brackets-gherkin/blob/master/main.js
//var Quotes = {
//  SINGLE: 1,
//  DOUBLE: 2
//};

//var regex = {
//  keywords: /(Feature| {2}(Scenario|In order to|As|I)| {4}(Given|When|Then|And))/
//};

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("gherkin", function () {
  return {
    startState: function () {
      return {
        lineNumber: 0,
        tableHeaderLine: false,
        allowFeature: true,
        allowBackground: false,
        allowScenario: false,
        allowSteps: false,
        allowPlaceholders: false,
        allowMultilineArgument: false,
        inMultilineString: false,
        inMultilineTable: false,
        inKeywordLine: false
      };
    },
    token: function (stream, state) {
      if (stream.sol()) {
        state.lineNumber++;
        state.inKeywordLine = false;
        if (state.inMultilineTable) {
            state.tableHeaderLine = false;
            if (!stream.match(/\s*\|/, false)) {
              state.allowMultilineArgument = false;
              state.inMultilineTable = false;
            }
        }
      }

      stream.eatSpace();

      if (state.allowMultilineArgument) {

        // STRING
        if (state.inMultilineString) {
          if (stream.match('"""')) {
            state.inMultilineString = false;
            state.allowMultilineArgument = false;
          } else {
            stream.match(/.*/);
          }
          return "string";
        }

        // TABLE
        if (state.inMultilineTable) {
          if (stream.match(/\|\s*/)) {
            return "bracket";
          } else {
            stream.match(/[^\|]*/);
            return state.tableHeaderLine ? "header" : "string";
          }
        }

        // DETECT START
        if (stream.match('"""')) {
          // String
          state.inMultilineString = true;
          return "string";
        } else if (stream.match("|")) {
          // Table
          state.inMultilineTable = true;
          state.tableHeaderLine = true;
          return "bracket";
        }

      }

      // LINE COMMENT
      if (stream.match(/#.*/)) {
        return "comment";

      // TAG
      } else if (!state.inKeywordLine && stream.match(/@\S+/)) {
        return "tag";

      // FEATURE
      } else if (!state.inKeywordLine && state.allowFeature && stream.match(/(機能|功能|フィーチャ|기능|โครงหลัก|ความสามารถ|ความต้องการทางธุรกิจ|ಹೆಚ್ಚಳ|గుణము|ਮੁਹਾਂਦਰਾ|ਨਕਸ਼ ਨੁਹਾਰ|ਖਾਸੀਅਤ|रूप लेख|وِیژگی|خاصية|תכונה|Функціонал|Функция|Функционалност|Функционал|Үзенчәлеклелек|Свойство|Особина|Мөмкинлек|Могућност|Λειτουργία|Δυνατότητα|Właściwość|Vlastnosť|Trajto|Tính năng|Savybė|Pretty much|Požiadavka|Požadavek|Potrzeba biznesowa|Özellik|Osobina|Ominaisuus|Omadus|OH HAI|Mogućnost|Mogucnost|Jellemző|Hwæt|Hwaet|Funzionalità|Funktionalitéit|Funktionalität|Funkcja|Funkcionalnost|Funkcionalitāte|Funkcia|Fungsi|Functionaliteit|Funcționalitate|Funcţionalitate|Functionalitate|Funcionalitat|Funcionalidade|Fonctionnalité|Fitur|Fīča|Feature|Eiginleiki|Egenskap|Egenskab|Característica|Caracteristica|Business Need|Aspekt|Arwedd|Ahoy matey!|Ability):/)) {
        state.allowScenario = true;
        state.allowBackground = true;
        state.allowPlaceholders = false;
        state.allowSteps = false;
        state.allowMultilineArgument = false;
        state.inKeywordLine = true;
        return "keyword";

      // BACKGROUND
      } else if (!state.inKeywordLine && state.allowBackground && stream.match(/(背景|배경|แนวคิด|ಹಿನ್ನೆಲೆ|నేపథ్యం|ਪਿਛੋਕੜ|पृष्ठभूमि|زمینه|الخلفية|רקע|Тарих|Предыстория|Предистория|Позадина|Передумова|Основа|Контекст|Кереш|Υπόβαθρο|Założenia|Yo\-ho\-ho|Tausta|Taust|Situācija|Rerefons|Pozadina|Pozadie|Pozadí|Osnova|Latar Belakang|Kontext|Konteksts|Kontekstas|Kontekst|Háttér|Hannergrond|Grundlage|Geçmiş|Fundo|Fono|First off|Dis is what went down|Dasar|Contexto|Contexte|Context|Contesto|Cenário de Fundo|Cenario de Fundo|Cefndir|Bối cảnh|Bakgrunnur|Bakgrunn|Bakgrund|Baggrund|Background|B4|Antecedents|Antecedentes|Ær|Aer|Achtergrond):/)) {
        state.allowPlaceholders = false;
        state.allowSteps = true;
        state.allowBackground = false;
        state.allowMultilineArgument = false;
        state.inKeywordLine = true;
        return "keyword";

      // SCENARIO OUTLINE
      } else if (!state.inKeywordLine && state.allowScenario && stream.match(/(場景大綱|场景大纲|劇本大綱|剧本大纲|テンプレ|シナリオテンプレート|シナリオテンプレ|シナリオアウトライン|시나리오 개요|สรุปเหตุการณ์|โครงสร้างของเหตุการณ์|ವಿವರಣೆ|కథనం|ਪਟਕਥਾ ਰੂਪ ਰੇਖਾ|ਪਟਕਥਾ ਢਾਂਚਾ|परिदृश्य रूपरेखा|سيناريو مخطط|الگوی سناریو|תבנית תרחיש|Сценарийның төзелеше|Сценарий структураси|Структура сценарію|Структура сценария|Структура сценарија|Скица|Рамка на сценарий|Концепт|Περιγραφή Σεναρίου|Wharrimean is|Template Situai|Template Senario|Template Keadaan|Tapausaihio|Szenariogrundriss|Szablon scenariusza|Swa hwær swa|Swa hwaer swa|Struktura scenarija|Structură scenariu|Structura scenariu|Skica|Skenario konsep|Shiver me timbers|Senaryo taslağı|Schema dello scenario|Scenariomall|Scenariomal|Scenario Template|Scenario Outline|Scenario Amlinellol|Scenārijs pēc parauga|Scenarijaus šablonas|Reckon it's like|Raamstsenaarium|Plang vum Szenario|Plan du Scénario|Plan du scénario|Osnova scénáře|Osnova Scenára|Náčrt Scenáru|Náčrt Scénáře|Náčrt Scenára|MISHUN SRSLY|Menggariskan Senario|Lýsing Dæma|Lýsing Atburðarásar|Konturo de la scenaro|Koncept|Khung tình huống|Khung kịch bản|Forgatókönyv vázlat|Esquema do Cenário|Esquema do Cenario|Esquema del escenario|Esquema de l'escenari|Esbozo do escenario|Delineação do Cenário|Delineacao do Cenario|All y'all|Abstrakt Scenario|Abstract Scenario):/)) {
        state.allowPlaceholders = true;
        state.allowSteps = true;
        state.allowMultilineArgument = false;
        state.inKeywordLine = true;
        return "keyword";

      // EXAMPLES
      } else if (state.allowScenario && stream.match(/(例子|例|サンプル|예|ชุดของเหตุการณ์|ชุดของตัวอย่าง|ಉದಾಹರಣೆಗಳು|ఉదాహరణలు|ਉਦਾਹਰਨਾਂ|उदाहरण|نمونه ها|امثلة|דוגמאות|Үрнәкләр|Сценарији|Примеры|Примери|Приклади|Мисоллар|Мисаллар|Σενάρια|Παραδείγματα|You'll wanna|Voorbeelden|Variantai|Tapaukset|Se þe|Se the|Se ðe|Scenarios|Scenariji|Scenarijai|Przykłady|Primjeri|Primeri|Příklady|Príklady|Piemēri|Példák|Pavyzdžiai|Paraugs|Örnekler|Juhtumid|Exemplos|Exemples|Exemple|Exempel|EXAMPLZ|Examples|Esempi|Enghreifftiau|Ekzemploj|Eksempler|Ejemplos|Dữ liệu|Dead men tell no tales|Dæmi|Contoh|Cenários|Cenarios|Beispiller|Beispiele|Atburðarásir):/)) {
        state.allowPlaceholders = false;
        state.allowSteps = true;
        state.allowBackground = false;
        state.allowMultilineArgument = true;
        return "keyword";

      // SCENARIO
      } else if (!state.inKeywordLine && state.allowScenario && stream.match(/(場景|场景|劇本|剧本|シナリオ|시나리오|เหตุการณ์|ಕಥಾಸಾರಾಂಶ|సన్నివేశం|ਪਟਕਥਾ|परिदृश्य|سيناريو|سناریو|תרחיש|Сценарій|Сценарио|Сценарий|Пример|Σενάριο|Tình huống|The thing of it is|Tapaus|Szenario|Swa|Stsenaarium|Skenario|Situai|Senaryo|Senario|Scenaro|Scenariusz|Scenariu|Scénario|Scenario|Scenarijus|Scenārijs|Scenarij|Scenarie|Scénář|Scenár|Primer|MISHUN|Kịch bản|Keadaan|Heave to|Forgatókönyv|Escenario|Escenari|Cenário|Cenario|Awww, look mate|Atburðarás):/)) {
        state.allowPlaceholders = false;
        state.allowSteps = true;
        state.allowBackground = false;
        state.allowMultilineArgument = false;
        state.inKeywordLine = true;
        return "keyword";

      // STEPS
      } else if (!state.inKeywordLine && state.allowSteps && stream.match(/(那麼|那么|而且|當|当|并且|同時|同时|前提|假设|假設|假定|假如|但是|但し|並且|もし|ならば|ただし|しかし|かつ|하지만|조건|먼저|만일|만약|단|그리고|그러면|และ |เมื่อ |แต่ |ดังนั้น |กำหนดให้ |ಸ್ಥಿತಿಯನ್ನು |ಮತ್ತು |ನೀಡಿದ |ನಂತರ |ಆದರೆ |మరియు |చెప్పబడినది |కాని |ఈ పరిస్థితిలో |అప్పుడు |ਪਰ |ਤਦ |ਜੇਕਰ |ਜਿਵੇਂ ਕਿ |ਜਦੋਂ |ਅਤੇ |यदि |परन्तु |पर |तब |तदा |तथा |जब |चूंकि |किन्तु |कदा |और |अगर |و |هنگامی |متى |لكن |عندما |ثم |بفرض |با فرض |اما |اذاً |آنگاه |כאשר |וגם |בהינתן |אזי |אז |אבל |Якщо |Һәм |Унда |Тоді |Тогда |То |Также |Та |Пусть |Припустимо, що |Припустимо |Онда |Но |Нехай |Нәтиҗәдә |Лекин |Ләкин |Коли |Когда |Когато |Када |Кад |К тому же |І |И |Задато |Задати |Задате |Если |Допустим |Дано |Дадено |Вә |Ва |Бирок |Әмма |Әйтик |Әгәр |Аммо |Али |Але |Агар |А також |А |Τότε |Όταν |Και |Δεδομένου |Αλλά |Þurh |Þegar |Þa þe |Þá |Þa |Zatati |Zakładając |Zadato |Zadate |Zadano |Zadani |Zadan |Za předpokladu |Za predpokladu |Youse know when youse got |Youse know like when |Yna |Yeah nah |Y'know |Y |Wun |Wtedy |When y'all |When |Wenn |WEN |wann |Ve |Và |Und |Un |ugeholl |Too right |Thurh |Thì |Then y'all |Then |Tha the |Tha |Tetapi |Tapi |Tak |Tada |Tad |Stel |Soit |Siis |Și |Şi |Si |Sed |Se |Så |Quando |Quand |Quan |Pryd |Potom |Pokud |Pokiaľ |Però |Pero |Pak |Oraz |Onda |Ond |Oletetaan |Og |Och |O zaman |Niin |Nhưng |När |Når |Mutta |Men |Mas |Maka |Majd |Mając |Mais |Maar |mä |Ma |Lorsque |Lorsqu'|Logo |Let go and haul |Kun |Kuid |Kui |Kiedy |Khi |Ketika |Kemudian |Keď |Když |Kaj |Kai |Kada |Kad |Jeżeli |Jeśli |Ja |It's just unbelievable |Ir |I CAN HAZ |I |Ha |Givun |Givet |Given y'all |Given |Gitt |Gegeven |Gegeben seien |Gegeben sei |Gdy |Gangway! |Fakat |Étant donnés |Etant donnés |Étant données |Etant données |Étant donnée |Etant donnée |Étant donné |Etant donné |Et |És |Entonces |Entón |Então |Entao |En |Eğer ki |Ef |Eeldades |E |Ðurh |Duota |Dun |Donitaĵo |Donat |Donada |Do |Diyelim ki |Diberi |Dengan |Den youse gotta |DEN |De |Dato |Dați fiind |Daţi fiind |Dati fiind |Dati |Date fiind |Date |Data |Dat fiind |Dar |Dann |dann |Dan |Dados |Dado |Dadas |Dada |Ða ðe |Ða |Cuando |Cho |Cando |Când |Cand |Cal |But y'all |But at the end of the day I reckon |BUT |But |Buh |Blimey! |Biết |Bet |Bagi |Aye |awer |Avast! |Atunci |Atesa |Atès |Apabila |Anrhegedig a |Angenommen |And y'all |And |AN |An |an |Amikor |Amennyiben |Ama |Als |Alors |Allora |Ali |Aleshores |Ale |Akkor |Ak |Adott |Ac |Aber |A zároveň |A tiež |A taktiež |A také |A |a |7 |\* )/)) {
        state.inStep = true;
        state.allowPlaceholders = true;
        state.allowMultilineArgument = true;
        state.inKeywordLine = true;
        return "keyword";

      // INLINE STRING
      } else if (stream.match(/"[^"]*"?/)) {
        return "string";

      // PLACEHOLDER
      } else if (state.allowPlaceholders && stream.match(/<[^>]*>?/)) {
        return "variable";

      // Fall through
      } else {
        stream.next();
        stream.eatWhile(/[^@"<#]/);
        return null;
      }
    }
  };
});

CodeMirror.defineMIME("text/x-feature", "gherkin");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/go/go.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("go", function(config) {
  var indentUnit = config.indentUnit;

  var keywords = {
    "break":true, "case":true, "chan":true, "const":true, "continue":true,
    "default":true, "defer":true, "else":true, "fallthrough":true, "for":true,
    "func":true, "go":true, "goto":true, "if":true, "import":true,
    "interface":true, "map":true, "package":true, "range":true, "return":true,
    "select":true, "struct":true, "switch":true, "type":true, "var":true,
    "bool":true, "byte":true, "complex64":true, "complex128":true,
    "float32":true, "float64":true, "int8":true, "int16":true, "int32":true,
    "int64":true, "string":true, "uint8":true, "uint16":true, "uint32":true,
    "uint64":true, "int":true, "uint":true, "uintptr":true, "error": true,
    "rune":true
  };

  var atoms = {
    "true":true, "false":true, "iota":true, "nil":true, "append":true,
    "cap":true, "close":true, "complex":true, "copy":true, "delete":true, "imag":true,
    "len":true, "make":true, "new":true, "panic":true, "print":true,
    "println":true, "real":true, "recover":true
  };

  var isOperatorChar = /[+\-*&^%:=<>!|\/]/;

  var curPunc;

  function tokenBase(stream, state) {
    var ch = stream.next();
    if (ch == '"' || ch == "'" || ch == "`") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    }
    if (/[\d\.]/.test(ch)) {
      if (ch == ".") {
        stream.match(/^[0-9]+([eE][\-+]?[0-9]+)?/);
      } else if (ch == "0") {
        stream.match(/^[xX][0-9a-fA-F]+/) || stream.match(/^0[0-7]+/);
      } else {
        stream.match(/^[0-9]*\.?[0-9]*([eE][\-+]?[0-9]+)?/);
      }
      return "number";
    }
    if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
      curPunc = ch;
      return null;
    }
    if (ch == "/") {
      if (stream.eat("*")) {
        state.tokenize = tokenComment;
        return tokenComment(stream, state);
      }
      if (stream.eat("/")) {
        stream.skipToEnd();
        return "comment";
      }
    }
    if (isOperatorChar.test(ch)) {
      stream.eatWhile(isOperatorChar);
      return "operator";
    }
    stream.eatWhile(/[\w\$_\xa1-\uffff]/);
    var cur = stream.current();
    if (keywords.propertyIsEnumerable(cur)) {
      if (cur == "case" || cur == "default") curPunc = "case";
      return "keyword";
    }
    if (atoms.propertyIsEnumerable(cur)) return "atom";
    return "variable";
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, next, end = false;
      while ((next = stream.next()) != null) {
        if (next == quote && !escaped) {end = true; break;}
        escaped = !escaped && quote != "`" && next == "\\";
      }
      if (end || !(escaped || quote == "`"))
        state.tokenize = tokenBase;
      return "string";
    };
  }

  function tokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" && maybeEnd) {
        state.tokenize = tokenBase;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return "comment";
  }

  function Context(indented, column, type, align, prev) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.align = align;
    this.prev = prev;
  }
  function pushContext(state, col, type) {
    return state.context = new Context(state.indented, col, type, null, state.context);
  }
  function popContext(state) {
    if (!state.context.prev) return;
    var t = state.context.type;
    if (t == ")" || t == "]" || t == "}")
      state.indented = state.context.indented;
    return state.context = state.context.prev;
  }

  // Interface

  return {
    startState: function(basecolumn) {
      return {
        tokenize: null,
        context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),
        indented: 0,
        startOfLine: true
      };
    },

    token: function(stream, state) {
      var ctx = state.context;
      if (stream.sol()) {
        if (ctx.align == null) ctx.align = false;
        state.indented = stream.indentation();
        state.startOfLine = true;
        if (ctx.type == "case") ctx.type = "}";
      }
      if (stream.eatSpace()) return null;
      curPunc = null;
      var style = (state.tokenize || tokenBase)(stream, state);
      if (style == "comment") return style;
      if (ctx.align == null) ctx.align = true;

      if (curPunc == "{") pushContext(state, stream.column(), "}");
      else if (curPunc == "[") pushContext(state, stream.column(), "]");
      else if (curPunc == "(") pushContext(state, stream.column(), ")");
      else if (curPunc == "case") ctx.type = "case";
      else if (curPunc == "}" && ctx.type == "}") popContext(state);
      else if (curPunc == ctx.type) popContext(state);
      state.startOfLine = false;
      return style;
    },

    indent: function(state, textAfter) {
      if (state.tokenize != tokenBase && state.tokenize != null) return CodeMirror.Pass;
      var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);
      if (ctx.type == "case" && /^(?:case|default)\b/.test(textAfter)) {
        state.context.type = "}";
        return ctx.indented;
      }
      var closing = firstChar == ctx.type;
      if (ctx.align) return ctx.column + (closing ? 0 : 1);
      else return ctx.indented + (closing ? 0 : indentUnit);
    },

    electricChars: "{}):",
    closeBrackets: "()[]{}''\"\"``",
    fold: "brace",
    blockCommentStart: "/*",
    blockCommentEnd: "*/",
    lineComment: "//"
  };
});

CodeMirror.defineMIME("text/x-go", "go");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/groovy/groovy.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("groovy", function(config) {
  function words(str) {
    var obj = {}, words = str.split(" ");
    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
    return obj;
  }
  var keywords = words(
    "abstract as assert boolean break byte case catch char class const continue def default " +
    "do double else enum extends final finally float for goto if implements import in " +
    "instanceof int interface long native new package private protected public return " +
    "short static strictfp super switch synchronized threadsafe throw throws trait transient " +
    "try void volatile while");
  var blockKeywords = words("catch class def do else enum finally for if interface switch trait try while");
  var standaloneKeywords = words("return break continue");
  var atoms = words("null true false this");

  var curPunc;
  function tokenBase(stream, state) {
    var ch = stream.next();
    if (ch == '"' || ch == "'") {
      return startString(ch, stream, state);
    }
    if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
      curPunc = ch;
      return null;
    }
    if (/\d/.test(ch)) {
      stream.eatWhile(/[\w\.]/);
      if (stream.eat(/eE/)) { stream.eat(/\+\-/); stream.eatWhile(/\d/); }
      return "number";
    }
    if (ch == "/") {
      if (stream.eat("*")) {
        state.tokenize.push(tokenComment);
        return tokenComment(stream, state);
      }
      if (stream.eat("/")) {
        stream.skipToEnd();
        return "comment";
      }
      if (expectExpression(state.lastToken, false)) {
        return startString(ch, stream, state);
      }
    }
    if (ch == "-" && stream.eat(">")) {
      curPunc = "->";
      return null;
    }
    if (/[+\-*&%=<>!?|\/~]/.test(ch)) {
      stream.eatWhile(/[+\-*&%=<>|~]/);
      return "operator";
    }
    stream.eatWhile(/[\w\$_]/);
    if (ch == "@") { stream.eatWhile(/[\w\$_\.]/); return "meta"; }
    if (state.lastToken == ".") return "property";
    if (stream.eat(":")) { curPunc = "proplabel"; return "property"; }
    var cur = stream.current();
    if (atoms.propertyIsEnumerable(cur)) { return "atom"; }
    if (keywords.propertyIsEnumerable(cur)) {
      if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
      else if (standaloneKeywords.propertyIsEnumerable(cur)) curPunc = "standalone";
      return "keyword";
    }
    return "variable";
  }
  tokenBase.isBase = true;

  function startString(quote, stream, state) {
    var tripleQuoted = false;
    if (quote != "/" && stream.eat(quote)) {
      if (stream.eat(quote)) tripleQuoted = true;
      else return "string";
    }
    function t(stream, state) {
      var escaped = false, next, end = !tripleQuoted;
      while ((next = stream.next()) != null) {
        if (next == quote && !escaped) {
          if (!tripleQuoted) { break; }
          if (stream.match(quote + quote)) { end = true; break; }
        }
        if (quote == '"' && next == "$" && !escaped && stream.eat("{")) {
          state.tokenize.push(tokenBaseUntilBrace());
          return "string";
        }
        escaped = !escaped && next == "\\";
      }
      if (end) state.tokenize.pop();
      return "string";
    }
    state.tokenize.push(t);
    return t(stream, state);
  }

  function tokenBaseUntilBrace() {
    var depth = 1;
    function t(stream, state) {
      if (stream.peek() == "}") {
        depth--;
        if (depth == 0) {
          state.tokenize.pop();
          return state.tokenize[state.tokenize.length-1](stream, state);
        }
      } else if (stream.peek() == "{") {
        depth++;
      }
      return tokenBase(stream, state);
    }
    t.isBase = true;
    return t;
  }

  function tokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" && maybeEnd) {
        state.tokenize.pop();
        break;
      }
      maybeEnd = (ch == "*");
    }
    return "comment";
  }

  function expectExpression(last, newline) {
    return !last || last == "operator" || last == "->" || /[\.\[\{\(,;:]/.test(last) ||
      last == "newstatement" || last == "keyword" || last == "proplabel" ||
      (last == "standalone" && !newline);
  }

  function Context(indented, column, type, align, prev) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.align = align;
    this.prev = prev;
  }
  function pushContext(state, col, type) {
    return state.context = new Context(state.indented, col, type, null, state.context);
  }
  function popContext(state) {
    var t = state.context.type;
    if (t == ")" || t == "]" || t == "}")
      state.indented = state.context.indented;
    return state.context = state.context.prev;
  }

  // Interface

  return {
    startState: function(basecolumn) {
      return {
        tokenize: [tokenBase],
        context: new Context((basecolumn || 0) - config.indentUnit, 0, "top", false),
        indented: 0,
        startOfLine: true,
        lastToken: null
      };
    },

    token: function(stream, state) {
      var ctx = state.context;
      if (stream.sol()) {
        if (ctx.align == null) ctx.align = false;
        state.indented = stream.indentation();
        state.startOfLine = true;
        // Automatic semicolon insertion
        if (ctx.type == "statement" && !expectExpression(state.lastToken, true)) {
          popContext(state); ctx = state.context;
        }
      }
      if (stream.eatSpace()) return null;
      curPunc = null;
      var style = state.tokenize[state.tokenize.length-1](stream, state);
      if (style == "comment") return style;
      if (ctx.align == null) ctx.align = true;

      if ((curPunc == ";" || curPunc == ":") && ctx.type == "statement") popContext(state);
      // Handle indentation for {x -> \n ... }
      else if (curPunc == "->" && ctx.type == "statement" && ctx.prev.type == "}") {
        popContext(state);
        state.context.align = false;
      }
      else if (curPunc == "{") pushContext(state, stream.column(), "}");
      else if (curPunc == "[") pushContext(state, stream.column(), "]");
      else if (curPunc == "(") pushContext(state, stream.column(), ")");
      else if (curPunc == "}") {
        while (ctx.type == "statement") ctx = popContext(state);
        if (ctx.type == "}") ctx = popContext(state);
        while (ctx.type == "statement") ctx = popContext(state);
      }
      else if (curPunc == ctx.type) popContext(state);
      else if (ctx.type == "}" || ctx.type == "top" || (ctx.type == "statement" && curPunc == "newstatement"))
        pushContext(state, stream.column(), "statement");
      state.startOfLine = false;
      state.lastToken = curPunc || style;
      return style;
    },

    indent: function(state, textAfter) {
      if (!state.tokenize[state.tokenize.length-1].isBase) return CodeMirror.Pass;
      var firstChar = textAfter && textAfter.charAt(0), ctx = state.context;
      if (ctx.type == "statement" && !expectExpression(state.lastToken, true)) ctx = ctx.prev;
      var closing = firstChar == ctx.type;
      if (ctx.type == "statement") return ctx.indented + (firstChar == "{" ? 0 : config.indentUnit);
      else if (ctx.align) return ctx.column + (closing ? 0 : 1);
      else return ctx.indented + (closing ? 0 : config.indentUnit);
    },

    electricChars: "{}",
    closeBrackets: {triples: "'\""},
    fold: "brace",
    blockCommentStart: "/*",
    blockCommentEnd: "*/",
    lineComment: "//"
  };
});

CodeMirror.defineMIME("text/x-groovy", "groovy");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/haml/haml.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"), __webpack_require__("./src/ipywidgets/node_modules/codemirror/mode/htmlmixed/htmlmixed.js"), __webpack_require__("./src/ipywidgets/node_modules/codemirror/mode/ruby/ruby.js"));
  else {}
})(function(CodeMirror) {
"use strict";

  // full haml mode. This handled embedded ruby and html fragments too
  CodeMirror.defineMode("haml", function(config) {
    var htmlMode = CodeMirror.getMode(config, {name: "htmlmixed"});
    var rubyMode = CodeMirror.getMode(config, "ruby");

    function rubyInQuote(endQuote) {
      return function(stream, state) {
        var ch = stream.peek();
        if (ch == endQuote && state.rubyState.tokenize.length == 1) {
          // step out of ruby context as it seems to complete processing all the braces
          stream.next();
          state.tokenize = html;
          return "closeAttributeTag";
        } else {
          return ruby(stream, state);
        }
      };
    }

    function ruby(stream, state) {
      if (stream.match("-#")) {
        stream.skipToEnd();
        return "comment";
      }
      return rubyMode.token(stream, state.rubyState);
    }

    function html(stream, state) {
      var ch = stream.peek();

      // handle haml declarations. All declarations that cant be handled here
      // will be passed to html mode
      if (state.previousToken.style == "comment" ) {
        if (state.indented > state.previousToken.indented) {
          stream.skipToEnd();
          return "commentLine";
        }
      }

      if (state.startOfLine) {
        if (ch == "!" && stream.match("!!")) {
          stream.skipToEnd();
          return "tag";
        } else if (stream.match(/^%[\w:#\.]+=/)) {
          state.tokenize = ruby;
          return "hamlTag";
        } else if (stream.match(/^%[\w:]+/)) {
          return "hamlTag";
        } else if (ch == "/" ) {
          stream.skipToEnd();
          return "comment";
        }
      }

      if (state.startOfLine || state.previousToken.style == "hamlTag") {
        if ( ch == "#" || ch == ".") {
          stream.match(/[\w-#\.]*/);
          return "hamlAttribute";
        }
      }

      // do not handle --> as valid ruby, make it HTML close comment instead
      if (state.startOfLine && !stream.match("-->", false) && (ch == "=" || ch == "-" )) {
        state.tokenize = ruby;
        return state.tokenize(stream, state);
      }

      if (state.previousToken.style == "hamlTag" ||
          state.previousToken.style == "closeAttributeTag" ||
          state.previousToken.style == "hamlAttribute") {
        if (ch == "(") {
          state.tokenize = rubyInQuote(")");
          return state.tokenize(stream, state);
        } else if (ch == "{") {
          if (!stream.match(/^\{%.*/)) {
            state.tokenize = rubyInQuote("}");
            return state.tokenize(stream, state);
          }
        }
      }

      return htmlMode.token(stream, state.htmlState);
    }

    return {
      // default to html mode
      startState: function() {
        var htmlState = CodeMirror.startState(htmlMode);
        var rubyState = CodeMirror.startState(rubyMode);
        return {
          htmlState: htmlState,
          rubyState: rubyState,
          indented: 0,
          previousToken: { style: null, indented: 0},
          tokenize: html
        };
      },

      copyState: function(state) {
        return {
          htmlState : CodeMirror.copyState(htmlMode, state.htmlState),
          rubyState: CodeMirror.copyState(rubyMode, state.rubyState),
          indented: state.indented,
          previousToken: state.previousToken,
          tokenize: state.tokenize
        };
      },

      token: function(stream, state) {
        if (stream.sol()) {
          state.indented = stream.indentation();
          state.startOfLine = true;
        }
        if (stream.eatSpace()) return null;
        var style = state.tokenize(stream, state);
        state.startOfLine = false;
        // dont record comment line as we only want to measure comment line with
        // the opening comment block
        if (style && style != "commentLine") {
          state.previousToken = { style: style, indented: state.indented };
        }
        // if current state is ruby and the previous token is not `,` reset the
        // tokenize to html
        if (stream.eol() && state.tokenize == ruby) {
          stream.backUp(1);
          var ch = stream.peek();
          stream.next();
          if (ch && ch != ",") {
            state.tokenize = html;
          }
        }
        // reprocess some of the specific style tag when finish setting previousToken
        if (style == "hamlTag") {
          style = "tag";
        } else if (style == "commentLine") {
          style = "comment";
        } else if (style == "hamlAttribute") {
          style = "attribute";
        } else if (style == "closeAttributeTag") {
          style = null;
        }
        return style;
      }
    };
  }, "htmlmixed", "ruby");

  CodeMirror.defineMIME("text/x-haml", "haml");
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/handlebars/handlebars.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"), __webpack_require__("./src/ipywidgets/node_modules/codemirror/addon/mode/simple.js"), __webpack_require__("./src/ipywidgets/node_modules/codemirror/addon/mode/multiplex.js"));
  else {}
})(function(CodeMirror) {
  "use strict";

  CodeMirror.defineSimpleMode("handlebars-tags", {
    start: [
      { regex: /\{\{\{/, push: "handlebars_raw", token: "tag" },
      { regex: /\{\{!--/, push: "dash_comment", token: "comment" },
      { regex: /\{\{!/,   push: "comment", token: "comment" },
      { regex: /\{\{/,    push: "handlebars", token: "tag" }
    ],
    handlebars_raw: [
      { regex: /\}\}\}/, pop: true, token: "tag" },
    ],
    handlebars: [
      { regex: /\}\}/, pop: true, token: "tag" },

      // Double and single quotes
      { regex: /"(?:[^\\"]|\\.)*"?/, token: "string" },
      { regex: /'(?:[^\\']|\\.)*'?/, token: "string" },

      // Handlebars keywords
      { regex: />|[#\/]([A-Za-z_]\w*)/, token: "keyword" },
      { regex: /(?:else|this)\b/, token: "keyword" },

      // Numeral
      { regex: /\d+/i, token: "number" },

      // Atoms like = and .
      { regex: /=|~|@|true|false/, token: "atom" },

      // Paths
      { regex: /(?:\.\.\/)*(?:[A-Za-z_][\w\.]*)+/, token: "variable-2" }
    ],
    dash_comment: [
      { regex: /--\}\}/, pop: true, token: "comment" },

      // Commented code
      { regex: /./, token: "comment"}
    ],
    comment: [
      { regex: /\}\}/, pop: true, token: "comment" },
      { regex: /./, token: "comment" }
    ],
    meta: {
      blockCommentStart: "{{--",
      blockCommentEnd: "--}}"
    }
  });

  CodeMirror.defineMode("handlebars", function(config, parserConfig) {
    var handlebars = CodeMirror.getMode(config, "handlebars-tags");
    if (!parserConfig || !parserConfig.base) return handlebars;
    return CodeMirror.multiplexingMode(
      CodeMirror.getMode(config, parserConfig.base),
      {open: "{{", close: /\}\}\}?/, mode: handlebars, parseDelimiters: true}
    );
  });

  CodeMirror.defineMIME("text/x-handlebars-template", "handlebars");
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/haskell-literate/haskell-literate.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"), __webpack_require__("./src/ipywidgets/node_modules/codemirror/mode/haskell/haskell.js"))
  else {}
})(function (CodeMirror) {
  "use strict"

  CodeMirror.defineMode("haskell-literate", function (config, parserConfig) {
    var baseMode = CodeMirror.getMode(config, (parserConfig && parserConfig.base) || "haskell")

    return {
      startState: function () {
        return {
          inCode: false,
          baseState: CodeMirror.startState(baseMode)
        }
      },
      token: function (stream, state) {
        if (stream.sol()) {
          if (state.inCode = stream.eat(">"))
            return "meta"
        }
        if (state.inCode) {
          return baseMode.token(stream, state.baseState)
        } else {
          stream.skipToEnd()
          return "comment"
        }
      },
      innerMode: function (state) {
        return state.inCode ? {state: state.baseState, mode: baseMode} : null
      }
    }
  }, "haskell")

  CodeMirror.defineMIME("text/x-literate-haskell", "haskell-literate")
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/haskell/haskell.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("haskell", function(_config, modeConfig) {

  function switchState(source, setState, f) {
    setState(f);
    return f(source, setState);
  }

  // These should all be Unicode extended, as per the Haskell 2010 report
  var smallRE = /[a-z_]/;
  var largeRE = /[A-Z]/;
  var digitRE = /\d/;
  var hexitRE = /[0-9A-Fa-f]/;
  var octitRE = /[0-7]/;
  var idRE = /[a-z_A-Z0-9'\xa1-\uffff]/;
  var symbolRE = /[-!#$%&*+.\/<=>?@\\^|~:]/;
  var specialRE = /[(),;[\]`{}]/;
  var whiteCharRE = /[ \t\v\f]/; // newlines are handled in tokenizer

  function normal(source, setState) {
    if (source.eatWhile(whiteCharRE)) {
      return null;
    }

    var ch = source.next();
    if (specialRE.test(ch)) {
      if (ch == '{' && source.eat('-')) {
        var t = "comment";
        if (source.eat('#')) {
          t = "meta";
        }
        return switchState(source, setState, ncomment(t, 1));
      }
      return null;
    }

    if (ch == '\'') {
      if (source.eat('\\')) {
        source.next();  // should handle other escapes here
      }
      else {
        source.next();
      }
      if (source.eat('\'')) {
        return "string";
      }
      return "string error";
    }

    if (ch == '"') {
      return switchState(source, setState, stringLiteral);
    }

    if (largeRE.test(ch)) {
      source.eatWhile(idRE);
      if (source.eat('.')) {
        return "qualifier";
      }
      return "variable-2";
    }

    if (smallRE.test(ch)) {
      source.eatWhile(idRE);
      return "variable";
    }

    if (digitRE.test(ch)) {
      if (ch == '0') {
        if (source.eat(/[xX]/)) {
          source.eatWhile(hexitRE); // should require at least 1
          return "integer";
        }
        if (source.eat(/[oO]/)) {
          source.eatWhile(octitRE); // should require at least 1
          return "number";
        }
      }
      source.eatWhile(digitRE);
      var t = "number";
      if (source.match(/^\.\d+/)) {
        t = "number";
      }
      if (source.eat(/[eE]/)) {
        t = "number";
        source.eat(/[-+]/);
        source.eatWhile(digitRE); // should require at least 1
      }
      return t;
    }

    if (ch == "." && source.eat("."))
      return "keyword";

    if (symbolRE.test(ch)) {
      if (ch == '-' && source.eat(/-/)) {
        source.eatWhile(/-/);
        if (!source.eat(symbolRE)) {
          source.skipToEnd();
          return "comment";
        }
      }
      var t = "variable";
      if (ch == ':') {
        t = "variable-2";
      }
      source.eatWhile(symbolRE);
      return t;
    }

    return "error";
  }

  function ncomment(type, nest) {
    if (nest == 0) {
      return normal;
    }
    return function(source, setState) {
      var currNest = nest;
      while (!source.eol()) {
        var ch = source.next();
        if (ch == '{' && source.eat('-')) {
          ++currNest;
        }
        else if (ch == '-' && source.eat('}')) {
          --currNest;
          if (currNest == 0) {
            setState(normal);
            return type;
          }
        }
      }
      setState(ncomment(type, currNest));
      return type;
    };
  }

  function stringLiteral(source, setState) {
    while (!source.eol()) {
      var ch = source.next();
      if (ch == '"') {
        setState(normal);
        return "string";
      }
      if (ch == '\\') {
        if (source.eol() || source.eat(whiteCharRE)) {
          setState(stringGap);
          return "string";
        }
        if (source.eat('&')) {
        }
        else {
          source.next(); // should handle other escapes here
        }
      }
    }
    setState(normal);
    return "string error";
  }

  function stringGap(source, setState) {
    if (source.eat('\\')) {
      return switchState(source, setState, stringLiteral);
    }
    source.next();
    setState(normal);
    return "error";
  }


  var wellKnownWords = (function() {
    var wkw = {};
    function setType(t) {
      return function () {
        for (var i = 0; i < arguments.length; i++)
          wkw[arguments[i]] = t;
      };
    }

    setType("keyword")(
      "case", "class", "data", "default", "deriving", "do", "else", "foreign",
      "if", "import", "in", "infix", "infixl", "infixr", "instance", "let",
      "module", "newtype", "of", "then", "type", "where", "_");

    setType("keyword")(
      "\.\.", ":", "::", "=", "\\", "<-", "->", "@", "~", "=>");

    setType("builtin")(
      "!!", "$!", "$", "&&", "+", "++", "-", ".", "/", "/=", "<", "<*", "<=",
      "<$>", "<*>", "=<<", "==", ">", ">=", ">>", ">>=", "^", "^^", "||", "*",
      "*>", "**");

    setType("builtin")(
      "Applicative", "Bool", "Bounded", "Char", "Double", "EQ", "Either", "Enum",
      "Eq", "False", "FilePath", "Float", "Floating", "Fractional", "Functor",
      "GT", "IO", "IOError", "Int", "Integer", "Integral", "Just", "LT", "Left",
      "Maybe", "Monad", "Nothing", "Num", "Ord", "Ordering", "Rational", "Read",
      "ReadS", "Real", "RealFloat", "RealFrac", "Right", "Show", "ShowS",
      "String", "True");

    setType("builtin")(
      "abs", "acos", "acosh", "all", "and", "any", "appendFile", "asTypeOf",
      "asin", "asinh", "atan", "atan2", "atanh", "break", "catch", "ceiling",
      "compare", "concat", "concatMap", "const", "cos", "cosh", "curry",
      "cycle", "decodeFloat", "div", "divMod", "drop", "dropWhile", "either",
      "elem", "encodeFloat", "enumFrom", "enumFromThen", "enumFromThenTo",
      "enumFromTo", "error", "even", "exp", "exponent", "fail", "filter",
      "flip", "floatDigits", "floatRadix", "floatRange", "floor", "fmap",
      "foldl", "foldl1", "foldr", "foldr1", "fromEnum", "fromInteger",
      "fromIntegral", "fromRational", "fst", "gcd", "getChar", "getContents",
      "getLine", "head", "id", "init", "interact", "ioError", "isDenormalized",
      "isIEEE", "isInfinite", "isNaN", "isNegativeZero", "iterate", "last",
      "lcm", "length", "lex", "lines", "log", "logBase", "lookup", "map",
      "mapM", "mapM_", "max", "maxBound", "maximum", "maybe", "min", "minBound",
      "minimum", "mod", "negate", "not", "notElem", "null", "odd", "or",
      "otherwise", "pi", "pred", "print", "product", "properFraction", "pure",
      "putChar", "putStr", "putStrLn", "quot", "quotRem", "read", "readFile",
      "readIO", "readList", "readLn", "readParen", "reads", "readsPrec",
      "realToFrac", "recip", "rem", "repeat", "replicate", "return", "reverse",
      "round", "scaleFloat", "scanl", "scanl1", "scanr", "scanr1", "seq",
      "sequence", "sequence_", "show", "showChar", "showList", "showParen",
      "showString", "shows", "showsPrec", "significand", "signum", "sin",
      "sinh", "snd", "span", "splitAt", "sqrt", "subtract", "succ", "sum",
      "tail", "take", "takeWhile", "tan", "tanh", "toEnum", "toInteger",
      "toRational", "truncate", "uncurry", "undefined", "unlines", "until",
      "unwords", "unzip", "unzip3", "userError", "words", "writeFile", "zip",
      "zip3", "zipWith", "zipWith3");

    var override = modeConfig.overrideKeywords;
    if (override) for (var word in override) if (override.hasOwnProperty(word))
      wkw[word] = override[word];

    return wkw;
  })();



  return {
    startState: function ()  { return { f: normal }; },
    copyState:  function (s) { return { f: s.f }; },

    token: function(stream, state) {
      var t = state.f(stream, function(s) { state.f = s; });
      var w = stream.current();
      return wellKnownWords.hasOwnProperty(w) ? wellKnownWords[w] : t;
    },

    blockCommentStart: "{-",
    blockCommentEnd: "-}",
    lineComment: "--"
  };

});

CodeMirror.defineMIME("text/x-haskell", "haskell");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/haxe/haxe.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("haxe", function(config, parserConfig) {
  var indentUnit = config.indentUnit;

  // Tokenizer

  function kw(type) {return {type: type, style: "keyword"};}
  var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c");
  var operator = kw("operator"), atom = {type: "atom", style: "atom"}, attribute = {type:"attribute", style: "attribute"};
  var type = kw("typedef");
  var keywords = {
    "if": A, "while": A, "else": B, "do": B, "try": B,
    "return": C, "break": C, "continue": C, "new": C, "throw": C,
    "var": kw("var"), "inline":attribute, "static": attribute, "using":kw("import"),
    "public": attribute, "private": attribute, "cast": kw("cast"), "import": kw("import"), "macro": kw("macro"),
    "function": kw("function"), "catch": kw("catch"), "untyped": kw("untyped"), "callback": kw("cb"),
    "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
    "in": operator, "never": kw("property_access"), "trace":kw("trace"),
    "class": type, "abstract":type, "enum":type, "interface":type, "typedef":type, "extends":type, "implements":type, "dynamic":type,
    "true": atom, "false": atom, "null": atom
  };

  var isOperatorChar = /[+\-*&%=<>!?|]/;

  function chain(stream, state, f) {
    state.tokenize = f;
    return f(stream, state);
  }

  function toUnescaped(stream, end) {
    var escaped = false, next;
    while ((next = stream.next()) != null) {
      if (next == end && !escaped)
        return true;
      escaped = !escaped && next == "\\";
    }
  }

  // Used as scratch variables to communicate multiple values without
  // consing up tons of objects.
  var type, content;
  function ret(tp, style, cont) {
    type = tp; content = cont;
    return style;
  }

  function haxeTokenBase(stream, state) {
    var ch = stream.next();
    if (ch == '"' || ch == "'") {
      return chain(stream, state, haxeTokenString(ch));
    } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
      return ret(ch);
    } else if (ch == "0" && stream.eat(/x/i)) {
      stream.eatWhile(/[\da-f]/i);
      return ret("number", "number");
    } else if (/\d/.test(ch) || ch == "-" && stream.eat(/\d/)) {
      stream.match(/^\d*(?:\.\d*(?!\.))?(?:[eE][+\-]?\d+)?/);
      return ret("number", "number");
    } else if (state.reAllowed && (ch == "~" && stream.eat(/\//))) {
      toUnescaped(stream, "/");
      stream.eatWhile(/[gimsu]/);
      return ret("regexp", "string-2");
    } else if (ch == "/") {
      if (stream.eat("*")) {
        return chain(stream, state, haxeTokenComment);
      } else if (stream.eat("/")) {
        stream.skipToEnd();
        return ret("comment", "comment");
      } else {
        stream.eatWhile(isOperatorChar);
        return ret("operator", null, stream.current());
      }
    } else if (ch == "#") {
        stream.skipToEnd();
        return ret("conditional", "meta");
    } else if (ch == "@") {
      stream.eat(/:/);
      stream.eatWhile(/[\w_]/);
      return ret ("metadata", "meta");
    } else if (isOperatorChar.test(ch)) {
      stream.eatWhile(isOperatorChar);
      return ret("operator", null, stream.current());
    } else {
      var word;
      if(/[A-Z]/.test(ch)) {
        stream.eatWhile(/[\w_<>]/);
        word = stream.current();
        return ret("type", "variable-3", word);
      } else {
        stream.eatWhile(/[\w_]/);
        var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];
        return (known && state.kwAllowed) ? ret(known.type, known.style, word) :
                       ret("variable", "variable", word);
      }
    }
  }

  function haxeTokenString(quote) {
    return function(stream, state) {
      if (toUnescaped(stream, quote))
        state.tokenize = haxeTokenBase;
      return ret("string", "string");
    };
  }

  function haxeTokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" && maybeEnd) {
        state.tokenize = haxeTokenBase;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return ret("comment", "comment");
  }

  // Parser

  var atomicTypes = {"atom": true, "number": true, "variable": true, "string": true, "regexp": true};

  function HaxeLexical(indented, column, type, align, prev, info) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.prev = prev;
    this.info = info;
    if (align != null) this.align = align;
  }

  function inScope(state, varname) {
    for (var v = state.localVars; v; v = v.next)
      if (v.name == varname) return true;
  }

  function parseHaxe(state, style, type, content, stream) {
    var cc = state.cc;
    // Communicate our context to the combinators.
    // (Less wasteful than consing up a hundred closures on every call.)
    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;

    if (!state.lexical.hasOwnProperty("align"))
      state.lexical.align = true;

    while(true) {
      var combinator = cc.length ? cc.pop() : statement;
      if (combinator(type, content)) {
        while(cc.length && cc[cc.length - 1].lex)
          cc.pop()();
        if (cx.marked) return cx.marked;
        if (type == "variable" && inScope(state, content)) return "variable-2";
        if (type == "variable" && imported(state, content)) return "variable-3";
        return style;
      }
    }
  }

  function imported(state, typename) {
    if (/[a-z]/.test(typename.charAt(0)))
      return false;
    var len = state.importedtypes.length;
    for (var i = 0; i<len; i++)
      if(state.importedtypes[i]==typename) return true;
  }

  function registerimport(importname) {
    var state = cx.state;
    for (var t = state.importedtypes; t; t = t.next)
      if(t.name == importname) return;
    state.importedtypes = { name: importname, next: state.importedtypes };
  }
  // Combinator utils

  var cx = {state: null, column: null, marked: null, cc: null};
  function pass() {
    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
  }
  function cont() {
    pass.apply(null, arguments);
    return true;
  }
  function inList(name, list) {
    for (var v = list; v; v = v.next)
      if (v.name == name) return true;
    return false;
  }
  function register(varname) {
    var state = cx.state;
    if (state.context) {
      cx.marked = "def";
      if (inList(varname, state.localVars)) return;
      state.localVars = {name: varname, next: state.localVars};
    } else if (state.globalVars) {
      if (inList(varname, state.globalVars)) return;
      state.globalVars = {name: varname, next: state.globalVars};
    }
  }

  // Combinators

  var defaultVars = {name: "this", next: null};
  function pushcontext() {
    if (!cx.state.context) cx.state.localVars = defaultVars;
    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};
  }
  function popcontext() {
    cx.state.localVars = cx.state.context.vars;
    cx.state.context = cx.state.context.prev;
  }
  popcontext.lex = true;
  function pushlex(type, info) {
    var result = function() {
      var state = cx.state;
      state.lexical = new HaxeLexical(state.indented, cx.stream.column(), type, null, state.lexical, info);
    };
    result.lex = true;
    return result;
  }
  function poplex() {
    var state = cx.state;
    if (state.lexical.prev) {
      if (state.lexical.type == ")")
        state.indented = state.lexical.indented;
      state.lexical = state.lexical.prev;
    }
  }
  poplex.lex = true;

  function expect(wanted) {
    function f(type) {
      if (type == wanted) return cont();
      else if (wanted == ";") return pass();
      else return cont(f);
    }
    return f;
  }

  function statement(type) {
    if (type == "@") return cont(metadef);
    if (type == "var") return cont(pushlex("vardef"), vardef1, expect(";"), poplex);
    if (type == "keyword a") return cont(pushlex("form"), expression, statement, poplex);
    if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
    if (type == "{") return cont(pushlex("}"), pushcontext, block, poplex, popcontext);
    if (type == ";") return cont();
    if (type == "attribute") return cont(maybeattribute);
    if (type == "function") return cont(functiondef);
    if (type == "for") return cont(pushlex("form"), expect("("), pushlex(")"), forspec1, expect(")"),
                                   poplex, statement, poplex);
    if (type == "variable") return cont(pushlex("stat"), maybelabel);
    if (type == "switch") return cont(pushlex("form"), expression, pushlex("}", "switch"), expect("{"),
                                      block, poplex, poplex);
    if (type == "case") return cont(expression, expect(":"));
    if (type == "default") return cont(expect(":"));
    if (type == "catch") return cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"),
                                     statement, poplex, popcontext);
    if (type == "import") return cont(importdef, expect(";"));
    if (type == "typedef") return cont(typedef);
    return pass(pushlex("stat"), expression, expect(";"), poplex);
  }
  function expression(type) {
    if (atomicTypes.hasOwnProperty(type)) return cont(maybeoperator);
    if (type == "type" ) return cont(maybeoperator);
    if (type == "function") return cont(functiondef);
    if (type == "keyword c") return cont(maybeexpression);
    if (type == "(") return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeoperator);
    if (type == "operator") return cont(expression);
    if (type == "[") return cont(pushlex("]"), commasep(maybeexpression, "]"), poplex, maybeoperator);
    if (type == "{") return cont(pushlex("}"), commasep(objprop, "}"), poplex, maybeoperator);
    return cont();
  }
  function maybeexpression(type) {
    if (type.match(/[;\}\)\],]/)) return pass();
    return pass(expression);
  }

  function maybeoperator(type, value) {
    if (type == "operator" && /\+\+|--/.test(value)) return cont(maybeoperator);
    if (type == "operator" || type == ":") return cont(expression);
    if (type == ";") return;
    if (type == "(") return cont(pushlex(")"), commasep(expression, ")"), poplex, maybeoperator);
    if (type == ".") return cont(property, maybeoperator);
    if (type == "[") return cont(pushlex("]"), expression, expect("]"), poplex, maybeoperator);
  }

  function maybeattribute(type) {
    if (type == "attribute") return cont(maybeattribute);
    if (type == "function") return cont(functiondef);
    if (type == "var") return cont(vardef1);
  }

  function metadef(type) {
    if(type == ":") return cont(metadef);
    if(type == "variable") return cont(metadef);
    if(type == "(") return cont(pushlex(")"), commasep(metaargs, ")"), poplex, statement);
  }
  function metaargs(type) {
    if(type == "variable") return cont();
  }

  function importdef (type, value) {
    if(type == "variable" && /[A-Z]/.test(value.charAt(0))) { registerimport(value); return cont(); }
    else if(type == "variable" || type == "property" || type == "." || value == "*") return cont(importdef);
  }

  function typedef (type, value)
  {
    if(type == "variable" && /[A-Z]/.test(value.charAt(0))) { registerimport(value); return cont(); }
    else if (type == "type" && /[A-Z]/.test(value.charAt(0))) { return cont(); }
  }

  function maybelabel(type) {
    if (type == ":") return cont(poplex, statement);
    return pass(maybeoperator, expect(";"), poplex);
  }
  function property(type) {
    if (type == "variable") {cx.marked = "property"; return cont();}
  }
  function objprop(type) {
    if (type == "variable") cx.marked = "property";
    if (atomicTypes.hasOwnProperty(type)) return cont(expect(":"), expression);
  }
  function commasep(what, end) {
    function proceed(type) {
      if (type == ",") return cont(what, proceed);
      if (type == end) return cont();
      return cont(expect(end));
    }
    return function(type) {
      if (type == end) return cont();
      else return pass(what, proceed);
    };
  }
  function block(type) {
    if (type == "}") return cont();
    return pass(statement, block);
  }
  function vardef1(type, value) {
    if (type == "variable"){register(value); return cont(typeuse, vardef2);}
    return cont();
  }
  function vardef2(type, value) {
    if (value == "=") return cont(expression, vardef2);
    if (type == ",") return cont(vardef1);
  }
  function forspec1(type, value) {
    if (type == "variable") {
      register(value);
      return cont(forin, expression)
    } else {
      return pass()
    }
  }
  function forin(_type, value) {
    if (value == "in") return cont();
  }
  function functiondef(type, value) {
    //function names starting with upper-case letters are recognised as types, so cludging them together here.
    if (type == "variable" || type == "type") {register(value); return cont(functiondef);}
    if (value == "new") return cont(functiondef);
    if (type == "(") return cont(pushlex(")"), pushcontext, commasep(funarg, ")"), poplex, typeuse, statement, popcontext);
  }
  function typeuse(type) {
    if(type == ":") return cont(typestring);
  }
  function typestring(type) {
    if(type == "type") return cont();
    if(type == "variable") return cont();
    if(type == "{") return cont(pushlex("}"), commasep(typeprop, "}"), poplex);
  }
  function typeprop(type) {
    if(type == "variable") return cont(typeuse);
  }
  function funarg(type, value) {
    if (type == "variable") {register(value); return cont(typeuse);}
  }

  // Interface
  return {
    startState: function(basecolumn) {
      var defaulttypes = ["Int", "Float", "String", "Void", "Std", "Bool", "Dynamic", "Array"];
      var state = {
        tokenize: haxeTokenBase,
        reAllowed: true,
        kwAllowed: true,
        cc: [],
        lexical: new HaxeLexical((basecolumn || 0) - indentUnit, 0, "block", false),
        localVars: parserConfig.localVars,
        importedtypes: defaulttypes,
        context: parserConfig.localVars && {vars: parserConfig.localVars},
        indented: 0
      };
      if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
        state.globalVars = parserConfig.globalVars;
      return state;
    },

    token: function(stream, state) {
      if (stream.sol()) {
        if (!state.lexical.hasOwnProperty("align"))
          state.lexical.align = false;
        state.indented = stream.indentation();
      }
      if (stream.eatSpace()) return null;
      var style = state.tokenize(stream, state);
      if (type == "comment") return style;
      state.reAllowed = !!(type == "operator" || type == "keyword c" || type.match(/^[\[{}\(,;:]$/));
      state.kwAllowed = type != '.';
      return parseHaxe(state, style, type, content, stream);
    },

    indent: function(state, textAfter) {
      if (state.tokenize != haxeTokenBase) return 0;
      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;
      if (lexical.type == "stat" && firstChar == "}") lexical = lexical.prev;
      var type = lexical.type, closing = firstChar == type;
      if (type == "vardef") return lexical.indented + 4;
      else if (type == "form" && firstChar == "{") return lexical.indented;
      else if (type == "stat" || type == "form") return lexical.indented + indentUnit;
      else if (lexical.info == "switch" && !closing)
        return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
      else if (lexical.align) return lexical.column + (closing ? 0 : 1);
      else return lexical.indented + (closing ? 0 : indentUnit);
    },

    electricChars: "{}",
    blockCommentStart: "/*",
    blockCommentEnd: "*/",
    lineComment: "//"
  };
});

CodeMirror.defineMIME("text/x-haxe", "haxe");

CodeMirror.defineMode("hxml", function () {

  return {
    startState: function () {
      return {
        define: false,
        inString: false
      };
    },
    token: function (stream, state) {
      var ch = stream.peek();
      var sol = stream.sol();

      ///* comments */
      if (ch == "#") {
        stream.skipToEnd();
        return "comment";
      }
      if (sol && ch == "-") {
        var style = "variable-2";

        stream.eat(/-/);

        if (stream.peek() == "-") {
          stream.eat(/-/);
          style = "keyword a";
        }

        if (stream.peek() == "D") {
          stream.eat(/[D]/);
          style = "keyword c";
          state.define = true;
        }

        stream.eatWhile(/[A-Z]/i);
        return style;
      }

      var ch = stream.peek();

      if (state.inString == false && ch == "'") {
        state.inString = true;
        stream.next();
      }

      if (state.inString == true) {
        if (stream.skipTo("'")) {

        } else {
          stream.skipToEnd();
        }

        if (stream.peek() == "'") {
          stream.next();
          state.inString = false;
        }

        return "string";
      }

      stream.next();
      return null;
    },
    lineComment: "#"
  };
});

CodeMirror.defineMIME("text/x-hxml", "hxml");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/htmlembedded/htmlembedded.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"), __webpack_require__("./src/ipywidgets/node_modules/codemirror/mode/htmlmixed/htmlmixed.js"),
        __webpack_require__("./src/ipywidgets/node_modules/codemirror/addon/mode/multiplex.js"));
  else {}
})(function(CodeMirror) {
  "use strict";

  CodeMirror.defineMode("htmlembedded", function(config, parserConfig) {
    var closeComment = parserConfig.closeComment || "--%>"
    return CodeMirror.multiplexingMode(CodeMirror.getMode(config, "htmlmixed"), {
      open: parserConfig.openComment || "<%--",
      close: closeComment,
      delimStyle: "comment",
      mode: {token: function(stream) {
        stream.skipTo(closeComment) || stream.skipToEnd()
        return "comment"
      }}
    }, {
      open: parserConfig.open || parserConfig.scriptStartRegex || "<%",
      close: parserConfig.close || parserConfig.scriptEndRegex || "%>",
      mode: CodeMirror.getMode(config, parserConfig.scriptingModeSpec)
    });
  }, "htmlmixed");

  CodeMirror.defineMIME("application/x-ejs", {name: "htmlembedded", scriptingModeSpec:"javascript"});
  CodeMirror.defineMIME("application/x-aspx", {name: "htmlembedded", scriptingModeSpec:"text/x-csharp"});
  CodeMirror.defineMIME("application/x-jsp", {name: "htmlembedded", scriptingModeSpec:"text/x-java"});
  CodeMirror.defineMIME("application/x-erb", {name: "htmlembedded", scriptingModeSpec:"ruby"});
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/htmlmixed/htmlmixed.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"), __webpack_require__("./src/ipywidgets/node_modules/codemirror/mode/xml/xml.js"), __webpack_require__("./src/ipywidgets/node_modules/codemirror/mode/javascript/javascript.js"), __webpack_require__("./src/ipywidgets/node_modules/codemirror/mode/css/css.js"));
  else {}
})(function(CodeMirror) {
  "use strict";

  var defaultTags = {
    script: [
      ["lang", /(javascript|babel)/i, "javascript"],
      ["type", /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i, "javascript"],
      ["type", /./, "text/plain"],
      [null, null, "javascript"]
    ],
    style:  [
      ["lang", /^css$/i, "css"],
      ["type", /^(text\/)?(x-)?(stylesheet|css)$/i, "css"],
      ["type", /./, "text/plain"],
      [null, null, "css"]
    ]
  };

  function maybeBackup(stream, pat, style) {
    var cur = stream.current(), close = cur.search(pat);
    if (close > -1) {
      stream.backUp(cur.length - close);
    } else if (cur.match(/<\/?$/)) {
      stream.backUp(cur.length);
      if (!stream.match(pat, false)) stream.match(cur);
    }
    return style;
  }

  var attrRegexpCache = {};
  function getAttrRegexp(attr) {
    var regexp = attrRegexpCache[attr];
    if (regexp) return regexp;
    return attrRegexpCache[attr] = new RegExp("\\s+" + attr + "\\s*=\\s*('|\")?([^'\"]+)('|\")?\\s*");
  }

  function getAttrValue(text, attr) {
    var match = text.match(getAttrRegexp(attr))
    return match ? /^\s*(.*?)\s*$/.exec(match[2])[1] : ""
  }

  function getTagRegexp(tagName, anchored) {
    return new RegExp((anchored ? "^" : "") + "<\/\s*" + tagName + "\s*>", "i");
  }

  function addTags(from, to) {
    for (var tag in from) {
      var dest = to[tag] || (to[tag] = []);
      var source = from[tag];
      for (var i = source.length - 1; i >= 0; i--)
        dest.unshift(source[i])
    }
  }

  function findMatchingMode(tagInfo, tagText) {
    for (var i = 0; i < tagInfo.length; i++) {
      var spec = tagInfo[i];
      if (!spec[0] || spec[1].test(getAttrValue(tagText, spec[0]))) return spec[2];
    }
  }

  CodeMirror.defineMode("htmlmixed", function (config, parserConfig) {
    var htmlMode = CodeMirror.getMode(config, {
      name: "xml",
      htmlMode: true,
      multilineTagIndentFactor: parserConfig.multilineTagIndentFactor,
      multilineTagIndentPastTag: parserConfig.multilineTagIndentPastTag,
      allowMissingTagName: parserConfig.allowMissingTagName,
    });

    var tags = {};
    var configTags = parserConfig && parserConfig.tags, configScript = parserConfig && parserConfig.scriptTypes;
    addTags(defaultTags, tags);
    if (configTags) addTags(configTags, tags);
    if (configScript) for (var i = configScript.length - 1; i >= 0; i--)
      tags.script.unshift(["type", configScript[i].matches, configScript[i].mode])

    function html(stream, state) {
      var style = htmlMode.token(stream, state.htmlState), tag = /\btag\b/.test(style), tagName
      if (tag && !/[<>\s\/]/.test(stream.current()) &&
          (tagName = state.htmlState.tagName && state.htmlState.tagName.toLowerCase()) &&
          tags.hasOwnProperty(tagName)) {
        state.inTag = tagName + " "
      } else if (state.inTag && tag && />$/.test(stream.current())) {
        var inTag = /^([\S]+) (.*)/.exec(state.inTag)
        state.inTag = null
        var modeSpec = stream.current() == ">" && findMatchingMode(tags[inTag[1]], inTag[2])
        var mode = CodeMirror.getMode(config, modeSpec)
        var endTagA = getTagRegexp(inTag[1], true), endTag = getTagRegexp(inTag[1], false);
        state.token = function (stream, state) {
          if (stream.match(endTagA, false)) {
            state.token = html;
            state.localState = state.localMode = null;
            return null;
          }
          return maybeBackup(stream, endTag, state.localMode.token(stream, state.localState));
        };
        state.localMode = mode;
        state.localState = CodeMirror.startState(mode, htmlMode.indent(state.htmlState, "", ""));
      } else if (state.inTag) {
        state.inTag += stream.current()
        if (stream.eol()) state.inTag += " "
      }
      return style;
    };

    return {
      startState: function () {
        var state = CodeMirror.startState(htmlMode);
        return {token: html, inTag: null, localMode: null, localState: null, htmlState: state};
      },

      copyState: function (state) {
        var local;
        if (state.localState) {
          local = CodeMirror.copyState(state.localMode, state.localState);
        }
        return {token: state.token, inTag: state.inTag,
                localMode: state.localMode, localState: local,
                htmlState: CodeMirror.copyState(htmlMode, state.htmlState)};
      },

      token: function (stream, state) {
        return state.token(stream, state);
      },

      indent: function (state, textAfter, line) {
        if (!state.localMode || /^\s*<\//.test(textAfter))
          return htmlMode.indent(state.htmlState, textAfter, line);
        else if (state.localMode.indent)
          return state.localMode.indent(state.localState, textAfter, line);
        else
          return CodeMirror.Pass;
      },

      innerMode: function (state) {
        return {state: state.localState || state.htmlState, mode: state.localMode || htmlMode};
      }
    };
  }, "xml", "javascript", "css");

  CodeMirror.defineMIME("text/html", "htmlmixed");
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/http/http.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("http", function() {
  function failFirstLine(stream, state) {
    stream.skipToEnd();
    state.cur = header;
    return "error";
  }

  function start(stream, state) {
    if (stream.match(/^HTTP\/\d\.\d/)) {
      state.cur = responseStatusCode;
      return "keyword";
    } else if (stream.match(/^[A-Z]+/) && /[ \t]/.test(stream.peek())) {
      state.cur = requestPath;
      return "keyword";
    } else {
      return failFirstLine(stream, state);
    }
  }

  function responseStatusCode(stream, state) {
    var code = stream.match(/^\d+/);
    if (!code) return failFirstLine(stream, state);

    state.cur = responseStatusText;
    var status = Number(code[0]);
    if (status >= 100 && status < 200) {
      return "positive informational";
    } else if (status >= 200 && status < 300) {
      return "positive success";
    } else if (status >= 300 && status < 400) {
      return "positive redirect";
    } else if (status >= 400 && status < 500) {
      return "negative client-error";
    } else if (status >= 500 && status < 600) {
      return "negative server-error";
    } else {
      return "error";
    }
  }

  function responseStatusText(stream, state) {
    stream.skipToEnd();
    state.cur = header;
    return null;
  }

  function requestPath(stream, state) {
    stream.eatWhile(/\S/);
    state.cur = requestProtocol;
    return "string-2";
  }

  function requestProtocol(stream, state) {
    if (stream.match(/^HTTP\/\d\.\d$/)) {
      state.cur = header;
      return "keyword";
    } else {
      return failFirstLine(stream, state);
    }
  }

  function header(stream) {
    if (stream.sol() && !stream.eat(/[ \t]/)) {
      if (stream.match(/^.*?:/)) {
        return "atom";
      } else {
        stream.skipToEnd();
        return "error";
      }
    } else {
      stream.skipToEnd();
      return "string";
    }
  }

  function body(stream) {
    stream.skipToEnd();
    return null;
  }

  return {
    token: function(stream, state) {
      var cur = state.cur;
      if (cur != header && cur != body && stream.eatSpace()) return null;
      return cur(stream, state);
    },

    blankLine: function(state) {
      state.cur = body;
    },

    startState: function() {
      return {cur: start};
    }
  };
});

CodeMirror.defineMIME("message/http", "http");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/idl/idl.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
  "use strict";

  function wordRegexp(words) {
    return new RegExp('^((' + words.join(')|(') + '))\\b', 'i');
  };

  var builtinArray = [
    'a_correlate', 'abs', 'acos', 'adapt_hist_equal', 'alog',
    'alog2', 'alog10', 'amoeba', 'annotate', 'app_user_dir',
    'app_user_dir_query', 'arg_present', 'array_equal', 'array_indices',
    'arrow', 'ascii_template', 'asin', 'assoc', 'atan',
    'axis', 'axis', 'bandpass_filter', 'bandreject_filter', 'barplot',
    'bar_plot', 'beseli', 'beselj', 'beselk', 'besely',
    'beta', 'biginteger', 'bilinear', 'bin_date', 'binary_template',
    'bindgen', 'binomial', 'bit_ffs', 'bit_population', 'blas_axpy',
    'blk_con', 'boolarr', 'boolean', 'boxplot', 'box_cursor',
    'breakpoint', 'broyden', 'bubbleplot', 'butterworth', 'bytarr',
    'byte', 'byteorder', 'bytscl', 'c_correlate', 'calendar',
    'caldat', 'call_external', 'call_function', 'call_method',
    'call_procedure', 'canny', 'catch', 'cd', 'cdf', 'ceil',
    'chebyshev', 'check_math', 'chisqr_cvf', 'chisqr_pdf', 'choldc',
    'cholsol', 'cindgen', 'cir_3pnt', 'clipboard', 'close',
    'clust_wts', 'cluster', 'cluster_tree', 'cmyk_convert', 'code_coverage',
    'color_convert', 'color_exchange', 'color_quan', 'color_range_map',
    'colorbar', 'colorize_sample', 'colormap_applicable',
    'colormap_gradient', 'colormap_rotation', 'colortable',
    'comfit', 'command_line_args', 'common', 'compile_opt', 'complex',
    'complexarr', 'complexround', 'compute_mesh_normals', 'cond', 'congrid',
    'conj', 'constrained_min', 'contour', 'contour', 'convert_coord',
    'convol', 'convol_fft', 'coord2to3', 'copy_lun', 'correlate',
    'cos', 'cosh', 'cpu', 'cramer', 'createboxplotdata',
    'create_cursor', 'create_struct', 'create_view', 'crossp', 'crvlength',
    'ct_luminance', 'cti_test', 'cursor', 'curvefit', 'cv_coord',
    'cvttobm', 'cw_animate', 'cw_animate_getp', 'cw_animate_load',
    'cw_animate_run', 'cw_arcball', 'cw_bgroup', 'cw_clr_index',
    'cw_colorsel', 'cw_defroi', 'cw_field', 'cw_filesel', 'cw_form',
    'cw_fslider', 'cw_light_editor', 'cw_light_editor_get',
    'cw_light_editor_set', 'cw_orient', 'cw_palette_editor',
    'cw_palette_editor_get', 'cw_palette_editor_set', 'cw_pdmenu',
    'cw_rgbslider', 'cw_tmpl', 'cw_zoom', 'db_exists',
    'dblarr', 'dcindgen', 'dcomplex', 'dcomplexarr', 'define_key',
    'define_msgblk', 'define_msgblk_from_file', 'defroi', 'defsysv',
    'delvar', 'dendro_plot', 'dendrogram', 'deriv', 'derivsig',
    'determ', 'device', 'dfpmin', 'diag_matrix', 'dialog_dbconnect',
    'dialog_message', 'dialog_pickfile', 'dialog_printersetup',
    'dialog_printjob', 'dialog_read_image',
    'dialog_write_image', 'dictionary', 'digital_filter', 'dilate', 'dindgen',
    'dissolve', 'dist', 'distance_measure', 'dlm_load', 'dlm_register',
    'doc_library', 'double', 'draw_roi', 'edge_dog', 'efont',
    'eigenql', 'eigenvec', 'ellipse', 'elmhes', 'emboss',
    'empty', 'enable_sysrtn', 'eof', 'eos', 'erase',
    'erf', 'erfc', 'erfcx', 'erode', 'errorplot',
    'errplot', 'estimator_filter', 'execute', 'exit', 'exp',
    'expand', 'expand_path', 'expint', 'extract', 'extract_slice',
    'f_cvf', 'f_pdf', 'factorial', 'fft', 'file_basename',
    'file_chmod', 'file_copy', 'file_delete', 'file_dirname',
    'file_expand_path', 'file_gunzip', 'file_gzip', 'file_info',
    'file_lines', 'file_link', 'file_mkdir', 'file_move',
    'file_poll_input', 'file_readlink', 'file_same',
    'file_search', 'file_tar', 'file_test', 'file_untar', 'file_unzip',
    'file_which', 'file_zip', 'filepath', 'findgen', 'finite',
    'fix', 'flick', 'float', 'floor', 'flow3',
    'fltarr', 'flush', 'format_axis_values', 'forward_function', 'free_lun',
    'fstat', 'fulstr', 'funct', 'function', 'fv_test',
    'fx_root', 'fz_roots', 'gamma', 'gamma_ct', 'gauss_cvf',
    'gauss_pdf', 'gauss_smooth', 'gauss2dfit', 'gaussfit',
    'gaussian_function', 'gaussint', 'get_drive_list', 'get_dxf_objects',
    'get_kbrd', 'get_login_info',
    'get_lun', 'get_screen_size', 'getenv', 'getwindows', 'greg2jul',
    'grib', 'grid_input', 'grid_tps', 'grid3', 'griddata',
    'gs_iter', 'h_eq_ct', 'h_eq_int', 'hanning', 'hash',
    'hdf', 'hdf5', 'heap_free', 'heap_gc', 'heap_nosave',
    'heap_refcount', 'heap_save', 'help', 'hilbert', 'hist_2d',
    'hist_equal', 'histogram', 'hls', 'hough', 'hqr',
    'hsv', 'i18n_multibytetoutf8',
    'i18n_multibytetowidechar', 'i18n_utf8tomultibyte',
    'i18n_widechartomultibyte',
    'ibeta', 'icontour', 'iconvertcoord', 'idelete', 'identity',
    'idl_base64', 'idl_container', 'idl_validname',
    'idlexbr_assistant', 'idlitsys_createtool',
    'idlunit', 'iellipse', 'igamma', 'igetcurrent', 'igetdata',
    'igetid', 'igetproperty', 'iimage', 'image', 'image_cont',
    'image_statistics', 'image_threshold', 'imaginary', 'imap', 'indgen',
    'int_2d', 'int_3d', 'int_tabulated', 'intarr', 'interpol',
    'interpolate', 'interval_volume', 'invert', 'ioctl', 'iopen',
    'ir_filter', 'iplot', 'ipolygon', 'ipolyline', 'iputdata',
    'iregister', 'ireset', 'iresolve', 'irotate', 'isa',
    'isave', 'iscale', 'isetcurrent', 'isetproperty', 'ishft',
    'isocontour', 'isosurface', 'isurface', 'itext', 'itranslate',
    'ivector', 'ivolume', 'izoom', 'journal', 'json_parse',
    'json_serialize', 'jul2greg', 'julday', 'keyword_set', 'krig2d',
    'kurtosis', 'kw_test', 'l64indgen', 'la_choldc', 'la_cholmprove',
    'la_cholsol', 'la_determ', 'la_eigenproblem', 'la_eigenql', 'la_eigenvec',
    'la_elmhes', 'la_gm_linear_model', 'la_hqr', 'la_invert',
    'la_least_square_equality', 'la_least_squares', 'la_linear_equation',
    'la_ludc', 'la_lumprove', 'la_lusol',
    'la_svd', 'la_tridc', 'la_trimprove', 'la_triql', 'la_trired',
    'la_trisol', 'label_date', 'label_region', 'ladfit', 'laguerre',
    'lambda', 'lambdap', 'lambertw', 'laplacian', 'least_squares_filter',
    'leefilt', 'legend', 'legendre', 'linbcg', 'lindgen',
    'linfit', 'linkimage', 'list', 'll_arc_distance', 'lmfit',
    'lmgr', 'lngamma', 'lnp_test', 'loadct', 'locale_get',
    'logical_and', 'logical_or', 'logical_true', 'lon64arr', 'lonarr',
    'long', 'long64', 'lsode', 'lu_complex', 'ludc',
    'lumprove', 'lusol', 'm_correlate', 'machar', 'make_array',
    'make_dll', 'make_rt', 'map', 'mapcontinents', 'mapgrid',
    'map_2points', 'map_continents', 'map_grid', 'map_image', 'map_patch',
    'map_proj_forward', 'map_proj_image', 'map_proj_info',
    'map_proj_init', 'map_proj_inverse',
    'map_set', 'matrix_multiply', 'matrix_power', 'max', 'md_test',
    'mean', 'meanabsdev', 'mean_filter', 'median', 'memory',
    'mesh_clip', 'mesh_decimate', 'mesh_issolid',
    'mesh_merge', 'mesh_numtriangles',
    'mesh_obj', 'mesh_smooth', 'mesh_surfacearea',
    'mesh_validate', 'mesh_volume',
    'message', 'min', 'min_curve_surf', 'mk_html_help', 'modifyct',
    'moment', 'morph_close', 'morph_distance',
    'morph_gradient', 'morph_hitormiss',
    'morph_open', 'morph_thin', 'morph_tophat', 'multi', 'n_elements',
    'n_params', 'n_tags', 'ncdf', 'newton', 'noise_hurl',
    'noise_pick', 'noise_scatter', 'noise_slur', 'norm', 'obj_class',
    'obj_destroy', 'obj_hasmethod', 'obj_isa', 'obj_new', 'obj_valid',
    'objarr', 'on_error', 'on_ioerror', 'online_help', 'openr',
    'openu', 'openw', 'oplot', 'oploterr', 'orderedhash',
    'p_correlate', 'parse_url', 'particle_trace', 'path_cache', 'path_sep',
    'pcomp', 'plot', 'plot3d', 'plot', 'plot_3dbox',
    'plot_field', 'ploterr', 'plots', 'polar_contour', 'polar_surface',
    'polyfill', 'polyshade', 'pnt_line', 'point_lun', 'polarplot',
    'poly', 'poly_2d', 'poly_area', 'poly_fit', 'polyfillv',
    'polygon', 'polyline', 'polywarp', 'popd', 'powell',
    'pref_commit', 'pref_get', 'pref_set', 'prewitt', 'primes',
    'print', 'printf', 'printd', 'pro', 'product',
    'profile', 'profiler', 'profiles', 'project_vol', 'ps_show_fonts',
    'psafm', 'pseudo', 'ptr_free', 'ptr_new', 'ptr_valid',
    'ptrarr', 'pushd', 'qgrid3', 'qhull', 'qromb',
    'qromo', 'qsimp', 'query_*', 'query_ascii', 'query_bmp',
    'query_csv', 'query_dicom', 'query_gif', 'query_image', 'query_jpeg',
    'query_jpeg2000', 'query_mrsid', 'query_pict', 'query_png', 'query_ppm',
    'query_srf', 'query_tiff', 'query_video', 'query_wav', 'r_correlate',
    'r_test', 'radon', 'randomn', 'randomu', 'ranks',
    'rdpix', 'read', 'readf', 'read_ascii', 'read_binary',
    'read_bmp', 'read_csv', 'read_dicom', 'read_gif', 'read_image',
    'read_interfile', 'read_jpeg', 'read_jpeg2000', 'read_mrsid', 'read_pict',
    'read_png', 'read_ppm', 'read_spr', 'read_srf', 'read_sylk',
    'read_tiff', 'read_video', 'read_wav', 'read_wave', 'read_x11_bitmap',
    'read_xwd', 'reads', 'readu', 'real_part', 'rebin',
    'recall_commands', 'recon3', 'reduce_colors', 'reform', 'region_grow',
    'register_cursor', 'regress', 'replicate',
    'replicate_inplace', 'resolve_all',
    'resolve_routine', 'restore', 'retall', 'return', 'reverse',
    'rk4', 'roberts', 'rot', 'rotate', 'round',
    'routine_filepath', 'routine_info', 'rs_test', 's_test', 'save',
    'savgol', 'scale3', 'scale3d', 'scatterplot', 'scatterplot3d',
    'scope_level', 'scope_traceback', 'scope_varfetch',
    'scope_varname', 'search2d',
    'search3d', 'sem_create', 'sem_delete', 'sem_lock', 'sem_release',
    'set_plot', 'set_shading', 'setenv', 'sfit', 'shade_surf',
    'shade_surf_irr', 'shade_volume', 'shift', 'shift_diff', 'shmdebug',
    'shmmap', 'shmunmap', 'shmvar', 'show3', 'showfont',
    'signum', 'simplex', 'sin', 'sindgen', 'sinh',
    'size', 'skewness', 'skip_lun', 'slicer3', 'slide_image',
    'smooth', 'sobel', 'socket', 'sort', 'spawn',
    'sph_4pnt', 'sph_scat', 'spher_harm', 'spl_init', 'spl_interp',
    'spline', 'spline_p', 'sprsab', 'sprsax', 'sprsin',
    'sprstp', 'sqrt', 'standardize', 'stddev', 'stop',
    'strarr', 'strcmp', 'strcompress', 'streamline', 'streamline',
    'stregex', 'stretch', 'string', 'strjoin', 'strlen',
    'strlowcase', 'strmatch', 'strmessage', 'strmid', 'strpos',
    'strput', 'strsplit', 'strtrim', 'struct_assign', 'struct_hide',
    'strupcase', 'surface', 'surface', 'surfr', 'svdc',
    'svdfit', 'svsol', 'swap_endian', 'swap_endian_inplace', 'symbol',
    'systime', 't_cvf', 't_pdf', 't3d', 'tag_names',
    'tan', 'tanh', 'tek_color', 'temporary', 'terminal_size',
    'tetra_clip', 'tetra_surface', 'tetra_volume', 'text', 'thin',
    'thread', 'threed', 'tic', 'time_test2', 'timegen',
    'timer', 'timestamp', 'timestamptovalues', 'tm_test', 'toc',
    'total', 'trace', 'transpose', 'tri_surf', 'triangulate',
    'trigrid', 'triql', 'trired', 'trisol', 'truncate_lun',
    'ts_coef', 'ts_diff', 'ts_fcast', 'ts_smooth', 'tv',
    'tvcrs', 'tvlct', 'tvrd', 'tvscl', 'typename',
    'uindgen', 'uint', 'uintarr', 'ul64indgen', 'ulindgen',
    'ulon64arr', 'ulonarr', 'ulong', 'ulong64', 'uniq',
    'unsharp_mask', 'usersym', 'value_locate', 'variance', 'vector',
    'vector_field', 'vel', 'velovect', 'vert_t3d', 'voigt',
    'volume', 'voronoi', 'voxel_proj', 'wait', 'warp_tri',
    'watershed', 'wdelete', 'wf_draw', 'where', 'widget_base',
    'widget_button', 'widget_combobox', 'widget_control',
    'widget_displaycontextmenu', 'widget_draw',
    'widget_droplist', 'widget_event', 'widget_info',
    'widget_label', 'widget_list',
    'widget_propertysheet', 'widget_slider', 'widget_tab',
    'widget_table', 'widget_text',
    'widget_tree', 'widget_tree_move', 'widget_window',
    'wiener_filter', 'window',
    'window', 'write_bmp', 'write_csv', 'write_gif', 'write_image',
    'write_jpeg', 'write_jpeg2000', 'write_nrif', 'write_pict', 'write_png',
    'write_ppm', 'write_spr', 'write_srf', 'write_sylk', 'write_tiff',
    'write_video', 'write_wav', 'write_wave', 'writeu', 'wset',
    'wshow', 'wtn', 'wv_applet', 'wv_cwt', 'wv_cw_wavelet',
    'wv_denoise', 'wv_dwt', 'wv_fn_coiflet',
    'wv_fn_daubechies', 'wv_fn_gaussian',
    'wv_fn_haar', 'wv_fn_morlet', 'wv_fn_paul',
    'wv_fn_symlet', 'wv_import_data',
    'wv_import_wavelet', 'wv_plot3d_wps', 'wv_plot_multires',
    'wv_pwt', 'wv_tool_denoise',
    'xbm_edit', 'xdisplayfile', 'xdxf', 'xfont', 'xinteranimate',
    'xloadct', 'xmanager', 'xmng_tmpl', 'xmtool', 'xobjview',
    'xobjview_rotate', 'xobjview_write_image',
    'xpalette', 'xpcolor', 'xplot3d',
    'xregistered', 'xroi', 'xsq_test', 'xsurface', 'xvaredit',
    'xvolume', 'xvolume_rotate', 'xvolume_write_image',
    'xyouts', 'zlib_compress', 'zlib_uncompress', 'zoom', 'zoom_24'
  ];
  var builtins = wordRegexp(builtinArray);

  var keywordArray = [
    'begin', 'end', 'endcase', 'endfor',
    'endwhile', 'endif', 'endrep', 'endforeach',
    'break', 'case', 'continue', 'for',
    'foreach', 'goto', 'if', 'then', 'else',
    'repeat', 'until', 'switch', 'while',
    'do', 'pro', 'function'
  ];
  var keywords = wordRegexp(keywordArray);

  CodeMirror.registerHelper("hintWords", "idl", builtinArray.concat(keywordArray));

  var identifiers = new RegExp('^[_a-z\xa1-\uffff][_a-z0-9\xa1-\uffff]*', 'i');

  var singleOperators = /[+\-*&=<>\/@#~$]/;
  var boolOperators = new RegExp('(and|or|eq|lt|le|gt|ge|ne|not)', 'i');

  function tokenBase(stream) {
    // whitespaces
    if (stream.eatSpace()) return null;

    // Handle one line Comments
    if (stream.match(';')) {
      stream.skipToEnd();
      return 'comment';
    }

    // Handle Number Literals
    if (stream.match(/^[0-9\.+-]/, false)) {
      if (stream.match(/^[+-]?0x[0-9a-fA-F]+/))
        return 'number';
      if (stream.match(/^[+-]?\d*\.\d+([EeDd][+-]?\d+)?/))
        return 'number';
      if (stream.match(/^[+-]?\d+([EeDd][+-]?\d+)?/))
        return 'number';
    }

    // Handle Strings
    if (stream.match(/^"([^"]|(""))*"/)) { return 'string'; }
    if (stream.match(/^'([^']|(''))*'/)) { return 'string'; }

    // Handle words
    if (stream.match(keywords)) { return 'keyword'; }
    if (stream.match(builtins)) { return 'builtin'; }
    if (stream.match(identifiers)) { return 'variable'; }

    if (stream.match(singleOperators) || stream.match(boolOperators)) {
      return 'operator'; }

    // Handle non-detected items
    stream.next();
    return null;
  };

  CodeMirror.defineMode('idl', function() {
    return {
      token: function(stream) {
        return tokenBase(stream);
      }
    };
  });

  CodeMirror.defineMIME('text/x-idl', 'idl');
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/jinja2/jinja2.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
  "use strict";

  CodeMirror.defineMode("jinja2", function() {
    var keywords = ["and", "as", "block", "endblock", "by", "cycle", "debug", "else", "elif",
      "extends", "filter", "endfilter", "firstof", "for",
      "endfor", "if", "endif", "ifchanged", "endifchanged",
      "ifequal", "endifequal", "ifnotequal",
      "endifnotequal", "in", "include", "load", "not", "now", "or",
      "parsed", "regroup", "reversed", "spaceless",
      "endspaceless", "ssi", "templatetag", "openblock",
      "closeblock", "openvariable", "closevariable",
      "openbrace", "closebrace", "opencomment",
      "closecomment", "widthratio", "url", "with", "endwith",
      "get_current_language", "trans", "endtrans", "noop", "blocktrans",
      "endblocktrans", "get_available_languages",
      "get_current_language_bidi", "plural"],
    operator = /^[+\-*&%=<>!?|~^]/,
    sign = /^[:\[\(\{]/,
    atom = ["true", "false"],
    number = /^(\d[+\-\*\/])?\d+(\.\d+)?/;

    keywords = new RegExp("((" + keywords.join(")|(") + "))\\b");
    atom = new RegExp("((" + atom.join(")|(") + "))\\b");

    function tokenBase (stream, state) {
      var ch = stream.peek();

      //Comment
      if (state.incomment) {
        if(!stream.skipTo("#}")) {
          stream.skipToEnd();
        } else {
          stream.eatWhile(/\#|}/);
          state.incomment = false;
        }
        return "comment";
      //Tag
      } else if (state.intag) {
        //After operator
        if(state.operator) {
          state.operator = false;
          if(stream.match(atom)) {
            return "atom";
          }
          if(stream.match(number)) {
            return "number";
          }
        }
        //After sign
        if(state.sign) {
          state.sign = false;
          if(stream.match(atom)) {
            return "atom";
          }
          if(stream.match(number)) {
            return "number";
          }
        }

        if(state.instring) {
          if(ch == state.instring) {
            state.instring = false;
          }
          stream.next();
          return "string";
        } else if(ch == "'" || ch == '"') {
          state.instring = ch;
          stream.next();
          return "string";
        } else if(stream.match(state.intag + "}") || stream.eat("-") && stream.match(state.intag + "}")) {
          state.intag = false;
          return "tag";
        } else if(stream.match(operator)) {
          state.operator = true;
          return "operator";
        } else if(stream.match(sign)) {
          state.sign = true;
        } else {
          if(stream.eat(" ") || stream.sol()) {
            if(stream.match(keywords)) {
              return "keyword";
            }
            if(stream.match(atom)) {
              return "atom";
            }
            if(stream.match(number)) {
              return "number";
            }
            if(stream.sol()) {
              stream.next();
            }
          } else {
            stream.next();
          }

        }
        return "variable";
      } else if (stream.eat("{")) {
        if (stream.eat("#")) {
          state.incomment = true;
          if(!stream.skipTo("#}")) {
            stream.skipToEnd();
          } else {
            stream.eatWhile(/\#|}/);
            state.incomment = false;
          }
          return "comment";
        //Open tag
        } else if (ch = stream.eat(/\{|%/)) {
          //Cache close tag
          state.intag = ch;
          if(ch == "{") {
            state.intag = "}";
          }
          stream.eat("-");
          return "tag";
        }
      }
      stream.next();
    };

    return {
      startState: function () {
        return {tokenize: tokenBase};
      },
      token: function (stream, state) {
        return state.tokenize(stream, state);
      },
      blockCommentStart: "{#",
      blockCommentEnd: "#}"
    };
  });

  CodeMirror.defineMIME("text/jinja2", "jinja2");
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/jsx/jsx.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"), __webpack_require__("./src/ipywidgets/node_modules/codemirror/mode/xml/xml.js"), __webpack_require__("./src/ipywidgets/node_modules/codemirror/mode/javascript/javascript.js"))
  else {}
})(function(CodeMirror) {
  "use strict"

  // Depth means the amount of open braces in JS context, in XML
  // context 0 means not in tag, 1 means in tag, and 2 means in tag
  // and js block comment.
  function Context(state, mode, depth, prev) {
    this.state = state; this.mode = mode; this.depth = depth; this.prev = prev
  }

  function copyContext(context) {
    return new Context(CodeMirror.copyState(context.mode, context.state),
                       context.mode,
                       context.depth,
                       context.prev && copyContext(context.prev))
  }

  CodeMirror.defineMode("jsx", function(config, modeConfig) {
    var xmlMode = CodeMirror.getMode(config, {name: "xml", allowMissing: true, multilineTagIndentPastTag: false, allowMissingTagName: true})
    var jsMode = CodeMirror.getMode(config, modeConfig && modeConfig.base || "javascript")

    function flatXMLIndent(state) {
      var tagName = state.tagName
      state.tagName = null
      var result = xmlMode.indent(state, "", "")
      state.tagName = tagName
      return result
    }

    function token(stream, state) {
      if (state.context.mode == xmlMode)
        return xmlToken(stream, state, state.context)
      else
        return jsToken(stream, state, state.context)
    }

    function xmlToken(stream, state, cx) {
      if (cx.depth == 2) { // Inside a JS /* */ comment
        if (stream.match(/^.*?\*\//)) cx.depth = 1
        else stream.skipToEnd()
        return "comment"
      }

      if (stream.peek() == "{") {
        xmlMode.skipAttribute(cx.state)

        var indent = flatXMLIndent(cx.state), xmlContext = cx.state.context
        // If JS starts on same line as tag
        if (xmlContext && stream.match(/^[^>]*>\s*$/, false)) {
          while (xmlContext.prev && !xmlContext.startOfLine)
            xmlContext = xmlContext.prev
          // If tag starts the line, use XML indentation level
          if (xmlContext.startOfLine) indent -= config.indentUnit
          // Else use JS indentation level
          else if (cx.prev.state.lexical) indent = cx.prev.state.lexical.indented
        // Else if inside of tag
        } else if (cx.depth == 1) {
          indent += config.indentUnit
        }

        state.context = new Context(CodeMirror.startState(jsMode, indent),
                                    jsMode, 0, state.context)
        return null
      }

      if (cx.depth == 1) { // Inside of tag
        if (stream.peek() == "<") { // Tag inside of tag
          xmlMode.skipAttribute(cx.state)
          state.context = new Context(CodeMirror.startState(xmlMode, flatXMLIndent(cx.state)),
                                      xmlMode, 0, state.context)
          return null
        } else if (stream.match("//")) {
          stream.skipToEnd()
          return "comment"
        } else if (stream.match("/*")) {
          cx.depth = 2
          return token(stream, state)
        }
      }

      var style = xmlMode.token(stream, cx.state), cur = stream.current(), stop
      if (/\btag\b/.test(style)) {
        if (/>$/.test(cur)) {
          if (cx.state.context) cx.depth = 0
          else state.context = state.context.prev
        } else if (/^</.test(cur)) {
          cx.depth = 1
        }
      } else if (!style && (stop = cur.indexOf("{")) > -1) {
        stream.backUp(cur.length - stop)
      }
      return style
    }

    function jsToken(stream, state, cx) {
      if (stream.peek() == "<" && jsMode.expressionAllowed(stream, cx.state)) {
        state.context = new Context(CodeMirror.startState(xmlMode, jsMode.indent(cx.state, "", "")),
                                    xmlMode, 0, state.context)
        jsMode.skipExpression(cx.state)
        return null
      }

      var style = jsMode.token(stream, cx.state)
      if (!style && cx.depth != null) {
        var cur = stream.current()
        if (cur == "{") {
          cx.depth++
        } else if (cur == "}") {
          if (--cx.depth == 0) state.context = state.context.prev
        }
      }
      return style
    }

    return {
      startState: function() {
        return {context: new Context(CodeMirror.startState(jsMode), jsMode)}
      },

      copyState: function(state) {
        return {context: copyContext(state.context)}
      },

      token: token,

      indent: function(state, textAfter, fullLine) {
        return state.context.mode.indent(state.context.state, textAfter, fullLine)
      },

      innerMode: function(state) {
        return state.context
      }
    }
  }, "xml", "javascript")

  CodeMirror.defineMIME("text/jsx", "jsx")
  CodeMirror.defineMIME("text/typescript-jsx", {name: "jsx", base: {name: "javascript", typescript: true}})
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/livescript/livescript.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

/**
 * Link to the project's GitHub page:
 * https://github.com/duralog/CodeMirror
 */

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
  "use strict";

  CodeMirror.defineMode('livescript', function(){
    var tokenBase = function(stream, state) {
      var next_rule = state.next || "start";
      if (next_rule) {
        state.next = state.next;
        var nr = Rules[next_rule];
        if (nr.splice) {
          for (var i$ = 0; i$ < nr.length; ++i$) {
            var r = nr[i$];
            if (r.regex && stream.match(r.regex)) {
              state.next = r.next || state.next;
              return r.token;
            }
          }
          stream.next();
          return 'error';
        }
        if (stream.match(r = Rules[next_rule])) {
          if (r.regex && stream.match(r.regex)) {
            state.next = r.next;
            return r.token;
          } else {
            stream.next();
            return 'error';
          }
        }
      }
      stream.next();
      return 'error';
    };
    var external = {
      startState: function(){
        return {
          next: 'start',
          lastToken: {style: null, indent: 0, content: ""}
        };
      },
      token: function(stream, state){
        while (stream.pos == stream.start)
          var style = tokenBase(stream, state);
        state.lastToken = {
          style: style,
          indent: stream.indentation(),
          content: stream.current()
        };
        return style.replace(/\./g, ' ');
      },
      indent: function(state){
        var indentation = state.lastToken.indent;
        if (state.lastToken.content.match(indenter)) {
          indentation += 2;
        }
        return indentation;
      }
    };
    return external;
  });

  var identifier = '(?![\\d\\s])[$\\w\\xAA-\\uFFDC](?:(?!\\s)[$\\w\\xAA-\\uFFDC]|-[A-Za-z])*';
  var indenter = RegExp('(?:[({[=:]|[-~]>|\\b(?:e(?:lse|xport)|d(?:o|efault)|t(?:ry|hen)|finally|import(?:\\s*all)?|const|var|let|new|catch(?:\\s*' + identifier + ')?))\\s*$');
  var keywordend = '(?![$\\w]|-[A-Za-z]|\\s*:(?![:=]))';
  var stringfill = {
    token: 'string',
    regex: '.+'
  };
  var Rules = {
    start: [
      {
        token: 'comment.doc',
        regex: '/\\*',
        next: 'comment'
      }, {
        token: 'comment',
        regex: '#.*'
      }, {
        token: 'keyword',
        regex: '(?:t(?:h(?:is|row|en)|ry|ypeof!?)|c(?:on(?:tinue|st)|a(?:se|tch)|lass)|i(?:n(?:stanceof)?|mp(?:ort(?:\\s+all)?|lements)|[fs])|d(?:e(?:fault|lete|bugger)|o)|f(?:or(?:\\s+own)?|inally|unction)|s(?:uper|witch)|e(?:lse|x(?:tends|port)|val)|a(?:nd|rguments)|n(?:ew|ot)|un(?:less|til)|w(?:hile|ith)|o[fr]|return|break|let|var|loop)' + keywordend
      }, {
        token: 'constant.language',
        regex: '(?:true|false|yes|no|on|off|null|void|undefined)' + keywordend
      }, {
        token: 'invalid.illegal',
        regex: '(?:p(?:ackage|r(?:ivate|otected)|ublic)|i(?:mplements|nterface)|enum|static|yield)' + keywordend
      }, {
        token: 'language.support.class',
        regex: '(?:R(?:e(?:gExp|ferenceError)|angeError)|S(?:tring|yntaxError)|E(?:rror|valError)|Array|Boolean|Date|Function|Number|Object|TypeError|URIError)' + keywordend
      }, {
        token: 'language.support.function',
        regex: '(?:is(?:NaN|Finite)|parse(?:Int|Float)|Math|JSON|(?:en|de)codeURI(?:Component)?)' + keywordend
      }, {
        token: 'variable.language',
        regex: '(?:t(?:hat|il|o)|f(?:rom|allthrough)|it|by|e)' + keywordend
      }, {
        token: 'identifier',
        regex: identifier + '\\s*:(?![:=])'
      }, {
        token: 'variable',
        regex: identifier
      }, {
        token: 'keyword.operator',
        regex: '(?:\\.{3}|\\s+\\?)'
      }, {
        token: 'keyword.variable',
        regex: '(?:@+|::|\\.\\.)',
        next: 'key'
      }, {
        token: 'keyword.operator',
        regex: '\\.\\s*',
        next: 'key'
      }, {
        token: 'string',
        regex: '\\\\\\S[^\\s,;)}\\]]*'
      }, {
        token: 'string.doc',
        regex: '\'\'\'',
        next: 'qdoc'
      }, {
        token: 'string.doc',
        regex: '"""',
        next: 'qqdoc'
      }, {
        token: 'string',
        regex: '\'',
        next: 'qstring'
      }, {
        token: 'string',
        regex: '"',
        next: 'qqstring'
      }, {
        token: 'string',
        regex: '`',
        next: 'js'
      }, {
        token: 'string',
        regex: '<\\[',
        next: 'words'
      }, {
        token: 'string.regex',
        regex: '//',
        next: 'heregex'
      }, {
        token: 'string.regex',
        regex: '\\/(?:[^[\\/\\n\\\\]*(?:(?:\\\\.|\\[[^\\]\\n\\\\]*(?:\\\\.[^\\]\\n\\\\]*)*\\])[^[\\/\\n\\\\]*)*)\\/[gimy$]{0,4}',
        next: 'key'
      }, {
        token: 'constant.numeric',
        regex: '(?:0x[\\da-fA-F][\\da-fA-F_]*|(?:[2-9]|[12]\\d|3[0-6])r[\\da-zA-Z][\\da-zA-Z_]*|(?:\\d[\\d_]*(?:\\.\\d[\\d_]*)?|\\.\\d[\\d_]*)(?:e[+-]?\\d[\\d_]*)?[\\w$]*)'
      }, {
        token: 'lparen',
        regex: '[({[]'
      }, {
        token: 'rparen',
        regex: '[)}\\]]',
        next: 'key'
      }, {
        token: 'keyword.operator',
        regex: '\\S+'
      }, {
        token: 'text',
        regex: '\\s+'
      }
    ],
    heregex: [
      {
        token: 'string.regex',
        regex: '.*?//[gimy$?]{0,4}',
        next: 'start'
      }, {
        token: 'string.regex',
        regex: '\\s*#{'
      }, {
        token: 'comment.regex',
        regex: '\\s+(?:#.*)?'
      }, {
        token: 'string.regex',
        regex: '\\S+'
      }
    ],
    key: [
      {
        token: 'keyword.operator',
        regex: '[.?@!]+'
      }, {
        token: 'identifier',
        regex: identifier,
        next: 'start'
      }, {
        token: 'text',
        regex: '',
        next: 'start'
      }
    ],
    comment: [
      {
        token: 'comment.doc',
        regex: '.*?\\*/',
        next: 'start'
      }, {
        token: 'comment.doc',
        regex: '.+'
      }
    ],
    qdoc: [
      {
        token: 'string',
        regex: ".*?'''",
        next: 'key'
      }, stringfill
    ],
    qqdoc: [
      {
        token: 'string',
        regex: '.*?"""',
        next: 'key'
      }, stringfill
    ],
    qstring: [
      {
        token: 'string',
        regex: '[^\\\\\']*(?:\\\\.[^\\\\\']*)*\'',
        next: 'key'
      }, stringfill
    ],
    qqstring: [
      {
        token: 'string',
        regex: '[^\\\\"]*(?:\\\\.[^\\\\"]*)*"',
        next: 'key'
      }, stringfill
    ],
    js: [
      {
        token: 'string',
        regex: '[^\\\\`]*(?:\\\\.[^\\\\`]*)*`',
        next: 'key'
      }, stringfill
    ],
    words: [
      {
        token: 'string',
        regex: '.*?\\]>',
        next: 'key'
      }, stringfill
    ]
  };
  for (var idx in Rules) {
    var r = Rules[idx];
    if (r.splice) {
      for (var i = 0, len = r.length; i < len; ++i) {
        var rr = r[i];
        if (typeof rr.regex === 'string') {
          Rules[idx][i].regex = new RegExp('^' + rr.regex);
        }
      }
    } else if (typeof rr.regex === 'string') {
      Rules[idx].regex = new RegExp('^' + r.regex);
    }
  }

  CodeMirror.defineMIME('text/x-livescript', 'livescript');

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/lua/lua.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// LUA mode. Ported to CodeMirror 2 from Franciszek Wawrzak's
// CodeMirror 1 mode.
// highlights keywords, strings, comments (no leveling supported! ("[==[")), tokens, basic indenting

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("lua", function(config, parserConfig) {
  var indentUnit = config.indentUnit;

  function prefixRE(words) {
    return new RegExp("^(?:" + words.join("|") + ")", "i");
  }
  function wordRE(words) {
    return new RegExp("^(?:" + words.join("|") + ")$", "i");
  }
  var specials = wordRE(parserConfig.specials || []);

  // long list of standard functions from lua manual
  var builtins = wordRE([
    "_G","_VERSION","assert","collectgarbage","dofile","error","getfenv","getmetatable","ipairs","load",
    "loadfile","loadstring","module","next","pairs","pcall","print","rawequal","rawget","rawset","require",
    "select","setfenv","setmetatable","tonumber","tostring","type","unpack","xpcall",

    "coroutine.create","coroutine.resume","coroutine.running","coroutine.status","coroutine.wrap","coroutine.yield",

    "debug.debug","debug.getfenv","debug.gethook","debug.getinfo","debug.getlocal","debug.getmetatable",
    "debug.getregistry","debug.getupvalue","debug.setfenv","debug.sethook","debug.setlocal","debug.setmetatable",
    "debug.setupvalue","debug.traceback",

    "close","flush","lines","read","seek","setvbuf","write",

    "io.close","io.flush","io.input","io.lines","io.open","io.output","io.popen","io.read","io.stderr","io.stdin",
    "io.stdout","io.tmpfile","io.type","io.write",

    "math.abs","math.acos","math.asin","math.atan","math.atan2","math.ceil","math.cos","math.cosh","math.deg",
    "math.exp","math.floor","math.fmod","math.frexp","math.huge","math.ldexp","math.log","math.log10","math.max",
    "math.min","math.modf","math.pi","math.pow","math.rad","math.random","math.randomseed","math.sin","math.sinh",
    "math.sqrt","math.tan","math.tanh",

    "os.clock","os.date","os.difftime","os.execute","os.exit","os.getenv","os.remove","os.rename","os.setlocale",
    "os.time","os.tmpname",

    "package.cpath","package.loaded","package.loaders","package.loadlib","package.path","package.preload",
    "package.seeall",

    "string.byte","string.char","string.dump","string.find","string.format","string.gmatch","string.gsub",
    "string.len","string.lower","string.match","string.rep","string.reverse","string.sub","string.upper",

    "table.concat","table.insert","table.maxn","table.remove","table.sort"
  ]);
  var keywords = wordRE(["and","break","elseif","false","nil","not","or","return",
                         "true","function", "end", "if", "then", "else", "do",
                         "while", "repeat", "until", "for", "in", "local" ]);

  var indentTokens = wordRE(["function", "if","repeat","do", "\\(", "{"]);
  var dedentTokens = wordRE(["end", "until", "\\)", "}"]);
  var dedentPartial = prefixRE(["end", "until", "\\)", "}", "else", "elseif"]);

  function readBracket(stream) {
    var level = 0;
    while (stream.eat("=")) ++level;
    stream.eat("[");
    return level;
  }

  function normal(stream, state) {
    var ch = stream.next();
    if (ch == "-" && stream.eat("-")) {
      if (stream.eat("[") && stream.eat("["))
        return (state.cur = bracketed(readBracket(stream), "comment"))(stream, state);
      stream.skipToEnd();
      return "comment";
    }
    if (ch == "\"" || ch == "'")
      return (state.cur = string(ch))(stream, state);
    if (ch == "[" && /[\[=]/.test(stream.peek()))
      return (state.cur = bracketed(readBracket(stream), "string"))(stream, state);
    if (/\d/.test(ch)) {
      stream.eatWhile(/[\w.%]/);
      return "number";
    }
    if (/[\w_]/.test(ch)) {
      stream.eatWhile(/[\w\\\-_.]/);
      return "variable";
    }
    return null;
  }

  function bracketed(level, style) {
    return function(stream, state) {
      var curlev = null, ch;
      while ((ch = stream.next()) != null) {
        if (curlev == null) {if (ch == "]") curlev = 0;}
        else if (ch == "=") ++curlev;
        else if (ch == "]" && curlev == level) { state.cur = normal; break; }
        else curlev = null;
      }
      return style;
    };
  }

  function string(quote) {
    return function(stream, state) {
      var escaped = false, ch;
      while ((ch = stream.next()) != null) {
        if (ch == quote && !escaped) break;
        escaped = !escaped && ch == "\\";
      }
      if (!escaped) state.cur = normal;
      return "string";
    };
  }

  return {
    startState: function(basecol) {
      return {basecol: basecol || 0, indentDepth: 0, cur: normal};
    },

    token: function(stream, state) {
      if (stream.eatSpace()) return null;
      var style = state.cur(stream, state);
      var word = stream.current();
      if (style == "variable") {
        if (keywords.test(word)) style = "keyword";
        else if (builtins.test(word)) style = "builtin";
        else if (specials.test(word)) style = "variable-2";
      }
      if ((style != "comment") && (style != "string")){
        if (indentTokens.test(word)) ++state.indentDepth;
        else if (dedentTokens.test(word)) --state.indentDepth;
      }
      return style;
    },

    indent: function(state, textAfter) {
      var closing = dedentPartial.test(textAfter);
      return state.basecol + indentUnit * (state.indentDepth - (closing ? 1 : 0));
    },

    electricInput: /^\s*(?:end|until|else|\)|\})$/,
    lineComment: "--",
    blockCommentStart: "--[[",
    blockCommentEnd: "]]"
  };
});

CodeMirror.defineMIME("text/x-lua", "lua");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/mathematica/mathematica.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// Mathematica mode copyright (c) 2015 by Calin Barbat
// Based on code by Patrick Scheibe (halirutan)
// See: https://github.com/halirutan/Mathematica-Source-Highlighting/tree/master/src/lang-mma.js

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode('mathematica', function(_config, _parserConfig) {

  // used pattern building blocks
  var Identifier = '[a-zA-Z\\$][a-zA-Z0-9\\$]*';
  var pBase      = "(?:\\d+)";
  var pFloat     = "(?:\\.\\d+|\\d+\\.\\d*|\\d+)";
  var pFloatBase = "(?:\\.\\w+|\\w+\\.\\w*|\\w+)";
  var pPrecision = "(?:`(?:`?"+pFloat+")?)";

  // regular expressions
  var reBaseForm        = new RegExp('(?:'+pBase+'(?:\\^\\^'+pFloatBase+pPrecision+'?(?:\\*\\^[+-]?\\d+)?))');
  var reFloatForm       = new RegExp('(?:' + pFloat + pPrecision + '?(?:\\*\\^[+-]?\\d+)?)');
  var reIdInContext     = new RegExp('(?:`?)(?:' + Identifier + ')(?:`(?:' + Identifier + '))*(?:`?)');

  function tokenBase(stream, state) {
    var ch;

    // get next character
    ch = stream.next();

    // string
    if (ch === '"') {
      state.tokenize = tokenString;
      return state.tokenize(stream, state);
    }

    // comment
    if (ch === '(') {
      if (stream.eat('*')) {
        state.commentLevel++;
        state.tokenize = tokenComment;
        return state.tokenize(stream, state);
      }
    }

    // go back one character
    stream.backUp(1);

    // look for numbers
    // Numbers in a baseform
    if (stream.match(reBaseForm, true, false)) {
      return 'number';
    }

    // Mathematica numbers. Floats (1.2, .2, 1.) can have optionally a precision (`float) or an accuracy definition
    // (``float). Note: while 1.2` is possible 1.2`` is not. At the end an exponent (float*^+12) can follow.
    if (stream.match(reFloatForm, true, false)) {
      return 'number';
    }

    /* In[23] and Out[34] */
    if (stream.match(/(?:In|Out)\[[0-9]*\]/, true, false)) {
      return 'atom';
    }

    // usage
    if (stream.match(/([a-zA-Z\$][a-zA-Z0-9\$]*(?:`[a-zA-Z0-9\$]+)*::usage)/, true, false)) {
      return 'meta';
    }

    // message
    if (stream.match(/([a-zA-Z\$][a-zA-Z0-9\$]*(?:`[a-zA-Z0-9\$]+)*::[a-zA-Z\$][a-zA-Z0-9\$]*):?/, true, false)) {
      return 'string-2';
    }

    // this makes a look-ahead match for something like variable:{_Integer}
    // the match is then forwarded to the mma-patterns tokenizer.
    if (stream.match(/([a-zA-Z\$][a-zA-Z0-9\$]*\s*:)(?:(?:[a-zA-Z\$][a-zA-Z0-9\$]*)|(?:[^:=>~@\^\&\*\)\[\]'\?,\|])).*/, true, false)) {
      return 'variable-2';
    }

    // catch variables which are used together with Blank (_), BlankSequence (__) or BlankNullSequence (___)
    // Cannot start with a number, but can have numbers at any other position. Examples
    // blub__Integer, a1_, b34_Integer32
    if (stream.match(/[a-zA-Z\$][a-zA-Z0-9\$]*_+[a-zA-Z\$][a-zA-Z0-9\$]*/, true, false)) {
      return 'variable-2';
    }
    if (stream.match(/[a-zA-Z\$][a-zA-Z0-9\$]*_+/, true, false)) {
      return 'variable-2';
    }
    if (stream.match(/_+[a-zA-Z\$][a-zA-Z0-9\$]*/, true, false)) {
      return 'variable-2';
    }

    // Named characters in Mathematica, like \[Gamma].
    if (stream.match(/\\\[[a-zA-Z\$][a-zA-Z0-9\$]*\]/, true, false)) {
      return 'variable-3';
    }

    // Match all braces separately
    if (stream.match(/(?:\[|\]|{|}|\(|\))/, true, false)) {
      return 'bracket';
    }

    // Catch Slots (#, ##, #3, ##9 and the V10 named slots #name). I have never seen someone using more than one digit after #, so we match
    // only one.
    if (stream.match(/(?:#[a-zA-Z\$][a-zA-Z0-9\$]*|#+[0-9]?)/, true, false)) {
      return 'variable-2';
    }

    // Literals like variables, keywords, functions
    if (stream.match(reIdInContext, true, false)) {
      return 'keyword';
    }

    // operators. Note that operators like @@ or /; are matched separately for each symbol.
    if (stream.match(/(?:\\|\+|\-|\*|\/|,|;|\.|:|@|~|=|>|<|&|\||_|`|'|\^|\?|!|%)/, true, false)) {
      return 'operator';
    }

    // everything else is an error
    stream.next(); // advance the stream.
    return 'error';
  }

  function tokenString(stream, state) {
    var next, end = false, escaped = false;
    while ((next = stream.next()) != null) {
      if (next === '"' && !escaped) {
        end = true;
        break;
      }
      escaped = !escaped && next === '\\';
    }
    if (end && !escaped) {
      state.tokenize = tokenBase;
    }
    return 'string';
  };

  function tokenComment(stream, state) {
    var prev, next;
    while(state.commentLevel > 0 && (next = stream.next()) != null) {
      if (prev === '(' && next === '*') state.commentLevel++;
      if (prev === '*' && next === ')') state.commentLevel--;
      prev = next;
    }
    if (state.commentLevel <= 0) {
      state.tokenize = tokenBase;
    }
    return 'comment';
  }

  return {
    startState: function() {return {tokenize: tokenBase, commentLevel: 0};},
    token: function(stream, state) {
      if (stream.eatSpace()) return null;
      return state.tokenize(stream, state);
    },
    blockCommentStart: "(*",
    blockCommentEnd: "*)"
  };
});

CodeMirror.defineMIME('text/x-mathematica', {
  name: 'mathematica'
});

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/mbox/mbox.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

var rfc2822 = [
  "From", "Sender", "Reply-To", "To", "Cc", "Bcc", "Message-ID",
  "In-Reply-To", "References", "Resent-From", "Resent-Sender", "Resent-To",
  "Resent-Cc", "Resent-Bcc", "Resent-Message-ID", "Return-Path", "Received"
];
var rfc2822NoEmail = [
  "Date", "Subject", "Comments", "Keywords", "Resent-Date"
];

CodeMirror.registerHelper("hintWords", "mbox", rfc2822.concat(rfc2822NoEmail));

var whitespace = /^[ \t]/;
var separator = /^From /; // See RFC 4155
var rfc2822Header = new RegExp("^(" + rfc2822.join("|") + "): ");
var rfc2822HeaderNoEmail = new RegExp("^(" + rfc2822NoEmail.join("|") + "): ");
var header = /^[^:]+:/; // Optional fields defined in RFC 2822
var email = /^[^ ]+@[^ ]+/;
var untilEmail = /^.*?(?=[^ ]+?@[^ ]+)/;
var bracketedEmail = /^<.*?>/;
var untilBracketedEmail = /^.*?(?=<.*>)/;

function styleForHeader(header) {
  if (header === "Subject") return "header";
  return "string";
}

function readToken(stream, state) {
  if (stream.sol()) {
    // From last line
    state.inSeparator = false;
    if (state.inHeader && stream.match(whitespace)) {
      // Header folding
      return null;
    } else {
      state.inHeader = false;
      state.header = null;
    }

    if (stream.match(separator)) {
      state.inHeaders = true;
      state.inSeparator = true;
      return "atom";
    }

    var match;
    var emailPermitted = false;
    if ((match = stream.match(rfc2822HeaderNoEmail)) ||
        (emailPermitted = true) && (match = stream.match(rfc2822Header))) {
      state.inHeaders = true;
      state.inHeader = true;
      state.emailPermitted = emailPermitted;
      state.header = match[1];
      return "atom";
    }

    // Use vim's heuristics: recognize custom headers only if the line is in a
    // block of legitimate headers.
    if (state.inHeaders && (match = stream.match(header))) {
      state.inHeader = true;
      state.emailPermitted = true;
      state.header = match[1];
      return "atom";
    }

    state.inHeaders = false;
    stream.skipToEnd();
    return null;
  }

  if (state.inSeparator) {
    if (stream.match(email)) return "link";
    if (stream.match(untilEmail)) return "atom";
    stream.skipToEnd();
    return "atom";
  }

  if (state.inHeader) {
    var style = styleForHeader(state.header);

    if (state.emailPermitted) {
      if (stream.match(bracketedEmail)) return style + " link";
      if (stream.match(untilBracketedEmail)) return style;
    }
    stream.skipToEnd();
    return style;
  }

  stream.skipToEnd();
  return null;
};

CodeMirror.defineMode("mbox", function() {
  return {
    startState: function() {
      return {
        // Is in a mbox separator
        inSeparator: false,
        // Is in a mail header
        inHeader: false,
        // If bracketed email is permitted. Only applicable when inHeader
        emailPermitted: false,
        // Name of current header
        header: null,
        // Is in a region of mail headers
        inHeaders: false
      };
    },
    token: readToken,
    blankLine: function(state) {
      state.inHeaders = state.inSeparator = state.inHeader = false;
    }
  };
});

CodeMirror.defineMIME("application/mbox", "mbox");
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/mirc/mirc.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

//mIRC mode by Ford_Lawnmower :: Based on Velocity mode by Steve O'Hara

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMIME("text/mirc", "mirc");
CodeMirror.defineMode("mirc", function() {
  function parseWords(str) {
    var obj = {}, words = str.split(" ");
    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
    return obj;
  }
  var specials = parseWords("$! $$ $& $? $+ $abook $abs $active $activecid " +
                            "$activewid $address $addtok $agent $agentname $agentstat $agentver " +
                            "$alias $and $anick $ansi2mirc $aop $appactive $appstate $asc $asctime " +
                            "$asin $atan $avoice $away $awaymsg $awaytime $banmask $base $bfind " +
                            "$binoff $biton $bnick $bvar $bytes $calc $cb $cd $ceil $chan $chanmodes " +
                            "$chantypes $chat $chr $cid $clevel $click $cmdbox $cmdline $cnick $color " +
                            "$com $comcall $comchan $comerr $compact $compress $comval $cos $count " +
                            "$cr $crc $creq $crlf $ctime $ctimer $ctrlenter $date $day $daylight " +
                            "$dbuh $dbuw $dccignore $dccport $dde $ddename $debug $decode $decompress " +
                            "$deltok $devent $dialog $did $didreg $didtok $didwm $disk $dlevel $dll " +
                            "$dllcall $dname $dns $duration $ebeeps $editbox $emailaddr $encode $error " +
                            "$eval $event $exist $feof $ferr $fgetc $file $filename $filtered $finddir " +
                            "$finddirn $findfile $findfilen $findtok $fline $floor $fopen $fread $fserve " +
                            "$fulladdress $fulldate $fullname $fullscreen $get $getdir $getdot $gettok $gmt " +
                            "$group $halted $hash $height $hfind $hget $highlight $hnick $hotline " +
                            "$hotlinepos $ial $ialchan $ibl $idle $iel $ifmatch $ignore $iif $iil " +
                            "$inelipse $ini $inmidi $inpaste $inpoly $input $inrect $inroundrect " +
                            "$insong $instok $int $inwave $ip $isalias $isbit $isdde $isdir $isfile " +
                            "$isid $islower $istok $isupper $keychar $keyrpt $keyval $knick $lactive " +
                            "$lactivecid $lactivewid $left $len $level $lf $line $lines $link $lock " +
                            "$lock $locked $log $logstamp $logstampfmt $longfn $longip $lower $ltimer " +
                            "$maddress $mask $matchkey $matchtok $md5 $me $menu $menubar $menucontext " +
                            "$menutype $mid $middir $mircdir $mircexe $mircini $mklogfn $mnick $mode " +
                            "$modefirst $modelast $modespl $mouse $msfile $network $newnick $nick $nofile " +
                            "$nopath $noqt $not $notags $notify $null $numeric $numok $oline $onpoly " +
                            "$opnick $or $ord $os $passivedcc $pic $play $pnick $port $portable $portfree " +
                            "$pos $prefix $prop $protect $puttok $qt $query $rand $r $rawmsg $read $readomo " +
                            "$readn $regex $regml $regsub $regsubex $remove $remtok $replace $replacex " +
                            "$reptok $result $rgb $right $round $scid $scon $script $scriptdir $scriptline " +
                            "$sdir $send $server $serverip $sfile $sha1 $shortfn $show $signal $sin " +
                            "$site $sline $snick $snicks $snotify $sock $sockbr $sockerr $sockname " +
                            "$sorttok $sound $sqrt $ssl $sreq $sslready $status $strip $str $stripped " +
                            "$syle $submenu $switchbar $tan $target $ticks $time $timer $timestamp " +
                            "$timestampfmt $timezone $tip $titlebar $toolbar $treebar $trust $ulevel " +
                            "$ulist $upper $uptime $url $usermode $v1 $v2 $var $vcmd $vcmdstat $vcmdver " +
                            "$version $vnick $vol $wid $width $wildsite $wildtok $window $wrap $xor");
  var keywords = parseWords("abook ajinvite alias aline ame amsg anick aop auser autojoin avoice " +
                            "away background ban bcopy beep bread break breplace bset btrunc bunset bwrite " +
                            "channel clear clearall cline clipboard close cnick color comclose comopen " +
                            "comreg continue copy creq ctcpreply ctcps dcc dccserver dde ddeserver " +
                            "debug dec describe dialog did didtok disable disconnect dlevel dline dll " +
                            "dns dqwindow drawcopy drawdot drawfill drawline drawpic drawrect drawreplace " +
                            "drawrot drawsave drawscroll drawtext ebeeps echo editbox emailaddr enable " +
                            "events exit fclose filter findtext finger firewall flash flist flood flush " +
                            "flushini font fopen fseek fsend fserve fullname fwrite ghide gload gmove " +
                            "gopts goto gplay gpoint gqreq groups gshow gsize gstop gtalk gunload hadd " +
                            "halt haltdef hdec hdel help hfree hinc hload hmake hop hsave ial ialclear " +
                            "ialmark identd if ignore iline inc invite iuser join kick linesep links list " +
                            "load loadbuf localinfo log mdi me menubar mkdir mnick mode msg nick noop notice " +
                            "notify omsg onotice part partall pdcc perform play playctrl pop protect pvoice " +
                            "qme qmsg query queryn quit raw reload remini remote remove rename renwin " +
                            "reseterror resetidle return rlevel rline rmdir run ruser save savebuf saveini " +
                            "say scid scon server set showmirc signam sline sockaccept sockclose socklist " +
                            "socklisten sockmark sockopen sockpause sockread sockrename sockudp sockwrite " +
                            "sound speak splay sreq strip switchbar timer timestamp titlebar tnick tokenize " +
                            "toolbar topic tray treebar ulist unload unset unsetall updatenl url uwho " +
                            "var vcadd vcmd vcrem vol while whois window winhelp write writeint if isalnum " +
                            "isalpha isaop isavoice isban ischan ishop isignore isin isincs isletter islower " +
                            "isnotify isnum ison isop isprotect isreg isupper isvoice iswm iswmcs " +
                            "elseif else goto menu nicklist status title icon size option text edit " +
                            "button check radio box scroll list combo link tab item");
  var functions = parseWords("if elseif else and not or eq ne in ni for foreach while switch");
  var isOperatorChar = /[+\-*&%=<>!?^\/\|]/;
  function chain(stream, state, f) {
    state.tokenize = f;
    return f(stream, state);
  }
  function tokenBase(stream, state) {
    var beforeParams = state.beforeParams;
    state.beforeParams = false;
    var ch = stream.next();
    if (/[\[\]{}\(\),\.]/.test(ch)) {
      if (ch == "(" && beforeParams) state.inParams = true;
      else if (ch == ")") state.inParams = false;
      return null;
    }
    else if (/\d/.test(ch)) {
      stream.eatWhile(/[\w\.]/);
      return "number";
    }
    else if (ch == "\\") {
      stream.eat("\\");
      stream.eat(/./);
      return "number";
    }
    else if (ch == "/" && stream.eat("*")) {
      return chain(stream, state, tokenComment);
    }
    else if (ch == ";" && stream.match(/ *\( *\(/)) {
      return chain(stream, state, tokenUnparsed);
    }
    else if (ch == ";" && !state.inParams) {
      stream.skipToEnd();
      return "comment";
    }
    else if (ch == '"') {
      stream.eat(/"/);
      return "keyword";
    }
    else if (ch == "$") {
      stream.eatWhile(/[$_a-z0-9A-Z\.:]/);
      if (specials && specials.propertyIsEnumerable(stream.current().toLowerCase())) {
        return "keyword";
      }
      else {
        state.beforeParams = true;
        return "builtin";
      }
    }
    else if (ch == "%") {
      stream.eatWhile(/[^,\s()]/);
      state.beforeParams = true;
      return "string";
    }
    else if (isOperatorChar.test(ch)) {
      stream.eatWhile(isOperatorChar);
      return "operator";
    }
    else {
      stream.eatWhile(/[\w\$_{}]/);
      var word = stream.current().toLowerCase();
      if (keywords && keywords.propertyIsEnumerable(word))
        return "keyword";
      if (functions && functions.propertyIsEnumerable(word)) {
        state.beforeParams = true;
        return "keyword";
      }
      return null;
    }
  }
  function tokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" && maybeEnd) {
        state.tokenize = tokenBase;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return "comment";
  }
  function tokenUnparsed(stream, state) {
    var maybeEnd = 0, ch;
    while (ch = stream.next()) {
      if (ch == ";" && maybeEnd == 2) {
        state.tokenize = tokenBase;
        break;
      }
      if (ch == ")")
        maybeEnd++;
      else if (ch != " ")
        maybeEnd = 0;
    }
    return "meta";
  }
  return {
    startState: function() {
      return {
        tokenize: tokenBase,
        beforeParams: false,
        inParams: false
      };
    },
    token: function(stream, state) {
      if (stream.eatSpace()) return null;
      return state.tokenize(stream, state);
    }
  };
});

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/mllike/mllike.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode('mllike', function(_config, parserConfig) {
  var words = {
    'as': 'keyword',
    'do': 'keyword',
    'else': 'keyword',
    'end': 'keyword',
    'exception': 'keyword',
    'fun': 'keyword',
    'functor': 'keyword',
    'if': 'keyword',
    'in': 'keyword',
    'include': 'keyword',
    'let': 'keyword',
    'of': 'keyword',
    'open': 'keyword',
    'rec': 'keyword',
    'struct': 'keyword',
    'then': 'keyword',
    'type': 'keyword',
    'val': 'keyword',
    'while': 'keyword',
    'with': 'keyword'
  };

  var extraWords = parserConfig.extraWords || {};
  for (var prop in extraWords) {
    if (extraWords.hasOwnProperty(prop)) {
      words[prop] = parserConfig.extraWords[prop];
    }
  }
  var hintWords = [];
  for (var k in words) { hintWords.push(k); }
  CodeMirror.registerHelper("hintWords", "mllike", hintWords);

  function tokenBase(stream, state) {
    var ch = stream.next();

    if (ch === '"') {
      state.tokenize = tokenString;
      return state.tokenize(stream, state);
    }
    if (ch === '{') {
      if (stream.eat('|')) {
        state.longString = true;
        state.tokenize = tokenLongString;
        return state.tokenize(stream, state);
      }
    }
    if (ch === '(') {
      if (stream.eat('*')) {
        state.commentLevel++;
        state.tokenize = tokenComment;
        return state.tokenize(stream, state);
      }
    }
    if (ch === '~' || ch === '?') {
      stream.eatWhile(/\w/);
      return 'variable-2';
    }
    if (ch === '`') {
      stream.eatWhile(/\w/);
      return 'quote';
    }
    if (ch === '/' && parserConfig.slashComments && stream.eat('/')) {
      stream.skipToEnd();
      return 'comment';
    }
    if (/\d/.test(ch)) {
      if (ch === '0' && stream.eat(/[bB]/)) {
        stream.eatWhile(/[01]/);
      } if (ch === '0' && stream.eat(/[xX]/)) {
        stream.eatWhile(/[0-9a-fA-F]/)
      } if (ch === '0' && stream.eat(/[oO]/)) {
        stream.eatWhile(/[0-7]/);
      } else {
        stream.eatWhile(/[\d_]/);
        if (stream.eat('.')) {
          stream.eatWhile(/[\d]/);
        }
        if (stream.eat(/[eE]/)) {
          stream.eatWhile(/[\d\-+]/);
        }
      }
      return 'number';
    }
    if ( /[+\-*&%=<>!?|@\.~:]/.test(ch)) {
      return 'operator';
    }
    if (/[\w\xa1-\uffff]/.test(ch)) {
      stream.eatWhile(/[\w\xa1-\uffff]/);
      var cur = stream.current();
      return words.hasOwnProperty(cur) ? words[cur] : 'variable';
    }
    return null
  }

  function tokenString(stream, state) {
    var next, end = false, escaped = false;
    while ((next = stream.next()) != null) {
      if (next === '"' && !escaped) {
        end = true;
        break;
      }
      escaped = !escaped && next === '\\';
    }
    if (end && !escaped) {
      state.tokenize = tokenBase;
    }
    return 'string';
  };

  function tokenComment(stream, state) {
    var prev, next;
    while(state.commentLevel > 0 && (next = stream.next()) != null) {
      if (prev === '(' && next === '*') state.commentLevel++;
      if (prev === '*' && next === ')') state.commentLevel--;
      prev = next;
    }
    if (state.commentLevel <= 0) {
      state.tokenize = tokenBase;
    }
    return 'comment';
  }

  function tokenLongString(stream, state) {
    var prev, next;
    while (state.longString && (next = stream.next()) != null) {
      if (prev === '|' && next === '}') state.longString = false;
      prev = next;
    }
    if (!state.longString) {
      state.tokenize = tokenBase;
    }
    return 'string';
  }

  return {
    startState: function() {return {tokenize: tokenBase, commentLevel: 0, longString: false};},
    token: function(stream, state) {
      if (stream.eatSpace()) return null;
      return state.tokenize(stream, state);
    },

    blockCommentStart: "(*",
    blockCommentEnd: "*)",
    lineComment: parserConfig.slashComments ? "//" : null
  };
});

CodeMirror.defineMIME('text/x-ocaml', {
  name: 'mllike',
  extraWords: {
    'and': 'keyword',
    'assert': 'keyword',
    'begin': 'keyword',
    'class': 'keyword',
    'constraint': 'keyword',
    'done': 'keyword',
    'downto': 'keyword',
    'external': 'keyword',
    'function': 'keyword',
    'initializer': 'keyword',
    'lazy': 'keyword',
    'match': 'keyword',
    'method': 'keyword',
    'module': 'keyword',
    'mutable': 'keyword',
    'new': 'keyword',
    'nonrec': 'keyword',
    'object': 'keyword',
    'private': 'keyword',
    'sig': 'keyword',
    'to': 'keyword',
    'try': 'keyword',
    'value': 'keyword',
    'virtual': 'keyword',
    'when': 'keyword',

    // builtins
    'raise': 'builtin',
    'failwith': 'builtin',
    'true': 'builtin',
    'false': 'builtin',

    // Pervasives builtins
    'asr': 'builtin',
    'land': 'builtin',
    'lor': 'builtin',
    'lsl': 'builtin',
    'lsr': 'builtin',
    'lxor': 'builtin',
    'mod': 'builtin',
    'or': 'builtin',

    // More Pervasives
    'raise_notrace': 'builtin',
    'trace': 'builtin',
    'exit': 'builtin',
    'print_string': 'builtin',
    'print_endline': 'builtin',

     'int': 'type',
     'float': 'type',
     'bool': 'type',
     'char': 'type',
     'string': 'type',
     'unit': 'type',

     // Modules
     'List': 'builtin'
  }
});

CodeMirror.defineMIME('text/x-fsharp', {
  name: 'mllike',
  extraWords: {
    'abstract': 'keyword',
    'assert': 'keyword',
    'base': 'keyword',
    'begin': 'keyword',
    'class': 'keyword',
    'default': 'keyword',
    'delegate': 'keyword',
    'do!': 'keyword',
    'done': 'keyword',
    'downcast': 'keyword',
    'downto': 'keyword',
    'elif': 'keyword',
    'extern': 'keyword',
    'finally': 'keyword',
    'for': 'keyword',
    'function': 'keyword',
    'global': 'keyword',
    'inherit': 'keyword',
    'inline': 'keyword',
    'interface': 'keyword',
    'internal': 'keyword',
    'lazy': 'keyword',
    'let!': 'keyword',
    'match': 'keyword',
    'member': 'keyword',
    'module': 'keyword',
    'mutable': 'keyword',
    'namespace': 'keyword',
    'new': 'keyword',
    'null': 'keyword',
    'override': 'keyword',
    'private': 'keyword',
    'public': 'keyword',
    'return!': 'keyword',
    'return': 'keyword',
    'select': 'keyword',
    'static': 'keyword',
    'to': 'keyword',
    'try': 'keyword',
    'upcast': 'keyword',
    'use!': 'keyword',
    'use': 'keyword',
    'void': 'keyword',
    'when': 'keyword',
    'yield!': 'keyword',
    'yield': 'keyword',

    // Reserved words
    'atomic': 'keyword',
    'break': 'keyword',
    'checked': 'keyword',
    'component': 'keyword',
    'const': 'keyword',
    'constraint': 'keyword',
    'constructor': 'keyword',
    'continue': 'keyword',
    'eager': 'keyword',
    'event': 'keyword',
    'external': 'keyword',
    'fixed': 'keyword',
    'method': 'keyword',
    'mixin': 'keyword',
    'object': 'keyword',
    'parallel': 'keyword',
    'process': 'keyword',
    'protected': 'keyword',
    'pure': 'keyword',
    'sealed': 'keyword',
    'tailcall': 'keyword',
    'trait': 'keyword',
    'virtual': 'keyword',
    'volatile': 'keyword',

    // builtins
    'List': 'builtin',
    'Seq': 'builtin',
    'Map': 'builtin',
    'Set': 'builtin',
    'Option': 'builtin',
    'int': 'builtin',
    'string': 'builtin',
    'not': 'builtin',
    'true': 'builtin',
    'false': 'builtin',

    'raise': 'builtin',
    'failwith': 'builtin'
  },
  slashComments: true
});


CodeMirror.defineMIME('text/x-sml', {
  name: 'mllike',
  extraWords: {
    'abstype': 'keyword',
    'and': 'keyword',
    'andalso': 'keyword',
    'case': 'keyword',
    'datatype': 'keyword',
    'fn': 'keyword',
    'handle': 'keyword',
    'infix': 'keyword',
    'infixr': 'keyword',
    'local': 'keyword',
    'nonfix': 'keyword',
    'op': 'keyword',
    'orelse': 'keyword',
    'raise': 'keyword',
    'withtype': 'keyword',
    'eqtype': 'keyword',
    'sharing': 'keyword',
    'sig': 'keyword',
    'signature': 'keyword',
    'structure': 'keyword',
    'where': 'keyword',
    'true': 'keyword',
    'false': 'keyword',

    // types
    'int': 'builtin',
    'real': 'builtin',
    'string': 'builtin',
    'char': 'builtin',
    'bool': 'builtin'
  },
  slashComments: true
});

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/modelica/modelica.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// Modelica support for CodeMirror, copyright (c) by Lennart Ochel

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})

(function(CodeMirror) {
  "use strict";

  CodeMirror.defineMode("modelica", function(config, parserConfig) {

    var indentUnit = config.indentUnit;
    var keywords = parserConfig.keywords || {};
    var builtin = parserConfig.builtin || {};
    var atoms = parserConfig.atoms || {};

    var isSingleOperatorChar = /[;=\(:\),{}.*<>+\-\/^\[\]]/;
    var isDoubleOperatorChar = /(:=|<=|>=|==|<>|\.\+|\.\-|\.\*|\.\/|\.\^)/;
    var isDigit = /[0-9]/;
    var isNonDigit = /[_a-zA-Z]/;

    function tokenLineComment(stream, state) {
      stream.skipToEnd();
      state.tokenize = null;
      return "comment";
    }

    function tokenBlockComment(stream, state) {
      var maybeEnd = false, ch;
      while (ch = stream.next()) {
        if (maybeEnd && ch == "/") {
          state.tokenize = null;
          break;
        }
        maybeEnd = (ch == "*");
      }
      return "comment";
    }

    function tokenString(stream, state) {
      var escaped = false, ch;
      while ((ch = stream.next()) != null) {
        if (ch == '"' && !escaped) {
          state.tokenize = null;
          state.sol = false;
          break;
        }
        escaped = !escaped && ch == "\\";
      }

      return "string";
    }

    function tokenIdent(stream, state) {
      stream.eatWhile(isDigit);
      while (stream.eat(isDigit) || stream.eat(isNonDigit)) { }


      var cur = stream.current();

      if(state.sol && (cur == "package" || cur == "model" || cur == "when" || cur == "connector")) state.level++;
      else if(state.sol && cur == "end" && state.level > 0) state.level--;

      state.tokenize = null;
      state.sol = false;

      if (keywords.propertyIsEnumerable(cur)) return "keyword";
      else if (builtin.propertyIsEnumerable(cur)) return "builtin";
      else if (atoms.propertyIsEnumerable(cur)) return "atom";
      else return "variable";
    }

    function tokenQIdent(stream, state) {
      while (stream.eat(/[^']/)) { }

      state.tokenize = null;
      state.sol = false;

      if(stream.eat("'"))
        return "variable";
      else
        return "error";
    }

    function tokenUnsignedNumber(stream, state) {
      stream.eatWhile(isDigit);
      if (stream.eat('.')) {
        stream.eatWhile(isDigit);
      }
      if (stream.eat('e') || stream.eat('E')) {
        if (!stream.eat('-'))
          stream.eat('+');
        stream.eatWhile(isDigit);
      }

      state.tokenize = null;
      state.sol = false;
      return "number";
    }

    // Interface
    return {
      startState: function() {
        return {
          tokenize: null,
          level: 0,
          sol: true
        };
      },

      token: function(stream, state) {
        if(state.tokenize != null) {
          return state.tokenize(stream, state);
        }

        if(stream.sol()) {
          state.sol = true;
        }

        // WHITESPACE
        if(stream.eatSpace()) {
          state.tokenize = null;
          return null;
        }

        var ch = stream.next();

        // LINECOMMENT
        if(ch == '/' && stream.eat('/')) {
          state.tokenize = tokenLineComment;
        }
        // BLOCKCOMMENT
        else if(ch == '/' && stream.eat('*')) {
          state.tokenize = tokenBlockComment;
        }
        // TWO SYMBOL TOKENS
        else if(isDoubleOperatorChar.test(ch+stream.peek())) {
          stream.next();
          state.tokenize = null;
          return "operator";
        }
        // SINGLE SYMBOL TOKENS
        else if(isSingleOperatorChar.test(ch)) {
          state.tokenize = null;
          return "operator";
        }
        // IDENT
        else if(isNonDigit.test(ch)) {
          state.tokenize = tokenIdent;
        }
        // Q-IDENT
        else if(ch == "'" && stream.peek() && stream.peek() != "'") {
          state.tokenize = tokenQIdent;
        }
        // STRING
        else if(ch == '"') {
          state.tokenize = tokenString;
        }
        // UNSIGNED_NUMBER
        else if(isDigit.test(ch)) {
          state.tokenize = tokenUnsignedNumber;
        }
        // ERROR
        else {
          state.tokenize = null;
          return "error";
        }

        return state.tokenize(stream, state);
      },

      indent: function(state, textAfter) {
        if (state.tokenize != null) return CodeMirror.Pass;

        var level = state.level;
        if(/(algorithm)/.test(textAfter)) level--;
        if(/(equation)/.test(textAfter)) level--;
        if(/(initial algorithm)/.test(textAfter)) level--;
        if(/(initial equation)/.test(textAfter)) level--;
        if(/(end)/.test(textAfter)) level--;

        if(level > 0)
          return indentUnit*level;
        else
          return 0;
      },

      blockCommentStart: "/*",
      blockCommentEnd: "*/",
      lineComment: "//"
    };
  });

  function words(str) {
    var obj = {}, words = str.split(" ");
    for (var i=0; i<words.length; ++i)
      obj[words[i]] = true;
    return obj;
  }

  var modelicaKeywords = "algorithm and annotation assert block break class connect connector constant constrainedby der discrete each else elseif elsewhen encapsulated end enumeration equation expandable extends external false final flow for function if import impure in initial inner input loop model not operator or outer output package parameter partial protected public pure record redeclare replaceable return stream then true type when while within";
  var modelicaBuiltin = "abs acos actualStream asin atan atan2 cardinality ceil cos cosh delay div edge exp floor getInstanceName homotopy inStream integer log log10 mod pre reinit rem semiLinear sign sin sinh spatialDistribution sqrt tan tanh";
  var modelicaAtoms = "Real Boolean Integer String";

  function def(mimes, mode) {
    if (typeof mimes == "string")
      mimes = [mimes];

    var words = [];

    function add(obj) {
      if (obj)
        for (var prop in obj)
          if (obj.hasOwnProperty(prop))
            words.push(prop);
    }

    add(mode.keywords);
    add(mode.builtin);
    add(mode.atoms);

    if (words.length) {
      mode.helperType = mimes[0];
      CodeMirror.registerHelper("hintWords", mimes[0], words);
    }

    for (var i=0; i<mimes.length; ++i)
      CodeMirror.defineMIME(mimes[i], mode);
  }

  def(["text/x-modelica"], {
    name: "modelica",
    keywords: words(modelicaKeywords),
    builtin: words(modelicaBuiltin),
    atoms: words(modelicaAtoms)
  });
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/mscgen/mscgen.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// mode(s) for the sequence chart dsl's mscgen, xù and msgenny
// For more information on mscgen, see the site of the original author:
// http://www.mcternan.me.uk/mscgen
//
// This mode for mscgen and the two derivative languages were
// originally made for use in the mscgen_js interpreter
// (https://sverweij.github.io/mscgen_js)

(function(mod) {
  if ( true)// CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
  "use strict";

  var languages = {
    mscgen: {
      "keywords" : ["msc"],
      "options" : ["hscale", "width", "arcgradient", "wordwraparcs"],
      "constants" : ["true", "false", "on", "off"],
      "attributes" : ["label", "idurl", "id", "url", "linecolor", "linecolour", "textcolor", "textcolour", "textbgcolor", "textbgcolour", "arclinecolor", "arclinecolour", "arctextcolor", "arctextcolour", "arctextbgcolor", "arctextbgcolour", "arcskip"],
      "brackets" : ["\\{", "\\}"], // [ and  ] are brackets too, but these get handled in with lists
      "arcsWords" : ["note", "abox", "rbox", "box"],
      "arcsOthers" : ["\\|\\|\\|", "\\.\\.\\.", "---", "--", "<->", "==", "<<=>>", "<=>", "\\.\\.", "<<>>", "::", "<:>", "->", "=>>", "=>", ">>", ":>", "<-", "<<=", "<=", "<<", "<:", "x-", "-x"],
      "singlecomment" : ["//", "#"],
      "operators" : ["="]
    },
    xu: {
      "keywords" : ["msc", "xu"],
      "options" : ["hscale", "width", "arcgradient", "wordwraparcs", "wordwrapentities", "watermark"],
      "constants" : ["true", "false", "on", "off", "auto"],
      "attributes" : ["label", "idurl", "id", "url", "linecolor", "linecolour", "textcolor", "textcolour", "textbgcolor", "textbgcolour", "arclinecolor", "arclinecolour", "arctextcolor", "arctextcolour", "arctextbgcolor", "arctextbgcolour", "arcskip", "title", "deactivate", "activate", "activation"],
      "brackets" : ["\\{", "\\}"],  // [ and  ] are brackets too, but these get handled in with lists
      "arcsWords" : ["note", "abox", "rbox", "box", "alt", "else", "opt", "break", "par", "seq", "strict", "neg", "critical", "ignore", "consider", "assert", "loop", "ref", "exc"],
      "arcsOthers" : ["\\|\\|\\|", "\\.\\.\\.", "---", "--", "<->", "==", "<<=>>", "<=>", "\\.\\.", "<<>>", "::", "<:>", "->", "=>>", "=>", ">>", ":>", "<-", "<<=", "<=", "<<", "<:", "x-", "-x"],
      "singlecomment" : ["//", "#"],
      "operators" : ["="]
    },
    msgenny: {
      "keywords" : null,
      "options" : ["hscale", "width", "arcgradient", "wordwraparcs", "wordwrapentities", "watermark"],
      "constants" : ["true", "false", "on", "off", "auto"],
      "attributes" : null,
      "brackets" : ["\\{", "\\}"],
      "arcsWords" : ["note", "abox", "rbox", "box", "alt", "else", "opt", "break", "par", "seq", "strict", "neg", "critical", "ignore", "consider", "assert", "loop", "ref", "exc"],
      "arcsOthers" : ["\\|\\|\\|", "\\.\\.\\.", "---", "--", "<->", "==", "<<=>>", "<=>", "\\.\\.", "<<>>", "::", "<:>", "->", "=>>", "=>", ">>", ":>", "<-", "<<=", "<=", "<<", "<:", "x-", "-x"],
      "singlecomment" : ["//", "#"],
      "operators" : ["="]
    }
  }

  CodeMirror.defineMode("mscgen", function(_, modeConfig) {
    var language = languages[modeConfig && modeConfig.language || "mscgen"]
    return {
      startState: startStateFn,
      copyState: copyStateFn,
      token: produceTokenFunction(language),
      lineComment : "#",
      blockCommentStart : "/*",
      blockCommentEnd : "*/"
    };
  });

  CodeMirror.defineMIME("text/x-mscgen", "mscgen");
  CodeMirror.defineMIME("text/x-xu", {name: "mscgen", language: "xu"});
  CodeMirror.defineMIME("text/x-msgenny", {name: "mscgen", language: "msgenny"});

  function wordRegexpBoundary(pWords) {
    return new RegExp("^\\b(?:" + pWords.join("|") + ")\\b", "i");
  }

  function wordRegexp(pWords) {
    return new RegExp("^(?:" + pWords.join("|") + ")", "i");
  }

  function startStateFn() {
    return {
      inComment : false,
      inString : false,
      inAttributeList : false,
      inScript : false
    };
  }

  function copyStateFn(pState) {
    return {
      inComment : pState.inComment,
      inString : pState.inString,
      inAttributeList : pState.inAttributeList,
      inScript : pState.inScript
    };
  }

  function produceTokenFunction(pConfig) {

    return function(pStream, pState) {
      if (pStream.match(wordRegexp(pConfig.brackets), true, true)) {
        return "bracket";
      }
      /* comments */
      if (!pState.inComment) {
        if (pStream.match(/\/\*[^\*\/]*/, true, true)) {
          pState.inComment = true;
          return "comment";
        }
        if (pStream.match(wordRegexp(pConfig.singlecomment), true, true)) {
          pStream.skipToEnd();
          return "comment";
        }
      }
      if (pState.inComment) {
        if (pStream.match(/[^\*\/]*\*\//, true, true))
          pState.inComment = false;
        else
          pStream.skipToEnd();
        return "comment";
      }
      /* strings */
      if (!pState.inString && pStream.match(/\"(\\\"|[^\"])*/, true, true)) {
        pState.inString = true;
        return "string";
      }
      if (pState.inString) {
        if (pStream.match(/[^\"]*\"/, true, true))
          pState.inString = false;
        else
          pStream.skipToEnd();
        return "string";
      }
      /* keywords & operators */
      if (!!pConfig.keywords && pStream.match(wordRegexpBoundary(pConfig.keywords), true, true))
        return "keyword";

      if (pStream.match(wordRegexpBoundary(pConfig.options), true, true))
        return "keyword";

      if (pStream.match(wordRegexpBoundary(pConfig.arcsWords), true, true))
        return "keyword";

      if (pStream.match(wordRegexp(pConfig.arcsOthers), true, true))
        return "keyword";

      if (!!pConfig.operators && pStream.match(wordRegexp(pConfig.operators), true, true))
        return "operator";

      if (!!pConfig.constants && pStream.match(wordRegexp(pConfig.constants), true, true))
        return "variable";

      /* attribute lists */
      if (!pConfig.inAttributeList && !!pConfig.attributes && pStream.match('[', true, true)) {
        pConfig.inAttributeList = true;
        return "bracket";
      }
      if (pConfig.inAttributeList) {
        if (pConfig.attributes !== null && pStream.match(wordRegexpBoundary(pConfig.attributes), true, true)) {
          return "attribute";
        }
        if (pStream.match(']', true, true)) {
          pConfig.inAttributeList = false;
          return "bracket";
        }
      }

      pStream.next();
      return "base";
    };
  }

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/mumps/mumps.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

/*
  This MUMPS Language script was constructed using vbscript.js as a template.
*/

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
  "use strict";

  CodeMirror.defineMode("mumps", function() {
    function wordRegexp(words) {
      return new RegExp("^((" + words.join(")|(") + "))\\b", "i");
    }

    var singleOperators = new RegExp("^[\\+\\-\\*/&#!_?\\\\<>=\\'\\[\\]]");
    var doubleOperators = new RegExp("^(('=)|(<=)|(>=)|('>)|('<)|([[)|(]])|(^$))");
    var singleDelimiters = new RegExp("^[\\.,:]");
    var brackets = new RegExp("[()]");
    var identifiers = new RegExp("^[%A-Za-z][A-Za-z0-9]*");
    var commandKeywords = ["break","close","do","else","for","goto", "halt", "hang", "if", "job","kill","lock","merge","new","open", "quit", "read", "set", "tcommit", "trollback", "tstart", "use", "view", "write", "xecute", "b","c","d","e","f","g", "h", "i", "j","k","l","m","n","o", "q", "r", "s", "tc", "tro", "ts", "u", "v", "w", "x"];
    // The following list includes intrinsic functions _and_ special variables
    var intrinsicFuncsWords = ["\\$ascii", "\\$char", "\\$data", "\\$ecode", "\\$estack", "\\$etrap", "\\$extract", "\\$find", "\\$fnumber", "\\$get", "\\$horolog", "\\$io", "\\$increment", "\\$job", "\\$justify", "\\$length", "\\$name", "\\$next", "\\$order", "\\$piece", "\\$qlength", "\\$qsubscript", "\\$query", "\\$quit", "\\$random", "\\$reverse", "\\$select", "\\$stack", "\\$test", "\\$text", "\\$translate", "\\$view", "\\$x", "\\$y", "\\$a", "\\$c", "\\$d", "\\$e", "\\$ec", "\\$es", "\\$et", "\\$f", "\\$fn", "\\$g", "\\$h", "\\$i", "\\$j", "\\$l", "\\$n", "\\$na", "\\$o", "\\$p", "\\$q", "\\$ql", "\\$qs", "\\$r", "\\$re", "\\$s", "\\$st", "\\$t", "\\$tr", "\\$v", "\\$z"];
    var intrinsicFuncs = wordRegexp(intrinsicFuncsWords);
    var command = wordRegexp(commandKeywords);

    function tokenBase(stream, state) {
      if (stream.sol()) {
        state.label = true;
        state.commandMode = 0;
      }

      // The <space> character has meaning in MUMPS. Ignoring consecutive
      // spaces would interfere with interpreting whether the next non-space
      // character belongs to the command or argument context.

      // Examine each character and update a mode variable whose interpretation is:
      //   >0 => command    0 => argument    <0 => command post-conditional
      var ch = stream.peek();

      if (ch == " " || ch == "\t") { // Pre-process <space>
        state.label = false;
        if (state.commandMode == 0)
          state.commandMode = 1;
        else if ((state.commandMode < 0) || (state.commandMode == 2))
          state.commandMode = 0;
      } else if ((ch != ".") && (state.commandMode > 0)) {
        if (ch == ":")
          state.commandMode = -1;   // SIS - Command post-conditional
        else
          state.commandMode = 2;
      }

      // Do not color parameter list as line tag
      if ((ch === "(") || (ch === "\u0009"))
        state.label = false;

      // MUMPS comment starts with ";"
      if (ch === ";") {
        stream.skipToEnd();
        return "comment";
      }

      // Number Literals // SIS/RLM - MUMPS permits canonic number followed by concatenate operator
      if (stream.match(/^[-+]?\d+(\.\d+)?([eE][-+]?\d+)?/))
        return "number";

      // Handle Strings
      if (ch == '"') {
        if (stream.skipTo('"')) {
          stream.next();
          return "string";
        } else {
          stream.skipToEnd();
          return "error";
        }
      }

      // Handle operators and Delimiters
      if (stream.match(doubleOperators) || stream.match(singleOperators))
        return "operator";

      // Prevents leading "." in DO block from falling through to error
      if (stream.match(singleDelimiters))
        return null;

      if (brackets.test(ch)) {
        stream.next();
        return "bracket";
      }

      if (state.commandMode > 0 && stream.match(command))
        return "variable-2";

      if (stream.match(intrinsicFuncs))
        return "builtin";

      if (stream.match(identifiers))
        return "variable";

      // Detect dollar-sign when not a documented intrinsic function
      // "^" may introduce a GVN or SSVN - Color same as function
      if (ch === "$" || ch === "^") {
        stream.next();
        return "builtin";
      }

      // MUMPS Indirection
      if (ch === "@") {
        stream.next();
        return "string-2";
      }

      if (/[\w%]/.test(ch)) {
        stream.eatWhile(/[\w%]/);
        return "variable";
      }

      // Handle non-detected items
      stream.next();
      return "error";
    }

    return {
      startState: function() {
        return {
          label: false,
          commandMode: 0
        };
      },

      token: function(stream, state) {
        var style = tokenBase(stream, state);
        if (state.label) return "tag";
        return style;
      }
    };
  });

  CodeMirror.defineMIME("text/x-mumps", "mumps");
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/nginx/nginx.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("nginx", function(config) {

  function words(str) {
    var obj = {}, words = str.split(" ");
    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
    return obj;
  }

  var keywords = words(
    /* ngxDirectiveControl */ "break return rewrite set" +
    /* ngxDirective */ " accept_mutex accept_mutex_delay access_log add_after_body add_before_body add_header addition_types aio alias allow ancient_browser ancient_browser_value auth_basic auth_basic_user_file auth_http auth_http_header auth_http_timeout autoindex autoindex_exact_size autoindex_localtime charset charset_types client_body_buffer_size client_body_in_file_only client_body_in_single_buffer client_body_temp_path client_body_timeout client_header_buffer_size client_header_timeout client_max_body_size connection_pool_size create_full_put_path daemon dav_access dav_methods debug_connection debug_points default_type degradation degrade deny devpoll_changes devpoll_events directio directio_alignment empty_gif env epoll_events error_log eventport_events expires fastcgi_bind fastcgi_buffer_size fastcgi_buffers fastcgi_busy_buffers_size fastcgi_cache fastcgi_cache_key fastcgi_cache_methods fastcgi_cache_min_uses fastcgi_cache_path fastcgi_cache_use_stale fastcgi_cache_valid fastcgi_catch_stderr fastcgi_connect_timeout fastcgi_hide_header fastcgi_ignore_client_abort fastcgi_ignore_headers fastcgi_index fastcgi_intercept_errors fastcgi_max_temp_file_size fastcgi_next_upstream fastcgi_param fastcgi_pass_header fastcgi_pass_request_body fastcgi_pass_request_headers fastcgi_read_timeout fastcgi_send_lowat fastcgi_send_timeout fastcgi_split_path_info fastcgi_store fastcgi_store_access fastcgi_temp_file_write_size fastcgi_temp_path fastcgi_upstream_fail_timeout fastcgi_upstream_max_fails flv geoip_city geoip_country google_perftools_profiles gzip gzip_buffers gzip_comp_level gzip_disable gzip_hash gzip_http_version gzip_min_length gzip_no_buffer gzip_proxied gzip_static gzip_types gzip_vary gzip_window if_modified_since ignore_invalid_headers image_filter image_filter_buffer image_filter_jpeg_quality image_filter_transparency imap_auth imap_capabilities imap_client_buffer index ip_hash keepalive_requests keepalive_timeout kqueue_changes kqueue_events large_client_header_buffers limit_conn limit_conn_log_level limit_rate limit_rate_after limit_req limit_req_log_level limit_req_zone limit_zone lingering_time lingering_timeout lock_file log_format log_not_found log_subrequest map_hash_bucket_size map_hash_max_size master_process memcached_bind memcached_buffer_size memcached_connect_timeout memcached_next_upstream memcached_read_timeout memcached_send_timeout memcached_upstream_fail_timeout memcached_upstream_max_fails merge_slashes min_delete_depth modern_browser modern_browser_value msie_padding msie_refresh multi_accept open_file_cache open_file_cache_errors open_file_cache_events open_file_cache_min_uses open_file_cache_valid open_log_file_cache output_buffers override_charset perl perl_modules perl_require perl_set pid pop3_auth pop3_capabilities port_in_redirect postpone_gzipping postpone_output protocol proxy proxy_bind proxy_buffer proxy_buffer_size proxy_buffering proxy_buffers proxy_busy_buffers_size proxy_cache proxy_cache_key proxy_cache_methods proxy_cache_min_uses proxy_cache_path proxy_cache_use_stale proxy_cache_valid proxy_connect_timeout proxy_headers_hash_bucket_size proxy_headers_hash_max_size proxy_hide_header proxy_ignore_client_abort proxy_ignore_headers proxy_intercept_errors proxy_max_temp_file_size proxy_method proxy_next_upstream proxy_pass_error_message proxy_pass_header proxy_pass_request_body proxy_pass_request_headers proxy_read_timeout proxy_redirect proxy_send_lowat proxy_send_timeout proxy_set_body proxy_set_header proxy_ssl_session_reuse proxy_store proxy_store_access proxy_temp_file_write_size proxy_temp_path proxy_timeout proxy_upstream_fail_timeout proxy_upstream_max_fails random_index read_ahead real_ip_header recursive_error_pages request_pool_size reset_timedout_connection resolver resolver_timeout rewrite_log rtsig_overflow_events rtsig_overflow_test rtsig_overflow_threshold rtsig_signo satisfy secure_link_secret send_lowat send_timeout sendfile sendfile_max_chunk server_name_in_redirect server_names_hash_bucket_size server_names_hash_max_size server_tokens set_real_ip_from smtp_auth smtp_capabilities smtp_client_buffer smtp_greeting_delay so_keepalive source_charset ssi ssi_ignore_recycled_buffers ssi_min_file_chunk ssi_silent_errors ssi_types ssi_value_length ssl ssl_certificate ssl_certificate_key ssl_ciphers ssl_client_certificate ssl_crl ssl_dhparam ssl_engine ssl_prefer_server_ciphers ssl_protocols ssl_session_cache ssl_session_timeout ssl_verify_client ssl_verify_depth starttls stub_status sub_filter sub_filter_once sub_filter_types tcp_nodelay tcp_nopush thread_stack_size timeout timer_resolution types_hash_bucket_size types_hash_max_size underscores_in_headers uninitialized_variable_warn use user userid userid_domain userid_expires userid_mark userid_name userid_p3p userid_path userid_service valid_referers variables_hash_bucket_size variables_hash_max_size worker_connections worker_cpu_affinity worker_priority worker_processes worker_rlimit_core worker_rlimit_nofile worker_rlimit_sigpending worker_threads working_directory xclient xml_entities xslt_stylesheet xslt_typesdrew@li229-23"
    );

  var keywords_block = words(
    /* ngxDirectiveBlock */ "http mail events server types location upstream charset_map limit_except if geo map"
    );

  var keywords_important = words(
    /* ngxDirectiveImportant */ "include root server server_name listen internal proxy_pass memcached_pass fastcgi_pass try_files"
    );

  var indentUnit = config.indentUnit, type;
  function ret(style, tp) {type = tp; return style;}

  function tokenBase(stream, state) {


    stream.eatWhile(/[\w\$_]/);

    var cur = stream.current();


    if (keywords.propertyIsEnumerable(cur)) {
      return "keyword";
    }
    else if (keywords_block.propertyIsEnumerable(cur)) {
      return "variable-2";
    }
    else if (keywords_important.propertyIsEnumerable(cur)) {
      return "string-2";
    }
    /**/

    var ch = stream.next();
    if (ch == "@") {stream.eatWhile(/[\w\\\-]/); return ret("meta", stream.current());}
    else if (ch == "/" && stream.eat("*")) {
      state.tokenize = tokenCComment;
      return tokenCComment(stream, state);
    }
    else if (ch == "<" && stream.eat("!")) {
      state.tokenize = tokenSGMLComment;
      return tokenSGMLComment(stream, state);
    }
    else if (ch == "=") ret(null, "compare");
    else if ((ch == "~" || ch == "|") && stream.eat("=")) return ret(null, "compare");
    else if (ch == "\"" || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    }
    else if (ch == "#") {
      stream.skipToEnd();
      return ret("comment", "comment");
    }
    else if (ch == "!") {
      stream.match(/^\s*\w*/);
      return ret("keyword", "important");
    }
    else if (/\d/.test(ch)) {
      stream.eatWhile(/[\w.%]/);
      return ret("number", "unit");
    }
    else if (/[,.+>*\/]/.test(ch)) {
      return ret(null, "select-op");
    }
    else if (/[;{}:\[\]]/.test(ch)) {
      return ret(null, ch);
    }
    else {
      stream.eatWhile(/[\w\\\-]/);
      return ret("variable", "variable");
    }
  }

  function tokenCComment(stream, state) {
    var maybeEnd = false, ch;
    while ((ch = stream.next()) != null) {
      if (maybeEnd && ch == "/") {
        state.tokenize = tokenBase;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return ret("comment", "comment");
  }

  function tokenSGMLComment(stream, state) {
    var dashes = 0, ch;
    while ((ch = stream.next()) != null) {
      if (dashes >= 2 && ch == ">") {
        state.tokenize = tokenBase;
        break;
      }
      dashes = (ch == "-") ? dashes + 1 : 0;
    }
    return ret("comment", "comment");
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, ch;
      while ((ch = stream.next()) != null) {
        if (ch == quote && !escaped)
          break;
        escaped = !escaped && ch == "\\";
      }
      if (!escaped) state.tokenize = tokenBase;
      return ret("string", "string");
    };
  }

  return {
    startState: function(base) {
      return {tokenize: tokenBase,
              baseIndent: base || 0,
              stack: []};
    },

    token: function(stream, state) {
      if (stream.eatSpace()) return null;
      type = null;
      var style = state.tokenize(stream, state);

      var context = state.stack[state.stack.length-1];
      if (type == "hash" && context == "rule") style = "atom";
      else if (style == "variable") {
        if (context == "rule") style = "number";
        else if (!context || context == "@media{") style = "tag";
      }

      if (context == "rule" && /^[\{\};]$/.test(type))
        state.stack.pop();
      if (type == "{") {
        if (context == "@media") state.stack[state.stack.length-1] = "@media{";
        else state.stack.push("{");
      }
      else if (type == "}") state.stack.pop();
      else if (type == "@media") state.stack.push("@media");
      else if (context == "{" && type != "comment") state.stack.push("rule");
      return style;
    },

    indent: function(state, textAfter) {
      var n = state.stack.length;
      if (/^\}/.test(textAfter))
        n -= state.stack[state.stack.length-1] == "rule" ? 2 : 1;
      return state.baseIndent + n * indentUnit;
    },

    electricChars: "}"
  };
});

CodeMirror.defineMIME("text/x-nginx-conf", "nginx");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/nsis/nsis.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// Author: Jan T. Sott (http://github.com/idleberg)

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"), __webpack_require__("./src/ipywidgets/node_modules/codemirror/addon/mode/simple.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineSimpleMode("nsis",{
  start:[
    // Numbers
    {regex: /(?:[+-]?)(?:0x[\d,a-f]+)|(?:0o[0-7]+)|(?:0b[0,1]+)|(?:\d+.?\d*)/, token: "number"},

    // Strings
    { regex: /"(?:[^\\"]|\\.)*"?/, token: "string" },
    { regex: /'(?:[^\\']|\\.)*'?/, token: "string" },
    { regex: /`(?:[^\\`]|\\.)*`?/, token: "string" },

    // Compile Time Commands
    {regex: /^\s*(?:\!(include|addincludedir|addplugindir|appendfile|cd|delfile|echo|error|execute|packhdr|pragma|finalize|getdllversion|gettlbversion|system|tempfile|warning|verbose|define|undef|insertmacro|macro|macroend|makensis|searchparse|searchreplace))\b/, token: "keyword"},

    // Conditional Compilation
    {regex: /^\s*(?:\!(if(?:n?def)?|ifmacron?def|macro))\b/, token: "keyword", indent: true},
    {regex: /^\s*(?:\!(else|endif|macroend))\b/, token: "keyword", dedent: true},

    // Runtime Commands
    {regex: /^\s*(?:Abort|AddBrandingImage|AddSize|AllowRootDirInstall|AllowSkipFiles|AutoCloseWindow|BGFont|BGGradient|BrandingText|BringToFront|Call|CallInstDLL|Caption|ChangeUI|CheckBitmap|ClearErrors|CompletedText|ComponentText|CopyFiles|CRCCheck|CreateDirectory|CreateFont|CreateShortCut|Delete|DeleteINISec|DeleteINIStr|DeleteRegKey|DeleteRegValue|DetailPrint|DetailsButtonText|DirText|DirVar|DirVerify|EnableWindow|EnumRegKey|EnumRegValue|Exch|Exec|ExecShell|ExecShellWait|ExecWait|ExpandEnvStrings|File|FileBufSize|FileClose|FileErrorText|FileOpen|FileRead|FileReadByte|FileReadUTF16LE|FileReadWord|FileWriteUTF16LE|FileSeek|FileWrite|FileWriteByte|FileWriteWord|FindClose|FindFirst|FindNext|FindWindow|FlushINI|GetCurInstType|GetCurrentAddress|GetDlgItem|GetDLLVersion|GetDLLVersionLocal|GetErrorLevel|GetFileTime|GetFileTimeLocal|GetFullPathName|GetFunctionAddress|GetInstDirError|GetKnownFolderPath|GetLabelAddress|GetTempFileName|Goto|HideWindow|Icon|IfAbort|IfErrors|IfFileExists|IfRebootFlag|IfRtlLanguage|IfShellVarContextAll|IfSilent|InitPluginsDir|InstallButtonText|InstallColors|InstallDir|InstallDirRegKey|InstProgressFlags|InstType|InstTypeGetText|InstTypeSetText|Int64Cmp|Int64CmpU|Int64Fmt|IntCmp|IntCmpU|IntFmt|IntOp|IntPtrCmp|IntPtrCmpU|IntPtrOp|IsWindow|LangString|LicenseBkColor|LicenseData|LicenseForceSelection|LicenseLangString|LicenseText|LoadAndSetImage|LoadLanguageFile|LockWindow|LogSet|LogText|ManifestDPIAware|ManifestLongPathAware|ManifestMaxVersionTested|ManifestSupportedOS|MessageBox|MiscButtonText|Name|Nop|OutFile|Page|PageCallbacks|PEAddResource|PEDllCharacteristics|PERemoveResource|PESubsysVer|Pop|Push|Quit|ReadEnvStr|ReadINIStr|ReadRegDWORD|ReadRegStr|Reboot|RegDLL|Rename|RequestExecutionLevel|ReserveFile|Return|RMDir|SearchPath|SectionGetFlags|SectionGetInstTypes|SectionGetSize|SectionGetText|SectionIn|SectionSetFlags|SectionSetInstTypes|SectionSetSize|SectionSetText|SendMessage|SetAutoClose|SetBrandingImage|SetCompress|SetCompressor|SetCompressorDictSize|SetCtlColors|SetCurInstType|SetDatablockOptimize|SetDateSave|SetDetailsPrint|SetDetailsView|SetErrorLevel|SetErrors|SetFileAttributes|SetFont|SetOutPath|SetOverwrite|SetRebootFlag|SetRegView|SetShellVarContext|SetSilent|ShowInstDetails|ShowUninstDetails|ShowWindow|SilentInstall|SilentUnInstall|Sleep|SpaceTexts|StrCmp|StrCmpS|StrCpy|StrLen|SubCaption|Unicode|UninstallButtonText|UninstallCaption|UninstallIcon|UninstallSubCaption|UninstallText|UninstPage|UnRegDLL|Var|VIAddVersionKey|VIFileVersion|VIProductVersion|WindowIcon|WriteINIStr|WriteRegBin|WriteRegDWORD|WriteRegExpandStr|WriteRegMultiStr|WriteRegNone|WriteRegStr|WriteUninstaller|XPStyle)\b/, token: "keyword"},
    {regex: /^\s*(?:Function|PageEx|Section(?:Group)?)\b/, token: "keyword", indent: true},
    {regex: /^\s*(?:(Function|PageEx|Section(?:Group)?)End)\b/, token: "keyword", dedent: true},

    // Command Options
    {regex: /\b(?:ARCHIVE|FILE_ATTRIBUTE_ARCHIVE|FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_NORMAL|FILE_ATTRIBUTE_OFFLINE|FILE_ATTRIBUTE_READONLY|FILE_ATTRIBUTE_SYSTEM|FILE_ATTRIBUTE_TEMPORARY|HIDDEN|HKCC|HKCR(32|64)?|HKCU(32|64)?|HKDD|HKEY_CLASSES_ROOT|HKEY_CURRENT_CONFIG|HKEY_CURRENT_USER|HKEY_DYN_DATA|HKEY_LOCAL_MACHINE|HKEY_PERFORMANCE_DATA|HKEY_USERS|HKLM(32|64)?|HKPD|HKU|IDABORT|IDCANCEL|IDD_DIR|IDD_INST|IDD_INSTFILES|IDD_LICENSE|IDD_SELCOM|IDD_UNINST|IDD_VERIFY|IDIGNORE|IDNO|IDOK|IDRETRY|IDYES|MB_ABORTRETRYIGNORE|MB_DEFBUTTON1|MB_DEFBUTTON2|MB_DEFBUTTON3|MB_DEFBUTTON4|MB_ICONEXCLAMATION|MB_ICONINFORMATION|MB_ICONQUESTION|MB_ICONSTOP|MB_OK|MB_OKCANCEL|MB_RETRYCANCEL|MB_RIGHT|MB_RTLREADING|MB_SETFOREGROUND|MB_TOPMOST|MB_USERICON|MB_YESNO|MB_YESNOCANCEL|NORMAL|OFFLINE|READONLY|SHCTX|SHELL_CONTEXT|SW_HIDE|SW_SHOWDEFAULT|SW_SHOWMAXIMIZED|SW_SHOWMINIMIZED|SW_SHOWNORMAL|SYSTEM|TEMPORARY)\b/, token: "atom"},
    {regex: /\b(?:admin|all|auto|both|bottom|bzip2|components|current|custom|directory|false|force|hide|highest|ifdiff|ifnewer|instfiles|lastused|leave|left|license|listonly|lzma|nevershow|none|normal|notset|off|on|right|show|silent|silentlog|textonly|top|true|try|un\.components|un\.custom|un\.directory|un\.instfiles|un\.license|uninstConfirm|user|Win10|Win7|Win8|WinVista|zlib)\b/, token: "builtin"},

    // LogicLib.nsh
    {regex: /\$\{(?:And(?:If(?:Not)?|Unless)|Break|Case(?:Else)?|Continue|Default|Do(?:Until|While)?|Else(?:If(?:Not)?|Unless)?|End(?:If|Select|Switch)|Exit(?:Do|For|While)|For(?:Each)?|If(?:Cmd|Not(?:Then)?|Then)?|Loop(?:Until|While)?|Or(?:If(?:Not)?|Unless)|Select|Switch|Unless|While)\}/, token: "variable-2", indent: true},

    // FileFunc.nsh
    {regex: /\$\{(?:BannerTrimPath|DirState|DriveSpace|Get(BaseName|Drives|ExeName|ExePath|FileAttributes|FileExt|FileName|FileVersion|Options|OptionsS|Parameters|Parent|Root|Size|Time)|Locate|RefreshShellIcons)\}/, token: "variable-2", dedent: true},

    // Memento.nsh
    {regex: /\$\{(?:Memento(?:Section(?:Done|End|Restore|Save)?|UnselectedSection))\}/, token: "variable-2", dedent: true},

    // TextFunc.nsh
    {regex: /\$\{(?:Config(?:Read|ReadS|Write|WriteS)|File(?:Join|ReadFromEnd|Recode)|Line(?:Find|Read|Sum)|Text(?:Compare|CompareS)|TrimNewLines)\}/, token: "variable-2", dedent: true},

    // WinVer.nsh
    {regex: /\$\{(?:(?:At(?:Least|Most)|Is)(?:ServicePack|Win(?:7|8|10|95|98|200(?:0|3|8(?:R2)?)|ME|NT4|Vista|XP))|Is(?:NT|Server))\}/, token: "variable", dedent: true},

    // WordFunc.nsh
    {regex: /\$\{(?:StrFilterS?|Version(?:Compare|Convert)|Word(?:AddS?|Find(?:(?:2|3)X)?S?|InsertS?|ReplaceS?))\}/, token: "variable-2", dedent: true},

    // x64.nsh
    {regex: /\$\{(?:RunningX64)\}/, token: "variable", dedent: true},
    {regex: /\$\{(?:Disable|Enable)X64FSRedirection\}/, token: "variable-2", dedent: true},

    // Line Comment
    {regex: /(#|;).*/, token: "comment"},

    // Block Comment
    {regex: /\/\*/, token: "comment", next: "comment"},

    // Operator
    {regex: /[-+\/*=<>!]+/, token: "operator"},

    // Variable
    {regex: /\$\w+/, token: "variable"},

    // Constant
    {regex: /\${[\w\.:-]+}/, token: "variable-2"},

    // Language String
    {regex: /\$\([\w\.:-]+\)/, token: "variable-3"}
  ],
  comment: [
    {regex: /.*?\*\//, token: "comment", next: "start"},
    {regex: /.*/, token: "comment"}
  ],
  meta: {
    electricInput: /^\s*((Function|PageEx|Section|Section(Group)?)End|(\!(endif|macroend))|\$\{(End(If|Unless|While)|Loop(Until)|Next)\})$/,
    blockCommentStart: "/*",
    blockCommentEnd: "*/",
    lineComment: ["#", ";"]
  }
});

CodeMirror.defineMIME("text/x-nsis", "nsis");
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/ntriples/ntriples.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

/**********************************************************
* This script provides syntax highlighting support for
* the N-Triples format.
* N-Triples format specification:
*     https://www.w3.org/TR/n-triples/
***********************************************************/

/*
    The following expression defines the defined ASF grammar transitions.

    pre_subject ->
        {
        ( writing_subject_uri | writing_bnode_uri )
            -> pre_predicate
                -> writing_predicate_uri
                    -> pre_object
                        -> writing_object_uri | writing_object_bnode |
                          (
                            writing_object_literal
                                -> writing_literal_lang | writing_literal_type
                          )
                            -> post_object
                                -> BEGIN
         } otherwise {
             -> ERROR
         }
*/

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("ntriples", function() {

  var Location = {
    PRE_SUBJECT         : 0,
    WRITING_SUB_URI     : 1,
    WRITING_BNODE_URI   : 2,
    PRE_PRED            : 3,
    WRITING_PRED_URI    : 4,
    PRE_OBJ             : 5,
    WRITING_OBJ_URI     : 6,
    WRITING_OBJ_BNODE   : 7,
    WRITING_OBJ_LITERAL : 8,
    WRITING_LIT_LANG    : 9,
    WRITING_LIT_TYPE    : 10,
    POST_OBJ            : 11,
    ERROR               : 12
  };
  function transitState(currState, c) {
    var currLocation = currState.location;
    var ret;

    // Opening.
    if     (currLocation == Location.PRE_SUBJECT && c == '<') ret = Location.WRITING_SUB_URI;
    else if(currLocation == Location.PRE_SUBJECT && c == '_') ret = Location.WRITING_BNODE_URI;
    else if(currLocation == Location.PRE_PRED    && c == '<') ret = Location.WRITING_PRED_URI;
    else if(currLocation == Location.PRE_OBJ     && c == '<') ret = Location.WRITING_OBJ_URI;
    else if(currLocation == Location.PRE_OBJ     && c == '_') ret = Location.WRITING_OBJ_BNODE;
    else if(currLocation == Location.PRE_OBJ     && c == '"') ret = Location.WRITING_OBJ_LITERAL;

    // Closing.
    else if(currLocation == Location.WRITING_SUB_URI     && c == '>') ret = Location.PRE_PRED;
    else if(currLocation == Location.WRITING_BNODE_URI   && c == ' ') ret = Location.PRE_PRED;
    else if(currLocation == Location.WRITING_PRED_URI    && c == '>') ret = Location.PRE_OBJ;
    else if(currLocation == Location.WRITING_OBJ_URI     && c == '>') ret = Location.POST_OBJ;
    else if(currLocation == Location.WRITING_OBJ_BNODE   && c == ' ') ret = Location.POST_OBJ;
    else if(currLocation == Location.WRITING_OBJ_LITERAL && c == '"') ret = Location.POST_OBJ;
    else if(currLocation == Location.WRITING_LIT_LANG && c == ' ') ret = Location.POST_OBJ;
    else if(currLocation == Location.WRITING_LIT_TYPE && c == '>') ret = Location.POST_OBJ;

    // Closing typed and language literal.
    else if(currLocation == Location.WRITING_OBJ_LITERAL && c == '@') ret = Location.WRITING_LIT_LANG;
    else if(currLocation == Location.WRITING_OBJ_LITERAL && c == '^') ret = Location.WRITING_LIT_TYPE;

    // Spaces.
    else if( c == ' ' &&
             (
               currLocation == Location.PRE_SUBJECT ||
               currLocation == Location.PRE_PRED    ||
               currLocation == Location.PRE_OBJ     ||
               currLocation == Location.POST_OBJ
             )
           ) ret = currLocation;

    // Reset.
    else if(currLocation == Location.POST_OBJ && c == '.') ret = Location.PRE_SUBJECT;

    // Error
    else ret = Location.ERROR;

    currState.location=ret;
  }

  return {
    startState: function() {
       return {
           location : Location.PRE_SUBJECT,
           uris     : [],
           anchors  : [],
           bnodes   : [],
           langs    : [],
           types    : []
       };
    },
    token: function(stream, state) {
      var ch = stream.next();
      if(ch == '<') {
         transitState(state, ch);
         var parsedURI = '';
         stream.eatWhile( function(c) { if( c != '#' && c != '>' ) { parsedURI += c; return true; } return false;} );
         state.uris.push(parsedURI);
         if( stream.match('#', false) ) return 'variable';
         stream.next();
         transitState(state, '>');
         return 'variable';
      }
      if(ch == '#') {
        var parsedAnchor = '';
        stream.eatWhile(function(c) { if(c != '>' && c != ' ') { parsedAnchor+= c; return true; } return false;});
        state.anchors.push(parsedAnchor);
        return 'variable-2';
      }
      if(ch == '>') {
          transitState(state, '>');
          return 'variable';
      }
      if(ch == '_') {
          transitState(state, ch);
          var parsedBNode = '';
          stream.eatWhile(function(c) { if( c != ' ' ) { parsedBNode += c; return true; } return false;});
          state.bnodes.push(parsedBNode);
          stream.next();
          transitState(state, ' ');
          return 'builtin';
      }
      if(ch == '"') {
          transitState(state, ch);
          stream.eatWhile( function(c) { return c != '"'; } );
          stream.next();
          if( stream.peek() != '@' && stream.peek() != '^' ) {
              transitState(state, '"');
          }
          return 'string';
      }
      if( ch == '@' ) {
          transitState(state, '@');
          var parsedLang = '';
          stream.eatWhile(function(c) { if( c != ' ' ) { parsedLang += c; return true; } return false;});
          state.langs.push(parsedLang);
          stream.next();
          transitState(state, ' ');
          return 'string-2';
      }
      if( ch == '^' ) {
          stream.next();
          transitState(state, '^');
          var parsedType = '';
          stream.eatWhile(function(c) { if( c != '>' ) { parsedType += c; return true; } return false;} );
          state.types.push(parsedType);
          stream.next();
          transitState(state, '>');
          return 'variable';
      }
      if( ch == ' ' ) {
          transitState(state, ch);
      }
      if( ch == '.' ) {
          transitState(state, ch);
      }
    }
  };
});

// define the registered Media Type for n-triples:
// https://www.w3.org/TR/n-triples/#n-triples-mediatype
CodeMirror.defineMIME("application/n-triples", "ntriples");

// N-Quads is based on the N-Triples format (so same highlighting works)
// https://www.w3.org/TR/n-quads/
CodeMirror.defineMIME("application/n-quads", "ntriples");

// previously used, though technically incorrect media type for n-triples
CodeMirror.defineMIME("text/n-triples", "ntriples");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/octave/octave.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("octave", function() {
  function wordRegexp(words) {
    return new RegExp("^((" + words.join(")|(") + "))\\b");
  }

  var singleOperators = new RegExp("^[\\+\\-\\*/&|\\^~<>!@'\\\\]");
  var singleDelimiters = new RegExp('^[\\(\\[\\{\\},:=;\\.]');
  var doubleOperators = new RegExp("^((==)|(~=)|(<=)|(>=)|(<<)|(>>)|(\\.[\\+\\-\\*/\\^\\\\]))");
  var doubleDelimiters = new RegExp("^((!=)|(\\+=)|(\\-=)|(\\*=)|(/=)|(&=)|(\\|=)|(\\^=))");
  var tripleDelimiters = new RegExp("^((>>=)|(<<=))");
  var expressionEnd = new RegExp("^[\\]\\)]");
  var identifiers = new RegExp("^[_A-Za-z\xa1-\uffff][_A-Za-z0-9\xa1-\uffff]*");

  var builtins = wordRegexp([
    'error', 'eval', 'function', 'abs', 'acos', 'atan', 'asin', 'cos',
    'cosh', 'exp', 'log', 'prod', 'sum', 'log10', 'max', 'min', 'sign', 'sin', 'sinh',
    'sqrt', 'tan', 'reshape', 'break', 'zeros', 'default', 'margin', 'round', 'ones',
    'rand', 'syn', 'ceil', 'floor', 'size', 'clear', 'zeros', 'eye', 'mean', 'std', 'cov',
    'det', 'eig', 'inv', 'norm', 'rank', 'trace', 'expm', 'logm', 'sqrtm', 'linspace', 'plot',
    'title', 'xlabel', 'ylabel', 'legend', 'text', 'grid', 'meshgrid', 'mesh', 'num2str',
    'fft', 'ifft', 'arrayfun', 'cellfun', 'input', 'fliplr', 'flipud', 'ismember'
  ]);

  var keywords = wordRegexp([
    'return', 'case', 'switch', 'else', 'elseif', 'end', 'endif', 'endfunction',
    'if', 'otherwise', 'do', 'for', 'while', 'try', 'catch', 'classdef', 'properties', 'events',
    'methods', 'global', 'persistent', 'endfor', 'endwhile', 'printf', 'sprintf', 'disp', 'until',
    'continue', 'pkg'
  ]);


  // tokenizers
  function tokenTranspose(stream, state) {
    if (!stream.sol() && stream.peek() === '\'') {
      stream.next();
      state.tokenize = tokenBase;
      return 'operator';
    }
    state.tokenize = tokenBase;
    return tokenBase(stream, state);
  }


  function tokenComment(stream, state) {
    if (stream.match(/^.*%}/)) {
      state.tokenize = tokenBase;
      return 'comment';
    };
    stream.skipToEnd();
    return 'comment';
  }

  function tokenBase(stream, state) {
    // whitespaces
    if (stream.eatSpace()) return null;

    // Handle one line Comments
    if (stream.match('%{')){
      state.tokenize = tokenComment;
      stream.skipToEnd();
      return 'comment';
    }

    if (stream.match(/^[%#]/)){
      stream.skipToEnd();
      return 'comment';
    }

    // Handle Number Literals
    if (stream.match(/^[0-9\.+-]/, false)) {
      if (stream.match(/^[+-]?0x[0-9a-fA-F]+[ij]?/)) {
        stream.tokenize = tokenBase;
        return 'number'; };
      if (stream.match(/^[+-]?\d*\.\d+([EeDd][+-]?\d+)?[ij]?/)) { return 'number'; };
      if (stream.match(/^[+-]?\d+([EeDd][+-]?\d+)?[ij]?/)) { return 'number'; };
    }
    if (stream.match(wordRegexp(['nan','NaN','inf','Inf']))) { return 'number'; };

    // Handle Strings
    var m = stream.match(/^"(?:[^"]|"")*("|$)/) || stream.match(/^'(?:[^']|'')*('|$)/)
    if (m) { return m[1] ? 'string' : "string error"; }

    // Handle words
    if (stream.match(keywords)) { return 'keyword'; } ;
    if (stream.match(builtins)) { return 'builtin'; } ;
    if (stream.match(identifiers)) { return 'variable'; } ;

    if (stream.match(singleOperators) || stream.match(doubleOperators)) { return 'operator'; };
    if (stream.match(singleDelimiters) || stream.match(doubleDelimiters) || stream.match(tripleDelimiters)) { return null; };

    if (stream.match(expressionEnd)) {
      state.tokenize = tokenTranspose;
      return null;
    };


    // Handle non-detected items
    stream.next();
    return 'error';
  };


  return {
    startState: function() {
      return {
        tokenize: tokenBase
      };
    },

    token: function(stream, state) {
      var style = state.tokenize(stream, state);
      if (style === 'number' || style === 'variable'){
        state.tokenize = tokenTranspose;
      }
      return style;
    },

    lineComment: '%',

    fold: 'indent'
  };
});

CodeMirror.defineMIME("text/x-octave", "octave");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/oz/oz.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("oz", function (conf) {

  function wordRegexp(words) {
    return new RegExp("^((" + words.join(")|(") + "))\\b");
  }

  var singleOperators = /[\^@!\|<>#~\.\*\-\+\\/,=]/;
  var doubleOperators = /(<-)|(:=)|(=<)|(>=)|(<=)|(<:)|(>:)|(=:)|(\\=)|(\\=:)|(!!)|(==)|(::)/;
  var tripleOperators = /(:::)|(\.\.\.)|(=<:)|(>=:)/;

  var middle = ["in", "then", "else", "of", "elseof", "elsecase", "elseif", "catch",
    "finally", "with", "require", "prepare", "import", "export", "define", "do"];
  var end = ["end"];

  var atoms = wordRegexp(["true", "false", "nil", "unit"]);
  var commonKeywords = wordRegexp(["andthen", "at", "attr", "declare", "feat", "from", "lex",
    "mod", "div", "mode", "orelse", "parser", "prod", "prop", "scanner", "self", "syn", "token"]);
  var openingKeywords = wordRegexp(["local", "proc", "fun", "case", "class", "if", "cond", "or", "dis",
    "choice", "not", "thread", "try", "raise", "lock", "for", "suchthat", "meth", "functor"]);
  var middleKeywords = wordRegexp(middle);
  var endKeywords = wordRegexp(end);

  // Tokenizers
  function tokenBase(stream, state) {
    if (stream.eatSpace()) {
      return null;
    }

    // Brackets
    if(stream.match(/[{}]/)) {
      return "bracket";
    }

    // Special [] keyword
    if (stream.match('[]')) {
        return "keyword"
    }

    // Operators
    if (stream.match(tripleOperators) || stream.match(doubleOperators)) {
      return "operator";
    }

    // Atoms
    if(stream.match(atoms)) {
      return 'atom';
    }

    // Opening keywords
    var matched = stream.match(openingKeywords);
    if (matched) {
      if (!state.doInCurrentLine)
        state.currentIndent++;
      else
        state.doInCurrentLine = false;

      // Special matching for signatures
      if(matched[0] == "proc" || matched[0] == "fun")
        state.tokenize = tokenFunProc;
      else if(matched[0] == "class")
        state.tokenize = tokenClass;
      else if(matched[0] == "meth")
        state.tokenize = tokenMeth;

      return 'keyword';
    }

    // Middle and other keywords
    if (stream.match(middleKeywords) || stream.match(commonKeywords)) {
      return "keyword"
    }

    // End keywords
    if (stream.match(endKeywords)) {
      state.currentIndent--;
      return 'keyword';
    }

    // Eat the next char for next comparisons
    var ch = stream.next();

    // Strings
    if (ch == '"' || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    }

    // Numbers
    if (/[~\d]/.test(ch)) {
      if (ch == "~") {
        if(! /^[0-9]/.test(stream.peek()))
          return null;
        else if (( stream.next() == "0" && stream.match(/^[xX][0-9a-fA-F]+/)) || stream.match(/^[0-9]*(\.[0-9]+)?([eE][~+]?[0-9]+)?/))
          return "number";
      }

      if ((ch == "0" && stream.match(/^[xX][0-9a-fA-F]+/)) || stream.match(/^[0-9]*(\.[0-9]+)?([eE][~+]?[0-9]+)?/))
        return "number";

      return null;
    }

    // Comments
    if (ch == "%") {
      stream.skipToEnd();
      return 'comment';
    }
    else if (ch == "/") {
      if (stream.eat("*")) {
        state.tokenize = tokenComment;
        return tokenComment(stream, state);
      }
    }

    // Single operators
    if(singleOperators.test(ch)) {
      return "operator";
    }

    // If nothing match, we skip the entire alphanumeric block
    stream.eatWhile(/\w/);

    return "variable";
  }

  function tokenClass(stream, state) {
    if (stream.eatSpace()) {
      return null;
    }
    stream.match(/([A-Z][A-Za-z0-9_]*)|(`.+`)/);
    state.tokenize = tokenBase;
    return "variable-3"
  }

  function tokenMeth(stream, state) {
    if (stream.eatSpace()) {
      return null;
    }
    stream.match(/([a-zA-Z][A-Za-z0-9_]*)|(`.+`)/);
    state.tokenize = tokenBase;
    return "def"
  }

  function tokenFunProc(stream, state) {
    if (stream.eatSpace()) {
      return null;
    }

    if(!state.hasPassedFirstStage && stream.eat("{")) {
      state.hasPassedFirstStage = true;
      return "bracket";
    }
    else if(state.hasPassedFirstStage) {
      stream.match(/([A-Z][A-Za-z0-9_]*)|(`.+`)|\$/);
      state.hasPassedFirstStage = false;
      state.tokenize = tokenBase;
      return "def"
    }
    else {
      state.tokenize = tokenBase;
      return null;
    }
  }

  function tokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" && maybeEnd) {
        state.tokenize = tokenBase;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return "comment";
  }

  function tokenString(quote) {
    return function (stream, state) {
      var escaped = false, next, end = false;
      while ((next = stream.next()) != null) {
        if (next == quote && !escaped) {
          end = true;
          break;
        }
        escaped = !escaped && next == "\\";
      }
      if (end || !escaped)
        state.tokenize = tokenBase;
      return "string";
    };
  }

  function buildElectricInputRegEx() {
    // Reindentation should occur on [] or on a match of any of
    // the block closing keywords, at the end of a line.
    var allClosings = middle.concat(end);
    return new RegExp("[\\[\\]]|(" + allClosings.join("|") + ")$");
  }

  return {

    startState: function () {
      return {
        tokenize: tokenBase,
        currentIndent: 0,
        doInCurrentLine: false,
        hasPassedFirstStage: false
      };
    },

    token: function (stream, state) {
      if (stream.sol())
        state.doInCurrentLine = 0;

      return state.tokenize(stream, state);
    },

    indent: function (state, textAfter) {
      var trueText = textAfter.replace(/^\s+|\s+$/g, '');

      if (trueText.match(endKeywords) || trueText.match(middleKeywords) || trueText.match(/(\[])/))
        return conf.indentUnit * (state.currentIndent - 1);

      if (state.currentIndent < 0)
        return 0;

      return state.currentIndent * conf.indentUnit;
    },
    fold: "indent",
    electricInput: buildElectricInputRegEx(),
    lineComment: "%",
    blockCommentStart: "/*",
    blockCommentEnd: "*/"
  };
});

CodeMirror.defineMIME("text/x-oz", "oz");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/pascal/pascal.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("pascal", function() {
  function words(str) {
    var obj = {}, words = str.split(" ");
    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
    return obj;
  }
  var keywords = words(
    "absolute and array asm begin case const constructor destructor div do " +
    "downto else end file for function goto if implementation in inherited " +
    "inline interface label mod nil not object of operator or packed procedure " +
    "program record reintroduce repeat self set shl shr string then to type " +
    "unit until uses var while with xor as class dispinterface except exports " +
    "finalization finally initialization inline is library on out packed " +
    "property raise resourcestring threadvar try absolute abstract alias " +
    "assembler bitpacked break cdecl continue cppdecl cvar default deprecated " +
    "dynamic enumerator experimental export external far far16 forward generic " +
    "helper implements index interrupt iocheck local message name near " +
    "nodefault noreturn nostackframe oldfpccall otherwise overload override " +
    "pascal platform private protected public published read register " +
    "reintroduce result safecall saveregisters softfloat specialize static " +
    "stdcall stored strict unaligned unimplemented varargs virtual write");
  var atoms = {"null": true};

  var isOperatorChar = /[+\-*&%=<>!?|\/]/;

  function tokenBase(stream, state) {
    var ch = stream.next();
    if (ch == "#" && state.startOfLine) {
      stream.skipToEnd();
      return "meta";
    }
    if (ch == '"' || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    }
    if (ch == "(" && stream.eat("*")) {
      state.tokenize = tokenComment;
      return tokenComment(stream, state);
    }
    if (ch == "{") {
      state.tokenize = tokenCommentBraces;
      return tokenCommentBraces(stream, state);
    }
    if (/[\[\]\(\),;\:\.]/.test(ch)) {
      return null;
    }
    if (/\d/.test(ch)) {
      stream.eatWhile(/[\w\.]/);
      return "number";
    }
    if (ch == "/") {
      if (stream.eat("/")) {
        stream.skipToEnd();
        return "comment";
      }
    }
    if (isOperatorChar.test(ch)) {
      stream.eatWhile(isOperatorChar);
      return "operator";
    }
    stream.eatWhile(/[\w\$_]/);
    var cur = stream.current();
    if (keywords.propertyIsEnumerable(cur)) return "keyword";
    if (atoms.propertyIsEnumerable(cur)) return "atom";
    return "variable";
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, next, end = false;
      while ((next = stream.next()) != null) {
        if (next == quote && !escaped) {end = true; break;}
        escaped = !escaped && next == "\\";
      }
      if (end || !escaped) state.tokenize = null;
      return "string";
    };
  }

  function tokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == ")" && maybeEnd) {
        state.tokenize = null;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return "comment";
  }

  function tokenCommentBraces(stream, state) {
    var ch;
    while (ch = stream.next()) {
      if (ch == "}") {
        state.tokenize = null;
        break;
      }
    }
    return "comment";
  }

  // Interface

  return {
    startState: function() {
      return {tokenize: null};
    },

    token: function(stream, state) {
      if (stream.eatSpace()) return null;
      var style = (state.tokenize || tokenBase)(stream, state);
      if (style == "comment" || style == "meta") return style;
      return style;
    },

    electricChars: "{}"
  };
});

CodeMirror.defineMIME("text/x-pascal", "pascal");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/pegjs/pegjs.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"), __webpack_require__("./src/ipywidgets/node_modules/codemirror/mode/javascript/javascript.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("pegjs", function (config) {
  var jsMode = CodeMirror.getMode(config, "javascript");

  function identifier(stream) {
    return stream.match(/^[a-zA-Z_][a-zA-Z0-9_]*/);
  }

  return {
    startState: function () {
      return {
        inString: false,
        stringType: null,
        inComment: false,
        inCharacterClass: false,
        braced: 0,
        lhs: true,
        localState: null
      };
    },
    token: function (stream, state) {
      if (stream)

      //check for state changes
      if (!state.inString && !state.inComment && ((stream.peek() == '"') || (stream.peek() == "'"))) {
        state.stringType = stream.peek();
        stream.next(); // Skip quote
        state.inString = true; // Update state
      }
      if (!state.inString && !state.inComment && stream.match('/*')) {
        state.inComment = true;
      }

      //return state
      if (state.inString) {
        while (state.inString && !stream.eol()) {
          if (stream.peek() === state.stringType) {
            stream.next(); // Skip quote
            state.inString = false; // Clear flag
          } else if (stream.peek() === '\\') {
            stream.next();
            stream.next();
          } else {
            stream.match(/^.[^\\\"\']*/);
          }
        }
        return state.lhs ? "property string" : "string"; // Token style
      } else if (state.inComment) {
        while (state.inComment && !stream.eol()) {
          if (stream.match('*/')) {
            state.inComment = false; // Clear flag
          } else {
            stream.match(/^.[^\*]*/);
          }
        }
        return "comment";
      } else if (state.inCharacterClass) {
          while (state.inCharacterClass && !stream.eol()) {
            if (!(stream.match(/^[^\]\\]+/) || stream.match(/^\\./))) {
              state.inCharacterClass = false;
            }
          }
      } else if (stream.peek() === '[') {
        stream.next();
        state.inCharacterClass = true;
        return 'bracket';
      } else if (stream.match('//')) {
        stream.skipToEnd();
        return "comment";
      } else if (state.braced || stream.peek() === '{') {
        if (state.localState === null) {
          state.localState = CodeMirror.startState(jsMode);
        }
        var token = jsMode.token(stream, state.localState);
        var text = stream.current();
        if (!token) {
          for (var i = 0; i < text.length; i++) {
            if (text[i] === '{') {
              state.braced++;
            } else if (text[i] === '}') {
              state.braced--;
            }
          };
        }
        return token;
      } else if (identifier(stream)) {
        if (stream.peek() === ':') {
          return 'variable';
        }
        return 'variable-2';
      } else if (['[', ']', '(', ')'].indexOf(stream.peek()) != -1) {
        stream.next();
        return 'bracket';
      } else if (!stream.eatSpace()) {
        stream.next();
      }
      return null;
    }
  };
}, "javascript");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/perl/perl.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// CodeMirror2 mode/perl/perl.js (text/x-perl) beta 0.10 (2011-11-08)
// This is a part of CodeMirror from https://github.com/sabaca/CodeMirror_mode_perl (mail@sabaca.com)

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("perl",function(){
        // http://perldoc.perl.org
        var PERL={                                      //   null - magic touch
                                                        //   1 - keyword
                                                        //   2 - def
                                                        //   3 - atom
                                                        //   4 - operator
                                                        //   5 - variable-2 (predefined)
                                                        //   [x,y] - x=1,2,3; y=must be defined if x{...}
                                                //      PERL operators
                '->'                            :   4,
                '++'                            :   4,
                '--'                            :   4,
                '**'                            :   4,
                                                        //   ! ~ \ and unary + and -
                '=~'                            :   4,
                '!~'                            :   4,
                '*'                             :   4,
                '/'                             :   4,
                '%'                             :   4,
                'x'                             :   4,
                '+'                             :   4,
                '-'                             :   4,
                '.'                             :   4,
                '<<'                            :   4,
                '>>'                            :   4,
                                                        //   named unary operators
                '<'                             :   4,
                '>'                             :   4,
                '<='                            :   4,
                '>='                            :   4,
                'lt'                            :   4,
                'gt'                            :   4,
                'le'                            :   4,
                'ge'                            :   4,
                '=='                            :   4,
                '!='                            :   4,
                '<=>'                           :   4,
                'eq'                            :   4,
                'ne'                            :   4,
                'cmp'                           :   4,
                '~~'                            :   4,
                '&'                             :   4,
                '|'                             :   4,
                '^'                             :   4,
                '&&'                            :   4,
                '||'                            :   4,
                '//'                            :   4,
                '..'                            :   4,
                '...'                           :   4,
                '?'                             :   4,
                ':'                             :   4,
                '='                             :   4,
                '+='                            :   4,
                '-='                            :   4,
                '*='                            :   4,  //   etc. ???
                ','                             :   4,
                '=>'                            :   4,
                '::'                            :   4,
                                                        //   list operators (rightward)
                'not'                           :   4,
                'and'                           :   4,
                'or'                            :   4,
                'xor'                           :   4,
                                                //      PERL predefined variables (I know, what this is a paranoid idea, but may be needed for people, who learn PERL, and for me as well, ...and may be for you?;)
                'BEGIN'                         :   [5,1],
                'END'                           :   [5,1],
                'PRINT'                         :   [5,1],
                'PRINTF'                        :   [5,1],
                'GETC'                          :   [5,1],
                'READ'                          :   [5,1],
                'READLINE'                      :   [5,1],
                'DESTROY'                       :   [5,1],
                'TIE'                           :   [5,1],
                'TIEHANDLE'                     :   [5,1],
                'UNTIE'                         :   [5,1],
                'STDIN'                         :    5,
                'STDIN_TOP'                     :    5,
                'STDOUT'                        :    5,
                'STDOUT_TOP'                    :    5,
                'STDERR'                        :    5,
                'STDERR_TOP'                    :    5,
                '$ARG'                          :    5,
                '$_'                            :    5,
                '@ARG'                          :    5,
                '@_'                            :    5,
                '$LIST_SEPARATOR'               :    5,
                '$"'                            :    5,
                '$PROCESS_ID'                   :    5,
                '$PID'                          :    5,
                '$$'                            :    5,
                '$REAL_GROUP_ID'                :    5,
                '$GID'                          :    5,
                '$('                            :    5,
                '$EFFECTIVE_GROUP_ID'           :    5,
                '$EGID'                         :    5,
                '$)'                            :    5,
                '$PROGRAM_NAME'                 :    5,
                '$0'                            :    5,
                '$SUBSCRIPT_SEPARATOR'          :    5,
                '$SUBSEP'                       :    5,
                '$;'                            :    5,
                '$REAL_USER_ID'                 :    5,
                '$UID'                          :    5,
                '$<'                            :    5,
                '$EFFECTIVE_USER_ID'            :    5,
                '$EUID'                         :    5,
                '$>'                            :    5,
                '$a'                            :    5,
                '$b'                            :    5,
                '$COMPILING'                    :    5,
                '$^C'                           :    5,
                '$DEBUGGING'                    :    5,
                '$^D'                           :    5,
                '${^ENCODING}'                  :    5,
                '$ENV'                          :    5,
                '%ENV'                          :    5,
                '$SYSTEM_FD_MAX'                :    5,
                '$^F'                           :    5,
                '@F'                            :    5,
                '${^GLOBAL_PHASE}'              :    5,
                '$^H'                           :    5,
                '%^H'                           :    5,
                '@INC'                          :    5,
                '%INC'                          :    5,
                '$INPLACE_EDIT'                 :    5,
                '$^I'                           :    5,
                '$^M'                           :    5,
                '$OSNAME'                       :    5,
                '$^O'                           :    5,
                '${^OPEN}'                      :    5,
                '$PERLDB'                       :    5,
                '$^P'                           :    5,
                '$SIG'                          :    5,
                '%SIG'                          :    5,
                '$BASETIME'                     :    5,
                '$^T'                           :    5,
                '${^TAINT}'                     :    5,
                '${^UNICODE}'                   :    5,
                '${^UTF8CACHE}'                 :    5,
                '${^UTF8LOCALE}'                :    5,
                '$PERL_VERSION'                 :    5,
                '$^V'                           :    5,
                '${^WIN32_SLOPPY_STAT}'         :    5,
                '$EXECUTABLE_NAME'              :    5,
                '$^X'                           :    5,
                '$1'                            :    5, // - regexp $1, $2...
                '$MATCH'                        :    5,
                '$&'                            :    5,
                '${^MATCH}'                     :    5,
                '$PREMATCH'                     :    5,
                '$`'                            :    5,
                '${^PREMATCH}'                  :    5,
                '$POSTMATCH'                    :    5,
                "$'"                            :    5,
                '${^POSTMATCH}'                 :    5,
                '$LAST_PAREN_MATCH'             :    5,
                '$+'                            :    5,
                '$LAST_SUBMATCH_RESULT'         :    5,
                '$^N'                           :    5,
                '@LAST_MATCH_END'               :    5,
                '@+'                            :    5,
                '%LAST_PAREN_MATCH'             :    5,
                '%+'                            :    5,
                '@LAST_MATCH_START'             :    5,
                '@-'                            :    5,
                '%LAST_MATCH_START'             :    5,
                '%-'                            :    5,
                '$LAST_REGEXP_CODE_RESULT'      :    5,
                '$^R'                           :    5,
                '${^RE_DEBUG_FLAGS}'            :    5,
                '${^RE_TRIE_MAXBUF}'            :    5,
                '$ARGV'                         :    5,
                '@ARGV'                         :    5,
                'ARGV'                          :    5,
                'ARGVOUT'                       :    5,
                '$OUTPUT_FIELD_SEPARATOR'       :    5,
                '$OFS'                          :    5,
                '$,'                            :    5,
                '$INPUT_LINE_NUMBER'            :    5,
                '$NR'                           :    5,
                '$.'                            :    5,
                '$INPUT_RECORD_SEPARATOR'       :    5,
                '$RS'                           :    5,
                '$/'                            :    5,
                '$OUTPUT_RECORD_SEPARATOR'      :    5,
                '$ORS'                          :    5,
                '$\\'                           :    5,
                '$OUTPUT_AUTOFLUSH'             :    5,
                '$|'                            :    5,
                '$ACCUMULATOR'                  :    5,
                '$^A'                           :    5,
                '$FORMAT_FORMFEED'              :    5,
                '$^L'                           :    5,
                '$FORMAT_PAGE_NUMBER'           :    5,
                '$%'                            :    5,
                '$FORMAT_LINES_LEFT'            :    5,
                '$-'                            :    5,
                '$FORMAT_LINE_BREAK_CHARACTERS' :    5,
                '$:'                            :    5,
                '$FORMAT_LINES_PER_PAGE'        :    5,
                '$='                            :    5,
                '$FORMAT_TOP_NAME'              :    5,
                '$^'                            :    5,
                '$FORMAT_NAME'                  :    5,
                '$~'                            :    5,
                '${^CHILD_ERROR_NATIVE}'        :    5,
                '$EXTENDED_OS_ERROR'            :    5,
                '$^E'                           :    5,
                '$EXCEPTIONS_BEING_CAUGHT'      :    5,
                '$^S'                           :    5,
                '$WARNING'                      :    5,
                '$^W'                           :    5,
                '${^WARNING_BITS}'              :    5,
                '$OS_ERROR'                     :    5,
                '$ERRNO'                        :    5,
                '$!'                            :    5,
                '%OS_ERROR'                     :    5,
                '%ERRNO'                        :    5,
                '%!'                            :    5,
                '$CHILD_ERROR'                  :    5,
                '$?'                            :    5,
                '$EVAL_ERROR'                   :    5,
                '$@'                            :    5,
                '$OFMT'                         :    5,
                '$#'                            :    5,
                '$*'                            :    5,
                '$ARRAY_BASE'                   :    5,
                '$['                            :    5,
                '$OLD_PERL_VERSION'             :    5,
                '$]'                            :    5,
                                                //      PERL blocks
                'if'                            :[1,1],
                elsif                           :[1,1],
                'else'                          :[1,1],
                'while'                         :[1,1],
                unless                          :[1,1],
                'for'                           :[1,1],
                foreach                         :[1,1],
                                                //      PERL functions
                'abs'                           :1,     // - absolute value function
                accept                          :1,     // - accept an incoming socket connect
                alarm                           :1,     // - schedule a SIGALRM
                'atan2'                         :1,     // - arctangent of Y/X in the range -PI to PI
                bind                            :1,     // - binds an address to a socket
                binmode                         :1,     // - prepare binary files for I/O
                bless                           :1,     // - create an object
                bootstrap                       :1,     //
                'break'                         :1,     // - break out of a "given" block
                caller                          :1,     // - get context of the current subroutine call
                chdir                           :1,     // - change your current working directory
                chmod                           :1,     // - changes the permissions on a list of files
                chomp                           :1,     // - remove a trailing record separator from a string
                chop                            :1,     // - remove the last character from a string
                chown                           :1,     // - change the ownership on a list of files
                chr                             :1,     // - get character this number represents
                chroot                          :1,     // - make directory new root for path lookups
                close                           :1,     // - close file (or pipe or socket) handle
                closedir                        :1,     // - close directory handle
                connect                         :1,     // - connect to a remote socket
                'continue'                      :[1,1], // - optional trailing block in a while or foreach
                'cos'                           :1,     // - cosine function
                crypt                           :1,     // - one-way passwd-style encryption
                dbmclose                        :1,     // - breaks binding on a tied dbm file
                dbmopen                         :1,     // - create binding on a tied dbm file
                'default'                       :1,     //
                defined                         :1,     // - test whether a value, variable, or function is defined
                'delete'                        :1,     // - deletes a value from a hash
                die                             :1,     // - raise an exception or bail out
                'do'                            :1,     // - turn a BLOCK into a TERM
                dump                            :1,     // - create an immediate core dump
                each                            :1,     // - retrieve the next key/value pair from a hash
                endgrent                        :1,     // - be done using group file
                endhostent                      :1,     // - be done using hosts file
                endnetent                       :1,     // - be done using networks file
                endprotoent                     :1,     // - be done using protocols file
                endpwent                        :1,     // - be done using passwd file
                endservent                      :1,     // - be done using services file
                eof                             :1,     // - test a filehandle for its end
                'eval'                          :1,     // - catch exceptions or compile and run code
                'exec'                          :1,     // - abandon this program to run another
                exists                          :1,     // - test whether a hash key is present
                exit                            :1,     // - terminate this program
                'exp'                           :1,     // - raise I to a power
                fcntl                           :1,     // - file control system call
                fileno                          :1,     // - return file descriptor from filehandle
                flock                           :1,     // - lock an entire file with an advisory lock
                fork                            :1,     // - create a new process just like this one
                format                          :1,     // - declare a picture format with use by the write() function
                formline                        :1,     // - internal function used for formats
                getc                            :1,     // - get the next character from the filehandle
                getgrent                        :1,     // - get next group record
                getgrgid                        :1,     // - get group record given group user ID
                getgrnam                        :1,     // - get group record given group name
                gethostbyaddr                   :1,     // - get host record given its address
                gethostbyname                   :1,     // - get host record given name
                gethostent                      :1,     // - get next hosts record
                getlogin                        :1,     // - return who logged in at this tty
                getnetbyaddr                    :1,     // - get network record given its address
                getnetbyname                    :1,     // - get networks record given name
                getnetent                       :1,     // - get next networks record
                getpeername                     :1,     // - find the other end of a socket connection
                getpgrp                         :1,     // - get process group
                getppid                         :1,     // - get parent process ID
                getpriority                     :1,     // - get current nice value
                getprotobyname                  :1,     // - get protocol record given name
                getprotobynumber                :1,     // - get protocol record numeric protocol
                getprotoent                     :1,     // - get next protocols record
                getpwent                        :1,     // - get next passwd record
                getpwnam                        :1,     // - get passwd record given user login name
                getpwuid                        :1,     // - get passwd record given user ID
                getservbyname                   :1,     // - get services record given its name
                getservbyport                   :1,     // - get services record given numeric port
                getservent                      :1,     // - get next services record
                getsockname                     :1,     // - retrieve the sockaddr for a given socket
                getsockopt                      :1,     // - get socket options on a given socket
                given                           :1,     //
                glob                            :1,     // - expand filenames using wildcards
                gmtime                          :1,     // - convert UNIX time into record or string using Greenwich time
                'goto'                          :1,     // - create spaghetti code
                grep                            :1,     // - locate elements in a list test true against a given criterion
                hex                             :1,     // - convert a string to a hexadecimal number
                'import'                        :1,     // - patch a module's namespace into your own
                index                           :1,     // - find a substring within a string
                'int'                           :1,     // - get the integer portion of a number
                ioctl                           :1,     // - system-dependent device control system call
                'join'                          :1,     // - join a list into a string using a separator
                keys                            :1,     // - retrieve list of indices from a hash
                kill                            :1,     // - send a signal to a process or process group
                last                            :1,     // - exit a block prematurely
                lc                              :1,     // - return lower-case version of a string
                lcfirst                         :1,     // - return a string with just the next letter in lower case
                length                          :1,     // - return the number of bytes in a string
                'link'                          :1,     // - create a hard link in the filesystem
                listen                          :1,     // - register your socket as a server
                local                           : 2,    // - create a temporary value for a global variable (dynamic scoping)
                localtime                       :1,     // - convert UNIX time into record or string using local time
                lock                            :1,     // - get a thread lock on a variable, subroutine, or method
                'log'                           :1,     // - retrieve the natural logarithm for a number
                lstat                           :1,     // - stat a symbolic link
                m                               :null,  // - match a string with a regular expression pattern
                map                             :1,     // - apply a change to a list to get back a new list with the changes
                mkdir                           :1,     // - create a directory
                msgctl                          :1,     // - SysV IPC message control operations
                msgget                          :1,     // - get SysV IPC message queue
                msgrcv                          :1,     // - receive a SysV IPC message from a message queue
                msgsnd                          :1,     // - send a SysV IPC message to a message queue
                my                              : 2,    // - declare and assign a local variable (lexical scoping)
                'new'                           :1,     //
                next                            :1,     // - iterate a block prematurely
                no                              :1,     // - unimport some module symbols or semantics at compile time
                oct                             :1,     // - convert a string to an octal number
                open                            :1,     // - open a file, pipe, or descriptor
                opendir                         :1,     // - open a directory
                ord                             :1,     // - find a character's numeric representation
                our                             : 2,    // - declare and assign a package variable (lexical scoping)
                pack                            :1,     // - convert a list into a binary representation
                'package'                       :1,     // - declare a separate global namespace
                pipe                            :1,     // - open a pair of connected filehandles
                pop                             :1,     // - remove the last element from an array and return it
                pos                             :1,     // - find or set the offset for the last/next m//g search
                print                           :1,     // - output a list to a filehandle
                printf                          :1,     // - output a formatted list to a filehandle
                prototype                       :1,     // - get the prototype (if any) of a subroutine
                push                            :1,     // - append one or more elements to an array
                q                               :null,  // - singly quote a string
                qq                              :null,  // - doubly quote a string
                qr                              :null,  // - Compile pattern
                quotemeta                       :null,  // - quote regular expression magic characters
                qw                              :null,  // - quote a list of words
                qx                              :null,  // - backquote quote a string
                rand                            :1,     // - retrieve the next pseudorandom number
                read                            :1,     // - fixed-length buffered input from a filehandle
                readdir                         :1,     // - get a directory from a directory handle
                readline                        :1,     // - fetch a record from a file
                readlink                        :1,     // - determine where a symbolic link is pointing
                readpipe                        :1,     // - execute a system command and collect standard output
                recv                            :1,     // - receive a message over a Socket
                redo                            :1,     // - start this loop iteration over again
                ref                             :1,     // - find out the type of thing being referenced
                rename                          :1,     // - change a filename
                require                         :1,     // - load in external functions from a library at runtime
                reset                           :1,     // - clear all variables of a given name
                'return'                        :1,     // - get out of a function early
                reverse                         :1,     // - flip a string or a list
                rewinddir                       :1,     // - reset directory handle
                rindex                          :1,     // - right-to-left substring search
                rmdir                           :1,     // - remove a directory
                s                               :null,  // - replace a pattern with a string
                say                             :1,     // - print with newline
                scalar                          :1,     // - force a scalar context
                seek                            :1,     // - reposition file pointer for random-access I/O
                seekdir                         :1,     // - reposition directory pointer
                select                          :1,     // - reset default output or do I/O multiplexing
                semctl                          :1,     // - SysV semaphore control operations
                semget                          :1,     // - get set of SysV semaphores
                semop                           :1,     // - SysV semaphore operations
                send                            :1,     // - send a message over a socket
                setgrent                        :1,     // - prepare group file for use
                sethostent                      :1,     // - prepare hosts file for use
                setnetent                       :1,     // - prepare networks file for use
                setpgrp                         :1,     // - set the process group of a process
                setpriority                     :1,     // - set a process's nice value
                setprotoent                     :1,     // - prepare protocols file for use
                setpwent                        :1,     // - prepare passwd file for use
                setservent                      :1,     // - prepare services file for use
                setsockopt                      :1,     // - set some socket options
                shift                           :1,     // - remove the first element of an array, and return it
                shmctl                          :1,     // - SysV shared memory operations
                shmget                          :1,     // - get SysV shared memory segment identifier
                shmread                         :1,     // - read SysV shared memory
                shmwrite                        :1,     // - write SysV shared memory
                shutdown                        :1,     // - close down just half of a socket connection
                'sin'                           :1,     // - return the sine of a number
                sleep                           :1,     // - block for some number of seconds
                socket                          :1,     // - create a socket
                socketpair                      :1,     // - create a pair of sockets
                'sort'                          :1,     // - sort a list of values
                splice                          :1,     // - add or remove elements anywhere in an array
                'split'                         :1,     // - split up a string using a regexp delimiter
                sprintf                         :1,     // - formatted print into a string
                'sqrt'                          :1,     // - square root function
                srand                           :1,     // - seed the random number generator
                stat                            :1,     // - get a file's status information
                state                           :1,     // - declare and assign a state variable (persistent lexical scoping)
                study                           :1,     // - optimize input data for repeated searches
                'sub'                           :1,     // - declare a subroutine, possibly anonymously
                'substr'                        :1,     // - get or alter a portion of a string
                symlink                         :1,     // - create a symbolic link to a file
                syscall                         :1,     // - execute an arbitrary system call
                sysopen                         :1,     // - open a file, pipe, or descriptor
                sysread                         :1,     // - fixed-length unbuffered input from a filehandle
                sysseek                         :1,     // - position I/O pointer on handle used with sysread and syswrite
                system                          :1,     // - run a separate program
                syswrite                        :1,     // - fixed-length unbuffered output to a filehandle
                tell                            :1,     // - get current seekpointer on a filehandle
                telldir                         :1,     // - get current seekpointer on a directory handle
                tie                             :1,     // - bind a variable to an object class
                tied                            :1,     // - get a reference to the object underlying a tied variable
                time                            :1,     // - return number of seconds since 1970
                times                           :1,     // - return elapsed time for self and child processes
                tr                              :null,  // - transliterate a string
                truncate                        :1,     // - shorten a file
                uc                              :1,     // - return upper-case version of a string
                ucfirst                         :1,     // - return a string with just the next letter in upper case
                umask                           :1,     // - set file creation mode mask
                undef                           :1,     // - remove a variable or function definition
                unlink                          :1,     // - remove one link to a file
                unpack                          :1,     // - convert binary structure into normal perl variables
                unshift                         :1,     // - prepend more elements to the beginning of a list
                untie                           :1,     // - break a tie binding to a variable
                use                             :1,     // - load in a module at compile time
                utime                           :1,     // - set a file's last access and modify times
                values                          :1,     // - return a list of the values in a hash
                vec                             :1,     // - test or set particular bits in a string
                wait                            :1,     // - wait for any child process to die
                waitpid                         :1,     // - wait for a particular child process to die
                wantarray                       :1,     // - get void vs scalar vs list context of current subroutine call
                warn                            :1,     // - print debugging info
                when                            :1,     //
                write                           :1,     // - print a picture record
                y                               :null}; // - transliterate a string

        var RXstyle="string-2";
        var RXmodifiers=/[goseximacplud]/;              // NOTE: "m", "s", "y" and "tr" need to correct real modifiers for each regexp type

        function tokenChain(stream,state,chain,style,tail){     // NOTE: chain.length > 2 is not working now (it's for s[...][...]geos;)
                state.chain=null;                               //                                                          12   3tail
                state.style=null;
                state.tail=null;
                state.tokenize=function(stream,state){
                        var e=false,c,i=0;
                        while(c=stream.next()){
                                if(c===chain[i]&&!e){
                                        if(chain[++i]!==undefined){
                                                state.chain=chain[i];
                                                state.style=style;
                                                state.tail=tail;}
                                        else if(tail)
                                                stream.eatWhile(tail);
                                        state.tokenize=tokenPerl;
                                        return style;}
                                e=!e&&c=="\\";}
                        return style;};
                return state.tokenize(stream,state);}

        function tokenSOMETHING(stream,state,string){
                state.tokenize=function(stream,state){
                        if(stream.string==string)
                                state.tokenize=tokenPerl;
                        stream.skipToEnd();
                        return "string";};
                return state.tokenize(stream,state);}

        function tokenPerl(stream,state){
                if(stream.eatSpace())
                        return null;
                if(state.chain)
                        return tokenChain(stream,state,state.chain,state.style,state.tail);
                if(stream.match(/^\-?[\d\.]/,false))
                        if(stream.match(/^(\-?(\d*\.\d+(e[+-]?\d+)?|\d+\.\d*)|0x[\da-fA-F]+|0b[01]+|\d+(e[+-]?\d+)?)/))
                                return 'number';
                if(stream.match(/^<<(?=[_a-zA-Z])/)){                  // NOTE: <<SOMETHING\n...\nSOMETHING\n
                        stream.eatWhile(/\w/);
                        return tokenSOMETHING(stream,state,stream.current().substr(2));}
                if(stream.sol()&&stream.match(/^\=item(?!\w)/)){// NOTE: \n=item...\n=cut\n
                        return tokenSOMETHING(stream,state,'=cut');}
                var ch=stream.next();
                if(ch=='"'||ch=="'"){                           // NOTE: ' or " or <<'SOMETHING'\n...\nSOMETHING\n or <<"SOMETHING"\n...\nSOMETHING\n
                        if(prefix(stream, 3)=="<<"+ch){
                                var p=stream.pos;
                                stream.eatWhile(/\w/);
                                var n=stream.current().substr(1);
                                if(n&&stream.eat(ch))
                                        return tokenSOMETHING(stream,state,n);
                                stream.pos=p;}
                        return tokenChain(stream,state,[ch],"string");}
                if(ch=="q"){
                        var c=look(stream, -2);
                        if(!(c&&/\w/.test(c))){
                                c=look(stream, 0);
                                if(c=="x"){
                                        c=look(stream, 1);
                                        if(c=="("){
                                                eatSuffix(stream, 2);
                                                return tokenChain(stream,state,[")"],RXstyle,RXmodifiers);}
                                        if(c=="["){
                                                eatSuffix(stream, 2);
                                                return tokenChain(stream,state,["]"],RXstyle,RXmodifiers);}
                                        if(c=="{"){
                                                eatSuffix(stream, 2);
                                                return tokenChain(stream,state,["}"],RXstyle,RXmodifiers);}
                                        if(c=="<"){
                                                eatSuffix(stream, 2);
                                                return tokenChain(stream,state,[">"],RXstyle,RXmodifiers);}
                                        if(/[\^'"!~\/]/.test(c)){
                                                eatSuffix(stream, 1);
                                                return tokenChain(stream,state,[stream.eat(c)],RXstyle,RXmodifiers);}}
                                else if(c=="q"){
                                        c=look(stream, 1);
                                        if(c=="("){
                                                eatSuffix(stream, 2);
                                                return tokenChain(stream,state,[")"],"string");}
                                        if(c=="["){
                                                eatSuffix(stream, 2);
                                                return tokenChain(stream,state,["]"],"string");}
                                        if(c=="{"){
                                                eatSuffix(stream, 2);
                                                return tokenChain(stream,state,["}"],"string");}
                                        if(c=="<"){
                                                eatSuffix(stream, 2);
                                                return tokenChain(stream,state,[">"],"string");}
                                        if(/[\^'"!~\/]/.test(c)){
                                                eatSuffix(stream, 1);
                                                return tokenChain(stream,state,[stream.eat(c)],"string");}}
                                else if(c=="w"){
                                        c=look(stream, 1);
                                        if(c=="("){
                                                eatSuffix(stream, 2);
                                                return tokenChain(stream,state,[")"],"bracket");}
                                        if(c=="["){
                                                eatSuffix(stream, 2);
                                                return tokenChain(stream,state,["]"],"bracket");}
                                        if(c=="{"){
                                                eatSuffix(stream, 2);
                                                return tokenChain(stream,state,["}"],"bracket");}
                                        if(c=="<"){
                                                eatSuffix(stream, 2);
                                                return tokenChain(stream,state,[">"],"bracket");}
                                        if(/[\^'"!~\/]/.test(c)){
                                                eatSuffix(stream, 1);
                                                return tokenChain(stream,state,[stream.eat(c)],"bracket");}}
                                else if(c=="r"){
                                        c=look(stream, 1);
                                        if(c=="("){
                                                eatSuffix(stream, 2);
                                                return tokenChain(stream,state,[")"],RXstyle,RXmodifiers);}
                                        if(c=="["){
                                                eatSuffix(stream, 2);
                                                return tokenChain(stream,state,["]"],RXstyle,RXmodifiers);}
                                        if(c=="{"){
                                                eatSuffix(stream, 2);
                                                return tokenChain(stream,state,["}"],RXstyle,RXmodifiers);}
                                        if(c=="<"){
                                                eatSuffix(stream, 2);
                                                return tokenChain(stream,state,[">"],RXstyle,RXmodifiers);}
                                        if(/[\^'"!~\/]/.test(c)){
                                                eatSuffix(stream, 1);
                                                return tokenChain(stream,state,[stream.eat(c)],RXstyle,RXmodifiers);}}
                                else if(/[\^'"!~\/(\[{<]/.test(c)){
                                        if(c=="("){
                                                eatSuffix(stream, 1);
                                                return tokenChain(stream,state,[")"],"string");}
                                        if(c=="["){
                                                eatSuffix(stream, 1);
                                                return tokenChain(stream,state,["]"],"string");}
                                        if(c=="{"){
                                                eatSuffix(stream, 1);
                                                return tokenChain(stream,state,["}"],"string");}
                                        if(c=="<"){
                                                eatSuffix(stream, 1);
                                                return tokenChain(stream,state,[">"],"string");}
                                        if(/[\^'"!~\/]/.test(c)){
                                                return tokenChain(stream,state,[stream.eat(c)],"string");}}}}
                if(ch=="m"){
                        var c=look(stream, -2);
                        if(!(c&&/\w/.test(c))){
                                c=stream.eat(/[(\[{<\^'"!~\/]/);
                                if(c){
                                        if(/[\^'"!~\/]/.test(c)){
                                                return tokenChain(stream,state,[c],RXstyle,RXmodifiers);}
                                        if(c=="("){
                                                return tokenChain(stream,state,[")"],RXstyle,RXmodifiers);}
                                        if(c=="["){
                                                return tokenChain(stream,state,["]"],RXstyle,RXmodifiers);}
                                        if(c=="{"){
                                                return tokenChain(stream,state,["}"],RXstyle,RXmodifiers);}
                                        if(c=="<"){
                                                return tokenChain(stream,state,[">"],RXstyle,RXmodifiers);}}}}
                if(ch=="s"){
                        var c=/[\/>\]})\w]/.test(look(stream, -2));
                        if(!c){
                                c=stream.eat(/[(\[{<\^'"!~\/]/);
                                if(c){
                                        if(c=="[")
                                                return tokenChain(stream,state,["]","]"],RXstyle,RXmodifiers);
                                        if(c=="{")
                                                return tokenChain(stream,state,["}","}"],RXstyle,RXmodifiers);
                                        if(c=="<")
                                                return tokenChain(stream,state,[">",">"],RXstyle,RXmodifiers);
                                        if(c=="(")
                                                return tokenChain(stream,state,[")",")"],RXstyle,RXmodifiers);
                                        return tokenChain(stream,state,[c,c],RXstyle,RXmodifiers);}}}
                if(ch=="y"){
                        var c=/[\/>\]})\w]/.test(look(stream, -2));
                        if(!c){
                                c=stream.eat(/[(\[{<\^'"!~\/]/);
                                if(c){
                                        if(c=="[")
                                                return tokenChain(stream,state,["]","]"],RXstyle,RXmodifiers);
                                        if(c=="{")
                                                return tokenChain(stream,state,["}","}"],RXstyle,RXmodifiers);
                                        if(c=="<")
                                                return tokenChain(stream,state,[">",">"],RXstyle,RXmodifiers);
                                        if(c=="(")
                                                return tokenChain(stream,state,[")",")"],RXstyle,RXmodifiers);
                                        return tokenChain(stream,state,[c,c],RXstyle,RXmodifiers);}}}
                if(ch=="t"){
                        var c=/[\/>\]})\w]/.test(look(stream, -2));
                        if(!c){
                                c=stream.eat("r");if(c){
                                c=stream.eat(/[(\[{<\^'"!~\/]/);
                                if(c){
                                        if(c=="[")
                                                return tokenChain(stream,state,["]","]"],RXstyle,RXmodifiers);
                                        if(c=="{")
                                                return tokenChain(stream,state,["}","}"],RXstyle,RXmodifiers);
                                        if(c=="<")
                                                return tokenChain(stream,state,[">",">"],RXstyle,RXmodifiers);
                                        if(c=="(")
                                                return tokenChain(stream,state,[")",")"],RXstyle,RXmodifiers);
                                        return tokenChain(stream,state,[c,c],RXstyle,RXmodifiers);}}}}
                if(ch=="`"){
                        return tokenChain(stream,state,[ch],"variable-2");}
                if(ch=="/"){
                        if(!/~\s*$/.test(prefix(stream)))
                                return "operator";
                        else
                                return tokenChain(stream,state,[ch],RXstyle,RXmodifiers);}
                if(ch=="$"){
                        var p=stream.pos;
                        if(stream.eatWhile(/\d/)||stream.eat("{")&&stream.eatWhile(/\d/)&&stream.eat("}"))
                                return "variable-2";
                        else
                                stream.pos=p;}
                if(/[$@%]/.test(ch)){
                        var p=stream.pos;
                        if(stream.eat("^")&&stream.eat(/[A-Z]/)||!/[@$%&]/.test(look(stream, -2))&&stream.eat(/[=|\\\-#?@;:&`~\^!\[\]*'"$+.,\/<>()]/)){
                                var c=stream.current();
                                if(PERL[c])
                                        return "variable-2";}
                        stream.pos=p;}
                if(/[$@%&]/.test(ch)){
                        if(stream.eatWhile(/[\w$]/)||stream.eat("{")&&stream.eatWhile(/[\w$]/)&&stream.eat("}")){
                                var c=stream.current();
                                if(PERL[c])
                                        return "variable-2";
                                else
                                        return "variable";}}
                if(ch=="#"){
                        if(look(stream, -2)!="$"){
                                stream.skipToEnd();
                                return "comment";}}
                if(/[:+\-\^*$&%@=<>!?|\/~\.]/.test(ch)){
                        var p=stream.pos;
                        stream.eatWhile(/[:+\-\^*$&%@=<>!?|\/~\.]/);
                        if(PERL[stream.current()])
                                return "operator";
                        else
                                stream.pos=p;}
                if(ch=="_"){
                        if(stream.pos==1){
                                if(suffix(stream, 6)=="_END__"){
                                        return tokenChain(stream,state,['\0'],"comment");}
                                else if(suffix(stream, 7)=="_DATA__"){
                                        return tokenChain(stream,state,['\0'],"variable-2");}
                                else if(suffix(stream, 7)=="_C__"){
                                        return tokenChain(stream,state,['\0'],"string");}}}
                if(/\w/.test(ch)){
                        var p=stream.pos;
                        if(look(stream, -2)=="{"&&(look(stream, 0)=="}"||stream.eatWhile(/\w/)&&look(stream, 0)=="}"))
                                return "string";
                        else
                                stream.pos=p;}
                if(/[A-Z]/.test(ch)){
                        var l=look(stream, -2);
                        var p=stream.pos;
                        stream.eatWhile(/[A-Z_]/);
                        if(/[\da-z]/.test(look(stream, 0))){
                                stream.pos=p;}
                        else{
                                var c=PERL[stream.current()];
                                if(!c)
                                        return "meta";
                                if(c[1])
                                        c=c[0];
                                if(l!=":"){
                                        if(c==1)
                                                return "keyword";
                                        else if(c==2)
                                                return "def";
                                        else if(c==3)
                                                return "atom";
                                        else if(c==4)
                                                return "operator";
                                        else if(c==5)
                                                return "variable-2";
                                        else
                                                return "meta";}
                                else
                                        return "meta";}}
                if(/[a-zA-Z_]/.test(ch)){
                        var l=look(stream, -2);
                        stream.eatWhile(/\w/);
                        var c=PERL[stream.current()];
                        if(!c)
                                return "meta";
                        if(c[1])
                                c=c[0];
                        if(l!=":"){
                                if(c==1)
                                        return "keyword";
                                else if(c==2)
                                        return "def";
                                else if(c==3)
                                        return "atom";
                                else if(c==4)
                                        return "operator";
                                else if(c==5)
                                        return "variable-2";
                                else
                                        return "meta";}
                        else
                                return "meta";}
                return null;}

        return {
            startState: function() {
                return {
                    tokenize: tokenPerl,
                    chain: null,
                    style: null,
                    tail: null
                };
            },
            token: function(stream, state) {
                return (state.tokenize || tokenPerl)(stream, state);
            },
            lineComment: '#'
        };
});

CodeMirror.registerHelper("wordChars", "perl", /[\w$]/);

CodeMirror.defineMIME("text/x-perl", "perl");

// it's like "peek", but need for look-ahead or look-behind if index < 0
function look(stream, c){
  return stream.string.charAt(stream.pos+(c||0));
}

// return a part of prefix of current stream from current position
function prefix(stream, c){
  if(c){
    var x=stream.pos-c;
    return stream.string.substr((x>=0?x:0),c);}
  else{
    return stream.string.substr(0,stream.pos-1);
  }
}

// return a part of suffix of current stream from current position
function suffix(stream, c){
  var y=stream.string.length;
  var x=y-stream.pos+1;
  return stream.string.substr(stream.pos,(c&&c<y?c:x));
}

// eating and vomiting a part of stream from current position
function eatSuffix(stream, c){
  var x=stream.pos+c;
  var y;
  if(x<=0)
    stream.pos=0;
  else if(x>=(y=stream.string.length-1))
    stream.pos=y;
  else
    stream.pos=x;
}

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/php/php.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"), __webpack_require__("./src/ipywidgets/node_modules/codemirror/mode/htmlmixed/htmlmixed.js"), __webpack_require__("./src/ipywidgets/node_modules/codemirror/mode/clike/clike.js"));
  else {}
})(function(CodeMirror) {
  "use strict";

  function keywords(str) {
    var obj = {}, words = str.split(" ");
    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
    return obj;
  }

  // Helper for phpString
  function matchSequence(list, end, escapes) {
    if (list.length == 0) return phpString(end);
    return function (stream, state) {
      var patterns = list[0];
      for (var i = 0; i < patterns.length; i++) if (stream.match(patterns[i][0])) {
        state.tokenize = matchSequence(list.slice(1), end);
        return patterns[i][1];
      }
      state.tokenize = phpString(end, escapes);
      return "string";
    };
  }
  function phpString(closing, escapes) {
    return function(stream, state) { return phpString_(stream, state, closing, escapes); };
  }
  function phpString_(stream, state, closing, escapes) {
    // "Complex" syntax
    if (escapes !== false && stream.match("${", false) || stream.match("{$", false)) {
      state.tokenize = null;
      return "string";
    }

    // Simple syntax
    if (escapes !== false && stream.match(/^\$[a-zA-Z_][a-zA-Z0-9_]*/)) {
      // After the variable name there may appear array or object operator.
      if (stream.match("[", false)) {
        // Match array operator
        state.tokenize = matchSequence([
          [["[", null]],
          [[/\d[\w\.]*/, "number"],
           [/\$[a-zA-Z_][a-zA-Z0-9_]*/, "variable-2"],
           [/[\w\$]+/, "variable"]],
          [["]", null]]
        ], closing, escapes);
      }
      if (stream.match(/^->\w/, false)) {
        // Match object operator
        state.tokenize = matchSequence([
          [["->", null]],
          [[/[\w]+/, "variable"]]
        ], closing, escapes);
      }
      return "variable-2";
    }

    var escaped = false;
    // Normal string
    while (!stream.eol() &&
           (escaped || escapes === false ||
            (!stream.match("{$", false) &&
             !stream.match(/^(\$[a-zA-Z_][a-zA-Z0-9_]*|\$\{)/, false)))) {
      if (!escaped && stream.match(closing)) {
        state.tokenize = null;
        state.tokStack.pop(); state.tokStack.pop();
        break;
      }
      escaped = stream.next() == "\\" && !escaped;
    }
    return "string";
  }

  var phpKeywords = "abstract and array as break case catch class clone const continue declare default " +
    "do else elseif enddeclare endfor endforeach endif endswitch endwhile extends final " +
    "for foreach function global goto if implements interface instanceof namespace " +
    "new or private protected public static switch throw trait try use var while xor " +
    "die echo empty exit eval include include_once isset list require require_once return " +
    "print unset __halt_compiler self static parent yield insteadof finally";
  var phpAtoms = "true false null TRUE FALSE NULL __CLASS__ __DIR__ __FILE__ __LINE__ __METHOD__ __FUNCTION__ __NAMESPACE__ __TRAIT__";
  var phpBuiltin = "func_num_args func_get_arg func_get_args strlen strcmp strncmp strcasecmp strncasecmp each error_reporting define defined trigger_error user_error set_error_handler restore_error_handler get_declared_classes get_loaded_extensions extension_loaded get_extension_funcs debug_backtrace constant bin2hex hex2bin sleep usleep time mktime gmmktime strftime gmstrftime strtotime date gmdate getdate localtime checkdate flush wordwrap htmlspecialchars htmlentities html_entity_decode md5 md5_file crc32 getimagesize image_type_to_mime_type phpinfo phpversion phpcredits strnatcmp strnatcasecmp substr_count strspn strcspn strtok strtoupper strtolower strpos strrpos strrev hebrev hebrevc nl2br basename dirname pathinfo stripslashes stripcslashes strstr stristr strrchr str_shuffle str_word_count strcoll substr substr_replace quotemeta ucfirst ucwords strtr addslashes addcslashes rtrim str_replace str_repeat count_chars chunk_split trim ltrim strip_tags similar_text explode implode setlocale localeconv parse_str str_pad chop strchr sprintf printf vprintf vsprintf sscanf fscanf parse_url urlencode urldecode rawurlencode rawurldecode readlink linkinfo link unlink exec system escapeshellcmd escapeshellarg passthru shell_exec proc_open proc_close rand srand getrandmax mt_rand mt_srand mt_getrandmax base64_decode base64_encode abs ceil floor round is_finite is_nan is_infinite bindec hexdec octdec decbin decoct dechex base_convert number_format fmod ip2long long2ip getenv putenv getopt microtime gettimeofday getrusage uniqid quoted_printable_decode set_time_limit get_cfg_var magic_quotes_runtime set_magic_quotes_runtime get_magic_quotes_gpc get_magic_quotes_runtime import_request_variables error_log serialize unserialize memory_get_usage memory_get_peak_usage var_dump var_export debug_zval_dump print_r highlight_file show_source highlight_string ini_get ini_get_all ini_set ini_alter ini_restore get_include_path set_include_path restore_include_path setcookie header headers_sent connection_aborted connection_status ignore_user_abort parse_ini_file is_uploaded_file move_uploaded_file intval floatval doubleval strval gettype settype is_null is_resource is_bool is_long is_float is_int is_integer is_double is_real is_numeric is_string is_array is_object is_scalar ereg ereg_replace eregi eregi_replace split spliti join sql_regcase dl pclose popen readfile rewind rmdir umask fclose feof fgetc fgets fgetss fread fopen fpassthru ftruncate fstat fseek ftell fflush fwrite fputs mkdir rename copy tempnam tmpfile file file_get_contents file_put_contents stream_select stream_context_create stream_context_set_params stream_context_set_option stream_context_get_options stream_filter_prepend stream_filter_append fgetcsv flock get_meta_tags stream_set_write_buffer set_file_buffer set_socket_blocking stream_set_blocking socket_set_blocking stream_get_meta_data stream_register_wrapper stream_wrapper_register stream_set_timeout socket_set_timeout socket_get_status realpath fnmatch fsockopen pfsockopen pack unpack get_browser crypt opendir closedir chdir getcwd rewinddir readdir dir glob fileatime filectime filegroup fileinode filemtime fileowner fileperms filesize filetype file_exists is_writable is_writeable is_readable is_executable is_file is_dir is_link stat lstat chown touch clearstatcache mail ob_start ob_flush ob_clean ob_end_flush ob_end_clean ob_get_flush ob_get_clean ob_get_length ob_get_level ob_get_status ob_get_contents ob_implicit_flush ob_list_handlers ksort krsort natsort natcasesort asort arsort sort rsort usort uasort uksort shuffle array_walk count end prev next reset current key min max in_array array_search extract compact array_fill range array_multisort array_push array_pop array_shift array_unshift array_splice array_slice array_merge array_merge_recursive array_keys array_values array_count_values array_reverse array_reduce array_pad array_flip array_change_key_case array_rand array_unique array_intersect array_intersect_assoc array_diff array_diff_assoc array_sum array_filter array_map array_chunk array_key_exists array_intersect_key array_combine array_column pos sizeof key_exists assert assert_options version_compare ftok str_rot13 aggregate session_name session_module_name session_save_path session_id session_regenerate_id session_decode session_register session_unregister session_is_registered session_encode session_start session_destroy session_unset session_set_save_handler session_cache_limiter session_cache_expire session_set_cookie_params session_get_cookie_params session_write_close preg_match preg_match_all preg_replace preg_replace_callback preg_split preg_quote preg_grep overload ctype_alnum ctype_alpha ctype_cntrl ctype_digit ctype_lower ctype_graph ctype_print ctype_punct ctype_space ctype_upper ctype_xdigit virtual apache_request_headers apache_note apache_lookup_uri apache_child_terminate apache_setenv apache_response_headers apache_get_version getallheaders mysql_connect mysql_pconnect mysql_close mysql_select_db mysql_create_db mysql_drop_db mysql_query mysql_unbuffered_query mysql_db_query mysql_list_dbs mysql_list_tables mysql_list_fields mysql_list_processes mysql_error mysql_errno mysql_affected_rows mysql_insert_id mysql_result mysql_num_rows mysql_num_fields mysql_fetch_row mysql_fetch_array mysql_fetch_assoc mysql_fetch_object mysql_data_seek mysql_fetch_lengths mysql_fetch_field mysql_field_seek mysql_free_result mysql_field_name mysql_field_table mysql_field_len mysql_field_type mysql_field_flags mysql_escape_string mysql_real_escape_string mysql_stat mysql_thread_id mysql_client_encoding mysql_get_client_info mysql_get_host_info mysql_get_proto_info mysql_get_server_info mysql_info mysql mysql_fieldname mysql_fieldtable mysql_fieldlen mysql_fieldtype mysql_fieldflags mysql_selectdb mysql_createdb mysql_dropdb mysql_freeresult mysql_numfields mysql_numrows mysql_listdbs mysql_listtables mysql_listfields mysql_db_name mysql_dbname mysql_tablename mysql_table_name pg_connect pg_pconnect pg_close pg_connection_status pg_connection_busy pg_connection_reset pg_host pg_dbname pg_port pg_tty pg_options pg_ping pg_query pg_send_query pg_cancel_query pg_fetch_result pg_fetch_row pg_fetch_assoc pg_fetch_array pg_fetch_object pg_fetch_all pg_affected_rows pg_get_result pg_result_seek pg_result_status pg_free_result pg_last_oid pg_num_rows pg_num_fields pg_field_name pg_field_num pg_field_size pg_field_type pg_field_prtlen pg_field_is_null pg_get_notify pg_get_pid pg_result_error pg_last_error pg_last_notice pg_put_line pg_end_copy pg_copy_to pg_copy_from pg_trace pg_untrace pg_lo_create pg_lo_unlink pg_lo_open pg_lo_close pg_lo_read pg_lo_write pg_lo_read_all pg_lo_import pg_lo_export pg_lo_seek pg_lo_tell pg_escape_string pg_escape_bytea pg_unescape_bytea pg_client_encoding pg_set_client_encoding pg_meta_data pg_convert pg_insert pg_update pg_delete pg_select pg_exec pg_getlastoid pg_cmdtuples pg_errormessage pg_numrows pg_numfields pg_fieldname pg_fieldsize pg_fieldtype pg_fieldnum pg_fieldprtlen pg_fieldisnull pg_freeresult pg_result pg_loreadall pg_locreate pg_lounlink pg_loopen pg_loclose pg_loread pg_lowrite pg_loimport pg_loexport http_response_code get_declared_traits getimagesizefromstring socket_import_stream stream_set_chunk_size trait_exists header_register_callback class_uses session_status session_register_shutdown echo print global static exit array empty eval isset unset die include require include_once require_once json_decode json_encode json_last_error json_last_error_msg curl_close curl_copy_handle curl_errno curl_error curl_escape curl_exec curl_file_create curl_getinfo curl_init curl_multi_add_handle curl_multi_close curl_multi_exec curl_multi_getcontent curl_multi_info_read curl_multi_init curl_multi_remove_handle curl_multi_select curl_multi_setopt curl_multi_strerror curl_pause curl_reset curl_setopt_array curl_setopt curl_share_close curl_share_init curl_share_setopt curl_strerror curl_unescape curl_version mysqli_affected_rows mysqli_autocommit mysqli_change_user mysqli_character_set_name mysqli_close mysqli_commit mysqli_connect_errno mysqli_connect_error mysqli_connect mysqli_data_seek mysqli_debug mysqli_dump_debug_info mysqli_errno mysqli_error_list mysqli_error mysqli_fetch_all mysqli_fetch_array mysqli_fetch_assoc mysqli_fetch_field_direct mysqli_fetch_field mysqli_fetch_fields mysqli_fetch_lengths mysqli_fetch_object mysqli_fetch_row mysqli_field_count mysqli_field_seek mysqli_field_tell mysqli_free_result mysqli_get_charset mysqli_get_client_info mysqli_get_client_stats mysqli_get_client_version mysqli_get_connection_stats mysqli_get_host_info mysqli_get_proto_info mysqli_get_server_info mysqli_get_server_version mysqli_info mysqli_init mysqli_insert_id mysqli_kill mysqli_more_results mysqli_multi_query mysqli_next_result mysqli_num_fields mysqli_num_rows mysqli_options mysqli_ping mysqli_prepare mysqli_query mysqli_real_connect mysqli_real_escape_string mysqli_real_query mysqli_reap_async_query mysqli_refresh mysqli_rollback mysqli_select_db mysqli_set_charset mysqli_set_local_infile_default mysqli_set_local_infile_handler mysqli_sqlstate mysqli_ssl_set mysqli_stat mysqli_stmt_init mysqli_store_result mysqli_thread_id mysqli_thread_safe mysqli_use_result mysqli_warning_count";
  CodeMirror.registerHelper("hintWords", "php", [phpKeywords, phpAtoms, phpBuiltin].join(" ").split(" "));
  CodeMirror.registerHelper("wordChars", "php", /[\w$]/);

  var phpConfig = {
    name: "clike",
    helperType: "php",
    keywords: keywords(phpKeywords),
    blockKeywords: keywords("catch do else elseif for foreach if switch try while finally"),
    defKeywords: keywords("class function interface namespace trait"),
    atoms: keywords(phpAtoms),
    builtin: keywords(phpBuiltin),
    multiLineStrings: true,
    hooks: {
      "$": function(stream) {
        stream.eatWhile(/[\w\$_]/);
        return "variable-2";
      },
      "<": function(stream, state) {
        var before;
        if (before = stream.match(/^<<\s*/)) {
          var quoted = stream.eat(/['"]/);
          stream.eatWhile(/[\w\.]/);
          var delim = stream.current().slice(before[0].length + (quoted ? 2 : 1));
          if (quoted) stream.eat(quoted);
          if (delim) {
            (state.tokStack || (state.tokStack = [])).push(delim, 0);
            state.tokenize = phpString(delim, quoted != "'");
            return "string";
          }
        }
        return false;
      },
      "#": function(stream) {
        while (!stream.eol() && !stream.match("?>", false)) stream.next();
        return "comment";
      },
      "/": function(stream) {
        if (stream.eat("/")) {
          while (!stream.eol() && !stream.match("?>", false)) stream.next();
          return "comment";
        }
        return false;
      },
      '"': function(_stream, state) {
        (state.tokStack || (state.tokStack = [])).push('"', 0);
        state.tokenize = phpString('"');
        return "string";
      },
      "{": function(_stream, state) {
        if (state.tokStack && state.tokStack.length)
          state.tokStack[state.tokStack.length - 1]++;
        return false;
      },
      "}": function(_stream, state) {
        if (state.tokStack && state.tokStack.length > 0 &&
            !--state.tokStack[state.tokStack.length - 1]) {
          state.tokenize = phpString(state.tokStack[state.tokStack.length - 2]);
        }
        return false;
      }
    }
  };

  CodeMirror.defineMode("php", function(config, parserConfig) {
    var htmlMode = CodeMirror.getMode(config, (parserConfig && parserConfig.htmlMode) || "text/html");
    var phpMode = CodeMirror.getMode(config, phpConfig);

    function dispatch(stream, state) {
      var isPHP = state.curMode == phpMode;
      if (stream.sol() && state.pending && state.pending != '"' && state.pending != "'") state.pending = null;
      if (!isPHP) {
        if (stream.match(/^<\?\w*/)) {
          state.curMode = phpMode;
          if (!state.php) state.php = CodeMirror.startState(phpMode, htmlMode.indent(state.html, "", ""))
          state.curState = state.php;
          return "meta";
        }
        if (state.pending == '"' || state.pending == "'") {
          while (!stream.eol() && stream.next() != state.pending) {}
          var style = "string";
        } else if (state.pending && stream.pos < state.pending.end) {
          stream.pos = state.pending.end;
          var style = state.pending.style;
        } else {
          var style = htmlMode.token(stream, state.curState);
        }
        if (state.pending) state.pending = null;
        var cur = stream.current(), openPHP = cur.search(/<\?/), m;
        if (openPHP != -1) {
          if (style == "string" && (m = cur.match(/[\'\"]$/)) && !/\?>/.test(cur)) state.pending = m[0];
          else state.pending = {end: stream.pos, style: style};
          stream.backUp(cur.length - openPHP);
        }
        return style;
      } else if (isPHP && state.php.tokenize == null && stream.match("?>")) {
        state.curMode = htmlMode;
        state.curState = state.html;
        if (!state.php.context.prev) state.php = null;
        return "meta";
      } else {
        return phpMode.token(stream, state.curState);
      }
    }

    return {
      startState: function() {
        var html = CodeMirror.startState(htmlMode)
        var php = parserConfig.startOpen ? CodeMirror.startState(phpMode) : null
        return {html: html,
                php: php,
                curMode: parserConfig.startOpen ? phpMode : htmlMode,
                curState: parserConfig.startOpen ? php : html,
                pending: null};
      },

      copyState: function(state) {
        var html = state.html, htmlNew = CodeMirror.copyState(htmlMode, html),
            php = state.php, phpNew = php && CodeMirror.copyState(phpMode, php), cur;
        if (state.curMode == htmlMode) cur = htmlNew;
        else cur = phpNew;
        return {html: htmlNew, php: phpNew, curMode: state.curMode, curState: cur,
                pending: state.pending};
      },

      token: dispatch,

      indent: function(state, textAfter, line) {
        if ((state.curMode != phpMode && /^\s*<\//.test(textAfter)) ||
            (state.curMode == phpMode && /^\?>/.test(textAfter)))
          return htmlMode.indent(state.html, textAfter, line);
        return state.curMode.indent(state.curState, textAfter, line);
      },

      blockCommentStart: "/*",
      blockCommentEnd: "*/",
      lineComment: "//",

      innerMode: function(state) { return {state: state.curState, mode: state.curMode}; }
    };
  }, "htmlmixed", "clike");

  CodeMirror.defineMIME("application/x-httpd-php", "php");
  CodeMirror.defineMIME("application/x-httpd-php-open", {name: "php", startOpen: true});
  CodeMirror.defineMIME("text/x-php", phpConfig);
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/pig/pig.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

/*
 *      Pig Latin Mode for CodeMirror 2
 *      @author Prasanth Jayachandran
 *      @link   https://github.com/prasanthj/pig-codemirror-2
 *  This implementation is adapted from PL/SQL mode in CodeMirror 2.
 */
(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("pig", function(_config, parserConfig) {
  var keywords = parserConfig.keywords,
  builtins = parserConfig.builtins,
  types = parserConfig.types,
  multiLineStrings = parserConfig.multiLineStrings;

  var isOperatorChar = /[*+\-%<>=&?:\/!|]/;

  function chain(stream, state, f) {
    state.tokenize = f;
    return f(stream, state);
  }

  function tokenComment(stream, state) {
    var isEnd = false;
    var ch;
    while(ch = stream.next()) {
      if(ch == "/" && isEnd) {
        state.tokenize = tokenBase;
        break;
      }
      isEnd = (ch == "*");
    }
    return "comment";
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, next, end = false;
      while((next = stream.next()) != null) {
        if (next == quote && !escaped) {
          end = true; break;
        }
        escaped = !escaped && next == "\\";
      }
      if (end || !(escaped || multiLineStrings))
        state.tokenize = tokenBase;
      return "error";
    };
  }


  function tokenBase(stream, state) {
    var ch = stream.next();

    // is a start of string?
    if (ch == '"' || ch == "'")
      return chain(stream, state, tokenString(ch));
    // is it one of the special chars
    else if(/[\[\]{}\(\),;\.]/.test(ch))
      return null;
    // is it a number?
    else if(/\d/.test(ch)) {
      stream.eatWhile(/[\w\.]/);
      return "number";
    }
    // multi line comment or operator
    else if (ch == "/") {
      if (stream.eat("*")) {
        return chain(stream, state, tokenComment);
      }
      else {
        stream.eatWhile(isOperatorChar);
        return "operator";
      }
    }
    // single line comment or operator
    else if (ch=="-") {
      if(stream.eat("-")){
        stream.skipToEnd();
        return "comment";
      }
      else {
        stream.eatWhile(isOperatorChar);
        return "operator";
      }
    }
    // is it an operator
    else if (isOperatorChar.test(ch)) {
      stream.eatWhile(isOperatorChar);
      return "operator";
    }
    else {
      // get the while word
      stream.eatWhile(/[\w\$_]/);
      // is it one of the listed keywords?
      if (keywords && keywords.propertyIsEnumerable(stream.current().toUpperCase())) {
        //keywords can be used as variables like flatten(group), group.$0 etc..
        if (!stream.eat(")") && !stream.eat("."))
          return "keyword";
      }
      // is it one of the builtin functions?
      if (builtins && builtins.propertyIsEnumerable(stream.current().toUpperCase()))
        return "variable-2";
      // is it one of the listed types?
      if (types && types.propertyIsEnumerable(stream.current().toUpperCase()))
        return "variable-3";
      // default is a 'variable'
      return "variable";
    }
  }

  // Interface
  return {
    startState: function() {
      return {
        tokenize: tokenBase,
        startOfLine: true
      };
    },

    token: function(stream, state) {
      if(stream.eatSpace()) return null;
      var style = state.tokenize(stream, state);
      return style;
    }
  };
});

(function() {
  function keywords(str) {
    var obj = {}, words = str.split(" ");
    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
    return obj;
  }

  // builtin funcs taken from trunk revision 1303237
  var pBuiltins = "ABS ACOS ARITY ASIN ATAN AVG BAGSIZE BINSTORAGE BLOOM BUILDBLOOM CBRT CEIL "
    + "CONCAT COR COS COSH COUNT COUNT_STAR COV CONSTANTSIZE CUBEDIMENSIONS DIFF DISTINCT DOUBLEABS "
    + "DOUBLEAVG DOUBLEBASE DOUBLEMAX DOUBLEMIN DOUBLEROUND DOUBLESUM EXP FLOOR FLOATABS FLOATAVG "
    + "FLOATMAX FLOATMIN FLOATROUND FLOATSUM GENERICINVOKER INDEXOF INTABS INTAVG INTMAX INTMIN "
    + "INTSUM INVOKEFORDOUBLE INVOKEFORFLOAT INVOKEFORINT INVOKEFORLONG INVOKEFORSTRING INVOKER "
    + "ISEMPTY JSONLOADER JSONMETADATA JSONSTORAGE LAST_INDEX_OF LCFIRST LOG LOG10 LOWER LONGABS "
    + "LONGAVG LONGMAX LONGMIN LONGSUM MAX MIN MAPSIZE MONITOREDUDF NONDETERMINISTIC OUTPUTSCHEMA  "
    + "PIGSTORAGE PIGSTREAMING RANDOM REGEX_EXTRACT REGEX_EXTRACT_ALL REPLACE ROUND SIN SINH SIZE "
    + "SQRT STRSPLIT SUBSTRING SUM STRINGCONCAT STRINGMAX STRINGMIN STRINGSIZE TAN TANH TOBAG "
    + "TOKENIZE TOMAP TOP TOTUPLE TRIM TEXTLOADER TUPLESIZE UCFIRST UPPER UTF8STORAGECONVERTER ";

  // taken from QueryLexer.g
  var pKeywords = "VOID IMPORT RETURNS DEFINE LOAD FILTER FOREACH ORDER CUBE DISTINCT COGROUP "
    + "JOIN CROSS UNION SPLIT INTO IF OTHERWISE ALL AS BY USING INNER OUTER ONSCHEMA PARALLEL "
    + "PARTITION GROUP AND OR NOT GENERATE FLATTEN ASC DESC IS STREAM THROUGH STORE MAPREDUCE "
    + "SHIP CACHE INPUT OUTPUT STDERROR STDIN STDOUT LIMIT SAMPLE LEFT RIGHT FULL EQ GT LT GTE LTE "
    + "NEQ MATCHES TRUE FALSE DUMP";

  // data types
  var pTypes = "BOOLEAN INT LONG FLOAT DOUBLE CHARARRAY BYTEARRAY BAG TUPLE MAP ";

  CodeMirror.defineMIME("text/x-pig", {
    name: "pig",
    builtins: keywords(pBuiltins),
    keywords: keywords(pKeywords),
    types: keywords(pTypes)
  });

  CodeMirror.registerHelper("hintWords", "pig", (pBuiltins + pTypes + pKeywords).split(" "));
}());

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/powershell/powershell.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  'use strict';
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
'use strict';

CodeMirror.defineMode('powershell', function() {
  function buildRegexp(patterns, options) {
    options = options || {};
    var prefix = options.prefix !== undefined ? options.prefix : '^';
    var suffix = options.suffix !== undefined ? options.suffix : '\\b';

    for (var i = 0; i < patterns.length; i++) {
      if (patterns[i] instanceof RegExp) {
        patterns[i] = patterns[i].source;
      }
      else {
        patterns[i] = patterns[i].replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
      }
    }

    return new RegExp(prefix + '(' + patterns.join('|') + ')' + suffix, 'i');
  }

  var notCharacterOrDash = '(?=[^A-Za-z\\d\\-_]|$)';
  var varNames = /[\w\-:]/
  var keywords = buildRegexp([
    /begin|break|catch|continue|data|default|do|dynamicparam/,
    /else|elseif|end|exit|filter|finally|for|foreach|from|function|if|in/,
    /param|process|return|switch|throw|trap|try|until|where|while/
  ], { suffix: notCharacterOrDash });

  var punctuation = /[\[\]{},;`\\\.]|@[({]/;
  var wordOperators = buildRegexp([
    'f',
    /b?not/,
    /[ic]?split/, 'join',
    /is(not)?/, 'as',
    /[ic]?(eq|ne|[gl][te])/,
    /[ic]?(not)?(like|match|contains)/,
    /[ic]?replace/,
    /b?(and|or|xor)/
  ], { prefix: '-' });
  var symbolOperators = /[+\-*\/%]=|\+\+|--|\.\.|[+\-*&^%:=!|\/]|<(?!#)|(?!#)>/;
  var operators = buildRegexp([wordOperators, symbolOperators], { suffix: '' });

  var numbers = /^((0x[\da-f]+)|((\d+\.\d+|\d\.|\.\d+|\d+)(e[\+\-]?\d+)?))[ld]?([kmgtp]b)?/i;

  var identifiers = /^[A-Za-z\_][A-Za-z\-\_\d]*\b/;

  var symbolBuiltins = /[A-Z]:|%|\?/i;
  var namedBuiltins = buildRegexp([
    /Add-(Computer|Content|History|Member|PSSnapin|Type)/,
    /Checkpoint-Computer/,
    /Clear-(Content|EventLog|History|Host|Item(Property)?|Variable)/,
    /Compare-Object/,
    /Complete-Transaction/,
    /Connect-PSSession/,
    /ConvertFrom-(Csv|Json|SecureString|StringData)/,
    /Convert-Path/,
    /ConvertTo-(Csv|Html|Json|SecureString|Xml)/,
    /Copy-Item(Property)?/,
    /Debug-Process/,
    /Disable-(ComputerRestore|PSBreakpoint|PSRemoting|PSSessionConfiguration)/,
    /Disconnect-PSSession/,
    /Enable-(ComputerRestore|PSBreakpoint|PSRemoting|PSSessionConfiguration)/,
    /(Enter|Exit)-PSSession/,
    /Export-(Alias|Clixml|Console|Counter|Csv|FormatData|ModuleMember|PSSession)/,
    /ForEach-Object/,
    /Format-(Custom|List|Table|Wide)/,
    new RegExp('Get-(Acl|Alias|AuthenticodeSignature|ChildItem|Command|ComputerRestorePoint|Content|ControlPanelItem|Counter|Credential'
      + '|Culture|Date|Event|EventLog|EventSubscriber|ExecutionPolicy|FormatData|Help|History|Host|HotFix|Item|ItemProperty|Job'
      + '|Location|Member|Module|PfxCertificate|Process|PSBreakpoint|PSCallStack|PSDrive|PSProvider|PSSession|PSSessionConfiguration'
      + '|PSSnapin|Random|Service|TraceSource|Transaction|TypeData|UICulture|Unique|Variable|Verb|WinEvent|WmiObject)'),
    /Group-Object/,
    /Import-(Alias|Clixml|Counter|Csv|LocalizedData|Module|PSSession)/,
    /ImportSystemModules/,
    /Invoke-(Command|Expression|History|Item|RestMethod|WebRequest|WmiMethod)/,
    /Join-Path/,
    /Limit-EventLog/,
    /Measure-(Command|Object)/,
    /Move-Item(Property)?/,
    new RegExp('New-(Alias|Event|EventLog|Item(Property)?|Module|ModuleManifest|Object|PSDrive|PSSession|PSSessionConfigurationFile'
      + '|PSSessionOption|PSTransportOption|Service|TimeSpan|Variable|WebServiceProxy|WinEvent)'),
    /Out-(Default|File|GridView|Host|Null|Printer|String)/,
    /Pause/,
    /(Pop|Push)-Location/,
    /Read-Host/,
    /Receive-(Job|PSSession)/,
    /Register-(EngineEvent|ObjectEvent|PSSessionConfiguration|WmiEvent)/,
    /Remove-(Computer|Event|EventLog|Item(Property)?|Job|Module|PSBreakpoint|PSDrive|PSSession|PSSnapin|TypeData|Variable|WmiObject)/,
    /Rename-(Computer|Item(Property)?)/,
    /Reset-ComputerMachinePassword/,
    /Resolve-Path/,
    /Restart-(Computer|Service)/,
    /Restore-Computer/,
    /Resume-(Job|Service)/,
    /Save-Help/,
    /Select-(Object|String|Xml)/,
    /Send-MailMessage/,
    new RegExp('Set-(Acl|Alias|AuthenticodeSignature|Content|Date|ExecutionPolicy|Item(Property)?|Location|PSBreakpoint|PSDebug' +
               '|PSSessionConfiguration|Service|StrictMode|TraceSource|Variable|WmiInstance)'),
    /Show-(Command|ControlPanelItem|EventLog)/,
    /Sort-Object/,
    /Split-Path/,
    /Start-(Job|Process|Service|Sleep|Transaction|Transcript)/,
    /Stop-(Computer|Job|Process|Service|Transcript)/,
    /Suspend-(Job|Service)/,
    /TabExpansion2/,
    /Tee-Object/,
    /Test-(ComputerSecureChannel|Connection|ModuleManifest|Path|PSSessionConfigurationFile)/,
    /Trace-Command/,
    /Unblock-File/,
    /Undo-Transaction/,
    /Unregister-(Event|PSSessionConfiguration)/,
    /Update-(FormatData|Help|List|TypeData)/,
    /Use-Transaction/,
    /Wait-(Event|Job|Process)/,
    /Where-Object/,
    /Write-(Debug|Error|EventLog|Host|Output|Progress|Verbose|Warning)/,
    /cd|help|mkdir|more|oss|prompt/,
    /ac|asnp|cat|cd|chdir|clc|clear|clhy|cli|clp|cls|clv|cnsn|compare|copy|cp|cpi|cpp|cvpa|dbp|del|diff|dir|dnsn|ebp/,
    /echo|epal|epcsv|epsn|erase|etsn|exsn|fc|fl|foreach|ft|fw|gal|gbp|gc|gci|gcm|gcs|gdr|ghy|gi|gjb|gl|gm|gmo|gp|gps/,
    /group|gsn|gsnp|gsv|gu|gv|gwmi|h|history|icm|iex|ihy|ii|ipal|ipcsv|ipmo|ipsn|irm|ise|iwmi|iwr|kill|lp|ls|man|md/,
    /measure|mi|mount|move|mp|mv|nal|ndr|ni|nmo|npssc|nsn|nv|ogv|oh|popd|ps|pushd|pwd|r|rbp|rcjb|rcsn|rd|rdr|ren|ri/,
    /rjb|rm|rmdir|rmo|rni|rnp|rp|rsn|rsnp|rujb|rv|rvpa|rwmi|sajb|sal|saps|sasv|sbp|sc|select|set|shcm|si|sl|sleep|sls/,
    /sort|sp|spjb|spps|spsv|start|sujb|sv|swmi|tee|trcm|type|where|wjb|write/
  ], { prefix: '', suffix: '' });
  var variableBuiltins = buildRegexp([
    /[$?^_]|Args|ConfirmPreference|ConsoleFileName|DebugPreference|Error|ErrorActionPreference|ErrorView|ExecutionContext/,
    /FormatEnumerationLimit|Home|Host|Input|MaximumAliasCount|MaximumDriveCount|MaximumErrorCount|MaximumFunctionCount/,
    /MaximumHistoryCount|MaximumVariableCount|MyInvocation|NestedPromptLevel|OutputEncoding|Pid|Profile|ProgressPreference/,
    /PSBoundParameters|PSCommandPath|PSCulture|PSDefaultParameterValues|PSEmailServer|PSHome|PSScriptRoot|PSSessionApplicationName/,
    /PSSessionConfigurationName|PSSessionOption|PSUICulture|PSVersionTable|Pwd|ShellId|StackTrace|VerbosePreference/,
    /WarningPreference|WhatIfPreference/,

    /Event|EventArgs|EventSubscriber|Sender/,
    /Matches|Ofs|ForEach|LastExitCode|PSCmdlet|PSItem|PSSenderInfo|This/,
    /true|false|null/
  ], { prefix: '\\$', suffix: '' });

  var builtins = buildRegexp([symbolBuiltins, namedBuiltins, variableBuiltins], { suffix: notCharacterOrDash });

  var grammar = {
    keyword: keywords,
    number: numbers,
    operator: operators,
    builtin: builtins,
    punctuation: punctuation,
    identifier: identifiers
  };

  // tokenizers
  function tokenBase(stream, state) {
    // Handle Comments
    //var ch = stream.peek();

    var parent = state.returnStack[state.returnStack.length - 1];
    if (parent && parent.shouldReturnFrom(state)) {
      state.tokenize = parent.tokenize;
      state.returnStack.pop();
      return state.tokenize(stream, state);
    }

    if (stream.eatSpace()) {
      return null;
    }

    if (stream.eat('(')) {
      state.bracketNesting += 1;
      return 'punctuation';
    }

    if (stream.eat(')')) {
      state.bracketNesting -= 1;
      return 'punctuation';
    }

    for (var key in grammar) {
      if (stream.match(grammar[key])) {
        return key;
      }
    }

    var ch = stream.next();

    // single-quote string
    if (ch === "'") {
      return tokenSingleQuoteString(stream, state);
    }

    if (ch === '$') {
      return tokenVariable(stream, state);
    }

    // double-quote string
    if (ch === '"') {
      return tokenDoubleQuoteString(stream, state);
    }

    if (ch === '<' && stream.eat('#')) {
      state.tokenize = tokenComment;
      return tokenComment(stream, state);
    }

    if (ch === '#') {
      stream.skipToEnd();
      return 'comment';
    }

    if (ch === '@') {
      var quoteMatch = stream.eat(/["']/);
      if (quoteMatch && stream.eol()) {
        state.tokenize = tokenMultiString;
        state.startQuote = quoteMatch[0];
        return tokenMultiString(stream, state);
      } else if (stream.eol()) {
        return 'error';
      } else if (stream.peek().match(/[({]/)) {
        return 'punctuation';
      } else if (stream.peek().match(varNames)) {
        // splatted variable
        return tokenVariable(stream, state);
      }
    }
    return 'error';
  }

  function tokenSingleQuoteString(stream, state) {
    var ch;
    while ((ch = stream.peek()) != null) {
      stream.next();

      if (ch === "'" && !stream.eat("'")) {
        state.tokenize = tokenBase;
        return 'string';
      }
    }

    return 'error';
  }

  function tokenDoubleQuoteString(stream, state) {
    var ch;
    while ((ch = stream.peek()) != null) {
      if (ch === '$') {
        state.tokenize = tokenStringInterpolation;
        return 'string';
      }

      stream.next();
      if (ch === '`') {
        stream.next();
        continue;
      }

      if (ch === '"' && !stream.eat('"')) {
        state.tokenize = tokenBase;
        return 'string';
      }
    }

    return 'error';
  }

  function tokenStringInterpolation(stream, state) {
    return tokenInterpolation(stream, state, tokenDoubleQuoteString);
  }

  function tokenMultiStringReturn(stream, state) {
    state.tokenize = tokenMultiString;
    state.startQuote = '"'
    return tokenMultiString(stream, state);
  }

  function tokenHereStringInterpolation(stream, state) {
    return tokenInterpolation(stream, state, tokenMultiStringReturn);
  }

  function tokenInterpolation(stream, state, parentTokenize) {
    if (stream.match('$(')) {
      var savedBracketNesting = state.bracketNesting;
      state.returnStack.push({
        /*jshint loopfunc:true */
        shouldReturnFrom: function(state) {
          return state.bracketNesting === savedBracketNesting;
        },
        tokenize: parentTokenize
      });
      state.tokenize = tokenBase;
      state.bracketNesting += 1;
      return 'punctuation';
    } else {
      stream.next();
      state.returnStack.push({
        shouldReturnFrom: function() { return true; },
        tokenize: parentTokenize
      });
      state.tokenize = tokenVariable;
      return state.tokenize(stream, state);
    }
  }

  function tokenComment(stream, state) {
    var maybeEnd = false, ch;
    while ((ch = stream.next()) != null) {
      if (maybeEnd && ch == '>') {
          state.tokenize = tokenBase;
          break;
      }
      maybeEnd = (ch === '#');
    }
    return 'comment';
  }

  function tokenVariable(stream, state) {
    var ch = stream.peek();
    if (stream.eat('{')) {
      state.tokenize = tokenVariableWithBraces;
      return tokenVariableWithBraces(stream, state);
    } else if (ch != undefined && ch.match(varNames)) {
      stream.eatWhile(varNames);
      state.tokenize = tokenBase;
      return 'variable-2';
    } else {
      state.tokenize = tokenBase;
      return 'error';
    }
  }

  function tokenVariableWithBraces(stream, state) {
    var ch;
    while ((ch = stream.next()) != null) {
      if (ch === '}') {
        state.tokenize = tokenBase;
        break;
      }
    }
    return 'variable-2';
  }

  function tokenMultiString(stream, state) {
    var quote = state.startQuote;
    if (stream.sol() && stream.match(new RegExp(quote + '@'))) {
      state.tokenize = tokenBase;
    }
    else if (quote === '"') {
      while (!stream.eol()) {
        var ch = stream.peek();
        if (ch === '$') {
          state.tokenize = tokenHereStringInterpolation;
          return 'string';
        }

        stream.next();
        if (ch === '`') {
          stream.next();
        }
      }
    }
    else {
      stream.skipToEnd();
    }

    return 'string';
  }

  var external = {
    startState: function() {
      return {
        returnStack: [],
        bracketNesting: 0,
        tokenize: tokenBase
      };
    },

    token: function(stream, state) {
      return state.tokenize(stream, state);
    },

    blockCommentStart: '<#',
    blockCommentEnd: '#>',
    lineComment: '#',
    fold: 'brace'
  };
  return external;
});

CodeMirror.defineMIME('application/x-powershell', 'powershell');
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/properties/properties.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("properties", function() {
  return {
    token: function(stream, state) {
      var sol = stream.sol() || state.afterSection;
      var eol = stream.eol();

      state.afterSection = false;

      if (sol) {
        if (state.nextMultiline) {
          state.inMultiline = true;
          state.nextMultiline = false;
        } else {
          state.position = "def";
        }
      }

      if (eol && ! state.nextMultiline) {
        state.inMultiline = false;
        state.position = "def";
      }

      if (sol) {
        while(stream.eatSpace()) {}
      }

      var ch = stream.next();

      if (sol && (ch === "#" || ch === "!" || ch === ";")) {
        state.position = "comment";
        stream.skipToEnd();
        return "comment";
      } else if (sol && ch === "[") {
        state.afterSection = true;
        stream.skipTo("]"); stream.eat("]");
        return "header";
      } else if (ch === "=" || ch === ":") {
        state.position = "quote";
        return null;
      } else if (ch === "\\" && state.position === "quote") {
        if (stream.eol()) {  // end of line?
          // Multiline value
          state.nextMultiline = true;
        }
      }

      return state.position;
    },

    startState: function() {
      return {
        position : "def",       // Current position, "def", "quote" or "comment"
        nextMultiline : false,  // Is the next line multiline value
        inMultiline : false,    // Is the current line a multiline value
        afterSection : false    // Did we just open a section
      };
    }

  };
});

CodeMirror.defineMIME("text/x-properties", "properties");
CodeMirror.defineMIME("text/x-ini", "properties");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/protobuf/protobuf.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
  "use strict";

  function wordRegexp(words) {
    return new RegExp("^((" + words.join(")|(") + "))\\b", "i");
  };

  var keywordArray = [
    "package", "message", "import", "syntax",
    "required", "optional", "repeated", "reserved", "default", "extensions", "packed",
    "bool", "bytes", "double", "enum", "float", "string",
    "int32", "int64", "uint32", "uint64", "sint32", "sint64", "fixed32", "fixed64", "sfixed32", "sfixed64",
    "option", "service", "rpc", "returns"
  ];
  var keywords = wordRegexp(keywordArray);

  CodeMirror.registerHelper("hintWords", "protobuf", keywordArray);

  var identifiers = new RegExp("^[_A-Za-z\xa1-\uffff][_A-Za-z0-9\xa1-\uffff]*");

  function tokenBase(stream) {
    // whitespaces
    if (stream.eatSpace()) return null;

    // Handle one line Comments
    if (stream.match("//")) {
      stream.skipToEnd();
      return "comment";
    }

    // Handle Number Literals
    if (stream.match(/^[0-9\.+-]/, false)) {
      if (stream.match(/^[+-]?0x[0-9a-fA-F]+/))
        return "number";
      if (stream.match(/^[+-]?\d*\.\d+([EeDd][+-]?\d+)?/))
        return "number";
      if (stream.match(/^[+-]?\d+([EeDd][+-]?\d+)?/))
        return "number";
    }

    // Handle Strings
    if (stream.match(/^"([^"]|(""))*"/)) { return "string"; }
    if (stream.match(/^'([^']|(''))*'/)) { return "string"; }

    // Handle words
    if (stream.match(keywords)) { return "keyword"; }
    if (stream.match(identifiers)) { return "variable"; } ;

    // Handle non-detected items
    stream.next();
    return null;
  };

  CodeMirror.defineMode("protobuf", function() {
    return {
      token: tokenBase,
      fold: "brace"
    };
  });

  CodeMirror.defineMIME("text/x-protobuf", "protobuf");
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/pug/pug.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"), __webpack_require__("./src/ipywidgets/node_modules/codemirror/mode/javascript/javascript.js"), __webpack_require__("./src/ipywidgets/node_modules/codemirror/mode/css/css.js"), __webpack_require__("./src/ipywidgets/node_modules/codemirror/mode/htmlmixed/htmlmixed.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("pug", function (config) {
  // token types
  var KEYWORD = 'keyword';
  var DOCTYPE = 'meta';
  var ID = 'builtin';
  var CLASS = 'qualifier';

  var ATTRS_NEST = {
    '{': '}',
    '(': ')',
    '[': ']'
  };

  var jsMode = CodeMirror.getMode(config, 'javascript');

  function State() {
    this.javaScriptLine = false;
    this.javaScriptLineExcludesColon = false;

    this.javaScriptArguments = false;
    this.javaScriptArgumentsDepth = 0;

    this.isInterpolating = false;
    this.interpolationNesting = 0;

    this.jsState = CodeMirror.startState(jsMode);

    this.restOfLine = '';

    this.isIncludeFiltered = false;
    this.isEach = false;

    this.lastTag = '';
    this.scriptType = '';

    // Attributes Mode
    this.isAttrs = false;
    this.attrsNest = [];
    this.inAttributeName = true;
    this.attributeIsType = false;
    this.attrValue = '';

    // Indented Mode
    this.indentOf = Infinity;
    this.indentToken = '';

    this.innerMode = null;
    this.innerState = null;

    this.innerModeForLine = false;
  }
  /**
   * Safely copy a state
   *
   * @return {State}
   */
  State.prototype.copy = function () {
    var res = new State();
    res.javaScriptLine = this.javaScriptLine;
    res.javaScriptLineExcludesColon = this.javaScriptLineExcludesColon;
    res.javaScriptArguments = this.javaScriptArguments;
    res.javaScriptArgumentsDepth = this.javaScriptArgumentsDepth;
    res.isInterpolating = this.isInterpolating;
    res.interpolationNesting = this.interpolationNesting;

    res.jsState = CodeMirror.copyState(jsMode, this.jsState);

    res.innerMode = this.innerMode;
    if (this.innerMode && this.innerState) {
      res.innerState = CodeMirror.copyState(this.innerMode, this.innerState);
    }

    res.restOfLine = this.restOfLine;

    res.isIncludeFiltered = this.isIncludeFiltered;
    res.isEach = this.isEach;
    res.lastTag = this.lastTag;
    res.scriptType = this.scriptType;
    res.isAttrs = this.isAttrs;
    res.attrsNest = this.attrsNest.slice();
    res.inAttributeName = this.inAttributeName;
    res.attributeIsType = this.attributeIsType;
    res.attrValue = this.attrValue;
    res.indentOf = this.indentOf;
    res.indentToken = this.indentToken;

    res.innerModeForLine = this.innerModeForLine;

    return res;
  };

  function javaScript(stream, state) {
    if (stream.sol()) {
      // if javaScriptLine was set at end of line, ignore it
      state.javaScriptLine = false;
      state.javaScriptLineExcludesColon = false;
    }
    if (state.javaScriptLine) {
      if (state.javaScriptLineExcludesColon && stream.peek() === ':') {
        state.javaScriptLine = false;
        state.javaScriptLineExcludesColon = false;
        return;
      }
      var tok = jsMode.token(stream, state.jsState);
      if (stream.eol()) state.javaScriptLine = false;
      return tok || true;
    }
  }
  function javaScriptArguments(stream, state) {
    if (state.javaScriptArguments) {
      if (state.javaScriptArgumentsDepth === 0 && stream.peek() !== '(') {
        state.javaScriptArguments = false;
        return;
      }
      if (stream.peek() === '(') {
        state.javaScriptArgumentsDepth++;
      } else if (stream.peek() === ')') {
        state.javaScriptArgumentsDepth--;
      }
      if (state.javaScriptArgumentsDepth === 0) {
        state.javaScriptArguments = false;
        return;
      }

      var tok = jsMode.token(stream, state.jsState);
      return tok || true;
    }
  }

  function yieldStatement(stream) {
    if (stream.match(/^yield\b/)) {
        return 'keyword';
    }
  }

  function doctype(stream) {
    if (stream.match(/^(?:doctype) *([^\n]+)?/)) {
        return DOCTYPE;
    }
  }

  function interpolation(stream, state) {
    if (stream.match('#{')) {
      state.isInterpolating = true;
      state.interpolationNesting = 0;
      return 'punctuation';
    }
  }

  function interpolationContinued(stream, state) {
    if (state.isInterpolating) {
      if (stream.peek() === '}') {
        state.interpolationNesting--;
        if (state.interpolationNesting < 0) {
          stream.next();
          state.isInterpolating = false;
          return 'punctuation';
        }
      } else if (stream.peek() === '{') {
        state.interpolationNesting++;
      }
      return jsMode.token(stream, state.jsState) || true;
    }
  }

  function caseStatement(stream, state) {
    if (stream.match(/^case\b/)) {
      state.javaScriptLine = true;
      return KEYWORD;
    }
  }

  function when(stream, state) {
    if (stream.match(/^when\b/)) {
      state.javaScriptLine = true;
      state.javaScriptLineExcludesColon = true;
      return KEYWORD;
    }
  }

  function defaultStatement(stream) {
    if (stream.match(/^default\b/)) {
      return KEYWORD;
    }
  }

  function extendsStatement(stream, state) {
    if (stream.match(/^extends?\b/)) {
      state.restOfLine = 'string';
      return KEYWORD;
    }
  }

  function append(stream, state) {
    if (stream.match(/^append\b/)) {
      state.restOfLine = 'variable';
      return KEYWORD;
    }
  }
  function prepend(stream, state) {
    if (stream.match(/^prepend\b/)) {
      state.restOfLine = 'variable';
      return KEYWORD;
    }
  }
  function block(stream, state) {
    if (stream.match(/^block\b *(?:(prepend|append)\b)?/)) {
      state.restOfLine = 'variable';
      return KEYWORD;
    }
  }

  function include(stream, state) {
    if (stream.match(/^include\b/)) {
      state.restOfLine = 'string';
      return KEYWORD;
    }
  }

  function includeFiltered(stream, state) {
    if (stream.match(/^include:([a-zA-Z0-9\-]+)/, false) && stream.match('include')) {
      state.isIncludeFiltered = true;
      return KEYWORD;
    }
  }

  function includeFilteredContinued(stream, state) {
    if (state.isIncludeFiltered) {
      var tok = filter(stream, state);
      state.isIncludeFiltered = false;
      state.restOfLine = 'string';
      return tok;
    }
  }

  function mixin(stream, state) {
    if (stream.match(/^mixin\b/)) {
      state.javaScriptLine = true;
      return KEYWORD;
    }
  }

  function call(stream, state) {
    if (stream.match(/^\+([-\w]+)/)) {
      if (!stream.match(/^\( *[-\w]+ *=/, false)) {
        state.javaScriptArguments = true;
        state.javaScriptArgumentsDepth = 0;
      }
      return 'variable';
    }
    if (stream.match('+#{', false)) {
      stream.next();
      state.mixinCallAfter = true;
      return interpolation(stream, state);
    }
  }
  function callArguments(stream, state) {
    if (state.mixinCallAfter) {
      state.mixinCallAfter = false;
      if (!stream.match(/^\( *[-\w]+ *=/, false)) {
        state.javaScriptArguments = true;
        state.javaScriptArgumentsDepth = 0;
      }
      return true;
    }
  }

  function conditional(stream, state) {
    if (stream.match(/^(if|unless|else if|else)\b/)) {
      state.javaScriptLine = true;
      return KEYWORD;
    }
  }

  function each(stream, state) {
    if (stream.match(/^(- *)?(each|for)\b/)) {
      state.isEach = true;
      return KEYWORD;
    }
  }
  function eachContinued(stream, state) {
    if (state.isEach) {
      if (stream.match(/^ in\b/)) {
        state.javaScriptLine = true;
        state.isEach = false;
        return KEYWORD;
      } else if (stream.sol() || stream.eol()) {
        state.isEach = false;
      } else if (stream.next()) {
        while (!stream.match(/^ in\b/, false) && stream.next());
        return 'variable';
      }
    }
  }

  function whileStatement(stream, state) {
    if (stream.match(/^while\b/)) {
      state.javaScriptLine = true;
      return KEYWORD;
    }
  }

  function tag(stream, state) {
    var captures;
    if (captures = stream.match(/^(\w(?:[-:\w]*\w)?)\/?/)) {
      state.lastTag = captures[1].toLowerCase();
      if (state.lastTag === 'script') {
        state.scriptType = 'application/javascript';
      }
      return 'tag';
    }
  }

  function filter(stream, state) {
    if (stream.match(/^:([\w\-]+)/)) {
      var innerMode;
      if (config && config.innerModes) {
        innerMode = config.innerModes(stream.current().substring(1));
      }
      if (!innerMode) {
        innerMode = stream.current().substring(1);
      }
      if (typeof innerMode === 'string') {
        innerMode = CodeMirror.getMode(config, innerMode);
      }
      setInnerMode(stream, state, innerMode);
      return 'atom';
    }
  }

  function code(stream, state) {
    if (stream.match(/^(!?=|-)/)) {
      state.javaScriptLine = true;
      return 'punctuation';
    }
  }

  function id(stream) {
    if (stream.match(/^#([\w-]+)/)) {
      return ID;
    }
  }

  function className(stream) {
    if (stream.match(/^\.([\w-]+)/)) {
      return CLASS;
    }
  }

  function attrs(stream, state) {
    if (stream.peek() == '(') {
      stream.next();
      state.isAttrs = true;
      state.attrsNest = [];
      state.inAttributeName = true;
      state.attrValue = '';
      state.attributeIsType = false;
      return 'punctuation';
    }
  }

  function attrsContinued(stream, state) {
    if (state.isAttrs) {
      if (ATTRS_NEST[stream.peek()]) {
        state.attrsNest.push(ATTRS_NEST[stream.peek()]);
      }
      if (state.attrsNest[state.attrsNest.length - 1] === stream.peek()) {
        state.attrsNest.pop();
      } else  if (stream.eat(')')) {
        state.isAttrs = false;
        return 'punctuation';
      }
      if (state.inAttributeName && stream.match(/^[^=,\)!]+/)) {
        if (stream.peek() === '=' || stream.peek() === '!') {
          state.inAttributeName = false;
          state.jsState = CodeMirror.startState(jsMode);
          if (state.lastTag === 'script' && stream.current().trim().toLowerCase() === 'type') {
            state.attributeIsType = true;
          } else {
            state.attributeIsType = false;
          }
        }
        return 'attribute';
      }

      var tok = jsMode.token(stream, state.jsState);
      if (state.attributeIsType && tok === 'string') {
        state.scriptType = stream.current().toString();
      }
      if (state.attrsNest.length === 0 && (tok === 'string' || tok === 'variable' || tok === 'keyword')) {
        try {
          Function('', 'var x ' + state.attrValue.replace(/,\s*$/, '').replace(/^!/, ''));
          state.inAttributeName = true;
          state.attrValue = '';
          stream.backUp(stream.current().length);
          return attrsContinued(stream, state);
        } catch (ex) {
          //not the end of an attribute
        }
      }
      state.attrValue += stream.current();
      return tok || true;
    }
  }

  function attributesBlock(stream, state) {
    if (stream.match(/^&attributes\b/)) {
      state.javaScriptArguments = true;
      state.javaScriptArgumentsDepth = 0;
      return 'keyword';
    }
  }

  function indent(stream) {
    if (stream.sol() && stream.eatSpace()) {
      return 'indent';
    }
  }

  function comment(stream, state) {
    if (stream.match(/^ *\/\/(-)?([^\n]*)/)) {
      state.indentOf = stream.indentation();
      state.indentToken = 'comment';
      return 'comment';
    }
  }

  function colon(stream) {
    if (stream.match(/^: */)) {
      return 'colon';
    }
  }

  function text(stream, state) {
    if (stream.match(/^(?:\| ?| )([^\n]+)/)) {
      return 'string';
    }
    if (stream.match(/^(<[^\n]*)/, false)) {
      // html string
      setInnerMode(stream, state, 'htmlmixed');
      state.innerModeForLine = true;
      return innerMode(stream, state, true);
    }
  }

  function dot(stream, state) {
    if (stream.eat('.')) {
      var innerMode = null;
      if (state.lastTag === 'script' && state.scriptType.toLowerCase().indexOf('javascript') != -1) {
        innerMode = state.scriptType.toLowerCase().replace(/"|'/g, '');
      } else if (state.lastTag === 'style') {
        innerMode = 'css';
      }
      setInnerMode(stream, state, innerMode);
      return 'dot';
    }
  }

  function fail(stream) {
    stream.next();
    return null;
  }


  function setInnerMode(stream, state, mode) {
    mode = CodeMirror.mimeModes[mode] || mode;
    mode = config.innerModes ? config.innerModes(mode) || mode : mode;
    mode = CodeMirror.mimeModes[mode] || mode;
    mode = CodeMirror.getMode(config, mode);
    state.indentOf = stream.indentation();

    if (mode && mode.name !== 'null') {
      state.innerMode = mode;
    } else {
      state.indentToken = 'string';
    }
  }
  function innerMode(stream, state, force) {
    if (stream.indentation() > state.indentOf || (state.innerModeForLine && !stream.sol()) || force) {
      if (state.innerMode) {
        if (!state.innerState) {
          state.innerState = state.innerMode.startState ? CodeMirror.startState(state.innerMode, stream.indentation()) : {};
        }
        return stream.hideFirstChars(state.indentOf + 2, function () {
          return state.innerMode.token(stream, state.innerState) || true;
        });
      } else {
        stream.skipToEnd();
        return state.indentToken;
      }
    } else if (stream.sol()) {
      state.indentOf = Infinity;
      state.indentToken = null;
      state.innerMode = null;
      state.innerState = null;
    }
  }
  function restOfLine(stream, state) {
    if (stream.sol()) {
      // if restOfLine was set at end of line, ignore it
      state.restOfLine = '';
    }
    if (state.restOfLine) {
      stream.skipToEnd();
      var tok = state.restOfLine;
      state.restOfLine = '';
      return tok;
    }
  }


  function startState() {
    return new State();
  }
  function copyState(state) {
    return state.copy();
  }
  /**
   * Get the next token in the stream
   *
   * @param {Stream} stream
   * @param {State} state
   */
  function nextToken(stream, state) {
    var tok = innerMode(stream, state)
      || restOfLine(stream, state)
      || interpolationContinued(stream, state)
      || includeFilteredContinued(stream, state)
      || eachContinued(stream, state)
      || attrsContinued(stream, state)
      || javaScript(stream, state)
      || javaScriptArguments(stream, state)
      || callArguments(stream, state)

      || yieldStatement(stream)
      || doctype(stream)
      || interpolation(stream, state)
      || caseStatement(stream, state)
      || when(stream, state)
      || defaultStatement(stream)
      || extendsStatement(stream, state)
      || append(stream, state)
      || prepend(stream, state)
      || block(stream, state)
      || include(stream, state)
      || includeFiltered(stream, state)
      || mixin(stream, state)
      || call(stream, state)
      || conditional(stream, state)
      || each(stream, state)
      || whileStatement(stream, state)
      || tag(stream, state)
      || filter(stream, state)
      || code(stream, state)
      || id(stream)
      || className(stream)
      || attrs(stream, state)
      || attributesBlock(stream, state)
      || indent(stream)
      || text(stream, state)
      || comment(stream, state)
      || colon(stream)
      || dot(stream, state)
      || fail(stream);

    return tok === true ? null : tok;
  }
  return {
    startState: startState,
    copyState: copyState,
    token: nextToken
  };
}, 'javascript', 'css', 'htmlmixed');

CodeMirror.defineMIME('text/x-pug', 'pug');
CodeMirror.defineMIME('text/x-jade', 'pug');

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/puppet/puppet.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("puppet", function () {
  // Stores the words from the define method
  var words = {};
  // Taken, mostly, from the Puppet official variable standards regex
  var variable_regex = /({)?([a-z][a-z0-9_]*)?((::[a-z][a-z0-9_]*)*::)?[a-zA-Z0-9_]+(})?/;

  // Takes a string of words separated by spaces and adds them as
  // keys with the value of the first argument 'style'
  function define(style, string) {
    var split = string.split(' ');
    for (var i = 0; i < split.length; i++) {
      words[split[i]] = style;
    }
  }

  // Takes commonly known puppet types/words and classifies them to a style
  define('keyword', 'class define site node include import inherits');
  define('keyword', 'case if else in and elsif default or');
  define('atom', 'false true running present absent file directory undef');
  define('builtin', 'action augeas burst chain computer cron destination dport exec ' +
    'file filebucket group host icmp iniface interface jump k5login limit log_level ' +
    'log_prefix macauthorization mailalias maillist mcx mount nagios_command ' +
    'nagios_contact nagios_contactgroup nagios_host nagios_hostdependency ' +
    'nagios_hostescalation nagios_hostextinfo nagios_hostgroup nagios_service ' +
    'nagios_servicedependency nagios_serviceescalation nagios_serviceextinfo ' +
    'nagios_servicegroup nagios_timeperiod name notify outiface package proto reject ' +
    'resources router schedule scheduled_task selboolean selmodule service source ' +
    'sport ssh_authorized_key sshkey stage state table tidy todest toports tosource ' +
    'user vlan yumrepo zfs zone zpool');

  // After finding a start of a string ('|") this function attempts to find the end;
  // If a variable is encountered along the way, we display it differently when it
  // is encapsulated in a double-quoted string.
  function tokenString(stream, state) {
    var current, prev, found_var = false;
    while (!stream.eol() && (current = stream.next()) != state.pending) {
      if (current === '$' && prev != '\\' && state.pending == '"') {
        found_var = true;
        break;
      }
      prev = current;
    }
    if (found_var) {
      stream.backUp(1);
    }
    if (current == state.pending) {
      state.continueString = false;
    } else {
      state.continueString = true;
    }
    return "string";
  }

  // Main function
  function tokenize(stream, state) {
    // Matches one whole word
    var word = stream.match(/[\w]+/, false);
    // Matches attributes (i.e. ensure => present ; 'ensure' would be matched)
    var attribute = stream.match(/(\s+)?\w+\s+=>.*/, false);
    // Matches non-builtin resource declarations
    // (i.e. "apache::vhost {" or "mycustomclasss {" would be matched)
    var resource = stream.match(/(\s+)?[\w:_]+(\s+)?{/, false);
    // Matches virtual and exported resources (i.e. @@user { ; and the like)
    var special_resource = stream.match(/(\s+)?[@]{1,2}[\w:_]+(\s+)?{/, false);

    // Finally advance the stream
    var ch = stream.next();

    // Have we found a variable?
    if (ch === '$') {
      if (stream.match(variable_regex)) {
        // If so, and its in a string, assign it a different color
        return state.continueString ? 'variable-2' : 'variable';
      }
      // Otherwise return an invalid variable
      return "error";
    }
    // Should we still be looking for the end of a string?
    if (state.continueString) {
      // If so, go through the loop again
      stream.backUp(1);
      return tokenString(stream, state);
    }
    // Are we in a definition (class, node, define)?
    if (state.inDefinition) {
      // If so, return def (i.e. for 'class myclass {' ; 'myclass' would be matched)
      if (stream.match(/(\s+)?[\w:_]+(\s+)?/)) {
        return 'def';
      }
      // Match the rest it the next time around
      stream.match(/\s+{/);
      state.inDefinition = false;
    }
    // Are we in an 'include' statement?
    if (state.inInclude) {
      // Match and return the included class
      stream.match(/(\s+)?\S+(\s+)?/);
      state.inInclude = false;
      return 'def';
    }
    // Do we just have a function on our hands?
    // In 'ensure_resource("myclass")', 'ensure_resource' is matched
    if (stream.match(/(\s+)?\w+\(/)) {
      stream.backUp(1);
      return 'def';
    }
    // Have we matched the prior attribute regex?
    if (attribute) {
      stream.match(/(\s+)?\w+/);
      return 'tag';
    }
    // Do we have Puppet specific words?
    if (word && words.hasOwnProperty(word)) {
      // Negates the initial next()
      stream.backUp(1);
      // rs move the stream
      stream.match(/[\w]+/);
      // We want to process these words differently
      // do to the importance they have in Puppet
      if (stream.match(/\s+\S+\s+{/, false)) {
        state.inDefinition = true;
      }
      if (word == 'include') {
        state.inInclude = true;
      }
      // Returns their value as state in the prior define methods
      return words[word];
    }
    // Is there a match on a reference?
    if (/(^|\s+)[A-Z][\w:_]+/.test(word)) {
      // Negate the next()
      stream.backUp(1);
      // Match the full reference
      stream.match(/(^|\s+)[A-Z][\w:_]+/);
      return 'def';
    }
    // Have we matched the prior resource regex?
    if (resource) {
      stream.match(/(\s+)?[\w:_]+/);
      return 'def';
    }
    // Have we matched the prior special_resource regex?
    if (special_resource) {
      stream.match(/(\s+)?[@]{1,2}/);
      return 'special';
    }
    // Match all the comments. All of them.
    if (ch == "#") {
      stream.skipToEnd();
      return "comment";
    }
    // Have we found a string?
    if (ch == "'" || ch == '"') {
      // Store the type (single or double)
      state.pending = ch;
      // Perform the looping function to find the end
      return tokenString(stream, state);
    }
    // Match all the brackets
    if (ch == '{' || ch == '}') {
      return 'bracket';
    }
    // Match characters that we are going to assume
    // are trying to be regex
    if (ch == '/') {
      stream.match(/^[^\/]*\//);
      return 'variable-3';
    }
    // Match all the numbers
    if (ch.match(/[0-9]/)) {
      stream.eatWhile(/[0-9]+/);
      return 'number';
    }
    // Match the '=' and '=>' operators
    if (ch == '=') {
      if (stream.peek() == '>') {
          stream.next();
      }
      return "operator";
    }
    // Keep advancing through all the rest
    stream.eatWhile(/[\w-]/);
    // Return a blank line for everything else
    return null;
  }
  // Start it all
  return {
    startState: function () {
      var state = {};
      state.inDefinition = false;
      state.inInclude = false;
      state.continueString = false;
      state.pending = false;
      return state;
    },
    token: function (stream, state) {
      // Strip the spaces, but regex will account for them eitherway
      if (stream.eatSpace()) return null;
      // Go through the main process
      return tokenize(stream, state);
    }
  };
});

CodeMirror.defineMIME("text/x-puppet", "puppet");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/q/q.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("q",function(config){
  var indentUnit=config.indentUnit,
      curPunc,
      keywords=buildRE(["abs","acos","aj","aj0","all","and","any","asc","asin","asof","atan","attr","avg","avgs","bin","by","ceiling","cols","cor","cos","count","cov","cross","csv","cut","delete","deltas","desc","dev","differ","distinct","div","do","each","ej","enlist","eval","except","exec","exit","exp","fby","fills","first","fkeys","flip","floor","from","get","getenv","group","gtime","hclose","hcount","hdel","hopen","hsym","iasc","idesc","if","ij","in","insert","inter","inv","key","keys","last","like","list","lj","load","log","lower","lsq","ltime","ltrim","mavg","max","maxs","mcount","md5","mdev","med","meta","min","mins","mmax","mmin","mmu","mod","msum","neg","next","not","null","or","over","parse","peach","pj","plist","prd","prds","prev","prior","rand","rank","ratios","raze","read0","read1","reciprocal","reverse","rload","rotate","rsave","rtrim","save","scan","select","set","setenv","show","signum","sin","sqrt","ss","ssr","string","sublist","sum","sums","sv","system","tables","tan","til","trim","txf","type","uj","ungroup","union","update","upper","upsert","value","var","view","views","vs","wavg","where","where","while","within","wj","wj1","wsum","xasc","xbar","xcol","xcols","xdesc","xexp","xgroup","xkey","xlog","xprev","xrank"]),
      E=/[|/&^!+:\\\-*%$=~#;@><,?_\'\"\[\(\]\)\s{}]/;
  function buildRE(w){return new RegExp("^("+w.join("|")+")$");}
  function tokenBase(stream,state){
    var sol=stream.sol(),c=stream.next();
    curPunc=null;
    if(sol)
      if(c=="/")
        return(state.tokenize=tokenLineComment)(stream,state);
      else if(c=="\\"){
        if(stream.eol()||/\s/.test(stream.peek()))
          return stream.skipToEnd(),/^\\\s*$/.test(stream.current())?(state.tokenize=tokenCommentToEOF)(stream):state.tokenize=tokenBase,"comment";
        else
          return state.tokenize=tokenBase,"builtin";
      }
    if(/\s/.test(c))
      return stream.peek()=="/"?(stream.skipToEnd(),"comment"):"whitespace";
    if(c=='"')
      return(state.tokenize=tokenString)(stream,state);
    if(c=='`')
      return stream.eatWhile(/[A-Za-z\d_:\/.]/),"symbol";
    if(("."==c&&/\d/.test(stream.peek()))||/\d/.test(c)){
      var t=null;
      stream.backUp(1);
      if(stream.match(/^\d{4}\.\d{2}(m|\.\d{2}([DT](\d{2}(:\d{2}(:\d{2}(\.\d{1,9})?)?)?)?)?)/)
      || stream.match(/^\d+D(\d{2}(:\d{2}(:\d{2}(\.\d{1,9})?)?)?)/)
      || stream.match(/^\d{2}:\d{2}(:\d{2}(\.\d{1,9})?)?/)
      || stream.match(/^\d+[ptuv]{1}/))
        t="temporal";
      else if(stream.match(/^0[NwW]{1}/)
      || stream.match(/^0x[\da-fA-F]*/)
      || stream.match(/^[01]+[b]{1}/)
      || stream.match(/^\d+[chijn]{1}/)
      || stream.match(/-?\d*(\.\d*)?(e[+\-]?\d+)?(e|f)?/))
        t="number";
      return(t&&(!(c=stream.peek())||E.test(c)))?t:(stream.next(),"error");
    }
    if(/[A-Za-z]|\./.test(c))
      return stream.eatWhile(/[A-Za-z._\d]/),keywords.test(stream.current())?"keyword":"variable";
    if(/[|/&^!+:\\\-*%$=~#;@><\.,?_\']/.test(c))
      return null;
    if(/[{}\(\[\]\)]/.test(c))
      return null;
    return"error";
  }
  function tokenLineComment(stream,state){
    return stream.skipToEnd(),/\/\s*$/.test(stream.current())?(state.tokenize=tokenBlockComment)(stream,state):(state.tokenize=tokenBase),"comment";
  }
  function tokenBlockComment(stream,state){
    var f=stream.sol()&&stream.peek()=="\\";
    stream.skipToEnd();
    if(f&&/^\\\s*$/.test(stream.current()))
      state.tokenize=tokenBase;
    return"comment";
  }
  function tokenCommentToEOF(stream){return stream.skipToEnd(),"comment";}
  function tokenString(stream,state){
    var escaped=false,next,end=false;
    while((next=stream.next())){
      if(next=="\""&&!escaped){end=true;break;}
      escaped=!escaped&&next=="\\";
    }
    if(end)state.tokenize=tokenBase;
    return"string";
  }
  function pushContext(state,type,col){state.context={prev:state.context,indent:state.indent,col:col,type:type};}
  function popContext(state){state.indent=state.context.indent;state.context=state.context.prev;}
  return{
    startState:function(){
      return{tokenize:tokenBase,
             context:null,
             indent:0,
             col:0};
    },
    token:function(stream,state){
      if(stream.sol()){
        if(state.context&&state.context.align==null)
          state.context.align=false;
        state.indent=stream.indentation();
      }
      //if (stream.eatSpace()) return null;
      var style=state.tokenize(stream,state);
      if(style!="comment"&&state.context&&state.context.align==null&&state.context.type!="pattern"){
        state.context.align=true;
      }
      if(curPunc=="(")pushContext(state,")",stream.column());
      else if(curPunc=="[")pushContext(state,"]",stream.column());
      else if(curPunc=="{")pushContext(state,"}",stream.column());
      else if(/[\]\}\)]/.test(curPunc)){
        while(state.context&&state.context.type=="pattern")popContext(state);
        if(state.context&&curPunc==state.context.type)popContext(state);
      }
      else if(curPunc=="."&&state.context&&state.context.type=="pattern")popContext(state);
      else if(/atom|string|variable/.test(style)&&state.context){
        if(/[\}\]]/.test(state.context.type))
          pushContext(state,"pattern",stream.column());
        else if(state.context.type=="pattern"&&!state.context.align){
          state.context.align=true;
          state.context.col=stream.column();
        }
      }
      return style;
    },
    indent:function(state,textAfter){
      var firstChar=textAfter&&textAfter.charAt(0);
      var context=state.context;
      if(/[\]\}]/.test(firstChar))
        while (context&&context.type=="pattern")context=context.prev;
      var closing=context&&firstChar==context.type;
      if(!context)
        return 0;
      else if(context.type=="pattern")
        return context.col;
      else if(context.align)
        return context.col+(closing?0:1);
      else
        return context.indent+(closing?0:indentUnit);
    }
  };
});
CodeMirror.defineMIME("text/x-q","q");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/rpm/rpm.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("rpm-changes", function() {
  var headerSeparator = /^-+$/;
  var headerLine = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)  ?\d{1,2} \d{2}:\d{2}(:\d{2})? [A-Z]{3,4} \d{4} - /;
  var simpleEmail = /^[\w+.-]+@[\w.-]+/;

  return {
    token: function(stream) {
      if (stream.sol()) {
        if (stream.match(headerSeparator)) { return 'tag'; }
        if (stream.match(headerLine)) { return 'tag'; }
      }
      if (stream.match(simpleEmail)) { return 'string'; }
      stream.next();
      return null;
    }
  };
});

CodeMirror.defineMIME("text/x-rpm-changes", "rpm-changes");

// Quick and dirty spec file highlighting

CodeMirror.defineMode("rpm-spec", function() {
  var arch = /^(i386|i586|i686|x86_64|ppc64le|ppc64|ppc|ia64|s390x|s390|sparc64|sparcv9|sparc|noarch|alphaev6|alpha|hppa|mipsel)/;

  var preamble = /^[a-zA-Z0-9()]+:/;
  var section = /^%(debug_package|package|description|prep|build|install|files|clean|changelog|preinstall|preun|postinstall|postun|pretrans|posttrans|pre|post|triggerin|triggerun|verifyscript|check|triggerpostun|triggerprein|trigger)/;
  var control_flow_complex = /^%(ifnarch|ifarch|if)/; // rpm control flow macros
  var control_flow_simple = /^%(else|endif)/; // rpm control flow macros
  var operators = /^(\!|\?|\<\=|\<|\>\=|\>|\=\=|\&\&|\|\|)/; // operators in control flow macros

  return {
    startState: function () {
        return {
          controlFlow: false,
          macroParameters: false,
          section: false
        };
    },
    token: function (stream, state) {
      var ch = stream.peek();
      if (ch == "#") { stream.skipToEnd(); return "comment"; }

      if (stream.sol()) {
        if (stream.match(preamble)) { return "header"; }
        if (stream.match(section)) { return "atom"; }
      }

      if (stream.match(/^\$\w+/)) { return "def"; } // Variables like '$RPM_BUILD_ROOT'
      if (stream.match(/^\$\{\w+\}/)) { return "def"; } // Variables like '${RPM_BUILD_ROOT}'

      if (stream.match(control_flow_simple)) { return "keyword"; }
      if (stream.match(control_flow_complex)) {
        state.controlFlow = true;
        return "keyword";
      }
      if (state.controlFlow) {
        if (stream.match(operators)) { return "operator"; }
        if (stream.match(/^(\d+)/)) { return "number"; }
        if (stream.eol()) { state.controlFlow = false; }
      }

      if (stream.match(arch)) {
        if (stream.eol()) { state.controlFlow = false; }
        return "number";
      }

      // Macros like '%make_install' or '%attr(0775,root,root)'
      if (stream.match(/^%[\w]+/)) {
        if (stream.match('(')) { state.macroParameters = true; }
        return "keyword";
      }
      if (state.macroParameters) {
        if (stream.match(/^\d+/)) { return "number";}
        if (stream.match(')')) {
          state.macroParameters = false;
          return "keyword";
        }
      }

      // Macros like '%{defined fedora}'
      if (stream.match(/^%\{\??[\w \-\:\!]+\}/)) {
        if (stream.eol()) { state.controlFlow = false; }
        return "def";
      }

      //TODO: Include bash script sub-parser (CodeMirror supports that)
      stream.next();
      return null;
    }
  };
});

CodeMirror.defineMIME("text/x-rpm-spec", "rpm-spec");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/rst/rst.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"), __webpack_require__("./src/ipywidgets/node_modules/codemirror/mode/python/python.js"), __webpack_require__("./src/ipywidgets/node_modules/codemirror/mode/stex/stex.js"), __webpack_require__("./src/ipywidgets/node_modules/codemirror/addon/mode/overlay.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode('rst', function (config, options) {

  var rx_strong = /^\*\*[^\*\s](?:[^\*]*[^\*\s])?\*\*/;
  var rx_emphasis = /^\*[^\*\s](?:[^\*]*[^\*\s])?\*/;
  var rx_literal = /^``[^`\s](?:[^`]*[^`\s])``/;

  var rx_number = /^(?:[\d]+(?:[\.,]\d+)*)/;
  var rx_positive = /^(?:\s\+[\d]+(?:[\.,]\d+)*)/;
  var rx_negative = /^(?:\s\-[\d]+(?:[\.,]\d+)*)/;

  var rx_uri_protocol = "[Hh][Tt][Tt][Pp][Ss]?://";
  var rx_uri_domain = "(?:[\\d\\w.-]+)\\.(?:\\w{2,6})";
  var rx_uri_path = "(?:/[\\d\\w\\#\\%\\&\\-\\.\\,\\/\\:\\=\\?\\~]+)*";
  var rx_uri = new RegExp("^" + rx_uri_protocol + rx_uri_domain + rx_uri_path);

  var overlay = {
    token: function (stream) {

      if (stream.match(rx_strong) && stream.match (/\W+|$/, false))
        return 'strong';
      if (stream.match(rx_emphasis) && stream.match (/\W+|$/, false))
        return 'em';
      if (stream.match(rx_literal) && stream.match (/\W+|$/, false))
        return 'string-2';
      if (stream.match(rx_number))
        return 'number';
      if (stream.match(rx_positive))
        return 'positive';
      if (stream.match(rx_negative))
        return 'negative';
      if (stream.match(rx_uri))
        return 'link';

      while (stream.next() != null) {
        if (stream.match(rx_strong, false)) break;
        if (stream.match(rx_emphasis, false)) break;
        if (stream.match(rx_literal, false)) break;
        if (stream.match(rx_number, false)) break;
        if (stream.match(rx_positive, false)) break;
        if (stream.match(rx_negative, false)) break;
        if (stream.match(rx_uri, false)) break;
      }

      return null;
    }
  };

  var mode = CodeMirror.getMode(
    config, options.backdrop || 'rst-base'
  );

  return CodeMirror.overlayMode(mode, overlay, true); // combine
}, 'python', 'stex');

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

CodeMirror.defineMode('rst-base', function (config) {

  ///////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////

  function format(string) {
    var args = Array.prototype.slice.call(arguments, 1);
    return string.replace(/{(\d+)}/g, function (match, n) {
      return typeof args[n] != 'undefined' ? args[n] : match;
    });
  }

  ///////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////

  var mode_python = CodeMirror.getMode(config, 'python');
  var mode_stex = CodeMirror.getMode(config, 'stex');

  ///////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////

  var SEPA = "\\s+";
  var TAIL = "(?:\\s*|\\W|$)",
  rx_TAIL = new RegExp(format('^{0}', TAIL));

  var NAME =
    "(?:[^\\W\\d_](?:[\\w!\"#$%&'()\\*\\+,\\-\\.\/:;<=>\\?]*[^\\W_])?)",
  rx_NAME = new RegExp(format('^{0}', NAME));
  var NAME_WWS =
    "(?:[^\\W\\d_](?:[\\w\\s!\"#$%&'()\\*\\+,\\-\\.\/:;<=>\\?]*[^\\W_])?)";
  var REF_NAME = format('(?:{0}|`{1}`)', NAME, NAME_WWS);

  var TEXT1 = "(?:[^\\s\\|](?:[^\\|]*[^\\s\\|])?)";
  var TEXT2 = "(?:[^\\`]+)",
  rx_TEXT2 = new RegExp(format('^{0}', TEXT2));

  var rx_section = new RegExp(
    "^([!'#$%&\"()*+,-./:;<=>?@\\[\\\\\\]^_`{|}~])\\1{3,}\\s*$");
  var rx_explicit = new RegExp(
    format('^\\.\\.{0}', SEPA));
  var rx_link = new RegExp(
    format('^_{0}:{1}|^__:{1}', REF_NAME, TAIL));
  var rx_directive = new RegExp(
    format('^{0}::{1}', REF_NAME, TAIL));
  var rx_substitution = new RegExp(
    format('^\\|{0}\\|{1}{2}::{3}', TEXT1, SEPA, REF_NAME, TAIL));
  var rx_footnote = new RegExp(
    format('^\\[(?:\\d+|#{0}?|\\*)]{1}', REF_NAME, TAIL));
  var rx_citation = new RegExp(
    format('^\\[{0}\\]{1}', REF_NAME, TAIL));

  var rx_substitution_ref = new RegExp(
    format('^\\|{0}\\|', TEXT1));
  var rx_footnote_ref = new RegExp(
    format('^\\[(?:\\d+|#{0}?|\\*)]_', REF_NAME));
  var rx_citation_ref = new RegExp(
    format('^\\[{0}\\]_', REF_NAME));
  var rx_link_ref1 = new RegExp(
    format('^{0}__?', REF_NAME));
  var rx_link_ref2 = new RegExp(
    format('^`{0}`_', TEXT2));

  var rx_role_pre = new RegExp(
    format('^:{0}:`{1}`{2}', NAME, TEXT2, TAIL));
  var rx_role_suf = new RegExp(
    format('^`{1}`:{0}:{2}', NAME, TEXT2, TAIL));
  var rx_role = new RegExp(
    format('^:{0}:{1}', NAME, TAIL));

  var rx_directive_name = new RegExp(format('^{0}', REF_NAME));
  var rx_directive_tail = new RegExp(format('^::{0}', TAIL));
  var rx_substitution_text = new RegExp(format('^\\|{0}\\|', TEXT1));
  var rx_substitution_sepa = new RegExp(format('^{0}', SEPA));
  var rx_substitution_name = new RegExp(format('^{0}', REF_NAME));
  var rx_substitution_tail = new RegExp(format('^::{0}', TAIL));
  var rx_link_head = new RegExp("^_");
  var rx_link_name = new RegExp(format('^{0}|_', REF_NAME));
  var rx_link_tail = new RegExp(format('^:{0}', TAIL));

  var rx_verbatim = new RegExp('^::\\s*$');
  var rx_examples = new RegExp('^\\s+(?:>>>|In \\[\\d+\\]:)\\s');

  ///////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////

  function to_normal(stream, state) {
    var token = null;

    if (stream.sol() && stream.match(rx_examples, false)) {
      change(state, to_mode, {
        mode: mode_python, local: CodeMirror.startState(mode_python)
      });
    } else if (stream.sol() && stream.match(rx_explicit)) {
      change(state, to_explicit);
      token = 'meta';
    } else if (stream.sol() && stream.match(rx_section)) {
      change(state, to_normal);
      token = 'header';
    } else if (phase(state) == rx_role_pre ||
               stream.match(rx_role_pre, false)) {

      switch (stage(state)) {
      case 0:
        change(state, to_normal, context(rx_role_pre, 1));
        stream.match(/^:/);
        token = 'meta';
        break;
      case 1:
        change(state, to_normal, context(rx_role_pre, 2));
        stream.match(rx_NAME);
        token = 'keyword';

        if (stream.current().match(/^(?:math|latex)/)) {
          state.tmp_stex = true;
        }
        break;
      case 2:
        change(state, to_normal, context(rx_role_pre, 3));
        stream.match(/^:`/);
        token = 'meta';
        break;
      case 3:
        if (state.tmp_stex) {
          state.tmp_stex = undefined; state.tmp = {
            mode: mode_stex, local: CodeMirror.startState(mode_stex)
          };
        }

        if (state.tmp) {
          if (stream.peek() == '`') {
            change(state, to_normal, context(rx_role_pre, 4));
            state.tmp = undefined;
            break;
          }

          token = state.tmp.mode.token(stream, state.tmp.local);
          break;
        }

        change(state, to_normal, context(rx_role_pre, 4));
        stream.match(rx_TEXT2);
        token = 'string';
        break;
      case 4:
        change(state, to_normal, context(rx_role_pre, 5));
        stream.match(/^`/);
        token = 'meta';
        break;
      case 5:
        change(state, to_normal, context(rx_role_pre, 6));
        stream.match(rx_TAIL);
        break;
      default:
        change(state, to_normal);
      }
    } else if (phase(state) == rx_role_suf ||
               stream.match(rx_role_suf, false)) {

      switch (stage(state)) {
      case 0:
        change(state, to_normal, context(rx_role_suf, 1));
        stream.match(/^`/);
        token = 'meta';
        break;
      case 1:
        change(state, to_normal, context(rx_role_suf, 2));
        stream.match(rx_TEXT2);
        token = 'string';
        break;
      case 2:
        change(state, to_normal, context(rx_role_suf, 3));
        stream.match(/^`:/);
        token = 'meta';
        break;
      case 3:
        change(state, to_normal, context(rx_role_suf, 4));
        stream.match(rx_NAME);
        token = 'keyword';
        break;
      case 4:
        change(state, to_normal, context(rx_role_suf, 5));
        stream.match(/^:/);
        token = 'meta';
        break;
      case 5:
        change(state, to_normal, context(rx_role_suf, 6));
        stream.match(rx_TAIL);
        break;
      default:
        change(state, to_normal);
      }
    } else if (phase(state) == rx_role || stream.match(rx_role, false)) {

      switch (stage(state)) {
      case 0:
        change(state, to_normal, context(rx_role, 1));
        stream.match(/^:/);
        token = 'meta';
        break;
      case 1:
        change(state, to_normal, context(rx_role, 2));
        stream.match(rx_NAME);
        token = 'keyword';
        break;
      case 2:
        change(state, to_normal, context(rx_role, 3));
        stream.match(/^:/);
        token = 'meta';
        break;
      case 3:
        change(state, to_normal, context(rx_role, 4));
        stream.match(rx_TAIL);
        break;
      default:
        change(state, to_normal);
      }
    } else if (phase(state) == rx_substitution_ref ||
               stream.match(rx_substitution_ref, false)) {

      switch (stage(state)) {
      case 0:
        change(state, to_normal, context(rx_substitution_ref, 1));
        stream.match(rx_substitution_text);
        token = 'variable-2';
        break;
      case 1:
        change(state, to_normal, context(rx_substitution_ref, 2));
        if (stream.match(/^_?_?/)) token = 'link';
        break;
      default:
        change(state, to_normal);
      }
    } else if (stream.match(rx_footnote_ref)) {
      change(state, to_normal);
      token = 'quote';
    } else if (stream.match(rx_citation_ref)) {
      change(state, to_normal);
      token = 'quote';
    } else if (stream.match(rx_link_ref1)) {
      change(state, to_normal);
      if (!stream.peek() || stream.peek().match(/^\W$/)) {
        token = 'link';
      }
    } else if (phase(state) == rx_link_ref2 ||
               stream.match(rx_link_ref2, false)) {

      switch (stage(state)) {
      case 0:
        if (!stream.peek() || stream.peek().match(/^\W$/)) {
          change(state, to_normal, context(rx_link_ref2, 1));
        } else {
          stream.match(rx_link_ref2);
        }
        break;
      case 1:
        change(state, to_normal, context(rx_link_ref2, 2));
        stream.match(/^`/);
        token = 'link';
        break;
      case 2:
        change(state, to_normal, context(rx_link_ref2, 3));
        stream.match(rx_TEXT2);
        break;
      case 3:
        change(state, to_normal, context(rx_link_ref2, 4));
        stream.match(/^`_/);
        token = 'link';
        break;
      default:
        change(state, to_normal);
      }
    } else if (stream.match(rx_verbatim)) {
      change(state, to_verbatim);
    }

    else {
      if (stream.next()) change(state, to_normal);
    }

    return token;
  }

  ///////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////

  function to_explicit(stream, state) {
    var token = null;

    if (phase(state) == rx_substitution ||
        stream.match(rx_substitution, false)) {

      switch (stage(state)) {
      case 0:
        change(state, to_explicit, context(rx_substitution, 1));
        stream.match(rx_substitution_text);
        token = 'variable-2';
        break;
      case 1:
        change(state, to_explicit, context(rx_substitution, 2));
        stream.match(rx_substitution_sepa);
        break;
      case 2:
        change(state, to_explicit, context(rx_substitution, 3));
        stream.match(rx_substitution_name);
        token = 'keyword';
        break;
      case 3:
        change(state, to_explicit, context(rx_substitution, 4));
        stream.match(rx_substitution_tail);
        token = 'meta';
        break;
      default:
        change(state, to_normal);
      }
    } else if (phase(state) == rx_directive ||
               stream.match(rx_directive, false)) {

      switch (stage(state)) {
      case 0:
        change(state, to_explicit, context(rx_directive, 1));
        stream.match(rx_directive_name);
        token = 'keyword';

        if (stream.current().match(/^(?:math|latex)/))
          state.tmp_stex = true;
        else if (stream.current().match(/^python/))
          state.tmp_py = true;
        break;
      case 1:
        change(state, to_explicit, context(rx_directive, 2));
        stream.match(rx_directive_tail);
        token = 'meta';

        if (stream.match(/^latex\s*$/) || state.tmp_stex) {
          state.tmp_stex = undefined; change(state, to_mode, {
            mode: mode_stex, local: CodeMirror.startState(mode_stex)
          });
        }
        break;
      case 2:
        change(state, to_explicit, context(rx_directive, 3));
        if (stream.match(/^python\s*$/) || state.tmp_py) {
          state.tmp_py = undefined; change(state, to_mode, {
            mode: mode_python, local: CodeMirror.startState(mode_python)
          });
        }
        break;
      default:
        change(state, to_normal);
      }
    } else if (phase(state) == rx_link || stream.match(rx_link, false)) {

      switch (stage(state)) {
      case 0:
        change(state, to_explicit, context(rx_link, 1));
        stream.match(rx_link_head);
        stream.match(rx_link_name);
        token = 'link';
        break;
      case 1:
        change(state, to_explicit, context(rx_link, 2));
        stream.match(rx_link_tail);
        token = 'meta';
        break;
      default:
        change(state, to_normal);
      }
    } else if (stream.match(rx_footnote)) {
      change(state, to_normal);
      token = 'quote';
    } else if (stream.match(rx_citation)) {
      change(state, to_normal);
      token = 'quote';
    }

    else {
      stream.eatSpace();
      if (stream.eol()) {
        change(state, to_normal);
      } else {
        stream.skipToEnd();
        change(state, to_comment);
        token = 'comment';
      }
    }

    return token;
  }

  ///////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////

  function to_comment(stream, state) {
    return as_block(stream, state, 'comment');
  }

  function to_verbatim(stream, state) {
    return as_block(stream, state, 'meta');
  }

  function as_block(stream, state, token) {
    if (stream.eol() || stream.eatSpace()) {
      stream.skipToEnd();
      return token;
    } else {
      change(state, to_normal);
      return null;
    }
  }

  ///////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////

  function to_mode(stream, state) {

    if (state.ctx.mode && state.ctx.local) {

      if (stream.sol()) {
        if (!stream.eatSpace()) change(state, to_normal);
        return null;
      }

      return state.ctx.mode.token(stream, state.ctx.local);
    }

    change(state, to_normal);
    return null;
  }

  ///////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////

  function context(phase, stage, mode, local) {
    return {phase: phase, stage: stage, mode: mode, local: local};
  }

  function change(state, tok, ctx) {
    state.tok = tok;
    state.ctx = ctx || {};
  }

  function stage(state) {
    return state.ctx.stage || 0;
  }

  function phase(state) {
    return state.ctx.phase;
  }

  ///////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////

  return {
    startState: function () {
      return {tok: to_normal, ctx: context(undefined, 0)};
    },

    copyState: function (state) {
      var ctx = state.ctx, tmp = state.tmp;
      if (ctx.local)
        ctx = {mode: ctx.mode, local: CodeMirror.copyState(ctx.mode, ctx.local)};
      if (tmp)
        tmp = {mode: tmp.mode, local: CodeMirror.copyState(tmp.mode, tmp.local)};
      return {tok: state.tok, ctx: ctx, tmp: tmp};
    },

    innerMode: function (state) {
      return state.tmp      ? {state: state.tmp.local, mode: state.tmp.mode}
      : state.ctx.mode ? {state: state.ctx.local, mode: state.ctx.mode}
      : null;
    },

    token: function (stream, state) {
      return state.tok(stream, state);
    }
  };
}, 'python', 'stex');

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

CodeMirror.defineMIME('text/x-rst', 'rst');

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/ruby/ruby.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

function wordObj(words) {
  var o = {};
  for (var i = 0, e = words.length; i < e; ++i) o[words[i]] = true;
  return o;
}

var keywordList = [
  "alias", "and", "BEGIN", "begin", "break", "case", "class", "def", "defined?", "do", "else",
  "elsif", "END", "end", "ensure", "false", "for", "if", "in", "module", "next", "not", "or",
  "redo", "rescue", "retry", "return", "self", "super", "then", "true", "undef", "unless",
  "until", "when", "while", "yield", "nil", "raise", "throw", "catch", "fail", "loop", "callcc",
  "caller", "lambda", "proc", "public", "protected", "private", "require", "load",
  "require_relative", "extend", "autoload", "__END__", "__FILE__", "__LINE__", "__dir__"
], keywords = wordObj(keywordList);

var indentWords = wordObj(["def", "class", "case", "for", "while", "until", "module", "then",
                           "catch", "loop", "proc", "begin"]);
var dedentWords = wordObj(["end", "until"]);
var opening = {"[": "]", "{": "}", "(": ")"};
var closing = {"]": "[", "}": "{", ")": "("};

CodeMirror.defineMode("ruby", function(config) {
  var curPunc;

  function chain(newtok, stream, state) {
    state.tokenize.push(newtok);
    return newtok(stream, state);
  }

  function tokenBase(stream, state) {
    if (stream.sol() && stream.match("=begin") && stream.eol()) {
      state.tokenize.push(readBlockComment);
      return "comment";
    }
    if (stream.eatSpace()) return null;
    var ch = stream.next(), m;
    if (ch == "`" || ch == "'" || ch == '"') {
      return chain(readQuoted(ch, "string", ch == '"' || ch == "`"), stream, state);
    } else if (ch == "/") {
      if (regexpAhead(stream))
        return chain(readQuoted(ch, "string-2", true), stream, state);
      else
        return "operator";
    } else if (ch == "%") {
      var style = "string", embed = true;
      if (stream.eat("s")) style = "atom";
      else if (stream.eat(/[WQ]/)) style = "string";
      else if (stream.eat(/[r]/)) style = "string-2";
      else if (stream.eat(/[wxq]/)) { style = "string"; embed = false; }
      var delim = stream.eat(/[^\w\s=]/);
      if (!delim) return "operator";
      if (opening.propertyIsEnumerable(delim)) delim = opening[delim];
      return chain(readQuoted(delim, style, embed, true), stream, state);
    } else if (ch == "#") {
      stream.skipToEnd();
      return "comment";
    } else if (ch == "<" && (m = stream.match(/^<([-~])[\`\"\']?([a-zA-Z_?]\w*)[\`\"\']?(?:;|$)/))) {
      return chain(readHereDoc(m[2], m[1]), stream, state);
    } else if (ch == "0") {
      if (stream.eat("x")) stream.eatWhile(/[\da-fA-F]/);
      else if (stream.eat("b")) stream.eatWhile(/[01]/);
      else stream.eatWhile(/[0-7]/);
      return "number";
    } else if (/\d/.test(ch)) {
      stream.match(/^[\d_]*(?:\.[\d_]+)?(?:[eE][+\-]?[\d_]+)?/);
      return "number";
    } else if (ch == "?") {
      while (stream.match(/^\\[CM]-/)) {}
      if (stream.eat("\\")) stream.eatWhile(/\w/);
      else stream.next();
      return "string";
    } else if (ch == ":") {
      if (stream.eat("'")) return chain(readQuoted("'", "atom", false), stream, state);
      if (stream.eat('"')) return chain(readQuoted('"', "atom", true), stream, state);

      // :> :>> :< :<< are valid symbols
      if (stream.eat(/[\<\>]/)) {
        stream.eat(/[\<\>]/);
        return "atom";
      }

      // :+ :- :/ :* :| :& :! are valid symbols
      if (stream.eat(/[\+\-\*\/\&\|\:\!]/)) {
        return "atom";
      }

      // Symbols can't start by a digit
      if (stream.eat(/[a-zA-Z$@_\xa1-\uffff]/)) {
        stream.eatWhile(/[\w$\xa1-\uffff]/);
        // Only one ? ! = is allowed and only as the last character
        stream.eat(/[\?\!\=]/);
        return "atom";
      }
      return "operator";
    } else if (ch == "@" && stream.match(/^@?[a-zA-Z_\xa1-\uffff]/)) {
      stream.eat("@");
      stream.eatWhile(/[\w\xa1-\uffff]/);
      return "variable-2";
    } else if (ch == "$") {
      if (stream.eat(/[a-zA-Z_]/)) {
        stream.eatWhile(/[\w]/);
      } else if (stream.eat(/\d/)) {
        stream.eat(/\d/);
      } else {
        stream.next(); // Must be a special global like $: or $!
      }
      return "variable-3";
    } else if (/[a-zA-Z_\xa1-\uffff]/.test(ch)) {
      stream.eatWhile(/[\w\xa1-\uffff]/);
      stream.eat(/[\?\!]/);
      if (stream.eat(":")) return "atom";
      return "ident";
    } else if (ch == "|" && (state.varList || state.lastTok == "{" || state.lastTok == "do")) {
      curPunc = "|";
      return null;
    } else if (/[\(\)\[\]{}\\;]/.test(ch)) {
      curPunc = ch;
      return null;
    } else if (ch == "-" && stream.eat(">")) {
      return "arrow";
    } else if (/[=+\-\/*:\.^%<>~|]/.test(ch)) {
      var more = stream.eatWhile(/[=+\-\/*:\.^%<>~|]/);
      if (ch == "." && !more) curPunc = ".";
      return "operator";
    } else {
      return null;
    }
  }

  function regexpAhead(stream) {
    var start = stream.pos, depth = 0, next, found = false, escaped = false
    while ((next = stream.next()) != null) {
      if (!escaped) {
        if ("[{(".indexOf(next) > -1) {
          depth++
        } else if ("]})".indexOf(next) > -1) {
          depth--
          if (depth < 0) break
        } else if (next == "/" && depth == 0) {
          found = true
          break
        }
        escaped = next == "\\"
      } else {
        escaped = false
      }
    }
    stream.backUp(stream.pos - start)
    return found
  }

  function tokenBaseUntilBrace(depth) {
    if (!depth) depth = 1;
    return function(stream, state) {
      if (stream.peek() == "}") {
        if (depth == 1) {
          state.tokenize.pop();
          return state.tokenize[state.tokenize.length-1](stream, state);
        } else {
          state.tokenize[state.tokenize.length - 1] = tokenBaseUntilBrace(depth - 1);
        }
      } else if (stream.peek() == "{") {
        state.tokenize[state.tokenize.length - 1] = tokenBaseUntilBrace(depth + 1);
      }
      return tokenBase(stream, state);
    };
  }
  function tokenBaseOnce() {
    var alreadyCalled = false;
    return function(stream, state) {
      if (alreadyCalled) {
        state.tokenize.pop();
        return state.tokenize[state.tokenize.length-1](stream, state);
      }
      alreadyCalled = true;
      return tokenBase(stream, state);
    };
  }
  function readQuoted(quote, style, embed, unescaped) {
    return function(stream, state) {
      var escaped = false, ch;

      if (state.context.type === 'read-quoted-paused') {
        state.context = state.context.prev;
        stream.eat("}");
      }

      while ((ch = stream.next()) != null) {
        if (ch == quote && (unescaped || !escaped)) {
          state.tokenize.pop();
          break;
        }
        if (embed && ch == "#" && !escaped) {
          if (stream.eat("{")) {
            if (quote == "}") {
              state.context = {prev: state.context, type: 'read-quoted-paused'};
            }
            state.tokenize.push(tokenBaseUntilBrace());
            break;
          } else if (/[@\$]/.test(stream.peek())) {
            state.tokenize.push(tokenBaseOnce());
            break;
          }
        }
        escaped = !escaped && ch == "\\";
      }
      return style;
    };
  }
  function readHereDoc(phrase, mayIndent) {
    return function(stream, state) {
      if (mayIndent) stream.eatSpace()
      if (stream.match(phrase)) state.tokenize.pop();
      else stream.skipToEnd();
      return "string";
    };
  }
  function readBlockComment(stream, state) {
    if (stream.sol() && stream.match("=end") && stream.eol())
      state.tokenize.pop();
    stream.skipToEnd();
    return "comment";
  }

  return {
    startState: function() {
      return {tokenize: [tokenBase],
              indented: 0,
              context: {type: "top", indented: -config.indentUnit},
              continuedLine: false,
              lastTok: null,
              varList: false};
    },

    token: function(stream, state) {
      curPunc = null;
      if (stream.sol()) state.indented = stream.indentation();
      var style = state.tokenize[state.tokenize.length-1](stream, state), kwtype;
      var thisTok = curPunc;
      if (style == "ident") {
        var word = stream.current();
        style = state.lastTok == "." ? "property"
          : keywords.propertyIsEnumerable(stream.current()) ? "keyword"
          : /^[A-Z]/.test(word) ? "tag"
          : (state.lastTok == "def" || state.lastTok == "class" || state.varList) ? "def"
          : "variable";
        if (style == "keyword") {
          thisTok = word;
          if (indentWords.propertyIsEnumerable(word)) kwtype = "indent";
          else if (dedentWords.propertyIsEnumerable(word)) kwtype = "dedent";
          else if ((word == "if" || word == "unless") && stream.column() == stream.indentation())
            kwtype = "indent";
          else if (word == "do" && state.context.indented < state.indented)
            kwtype = "indent";
        }
      }
      if (curPunc || (style && style != "comment")) state.lastTok = thisTok;
      if (curPunc == "|") state.varList = !state.varList;

      if (kwtype == "indent" || /[\(\[\{]/.test(curPunc))
        state.context = {prev: state.context, type: curPunc || style, indented: state.indented};
      else if ((kwtype == "dedent" || /[\)\]\}]/.test(curPunc)) && state.context.prev)
        state.context = state.context.prev;

      if (stream.eol())
        state.continuedLine = (curPunc == "\\" || style == "operator");
      return style;
    },

    indent: function(state, textAfter) {
      if (state.tokenize[state.tokenize.length-1] != tokenBase) return CodeMirror.Pass;
      var firstChar = textAfter && textAfter.charAt(0);
      var ct = state.context;
      var closed = ct.type == closing[firstChar] ||
        ct.type == "keyword" && /^(?:end|until|else|elsif|when|rescue)\b/.test(textAfter);
      return ct.indented + (closed ? 0 : config.indentUnit) +
        (state.continuedLine ? config.indentUnit : 0);
    },

    electricInput: /^\s*(?:end|rescue|elsif|else|\})$/,
    lineComment: "#",
    fold: "indent"
  };
});

CodeMirror.defineMIME("text/x-ruby", "ruby");

CodeMirror.registerHelper("hintWords", "ruby", keywordList);

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/rust/rust.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"), __webpack_require__("./src/ipywidgets/node_modules/codemirror/addon/mode/simple.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineSimpleMode("rust",{
  start: [
    // string and byte string
    {regex: /b?"/, token: "string", next: "string"},
    // raw string and raw byte string
    {regex: /b?r"/, token: "string", next: "string_raw"},
    {regex: /b?r#+"/, token: "string", next: "string_raw_hash"},
    // character
    {regex: /'(?:[^'\\]|\\(?:[nrt0'"]|x[\da-fA-F]{2}|u\{[\da-fA-F]{6}\}))'/, token: "string-2"},
    // byte
    {regex: /b'(?:[^']|\\(?:['\\nrt0]|x[\da-fA-F]{2}))'/, token: "string-2"},

    {regex: /(?:(?:[0-9][0-9_]*)(?:(?:[Ee][+-]?[0-9_]+)|\.[0-9_]+(?:[Ee][+-]?[0-9_]+)?)(?:f32|f64)?)|(?:0(?:b[01_]+|(?:o[0-7_]+)|(?:x[0-9a-fA-F_]+))|(?:[0-9][0-9_]*))(?:u8|u16|u32|u64|i8|i16|i32|i64|isize|usize)?/,
     token: "number"},
    {regex: /(let(?:\s+mut)?|fn|enum|mod|struct|type|union)(\s+)([a-zA-Z_][a-zA-Z0-9_]*)/, token: ["keyword", null, "def"]},
    {regex: /(?:abstract|alignof|as|async|await|box|break|continue|const|crate|do|dyn|else|enum|extern|fn|for|final|if|impl|in|loop|macro|match|mod|move|offsetof|override|priv|proc|pub|pure|ref|return|self|sizeof|static|struct|super|trait|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/, token: "keyword"},
    {regex: /\b(?:Self|isize|usize|char|bool|u8|u16|u32|u64|f16|f32|f64|i8|i16|i32|i64|str|Option)\b/, token: "atom"},
    {regex: /\b(?:true|false|Some|None|Ok|Err)\b/, token: "builtin"},
    {regex: /\b(fn)(\s+)([a-zA-Z_][a-zA-Z0-9_]*)/,
     token: ["keyword", null ,"def"]},
    {regex: /#!?\[.*\]/, token: "meta"},
    {regex: /\/\/.*/, token: "comment"},
    {regex: /\/\*/, token: "comment", next: "comment"},
    {regex: /[-+\/*=<>!]+/, token: "operator"},
    {regex: /[a-zA-Z_]\w*!/,token: "variable-3"},
    {regex: /[a-zA-Z_]\w*/, token: "variable"},
    {regex: /[\{\[\(]/, indent: true},
    {regex: /[\}\]\)]/, dedent: true}
  ],
  string: [
    {regex: /"/, token: "string", next: "start"},
    {regex: /(?:[^\\"]|\\(?:.|$))*/, token: "string"}
  ],
  string_raw: [
    {regex: /"/, token: "string", next: "start"},
    {regex: /[^"]*/, token: "string"}
  ],
  string_raw_hash: [
    {regex: /"#+/, token: "string", next: "start"},
    {regex: /(?:[^"]|"(?!#))*/, token: "string"}
  ],
  comment: [
    {regex: /.*?\*\//, token: "comment", next: "start"},
    {regex: /.*/, token: "comment"}
  ],
  meta: {
    dontIndentStates: ["comment"],
    electricInput: /^\s*\}$/,
    blockCommentStart: "/*",
    blockCommentEnd: "*/",
    lineComment: "//",
    fold: "brace"
  }
});


CodeMirror.defineMIME("text/x-rustsrc", "rust");
CodeMirror.defineMIME("text/rust", "rust");
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/sas/sas.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE


// SAS mode copyright (c) 2016 Jared Dean, SAS Institute
// Created by Jared Dean

// TODO
// indent and de-indent
// identify macro variables


//Definitions
//  comment -- text within * ; or /* */
//  keyword -- SAS language variable
//  variable -- macro variables starts with '&' or variable formats
//  variable-2 -- DATA Step, proc, or macro names
//  string -- text within ' ' or " "
//  operator -- numeric operator + / - * ** le eq ge ... and so on
//  builtin -- proc %macro data run mend
//  atom
//  def

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
  "use strict";

  CodeMirror.defineMode("sas", function () {
    var words = {};
    var isDoubleOperatorSym = {
      eq: 'operator',
      lt: 'operator',
      le: 'operator',
      gt: 'operator',
      ge: 'operator',
      "in": 'operator',
      ne: 'operator',
      or: 'operator'
    };
    var isDoubleOperatorChar = /(<=|>=|!=|<>)/;
    var isSingleOperatorChar = /[=\(:\),{}.*<>+\-\/^\[\]]/;

    // Takes a string of words separated by spaces and adds them as
    // keys with the value of the first argument 'style'
    function define(style, string, context) {
      if (context) {
        var split = string.split(' ');
        for (var i = 0; i < split.length; i++) {
          words[split[i]] = {style: style, state: context};
        }
      }
    }
    //datastep
    define('def', 'stack pgm view source debug nesting nolist', ['inDataStep']);
    define('def', 'if while until for do do; end end; then else cancel', ['inDataStep']);
    define('def', 'label format _n_ _error_', ['inDataStep']);
    define('def', 'ALTER BUFNO BUFSIZE CNTLLEV COMPRESS DLDMGACTION ENCRYPT ENCRYPTKEY EXTENDOBSCOUNTER GENMAX GENNUM INDEX LABEL OBSBUF OUTREP PW PWREQ READ REPEMPTY REPLACE REUSE ROLE SORTEDBY SPILL TOBSNO TYPE WRITE FILECLOSE FIRSTOBS IN OBS POINTOBS WHERE WHEREUP IDXNAME IDXWHERE DROP KEEP RENAME', ['inDataStep']);
    define('def', 'filevar finfo finv fipname fipnamel fipstate first firstobs floor', ['inDataStep']);
    define('def', 'varfmt varinfmt varlabel varlen varname varnum varray varrayx vartype verify vformat vformatd vformatdx vformatn vformatnx vformatw vformatwx vformatx vinarray vinarrayx vinformat vinformatd vinformatdx vinformatn vinformatnx vinformatw vinformatwx vinformatx vlabel vlabelx vlength vlengthx vname vnamex vnferr vtype vtypex weekday', ['inDataStep']);
    define('def', 'zipfips zipname zipnamel zipstate', ['inDataStep']);
    define('def', 'put putc putn', ['inDataStep']);
    define('builtin', 'data run', ['inDataStep']);


    //proc
    define('def', 'data', ['inProc']);

    // flow control for macros
    define('def', '%if %end %end; %else %else; %do %do; %then', ['inMacro']);

    //everywhere
    define('builtin', 'proc run; quit; libname filename %macro %mend option options', ['ALL']);

    define('def', 'footnote title libname ods', ['ALL']);
    define('def', '%let %put %global %sysfunc %eval ', ['ALL']);
    // automatic macro variables http://support.sas.com/documentation/cdl/en/mcrolref/61885/HTML/default/viewer.htm#a003167023.htm
    define('variable', '&sysbuffr &syscc &syscharwidth &syscmd &sysdate &sysdate9 &sysday &sysdevic &sysdmg &sysdsn &sysencoding &sysenv &syserr &syserrortext &sysfilrc &syshostname &sysindex &sysinfo &sysjobid &syslast &syslckrc &syslibrc &syslogapplname &sysmacroname &sysmenv &sysmsg &sysncpu &sysodspath &sysparm &syspbuff &sysprocessid &sysprocessname &sysprocname &sysrc &sysscp &sysscpl &sysscpl &syssite &sysstartid &sysstartname &systcpiphostname &systime &sysuserid &sysver &sysvlong &sysvlong4 &syswarningtext', ['ALL']);

    //footnote[1-9]? title[1-9]?

    //options statement
    define('def', 'source2 nosource2 page pageno pagesize', ['ALL']);

    //proc and datastep
    define('def', '_all_ _character_ _cmd_ _freq_ _i_ _infile_ _last_ _msg_ _null_ _numeric_ _temporary_ _type_ abort abs addr adjrsq airy alpha alter altlog altprint and arcos array arsin as atan attrc attrib attrn authserver autoexec awscontrol awsdef awsmenu awsmenumerge awstitle backward band base betainv between blocksize blshift bnot bor brshift bufno bufsize bxor by byerr byline byte calculated call cards cards4 catcache cbufno cdf ceil center cexist change chisq cinv class cleanup close cnonct cntllev coalesce codegen col collate collin column comamid comaux1 comaux2 comdef compbl compound compress config continue convert cos cosh cpuid create cross crosstab css curobs cv daccdb daccdbsl daccsl daccsyd dacctab dairy datalines datalines4 datejul datepart datetime day dbcslang dbcstype dclose ddfm ddm delete delimiter depdb depdbsl depsl depsyd deptab dequote descending descript design= device dflang dhms dif digamma dim dinfo display distinct dkricond dkrocond dlm dnum do dopen doptname doptnum dread drop dropnote dsname dsnferr echo else emaildlg emailid emailpw emailserver emailsys encrypt end endsas engine eof eov erf erfc error errorcheck errors exist exp fappend fclose fcol fdelete feedback fetch fetchobs fexist fget file fileclose fileexist filefmt filename fileref  fmterr fmtsearch fnonct fnote font fontalias  fopen foptname foptnum force formatted formchar formdelim formdlim forward fpoint fpos fput fread frewind frlen from fsep fuzz fwrite gaminv gamma getoption getvarc getvarn go goto group gwindow hbar hbound helpenv helploc hms honorappearance hosthelp hostprint hour hpct html hvar ibessel ibr id if index indexc indexw initcmd initstmt inner input inputc inputn inr insert int intck intnx into intrr invaliddata irr is jbessel join juldate keep kentb kurtosis label lag last lbound leave left length levels lgamma lib  library libref line linesize link list log log10 log2 logpdf logpmf logsdf lostcard lowcase lrecl ls macro macrogen maps mautosource max maxdec maxr mdy mean measures median memtype merge merror min minute missing missover mlogic mod mode model modify month mopen mort mprint mrecall msglevel msymtabmax mvarsize myy n nest netpv new news nmiss no nobatch nobs nocaps nocardimage nocenter nocharcode nocmdmac nocol nocum nodate nodbcs nodetails nodmr nodms nodmsbatch nodup nodupkey noduplicates noechoauto noequals noerrorabend noexitwindows nofullstimer noicon noimplmac noint nolist noloadlist nomiss nomlogic nomprint nomrecall nomsgcase nomstored nomultenvappl nonotes nonumber noobs noovp nopad nopercent noprint noprintinit normal norow norsasuser nosetinit  nosplash nosymbolgen note notes notitle notitles notsorted noverbose noxsync noxwait npv null number numkeys nummousekeys nway obs  on open     order ordinal otherwise out outer outp= output over ovp p(1 5 10 25 50 75 90 95 99) pad pad2  paired parm parmcards path pathdll pathname pdf peek peekc pfkey pmf point poisson poke position printer probbeta probbnml probchi probf probgam probhypr probit probnegb probnorm probsig probt procleave prt ps  pw pwreq qtr quote r ranbin rancau random ranexp rangam range ranks rannor ranpoi rantbl rantri ranuni rcorr read recfm register regr remote remove rename repeat repeated replace resolve retain return reuse reverse rewind right round rsquare rtf rtrace rtraceloc s s2 samploc sasautos sascontrol sasfrscr sasmsg sasmstore sasscript sasuser saving scan sdf second select selection separated seq serror set setcomm setot sign simple sin sinh siteinfo skewness skip sle sls sortedby sortpgm sortseq sortsize soundex  spedis splashlocation split spool sqrt start std stderr stdin stfips stimer stname stnamel stop stopover sub subgroup subpopn substr sum sumwgt symbol symbolgen symget symput sysget sysin sysleave sysmsg sysparm sysprint sysprintfont sysprod sysrc system t table tables tan tanh tapeclose tbufsize terminal test then timepart tinv  tnonct to today tol tooldef totper transformout translate trantab tranwrd trigamma trim trimn trunc truncover type unformatted uniform union until upcase update user usericon uss validate value var  weight when where while wincharset window work workinit workterm write wsum xsync xwait yearcutoff yes yyq  min max', ['inDataStep', 'inProc']);
    define('operator', 'and not ', ['inDataStep', 'inProc']);

    // Main function
    function tokenize(stream, state) {
      // Finally advance the stream
      var ch = stream.next();

      // BLOCKCOMMENT
      if (ch === '/' && stream.eat('*')) {
        state.continueComment = true;
        return "comment";
      } else if (state.continueComment === true) { // in comment block
        //comment ends at the beginning of the line
        if (ch === '*' && stream.peek() === '/') {
          stream.next();
          state.continueComment = false;
        } else if (stream.skipTo('*')) { //comment is potentially later in line
          stream.skipTo('*');
          stream.next();
          if (stream.eat('/'))
            state.continueComment = false;
        } else {
          stream.skipToEnd();
        }
        return "comment";
      }

      if (ch == "*" && stream.column() == stream.indentation()) {
        stream.skipToEnd()
        return "comment"
      }

      // DoubleOperator match
      var doubleOperator = ch + stream.peek();

      if ((ch === '"' || ch === "'") && !state.continueString) {
        state.continueString = ch
        return "string"
      } else if (state.continueString) {
        if (state.continueString == ch) {
          state.continueString = null;
        } else if (stream.skipTo(state.continueString)) {
          // quote found on this line
          stream.next();
          state.continueString = null;
        } else {
          stream.skipToEnd();
        }
        return "string";
      } else if (state.continueString !== null && stream.eol()) {
        stream.skipTo(state.continueString) || stream.skipToEnd();
        return "string";
      } else if (/[\d\.]/.test(ch)) { //find numbers
        if (ch === ".")
          stream.match(/^[0-9]+([eE][\-+]?[0-9]+)?/);
        else if (ch === "0")
          stream.match(/^[xX][0-9a-fA-F]+/) || stream.match(/^0[0-7]+/);
        else
          stream.match(/^[0-9]*\.?[0-9]*([eE][\-+]?[0-9]+)?/);
        return "number";
      } else if (isDoubleOperatorChar.test(ch + stream.peek())) { // TWO SYMBOL TOKENS
        stream.next();
        return "operator";
      } else if (isDoubleOperatorSym.hasOwnProperty(doubleOperator)) {
        stream.next();
        if (stream.peek() === ' ')
          return isDoubleOperatorSym[doubleOperator.toLowerCase()];
      } else if (isSingleOperatorChar.test(ch)) { // SINGLE SYMBOL TOKENS
        return "operator";
      }

      // Matches one whole word -- even if the word is a character
      var word;
      if (stream.match(/[%&;\w]+/, false) != null) {
        word = ch + stream.match(/[%&;\w]+/, true);
        if (/&/.test(word)) return 'variable'
      } else {
        word = ch;
      }
      // the word after DATA PROC or MACRO
      if (state.nextword) {
        stream.match(/[\w]+/);
        // match memname.libname
        if (stream.peek() === '.') stream.skipTo(' ');
        state.nextword = false;
        return 'variable-2';
      }

      word = word.toLowerCase()
      // Are we in a DATA Step?
      if (state.inDataStep) {
        if (word === 'run;' || stream.match(/run\s;/)) {
          state.inDataStep = false;
          return 'builtin';
        }
        // variable formats
        if ((word) && stream.next() === '.') {
          //either a format or libname.memname
          if (/\w/.test(stream.peek())) return 'variable-2';
          else return 'variable';
        }
        // do we have a DATA Step keyword
        if (word && words.hasOwnProperty(word) &&
            (words[word].state.indexOf("inDataStep") !== -1 ||
             words[word].state.indexOf("ALL") !== -1)) {
          //backup to the start of the word
          if (stream.start < stream.pos)
            stream.backUp(stream.pos - stream.start);
          //advance the length of the word and return
          for (var i = 0; i < word.length; ++i) stream.next();
          return words[word].style;
        }
      }
      // Are we in an Proc statement?
      if (state.inProc) {
        if (word === 'run;' || word === 'quit;') {
          state.inProc = false;
          return 'builtin';
        }
        // do we have a proc keyword
        if (word && words.hasOwnProperty(word) &&
            (words[word].state.indexOf("inProc") !== -1 ||
             words[word].state.indexOf("ALL") !== -1)) {
          stream.match(/[\w]+/);
          return words[word].style;
        }
      }
      // Are we in a Macro statement?
      if (state.inMacro) {
        if (word === '%mend') {
          if (stream.peek() === ';') stream.next();
          state.inMacro = false;
          return 'builtin';
        }
        if (word && words.hasOwnProperty(word) &&
            (words[word].state.indexOf("inMacro") !== -1 ||
             words[word].state.indexOf("ALL") !== -1)) {
          stream.match(/[\w]+/);
          return words[word].style;
        }

        return 'atom';
      }
      // Do we have Keywords specific words?
      if (word && words.hasOwnProperty(word)) {
        // Negates the initial next()
        stream.backUp(1);
        // Actually move the stream
        stream.match(/[\w]+/);
        if (word === 'data' && /=/.test(stream.peek()) === false) {
          state.inDataStep = true;
          state.nextword = true;
          return 'builtin';
        }
        if (word === 'proc') {
          state.inProc = true;
          state.nextword = true;
          return 'builtin';
        }
        if (word === '%macro') {
          state.inMacro = true;
          state.nextword = true;
          return 'builtin';
        }
        if (/title[1-9]/.test(word)) return 'def';

        if (word === 'footnote') {
          stream.eat(/[1-9]/);
          return 'def';
        }

        // Returns their value as state in the prior define methods
        if (state.inDataStep === true && words[word].state.indexOf("inDataStep") !== -1)
          return words[word].style;
        if (state.inProc === true && words[word].state.indexOf("inProc") !== -1)
          return words[word].style;
        if (state.inMacro === true && words[word].state.indexOf("inMacro") !== -1)
          return words[word].style;
        if (words[word].state.indexOf("ALL") !== -1)
          return words[word].style;
        return null;
      }
      // Unrecognized syntax
      return null;
    }

    return {
      startState: function () {
        return {
          inDataStep: false,
          inProc: false,
          inMacro: false,
          nextword: false,
          continueString: null,
          continueComment: false
        };
      },
      token: function (stream, state) {
        // Strip the spaces, but regex will account for them either way
        if (stream.eatSpace()) return null;
        // Go through the main process
        return tokenize(stream, state);
      },

      blockCommentStart: "/*",
      blockCommentEnd: "*/"
    };

  });

  CodeMirror.defineMIME("text/x-sas", "sas");
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/sass/sass.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"), __webpack_require__("./src/ipywidgets/node_modules/codemirror/mode/css/css.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("sass", function(config) {
  var cssMode = CodeMirror.mimeModes["text/css"];
  var propertyKeywords = cssMode.propertyKeywords || {},
      colorKeywords = cssMode.colorKeywords || {},
      valueKeywords = cssMode.valueKeywords || {},
      fontProperties = cssMode.fontProperties || {};

  function tokenRegexp(words) {
    return new RegExp("^" + words.join("|"));
  }

  var keywords = ["true", "false", "null", "auto"];
  var keywordsRegexp = new RegExp("^" + keywords.join("|"));

  var operators = ["\\(", "\\)", "=", ">", "<", "==", ">=", "<=", "\\+", "-",
                   "\\!=", "/", "\\*", "%", "and", "or", "not", ";","\\{","\\}",":"];
  var opRegexp = tokenRegexp(operators);

  var pseudoElementsRegexp = /^::?[a-zA-Z_][\w\-]*/;

  var word;

  function isEndLine(stream) {
    return !stream.peek() || stream.match(/\s+$/, false);
  }

  function urlTokens(stream, state) {
    var ch = stream.peek();

    if (ch === ")") {
      stream.next();
      state.tokenizer = tokenBase;
      return "operator";
    } else if (ch === "(") {
      stream.next();
      stream.eatSpace();

      return "operator";
    } else if (ch === "'" || ch === '"') {
      state.tokenizer = buildStringTokenizer(stream.next());
      return "string";
    } else {
      state.tokenizer = buildStringTokenizer(")", false);
      return "string";
    }
  }
  function comment(indentation, multiLine) {
    return function(stream, state) {
      if (stream.sol() && stream.indentation() <= indentation) {
        state.tokenizer = tokenBase;
        return tokenBase(stream, state);
      }

      if (multiLine && stream.skipTo("*/")) {
        stream.next();
        stream.next();
        state.tokenizer = tokenBase;
      } else {
        stream.skipToEnd();
      }

      return "comment";
    };
  }

  function buildStringTokenizer(quote, greedy) {
    if (greedy == null) { greedy = true; }

    function stringTokenizer(stream, state) {
      var nextChar = stream.next();
      var peekChar = stream.peek();
      var previousChar = stream.string.charAt(stream.pos-2);

      var endingString = ((nextChar !== "\\" && peekChar === quote) || (nextChar === quote && previousChar !== "\\"));

      if (endingString) {
        if (nextChar !== quote && greedy) { stream.next(); }
        if (isEndLine(stream)) {
          state.cursorHalf = 0;
        }
        state.tokenizer = tokenBase;
        return "string";
      } else if (nextChar === "#" && peekChar === "{") {
        state.tokenizer = buildInterpolationTokenizer(stringTokenizer);
        stream.next();
        return "operator";
      } else {
        return "string";
      }
    }

    return stringTokenizer;
  }

  function buildInterpolationTokenizer(currentTokenizer) {
    return function(stream, state) {
      if (stream.peek() === "}") {
        stream.next();
        state.tokenizer = currentTokenizer;
        return "operator";
      } else {
        return tokenBase(stream, state);
      }
    };
  }

  function indent(state) {
    if (state.indentCount == 0) {
      state.indentCount++;
      var lastScopeOffset = state.scopes[0].offset;
      var currentOffset = lastScopeOffset + config.indentUnit;
      state.scopes.unshift({ offset:currentOffset });
    }
  }

  function dedent(state) {
    if (state.scopes.length == 1) return;

    state.scopes.shift();
  }

  function tokenBase(stream, state) {
    var ch = stream.peek();

    // Comment
    if (stream.match("/*")) {
      state.tokenizer = comment(stream.indentation(), true);
      return state.tokenizer(stream, state);
    }
    if (stream.match("//")) {
      state.tokenizer = comment(stream.indentation(), false);
      return state.tokenizer(stream, state);
    }

    // Interpolation
    if (stream.match("#{")) {
      state.tokenizer = buildInterpolationTokenizer(tokenBase);
      return "operator";
    }

    // Strings
    if (ch === '"' || ch === "'") {
      stream.next();
      state.tokenizer = buildStringTokenizer(ch);
      return "string";
    }

    if(!state.cursorHalf){// state.cursorHalf === 0
    // first half i.e. before : for key-value pairs
    // including selectors

      if (ch === "-") {
        if (stream.match(/^-\w+-/)) {
          return "meta";
        }
      }

      if (ch === ".") {
        stream.next();
        if (stream.match(/^[\w-]+/)) {
          indent(state);
          return "qualifier";
        } else if (stream.peek() === "#") {
          indent(state);
          return "tag";
        }
      }

      if (ch === "#") {
        stream.next();
        // ID selectors
        if (stream.match(/^[\w-]+/)) {
          indent(state);
          return "builtin";
        }
        if (stream.peek() === "#") {
          indent(state);
          return "tag";
        }
      }

      // Variables
      if (ch === "$") {
        stream.next();
        stream.eatWhile(/[\w-]/);
        return "variable-2";
      }

      // Numbers
      if (stream.match(/^-?[0-9\.]+/))
        return "number";

      // Units
      if (stream.match(/^(px|em|in)\b/))
        return "unit";

      if (stream.match(keywordsRegexp))
        return "keyword";

      if (stream.match(/^url/) && stream.peek() === "(") {
        state.tokenizer = urlTokens;
        return "atom";
      }

      if (ch === "=") {
        // Match shortcut mixin definition
        if (stream.match(/^=[\w-]+/)) {
          indent(state);
          return "meta";
        }
      }

      if (ch === "+") {
        // Match shortcut mixin definition
        if (stream.match(/^\+[\w-]+/)){
          return "variable-3";
        }
      }

      if(ch === "@"){
        if(stream.match('@extend')){
          if(!stream.match(/\s*[\w]/))
            dedent(state);
        }
      }


      // Indent Directives
      if (stream.match(/^@(else if|if|media|else|for|each|while|mixin|function)/)) {
        indent(state);
        return "def";
      }

      // Other Directives
      if (ch === "@") {
        stream.next();
        stream.eatWhile(/[\w-]/);
        return "def";
      }

      if (stream.eatWhile(/[\w-]/)){
        if(stream.match(/ *: *[\w-\+\$#!\("']/,false)){
          word = stream.current().toLowerCase();
          var prop = state.prevProp + "-" + word;
          if (propertyKeywords.hasOwnProperty(prop)) {
            return "property";
          } else if (propertyKeywords.hasOwnProperty(word)) {
            state.prevProp = word;
            return "property";
          } else if (fontProperties.hasOwnProperty(word)) {
            return "property";
          }
          return "tag";
        }
        else if(stream.match(/ *:/,false)){
          indent(state);
          state.cursorHalf = 1;
          state.prevProp = stream.current().toLowerCase();
          return "property";
        }
        else if(stream.match(/ *,/,false)){
          return "tag";
        }
        else{
          indent(state);
          return "tag";
        }
      }

      if(ch === ":"){
        if (stream.match(pseudoElementsRegexp)){ // could be a pseudo-element
          return "variable-3";
        }
        stream.next();
        state.cursorHalf=1;
        return "operator";
      }

    } // cursorHalf===0 ends here
    else{

      if (ch === "#") {
        stream.next();
        // Hex numbers
        if (stream.match(/[0-9a-fA-F]{6}|[0-9a-fA-F]{3}/)){
          if (isEndLine(stream)) {
            state.cursorHalf = 0;
          }
          return "number";
        }
      }

      // Numbers
      if (stream.match(/^-?[0-9\.]+/)){
        if (isEndLine(stream)) {
          state.cursorHalf = 0;
        }
        return "number";
      }

      // Units
      if (stream.match(/^(px|em|in)\b/)){
        if (isEndLine(stream)) {
          state.cursorHalf = 0;
        }
        return "unit";
      }

      if (stream.match(keywordsRegexp)){
        if (isEndLine(stream)) {
          state.cursorHalf = 0;
        }
        return "keyword";
      }

      if (stream.match(/^url/) && stream.peek() === "(") {
        state.tokenizer = urlTokens;
        if (isEndLine(stream)) {
          state.cursorHalf = 0;
        }
        return "atom";
      }

      // Variables
      if (ch === "$") {
        stream.next();
        stream.eatWhile(/[\w-]/);
        if (isEndLine(stream)) {
          state.cursorHalf = 0;
        }
        return "variable-2";
      }

      // bang character for !important, !default, etc.
      if (ch === "!") {
        stream.next();
        state.cursorHalf = 0;
        return stream.match(/^[\w]+/) ? "keyword": "operator";
      }

      if (stream.match(opRegexp)){
        if (isEndLine(stream)) {
          state.cursorHalf = 0;
        }
        return "operator";
      }

      // attributes
      if (stream.eatWhile(/[\w-]/)) {
        if (isEndLine(stream)) {
          state.cursorHalf = 0;
        }
        word = stream.current().toLowerCase();
        if (valueKeywords.hasOwnProperty(word)) {
          return "atom";
        } else if (colorKeywords.hasOwnProperty(word)) {
          return "keyword";
        } else if (propertyKeywords.hasOwnProperty(word)) {
          state.prevProp = stream.current().toLowerCase();
          return "property";
        } else {
          return "tag";
        }
      }

      //stream.eatSpace();
      if (isEndLine(stream)) {
        state.cursorHalf = 0;
        return null;
      }

    } // else ends here

    if (stream.match(opRegexp))
      return "operator";

    // If we haven't returned by now, we move 1 character
    // and return an error
    stream.next();
    return null;
  }

  function tokenLexer(stream, state) {
    if (stream.sol()) state.indentCount = 0;
    var style = state.tokenizer(stream, state);
    var current = stream.current();

    if (current === "@return" || current === "}"){
      dedent(state);
    }

    if (style !== null) {
      var startOfToken = stream.pos - current.length;

      var withCurrentIndent = startOfToken + (config.indentUnit * state.indentCount);

      var newScopes = [];

      for (var i = 0; i < state.scopes.length; i++) {
        var scope = state.scopes[i];

        if (scope.offset <= withCurrentIndent)
          newScopes.push(scope);
      }

      state.scopes = newScopes;
    }


    return style;
  }

  return {
    startState: function() {
      return {
        tokenizer: tokenBase,
        scopes: [{offset: 0, type: "sass"}],
        indentCount: 0,
        cursorHalf: 0,  // cursor half tells us if cursor lies after (1)
                        // or before (0) colon (well... more or less)
        definedVars: [],
        definedMixins: []
      };
    },
    token: function(stream, state) {
      var style = tokenLexer(stream, state);

      state.lastToken = { style: style, content: stream.current() };

      return style;
    },

    indent: function(state) {
      return state.scopes[0].offset;
    },

    blockCommentStart: "/*",
    blockCommentEnd: "*/",
    lineComment: "//",
    fold: "indent"
  };
}, "css");

CodeMirror.defineMIME("text/x-sass", "sass");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/scheme/scheme.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

/**
 * Author: Koh Zi Han, based on implementation by Koh Zi Chun
 */

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("scheme", function () {
    var BUILTIN = "builtin", COMMENT = "comment", STRING = "string",
        ATOM = "atom", NUMBER = "number", BRACKET = "bracket";
    var INDENT_WORD_SKIP = 2;

    function makeKeywords(str) {
        var obj = {}, words = str.split(" ");
        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
        return obj;
    }

    var keywords = makeKeywords("λ case-lambda call/cc class cond-expand define-class define-values exit-handler field import inherit init-field interface let*-values let-values let/ec mixin opt-lambda override protect provide public rename require require-for-syntax syntax syntax-case syntax-error unit/sig unless when with-syntax and begin call-with-current-continuation call-with-input-file call-with-output-file case cond define define-syntax define-macro defmacro delay do dynamic-wind else for-each if lambda let let* let-syntax letrec letrec-syntax map or syntax-rules abs acos angle append apply asin assoc assq assv atan boolean? caar cadr call-with-input-file call-with-output-file call-with-values car cdddar cddddr cdr ceiling char->integer char-alphabetic? char-ci<=? char-ci<? char-ci=? char-ci>=? char-ci>? char-downcase char-lower-case? char-numeric? char-ready? char-upcase char-upper-case? char-whitespace? char<=? char<? char=? char>=? char>? char? close-input-port close-output-port complex? cons cos current-input-port current-output-port denominator display eof-object? eq? equal? eqv? eval even? exact->inexact exact? exp expt #f floor force gcd imag-part inexact->exact inexact? input-port? integer->char integer? interaction-environment lcm length list list->string list->vector list-ref list-tail list? load log magnitude make-polar make-rectangular make-string make-vector max member memq memv min modulo negative? newline not null-environment null? number->string number? numerator odd? open-input-file open-output-file output-port? pair? peek-char port? positive? procedure? quasiquote quote quotient rational? rationalize read read-char real-part real? remainder reverse round scheme-report-environment set! set-car! set-cdr! sin sqrt string string->list string->number string->symbol string-append string-ci<=? string-ci<? string-ci=? string-ci>=? string-ci>? string-copy string-fill! string-length string-ref string-set! string<=? string<? string=? string>=? string>? string? substring symbol->string symbol? #t tan transcript-off transcript-on truncate values vector vector->list vector-fill! vector-length vector-ref vector-set! with-input-from-file with-output-to-file write write-char zero?");
    var indentKeys = makeKeywords("define let letrec let* lambda define-macro defmacro let-syntax letrec-syntax let-values let*-values define-syntax syntax-rules define-values when unless");

    function stateStack(indent, type, prev) { // represents a state stack object
        this.indent = indent;
        this.type = type;
        this.prev = prev;
    }

    function pushStack(state, indent, type) {
        state.indentStack = new stateStack(indent, type, state.indentStack);
    }

    function popStack(state) {
        state.indentStack = state.indentStack.prev;
    }

    var binaryMatcher = new RegExp(/^(?:[-+]i|[-+][01]+#*(?:\/[01]+#*)?i|[-+]?[01]+#*(?:\/[01]+#*)?@[-+]?[01]+#*(?:\/[01]+#*)?|[-+]?[01]+#*(?:\/[01]+#*)?[-+](?:[01]+#*(?:\/[01]+#*)?)?i|[-+]?[01]+#*(?:\/[01]+#*)?)(?=[()\s;"]|$)/i);
    var octalMatcher = new RegExp(/^(?:[-+]i|[-+][0-7]+#*(?:\/[0-7]+#*)?i|[-+]?[0-7]+#*(?:\/[0-7]+#*)?@[-+]?[0-7]+#*(?:\/[0-7]+#*)?|[-+]?[0-7]+#*(?:\/[0-7]+#*)?[-+](?:[0-7]+#*(?:\/[0-7]+#*)?)?i|[-+]?[0-7]+#*(?:\/[0-7]+#*)?)(?=[()\s;"]|$)/i);
    var hexMatcher = new RegExp(/^(?:[-+]i|[-+][\da-f]+#*(?:\/[\da-f]+#*)?i|[-+]?[\da-f]+#*(?:\/[\da-f]+#*)?@[-+]?[\da-f]+#*(?:\/[\da-f]+#*)?|[-+]?[\da-f]+#*(?:\/[\da-f]+#*)?[-+](?:[\da-f]+#*(?:\/[\da-f]+#*)?)?i|[-+]?[\da-f]+#*(?:\/[\da-f]+#*)?)(?=[()\s;"]|$)/i);
    var decimalMatcher = new RegExp(/^(?:[-+]i|[-+](?:(?:(?:\d+#+\.?#*|\d+\.\d*#*|\.\d+#*|\d+)(?:[esfdl][-+]?\d+)?)|\d+#*\/\d+#*)i|[-+]?(?:(?:(?:\d+#+\.?#*|\d+\.\d*#*|\.\d+#*|\d+)(?:[esfdl][-+]?\d+)?)|\d+#*\/\d+#*)@[-+]?(?:(?:(?:\d+#+\.?#*|\d+\.\d*#*|\.\d+#*|\d+)(?:[esfdl][-+]?\d+)?)|\d+#*\/\d+#*)|[-+]?(?:(?:(?:\d+#+\.?#*|\d+\.\d*#*|\.\d+#*|\d+)(?:[esfdl][-+]?\d+)?)|\d+#*\/\d+#*)[-+](?:(?:(?:\d+#+\.?#*|\d+\.\d*#*|\.\d+#*|\d+)(?:[esfdl][-+]?\d+)?)|\d+#*\/\d+#*)?i|(?:(?:(?:\d+#+\.?#*|\d+\.\d*#*|\.\d+#*|\d+)(?:[esfdl][-+]?\d+)?)|\d+#*\/\d+#*))(?=[()\s;"]|$)/i);

    function isBinaryNumber (stream) {
        return stream.match(binaryMatcher);
    }

    function isOctalNumber (stream) {
        return stream.match(octalMatcher);
    }

    function isDecimalNumber (stream, backup) {
        if (backup === true) {
            stream.backUp(1);
        }
        return stream.match(decimalMatcher);
    }

    function isHexNumber (stream) {
        return stream.match(hexMatcher);
    }

    return {
        startState: function () {
            return {
                indentStack: null,
                indentation: 0,
                mode: false,
                sExprComment: false,
                sExprQuote: false
            };
        },

        token: function (stream, state) {
            if (state.indentStack == null && stream.sol()) {
                // update indentation, but only if indentStack is empty
                state.indentation = stream.indentation();
            }

            // skip spaces
            if (stream.eatSpace()) {
                return null;
            }
            var returnType = null;

            switch(state.mode){
                case "string": // multi-line string parsing mode
                    var next, escaped = false;
                    while ((next = stream.next()) != null) {
                        if (next == "\"" && !escaped) {

                            state.mode = false;
                            break;
                        }
                        escaped = !escaped && next == "\\";
                    }
                    returnType = STRING; // continue on in scheme-string mode
                    break;
                case "comment": // comment parsing mode
                    var next, maybeEnd = false;
                    while ((next = stream.next()) != null) {
                        if (next == "#" && maybeEnd) {

                            state.mode = false;
                            break;
                        }
                        maybeEnd = (next == "|");
                    }
                    returnType = COMMENT;
                    break;
                case "s-expr-comment": // s-expr commenting mode
                    state.mode = false;
                    if(stream.peek() == "(" || stream.peek() == "["){
                        // actually start scheme s-expr commenting mode
                        state.sExprComment = 0;
                    }else{
                        // if not we just comment the entire of the next token
                        stream.eatWhile(/[^\s\(\)\[\]]/); // eat symbol atom
                        returnType = COMMENT;
                        break;
                    }
                default: // default parsing mode
                    var ch = stream.next();

                    if (ch == "\"") {
                        state.mode = "string";
                        returnType = STRING;

                    } else if (ch == "'") {
                        if (stream.peek() == "(" || stream.peek() == "["){
                            if (typeof state.sExprQuote != "number") {
                                state.sExprQuote = 0;
                            } // else already in a quoted expression
                            returnType = ATOM;
                        } else {
                            stream.eatWhile(/[\w_\-!$%&*+\.\/:<=>?@\^~]/);
                            returnType = ATOM;
                        }
                    } else if (ch == '#') {
                        if (stream.eat("|")) {                    // Multi-line comment
                            state.mode = "comment"; // toggle to comment mode
                            returnType = COMMENT;
                        } else if (stream.eat(/[tf]/i)) {            // #t/#f (atom)
                            returnType = ATOM;
                        } else if (stream.eat(';')) {                // S-Expr comment
                            state.mode = "s-expr-comment";
                            returnType = COMMENT;
                        } else {
                            var numTest = null, hasExactness = false, hasRadix = true;
                            if (stream.eat(/[ei]/i)) {
                                hasExactness = true;
                            } else {
                                stream.backUp(1);       // must be radix specifier
                            }
                            if (stream.match(/^#b/i)) {
                                numTest = isBinaryNumber;
                            } else if (stream.match(/^#o/i)) {
                                numTest = isOctalNumber;
                            } else if (stream.match(/^#x/i)) {
                                numTest = isHexNumber;
                            } else if (stream.match(/^#d/i)) {
                                numTest = isDecimalNumber;
                            } else if (stream.match(/^[-+0-9.]/, false)) {
                                hasRadix = false;
                                numTest = isDecimalNumber;
                            // re-consume the initial # if all matches failed
                            } else if (!hasExactness) {
                                stream.eat('#');
                            }
                            if (numTest != null) {
                                if (hasRadix && !hasExactness) {
                                    // consume optional exactness after radix
                                    stream.match(/^#[ei]/i);
                                }
                                if (numTest(stream))
                                    returnType = NUMBER;
                            }
                        }
                    } else if (/^[-+0-9.]/.test(ch) && isDecimalNumber(stream, true)) { // match non-prefixed number, must be decimal
                        returnType = NUMBER;
                    } else if (ch == ";") { // comment
                        stream.skipToEnd(); // rest of the line is a comment
                        returnType = COMMENT;
                    } else if (ch == "(" || ch == "[") {
                      var keyWord = ''; var indentTemp = stream.column(), letter;
                        /**
                        Either
                        (indent-word ..
                        (non-indent-word ..
                        (;something else, bracket, etc.
                        */

                        while ((letter = stream.eat(/[^\s\(\[\;\)\]]/)) != null) {
                            keyWord += letter;
                        }

                        if (keyWord.length > 0 && indentKeys.propertyIsEnumerable(keyWord)) { // indent-word

                            pushStack(state, indentTemp + INDENT_WORD_SKIP, ch);
                        } else { // non-indent word
                            // we continue eating the spaces
                            stream.eatSpace();
                            if (stream.eol() || stream.peek() == ";") {
                                // nothing significant after
                                // we restart indentation 1 space after
                                pushStack(state, indentTemp + 1, ch);
                            } else {
                                pushStack(state, indentTemp + stream.current().length, ch); // else we match
                            }
                        }
                        stream.backUp(stream.current().length - 1); // undo all the eating

                        if(typeof state.sExprComment == "number") state.sExprComment++;
                        if(typeof state.sExprQuote == "number") state.sExprQuote++;

                        returnType = BRACKET;
                    } else if (ch == ")" || ch == "]") {
                        returnType = BRACKET;
                        if (state.indentStack != null && state.indentStack.type == (ch == ")" ? "(" : "[")) {
                            popStack(state);

                            if(typeof state.sExprComment == "number"){
                                if(--state.sExprComment == 0){
                                    returnType = COMMENT; // final closing bracket
                                    state.sExprComment = false; // turn off s-expr commenting mode
                                }
                            }
                            if(typeof state.sExprQuote == "number"){
                                if(--state.sExprQuote == 0){
                                    returnType = ATOM; // final closing bracket
                                    state.sExprQuote = false; // turn off s-expr quote mode
                                }
                            }
                        }
                    } else {
                        stream.eatWhile(/[\w_\-!$%&*+\.\/:<=>?@\^~]/);

                        if (keywords && keywords.propertyIsEnumerable(stream.current())) {
                            returnType = BUILTIN;
                        } else returnType = "variable";
                    }
            }
            return (typeof state.sExprComment == "number") ? COMMENT : ((typeof state.sExprQuote == "number") ? ATOM : returnType);
        },

        indent: function (state) {
            if (state.indentStack == null) return state.indentation;
            return state.indentStack.indent;
        },

        closeBrackets: {pairs: "()[]{}\"\""},
        lineComment: ";;"
    };
});

CodeMirror.defineMIME("text/x-scheme", "scheme");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/sieve/sieve.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("sieve", function(config) {
  function words(str) {
    var obj = {}, words = str.split(" ");
    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
    return obj;
  }

  var keywords = words("if elsif else stop require");
  var atoms = words("true false not");
  var indentUnit = config.indentUnit;

  function tokenBase(stream, state) {

    var ch = stream.next();
    if (ch == "/" && stream.eat("*")) {
      state.tokenize = tokenCComment;
      return tokenCComment(stream, state);
    }

    if (ch === '#') {
      stream.skipToEnd();
      return "comment";
    }

    if (ch == "\"") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    }

    if (ch == "(") {
      state._indent.push("(");
      // add virtual angel wings so that editor behaves...
      // ...more sane in case of broken brackets
      state._indent.push("{");
      return null;
    }

    if (ch === "{") {
      state._indent.push("{");
      return null;
    }

    if (ch == ")")  {
      state._indent.pop();
      state._indent.pop();
    }

    if (ch === "}") {
      state._indent.pop();
      return null;
    }

    if (ch == ",")
      return null;

    if (ch == ";")
      return null;


    if (/[{}\(\),;]/.test(ch))
      return null;

    // 1*DIGIT "K" / "M" / "G"
    if (/\d/.test(ch)) {
      stream.eatWhile(/[\d]/);
      stream.eat(/[KkMmGg]/);
      return "number";
    }

    // ":" (ALPHA / "_") *(ALPHA / DIGIT / "_")
    if (ch == ":") {
      stream.eatWhile(/[a-zA-Z_]/);
      stream.eatWhile(/[a-zA-Z0-9_]/);

      return "operator";
    }

    stream.eatWhile(/\w/);
    var cur = stream.current();

    // "text:" *(SP / HTAB) (hash-comment / CRLF)
    // *(multiline-literal / multiline-dotstart)
    // "." CRLF
    if ((cur == "text") && stream.eat(":"))
    {
      state.tokenize = tokenMultiLineString;
      return "string";
    }

    if (keywords.propertyIsEnumerable(cur))
      return "keyword";

    if (atoms.propertyIsEnumerable(cur))
      return "atom";

    return null;
  }

  function tokenMultiLineString(stream, state)
  {
    state._multiLineString = true;
    // the first line is special it may contain a comment
    if (!stream.sol()) {
      stream.eatSpace();

      if (stream.peek() == "#") {
        stream.skipToEnd();
        return "comment";
      }

      stream.skipToEnd();
      return "string";
    }

    if ((stream.next() == ".")  && (stream.eol()))
    {
      state._multiLineString = false;
      state.tokenize = tokenBase;
    }

    return "string";
  }

  function tokenCComment(stream, state) {
    var maybeEnd = false, ch;
    while ((ch = stream.next()) != null) {
      if (maybeEnd && ch == "/") {
        state.tokenize = tokenBase;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return "comment";
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, ch;
      while ((ch = stream.next()) != null) {
        if (ch == quote && !escaped)
          break;
        escaped = !escaped && ch == "\\";
      }
      if (!escaped) state.tokenize = tokenBase;
      return "string";
    };
  }

  return {
    startState: function(base) {
      return {tokenize: tokenBase,
              baseIndent: base || 0,
              _indent: []};
    },

    token: function(stream, state) {
      if (stream.eatSpace())
        return null;

      return (state.tokenize || tokenBase)(stream, state);
    },

    indent: function(state, _textAfter) {
      var length = state._indent.length;
      if (_textAfter && (_textAfter[0] == "}"))
        length--;

      if (length <0)
        length = 0;

      return length * indentUnit;
    },

    electricChars: "}"
  };
});

CodeMirror.defineMIME("application/sieve", "sieve");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/slim/slim.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// Slim Highlighting for CodeMirror copyright (c) HicknHack Software Gmbh

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"), __webpack_require__("./src/ipywidgets/node_modules/codemirror/mode/htmlmixed/htmlmixed.js"), __webpack_require__("./src/ipywidgets/node_modules/codemirror/mode/ruby/ruby.js"));
  else {}
})(function(CodeMirror) {
"use strict";

  CodeMirror.defineMode("slim", function(config) {
    var htmlMode = CodeMirror.getMode(config, {name: "htmlmixed"});
    var rubyMode = CodeMirror.getMode(config, "ruby");
    var modes = { html: htmlMode, ruby: rubyMode };
    var embedded = {
      ruby: "ruby",
      javascript: "javascript",
      css: "text/css",
      sass: "text/x-sass",
      scss: "text/x-scss",
      less: "text/x-less",
      styl: "text/x-styl", // no highlighting so far
      coffee: "coffeescript",
      asciidoc: "text/x-asciidoc",
      markdown: "text/x-markdown",
      textile: "text/x-textile", // no highlighting so far
      creole: "text/x-creole", // no highlighting so far
      wiki: "text/x-wiki", // no highlighting so far
      mediawiki: "text/x-mediawiki", // no highlighting so far
      rdoc: "text/x-rdoc", // no highlighting so far
      builder: "text/x-builder", // no highlighting so far
      nokogiri: "text/x-nokogiri", // no highlighting so far
      erb: "application/x-erb"
    };
    var embeddedRegexp = function(map){
      var arr = [];
      for(var key in map) arr.push(key);
      return new RegExp("^("+arr.join('|')+"):");
    }(embedded);

    var styleMap = {
      "commentLine": "comment",
      "slimSwitch": "operator special",
      "slimTag": "tag",
      "slimId": "attribute def",
      "slimClass": "attribute qualifier",
      "slimAttribute": "attribute",
      "slimSubmode": "keyword special",
      "closeAttributeTag": null,
      "slimDoctype": null,
      "lineContinuation": null
    };
    var closing = {
      "{": "}",
      "[": "]",
      "(": ")"
    };

    var nameStartChar = "_a-zA-Z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD";
    var nameChar = nameStartChar + "\\-0-9\xB7\u0300-\u036F\u203F-\u2040";
    var nameRegexp = new RegExp("^[:"+nameStartChar+"](?::["+nameChar+"]|["+nameChar+"]*)");
    var attributeNameRegexp = new RegExp("^[:"+nameStartChar+"][:\\."+nameChar+"]*(?=\\s*=)");
    var wrappedAttributeNameRegexp = new RegExp("^[:"+nameStartChar+"][:\\."+nameChar+"]*");
    var classNameRegexp = /^\.-?[_a-zA-Z]+[\w\-]*/;
    var classIdRegexp = /^#[_a-zA-Z]+[\w\-]*/;

    function backup(pos, tokenize, style) {
      var restore = function(stream, state) {
        state.tokenize = tokenize;
        if (stream.pos < pos) {
          stream.pos = pos;
          return style;
        }
        return state.tokenize(stream, state);
      };
      return function(stream, state) {
        state.tokenize = restore;
        return tokenize(stream, state);
      };
    }

    function maybeBackup(stream, state, pat, offset, style) {
      var cur = stream.current();
      var idx = cur.search(pat);
      if (idx > -1) {
        state.tokenize = backup(stream.pos, state.tokenize, style);
        stream.backUp(cur.length - idx - offset);
      }
      return style;
    }

    function continueLine(state, column) {
      state.stack = {
        parent: state.stack,
        style: "continuation",
        indented: column,
        tokenize: state.line
      };
      state.line = state.tokenize;
    }
    function finishContinue(state) {
      if (state.line == state.tokenize) {
        state.line = state.stack.tokenize;
        state.stack = state.stack.parent;
      }
    }

    function lineContinuable(column, tokenize) {
      return function(stream, state) {
        finishContinue(state);
        if (stream.match(/^\\$/)) {
          continueLine(state, column);
          return "lineContinuation";
        }
        var style = tokenize(stream, state);
        if (stream.eol() && stream.current().match(/(?:^|[^\\])(?:\\\\)*\\$/)) {
          stream.backUp(1);
        }
        return style;
      };
    }
    function commaContinuable(column, tokenize) {
      return function(stream, state) {
        finishContinue(state);
        var style = tokenize(stream, state);
        if (stream.eol() && stream.current().match(/,$/)) {
          continueLine(state, column);
        }
        return style;
      };
    }

    function rubyInQuote(endQuote, tokenize) {
      // TODO: add multi line support
      return function(stream, state) {
        var ch = stream.peek();
        if (ch == endQuote && state.rubyState.tokenize.length == 1) {
          // step out of ruby context as it seems to complete processing all the braces
          stream.next();
          state.tokenize = tokenize;
          return "closeAttributeTag";
        } else {
          return ruby(stream, state);
        }
      };
    }
    function startRubySplat(tokenize) {
      var rubyState;
      var runSplat = function(stream, state) {
        if (state.rubyState.tokenize.length == 1 && !state.rubyState.context.prev) {
          stream.backUp(1);
          if (stream.eatSpace()) {
            state.rubyState = rubyState;
            state.tokenize = tokenize;
            return tokenize(stream, state);
          }
          stream.next();
        }
        return ruby(stream, state);
      };
      return function(stream, state) {
        rubyState = state.rubyState;
        state.rubyState = CodeMirror.startState(rubyMode);
        state.tokenize = runSplat;
        return ruby(stream, state);
      };
    }

    function ruby(stream, state) {
      return rubyMode.token(stream, state.rubyState);
    }

    function htmlLine(stream, state) {
      if (stream.match(/^\\$/)) {
        return "lineContinuation";
      }
      return html(stream, state);
    }
    function html(stream, state) {
      if (stream.match(/^#\{/)) {
        state.tokenize = rubyInQuote("}", state.tokenize);
        return null;
      }
      return maybeBackup(stream, state, /[^\\]#\{/, 1, htmlMode.token(stream, state.htmlState));
    }

    function startHtmlLine(lastTokenize) {
      return function(stream, state) {
        var style = htmlLine(stream, state);
        if (stream.eol()) state.tokenize = lastTokenize;
        return style;
      };
    }

    function startHtmlMode(stream, state, offset) {
      state.stack = {
        parent: state.stack,
        style: "html",
        indented: stream.column() + offset, // pipe + space
        tokenize: state.line
      };
      state.line = state.tokenize = html;
      return null;
    }

    function comment(stream, state) {
      stream.skipToEnd();
      return state.stack.style;
    }

    function commentMode(stream, state) {
      state.stack = {
        parent: state.stack,
        style: "comment",
        indented: state.indented + 1,
        tokenize: state.line
      };
      state.line = comment;
      return comment(stream, state);
    }

    function attributeWrapper(stream, state) {
      if (stream.eat(state.stack.endQuote)) {
        state.line = state.stack.line;
        state.tokenize = state.stack.tokenize;
        state.stack = state.stack.parent;
        return null;
      }
      if (stream.match(wrappedAttributeNameRegexp)) {
        state.tokenize = attributeWrapperAssign;
        return "slimAttribute";
      }
      stream.next();
      return null;
    }
    function attributeWrapperAssign(stream, state) {
      if (stream.match(/^==?/)) {
        state.tokenize = attributeWrapperValue;
        return null;
      }
      return attributeWrapper(stream, state);
    }
    function attributeWrapperValue(stream, state) {
      var ch = stream.peek();
      if (ch == '"' || ch == "\'") {
        state.tokenize = readQuoted(ch, "string", true, false, attributeWrapper);
        stream.next();
        return state.tokenize(stream, state);
      }
      if (ch == '[') {
        return startRubySplat(attributeWrapper)(stream, state);
      }
      if (stream.match(/^(true|false|nil)\b/)) {
        state.tokenize = attributeWrapper;
        return "keyword";
      }
      return startRubySplat(attributeWrapper)(stream, state);
    }

    function startAttributeWrapperMode(state, endQuote, tokenize) {
      state.stack = {
        parent: state.stack,
        style: "wrapper",
        indented: state.indented + 1,
        tokenize: tokenize,
        line: state.line,
        endQuote: endQuote
      };
      state.line = state.tokenize = attributeWrapper;
      return null;
    }

    function sub(stream, state) {
      if (stream.match(/^#\{/)) {
        state.tokenize = rubyInQuote("}", state.tokenize);
        return null;
      }
      var subStream = new CodeMirror.StringStream(stream.string.slice(state.stack.indented), stream.tabSize);
      subStream.pos = stream.pos - state.stack.indented;
      subStream.start = stream.start - state.stack.indented;
      subStream.lastColumnPos = stream.lastColumnPos - state.stack.indented;
      subStream.lastColumnValue = stream.lastColumnValue - state.stack.indented;
      var style = state.subMode.token(subStream, state.subState);
      stream.pos = subStream.pos + state.stack.indented;
      return style;
    }
    function firstSub(stream, state) {
      state.stack.indented = stream.column();
      state.line = state.tokenize = sub;
      return state.tokenize(stream, state);
    }

    function createMode(mode) {
      var query = embedded[mode];
      var spec = CodeMirror.mimeModes[query];
      if (spec) {
        return CodeMirror.getMode(config, spec);
      }
      var factory = CodeMirror.modes[query];
      if (factory) {
        return factory(config, {name: query});
      }
      return CodeMirror.getMode(config, "null");
    }

    function getMode(mode) {
      if (!modes.hasOwnProperty(mode)) {
        return modes[mode] = createMode(mode);
      }
      return modes[mode];
    }

    function startSubMode(mode, state) {
      var subMode = getMode(mode);
      var subState = CodeMirror.startState(subMode);

      state.subMode = subMode;
      state.subState = subState;

      state.stack = {
        parent: state.stack,
        style: "sub",
        indented: state.indented + 1,
        tokenize: state.line
      };
      state.line = state.tokenize = firstSub;
      return "slimSubmode";
    }

    function doctypeLine(stream, _state) {
      stream.skipToEnd();
      return "slimDoctype";
    }

    function startLine(stream, state) {
      var ch = stream.peek();
      if (ch == '<') {
        return (state.tokenize = startHtmlLine(state.tokenize))(stream, state);
      }
      if (stream.match(/^[|']/)) {
        return startHtmlMode(stream, state, 1);
      }
      if (stream.match(/^\/(!|\[\w+])?/)) {
        return commentMode(stream, state);
      }
      if (stream.match(/^(-|==?[<>]?)/)) {
        state.tokenize = lineContinuable(stream.column(), commaContinuable(stream.column(), ruby));
        return "slimSwitch";
      }
      if (stream.match(/^doctype\b/)) {
        state.tokenize = doctypeLine;
        return "keyword";
      }

      var m = stream.match(embeddedRegexp);
      if (m) {
        return startSubMode(m[1], state);
      }

      return slimTag(stream, state);
    }

    function slim(stream, state) {
      if (state.startOfLine) {
        return startLine(stream, state);
      }
      return slimTag(stream, state);
    }

    function slimTag(stream, state) {
      if (stream.eat('*')) {
        state.tokenize = startRubySplat(slimTagExtras);
        return null;
      }
      if (stream.match(nameRegexp)) {
        state.tokenize = slimTagExtras;
        return "slimTag";
      }
      return slimClass(stream, state);
    }
    function slimTagExtras(stream, state) {
      if (stream.match(/^(<>?|><?)/)) {
        state.tokenize = slimClass;
        return null;
      }
      return slimClass(stream, state);
    }
    function slimClass(stream, state) {
      if (stream.match(classIdRegexp)) {
        state.tokenize = slimClass;
        return "slimId";
      }
      if (stream.match(classNameRegexp)) {
        state.tokenize = slimClass;
        return "slimClass";
      }
      return slimAttribute(stream, state);
    }
    function slimAttribute(stream, state) {
      if (stream.match(/^([\[\{\(])/)) {
        return startAttributeWrapperMode(state, closing[RegExp.$1], slimAttribute);
      }
      if (stream.match(attributeNameRegexp)) {
        state.tokenize = slimAttributeAssign;
        return "slimAttribute";
      }
      if (stream.peek() == '*') {
        stream.next();
        state.tokenize = startRubySplat(slimContent);
        return null;
      }
      return slimContent(stream, state);
    }
    function slimAttributeAssign(stream, state) {
      if (stream.match(/^==?/)) {
        state.tokenize = slimAttributeValue;
        return null;
      }
      // should never happen, because of forward lookup
      return slimAttribute(stream, state);
    }

    function slimAttributeValue(stream, state) {
      var ch = stream.peek();
      if (ch == '"' || ch == "\'") {
        state.tokenize = readQuoted(ch, "string", true, false, slimAttribute);
        stream.next();
        return state.tokenize(stream, state);
      }
      if (ch == '[') {
        return startRubySplat(slimAttribute)(stream, state);
      }
      if (ch == ':') {
        return startRubySplat(slimAttributeSymbols)(stream, state);
      }
      if (stream.match(/^(true|false|nil)\b/)) {
        state.tokenize = slimAttribute;
        return "keyword";
      }
      return startRubySplat(slimAttribute)(stream, state);
    }
    function slimAttributeSymbols(stream, state) {
      stream.backUp(1);
      if (stream.match(/^[^\s],(?=:)/)) {
        state.tokenize = startRubySplat(slimAttributeSymbols);
        return null;
      }
      stream.next();
      return slimAttribute(stream, state);
    }
    function readQuoted(quote, style, embed, unescaped, nextTokenize) {
      return function(stream, state) {
        finishContinue(state);
        var fresh = stream.current().length == 0;
        if (stream.match(/^\\$/, fresh)) {
          if (!fresh) return style;
          continueLine(state, state.indented);
          return "lineContinuation";
        }
        if (stream.match(/^#\{/, fresh)) {
          if (!fresh) return style;
          state.tokenize = rubyInQuote("}", state.tokenize);
          return null;
        }
        var escaped = false, ch;
        while ((ch = stream.next()) != null) {
          if (ch == quote && (unescaped || !escaped)) {
            state.tokenize = nextTokenize;
            break;
          }
          if (embed && ch == "#" && !escaped) {
            if (stream.eat("{")) {
              stream.backUp(2);
              break;
            }
          }
          escaped = !escaped && ch == "\\";
        }
        if (stream.eol() && escaped) {
          stream.backUp(1);
        }
        return style;
      };
    }
    function slimContent(stream, state) {
      if (stream.match(/^==?/)) {
        state.tokenize = ruby;
        return "slimSwitch";
      }
      if (stream.match(/^\/$/)) { // tag close hint
        state.tokenize = slim;
        return null;
      }
      if (stream.match(/^:/)) { // inline tag
        state.tokenize = slimTag;
        return "slimSwitch";
      }
      startHtmlMode(stream, state, 0);
      return state.tokenize(stream, state);
    }

    var mode = {
      // default to html mode
      startState: function() {
        var htmlState = CodeMirror.startState(htmlMode);
        var rubyState = CodeMirror.startState(rubyMode);
        return {
          htmlState: htmlState,
          rubyState: rubyState,
          stack: null,
          last: null,
          tokenize: slim,
          line: slim,
          indented: 0
        };
      },

      copyState: function(state) {
        return {
          htmlState : CodeMirror.copyState(htmlMode, state.htmlState),
          rubyState: CodeMirror.copyState(rubyMode, state.rubyState),
          subMode: state.subMode,
          subState: state.subMode && CodeMirror.copyState(state.subMode, state.subState),
          stack: state.stack,
          last: state.last,
          tokenize: state.tokenize,
          line: state.line
        };
      },

      token: function(stream, state) {
        if (stream.sol()) {
          state.indented = stream.indentation();
          state.startOfLine = true;
          state.tokenize = state.line;
          while (state.stack && state.stack.indented > state.indented && state.last != "slimSubmode") {
            state.line = state.tokenize = state.stack.tokenize;
            state.stack = state.stack.parent;
            state.subMode = null;
            state.subState = null;
          }
        }
        if (stream.eatSpace()) return null;
        var style = state.tokenize(stream, state);
        state.startOfLine = false;
        if (style) state.last = style;
        return styleMap.hasOwnProperty(style) ? styleMap[style] : style;
      },

      blankLine: function(state) {
        if (state.subMode && state.subMode.blankLine) {
          return state.subMode.blankLine(state.subState);
        }
      },

      innerMode: function(state) {
        if (state.subMode) return {state: state.subState, mode: state.subMode};
        return {state: state, mode: mode};
      }

      //indent: function(state) {
      //  return state.indented;
      //}
    };
    return mode;
  }, "htmlmixed", "ruby");

  CodeMirror.defineMIME("text/x-slim", "slim");
  CodeMirror.defineMIME("application/x-slim", "slim");
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/smalltalk/smalltalk.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode('smalltalk', function(config) {

  var specialChars = /[+\-\/\\*~<>=@%|&?!.,:;^]/;
  var keywords = /true|false|nil|self|super|thisContext/;

  var Context = function(tokenizer, parent) {
    this.next = tokenizer;
    this.parent = parent;
  };

  var Token = function(name, context, eos) {
    this.name = name;
    this.context = context;
    this.eos = eos;
  };

  var State = function() {
    this.context = new Context(next, null);
    this.expectVariable = true;
    this.indentation = 0;
    this.userIndentationDelta = 0;
  };

  State.prototype.userIndent = function(indentation) {
    this.userIndentationDelta = indentation > 0 ? (indentation / config.indentUnit - this.indentation) : 0;
  };

  var next = function(stream, context, state) {
    var token = new Token(null, context, false);
    var aChar = stream.next();

    if (aChar === '"') {
      token = nextComment(stream, new Context(nextComment, context));

    } else if (aChar === '\'') {
      token = nextString(stream, new Context(nextString, context));

    } else if (aChar === '#') {
      if (stream.peek() === '\'') {
        stream.next();
        token = nextSymbol(stream, new Context(nextSymbol, context));
      } else {
        if (stream.eatWhile(/[^\s.{}\[\]()]/))
          token.name = 'string-2';
        else
          token.name = 'meta';
      }

    } else if (aChar === '$') {
      if (stream.next() === '<') {
        stream.eatWhile(/[^\s>]/);
        stream.next();
      }
      token.name = 'string-2';

    } else if (aChar === '|' && state.expectVariable) {
      token.context = new Context(nextTemporaries, context);

    } else if (/[\[\]{}()]/.test(aChar)) {
      token.name = 'bracket';
      token.eos = /[\[{(]/.test(aChar);

      if (aChar === '[') {
        state.indentation++;
      } else if (aChar === ']') {
        state.indentation = Math.max(0, state.indentation - 1);
      }

    } else if (specialChars.test(aChar)) {
      stream.eatWhile(specialChars);
      token.name = 'operator';
      token.eos = aChar !== ';'; // ; cascaded message expression

    } else if (/\d/.test(aChar)) {
      stream.eatWhile(/[\w\d]/);
      token.name = 'number';

    } else if (/[\w_]/.test(aChar)) {
      stream.eatWhile(/[\w\d_]/);
      token.name = state.expectVariable ? (keywords.test(stream.current()) ? 'keyword' : 'variable') : null;

    } else {
      token.eos = state.expectVariable;
    }

    return token;
  };

  var nextComment = function(stream, context) {
    stream.eatWhile(/[^"]/);
    return new Token('comment', stream.eat('"') ? context.parent : context, true);
  };

  var nextString = function(stream, context) {
    stream.eatWhile(/[^']/);
    return new Token('string', stream.eat('\'') ? context.parent : context, false);
  };

  var nextSymbol = function(stream, context) {
    stream.eatWhile(/[^']/);
    return new Token('string-2', stream.eat('\'') ? context.parent : context, false);
  };

  var nextTemporaries = function(stream, context) {
    var token = new Token(null, context, false);
    var aChar = stream.next();

    if (aChar === '|') {
      token.context = context.parent;
      token.eos = true;

    } else {
      stream.eatWhile(/[^|]/);
      token.name = 'variable';
    }

    return token;
  };

  return {
    startState: function() {
      return new State;
    },

    token: function(stream, state) {
      state.userIndent(stream.indentation());

      if (stream.eatSpace()) {
        return null;
      }

      var token = state.context.next(stream, state.context, state);
      state.context = token.context;
      state.expectVariable = token.eos;

      return token.name;
    },

    blankLine: function(state) {
      state.userIndent(0);
    },

    indent: function(state, textAfter) {
      var i = state.context.next === next && textAfter && textAfter.charAt(0) === ']' ? -1 : state.userIndentationDelta;
      return (state.indentation + i) * config.indentUnit;
    },

    electricChars: ']'
  };

});

CodeMirror.defineMIME('text/x-stsrc', {name: 'smalltalk'});

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/smarty/smarty.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

/**
 * Smarty 2 and 3 mode.
 */

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
  "use strict";

  CodeMirror.defineMode("smarty", function(config, parserConf) {
    var rightDelimiter = parserConf.rightDelimiter || "}";
    var leftDelimiter = parserConf.leftDelimiter || "{";
    var version = parserConf.version || 2;
    var baseMode = CodeMirror.getMode(config, parserConf.baseMode || "null");

    var keyFunctions = ["debug", "extends", "function", "include", "literal"];
    var regs = {
      operatorChars: /[+\-*&%=<>!?]/,
      validIdentifier: /[a-zA-Z0-9_]/,
      stringChar: /['"]/
    };

    var last;
    function cont(style, lastType) {
      last = lastType;
      return style;
    }

    function chain(stream, state, parser) {
      state.tokenize = parser;
      return parser(stream, state);
    }

    // Smarty 3 allows { and } surrounded by whitespace to NOT slip into Smarty mode
    function doesNotCount(stream, pos) {
      if (pos == null) pos = stream.pos;
      return version === 3 && leftDelimiter == "{" &&
        (pos == stream.string.length || /\s/.test(stream.string.charAt(pos)));
    }

    function tokenTop(stream, state) {
      var string = stream.string;
      for (var scan = stream.pos;;) {
        var nextMatch = string.indexOf(leftDelimiter, scan);
        scan = nextMatch + leftDelimiter.length;
        if (nextMatch == -1 || !doesNotCount(stream, nextMatch + leftDelimiter.length)) break;
      }
      if (nextMatch == stream.pos) {
        stream.match(leftDelimiter);
        if (stream.eat("*")) {
          return chain(stream, state, tokenBlock("comment", "*" + rightDelimiter));
        } else {
          state.depth++;
          state.tokenize = tokenSmarty;
          last = "startTag";
          return "tag";
        }
      }

      if (nextMatch > -1) stream.string = string.slice(0, nextMatch);
      var token = baseMode.token(stream, state.base);
      if (nextMatch > -1) stream.string = string;
      return token;
    }

    // parsing Smarty content
    function tokenSmarty(stream, state) {
      if (stream.match(rightDelimiter, true)) {
        if (version === 3) {
          state.depth--;
          if (state.depth <= 0) {
            state.tokenize = tokenTop;
          }
        } else {
          state.tokenize = tokenTop;
        }
        return cont("tag", null);
      }

      if (stream.match(leftDelimiter, true)) {
        state.depth++;
        return cont("tag", "startTag");
      }

      var ch = stream.next();
      if (ch == "$") {
        stream.eatWhile(regs.validIdentifier);
        return cont("variable-2", "variable");
      } else if (ch == "|") {
        return cont("operator", "pipe");
      } else if (ch == ".") {
        return cont("operator", "property");
      } else if (regs.stringChar.test(ch)) {
        state.tokenize = tokenAttribute(ch);
        return cont("string", "string");
      } else if (regs.operatorChars.test(ch)) {
        stream.eatWhile(regs.operatorChars);
        return cont("operator", "operator");
      } else if (ch == "[" || ch == "]") {
        return cont("bracket", "bracket");
      } else if (ch == "(" || ch == ")") {
        return cont("bracket", "operator");
      } else if (/\d/.test(ch)) {
        stream.eatWhile(/\d/);
        return cont("number", "number");
      } else {

        if (state.last == "variable") {
          if (ch == "@") {
            stream.eatWhile(regs.validIdentifier);
            return cont("property", "property");
          } else if (ch == "|") {
            stream.eatWhile(regs.validIdentifier);
            return cont("qualifier", "modifier");
          }
        } else if (state.last == "pipe") {
          stream.eatWhile(regs.validIdentifier);
          return cont("qualifier", "modifier");
        } else if (state.last == "whitespace") {
          stream.eatWhile(regs.validIdentifier);
          return cont("attribute", "modifier");
        } if (state.last == "property") {
          stream.eatWhile(regs.validIdentifier);
          return cont("property", null);
        } else if (/\s/.test(ch)) {
          last = "whitespace";
          return null;
        }

        var str = "";
        if (ch != "/") {
          str += ch;
        }
        var c = null;
        while (c = stream.eat(regs.validIdentifier)) {
          str += c;
        }
        for (var i=0, j=keyFunctions.length; i<j; i++) {
          if (keyFunctions[i] == str) {
            return cont("keyword", "keyword");
          }
        }
        if (/\s/.test(ch)) {
          return null;
        }
        return cont("tag", "tag");
      }
    }

    function tokenAttribute(quote) {
      return function(stream, state) {
        var prevChar = null;
        var currChar = null;
        while (!stream.eol()) {
          currChar = stream.peek();
          if (stream.next() == quote && prevChar !== '\\') {
            state.tokenize = tokenSmarty;
            break;
          }
          prevChar = currChar;
        }
        return "string";
      };
    }

    function tokenBlock(style, terminator) {
      return function(stream, state) {
        while (!stream.eol()) {
          if (stream.match(terminator)) {
            state.tokenize = tokenTop;
            break;
          }
          stream.next();
        }
        return style;
      };
    }

    return {
      startState: function() {
        return {
          base: CodeMirror.startState(baseMode),
          tokenize: tokenTop,
          last: null,
          depth: 0
        };
      },
      copyState: function(state) {
        return {
          base: CodeMirror.copyState(baseMode, state.base),
          tokenize: state.tokenize,
          last: state.last,
          depth: state.depth
        };
      },
      innerMode: function(state) {
        if (state.tokenize == tokenTop)
          return {mode: baseMode, state: state.base};
      },
      token: function(stream, state) {
        var style = state.tokenize(stream, state);
        state.last = last;
        return style;
      },
      indent: function(state, text, line) {
        if (state.tokenize == tokenTop && baseMode.indent)
          return baseMode.indent(state.base, text, line);
        else
          return CodeMirror.Pass;
      },
      blockCommentStart: leftDelimiter + "*",
      blockCommentEnd: "*" + rightDelimiter
    };
  });

  CodeMirror.defineMIME("text/x-smarty", "smarty");
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/solr/solr.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("solr", function() {
  "use strict";

  var isStringChar = /[^\s\|\!\+\-\*\?\~\^\&\:\(\)\[\]\{\}\"\\]/;
  var isOperatorChar = /[\|\!\+\-\*\?\~\^\&]/;
  var isOperatorString = /^(OR|AND|NOT|TO)$/i;

  function isNumber(word) {
    return parseFloat(word).toString() === word;
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, next;
      while ((next = stream.next()) != null) {
        if (next == quote && !escaped) break;
        escaped = !escaped && next == "\\";
      }

      if (!escaped) state.tokenize = tokenBase;
      return "string";
    };
  }

  function tokenOperator(operator) {
    return function(stream, state) {
      var style = "operator";
      if (operator == "+")
        style += " positive";
      else if (operator == "-")
        style += " negative";
      else if (operator == "|")
        stream.eat(/\|/);
      else if (operator == "&")
        stream.eat(/\&/);
      else if (operator == "^")
        style += " boost";

      state.tokenize = tokenBase;
      return style;
    };
  }

  function tokenWord(ch) {
    return function(stream, state) {
      var word = ch;
      while ((ch = stream.peek()) && ch.match(isStringChar) != null) {
        word += stream.next();
      }

      state.tokenize = tokenBase;
      if (isOperatorString.test(word))
        return "operator";
      else if (isNumber(word))
        return "number";
      else if (stream.peek() == ":")
        return "field";
      else
        return "string";
    };
  }

  function tokenBase(stream, state) {
    var ch = stream.next();
    if (ch == '"')
      state.tokenize = tokenString(ch);
    else if (isOperatorChar.test(ch))
      state.tokenize = tokenOperator(ch);
    else if (isStringChar.test(ch))
      state.tokenize = tokenWord(ch);

    return (state.tokenize != tokenBase) ? state.tokenize(stream, state) : null;
  }

  return {
    startState: function() {
      return {
        tokenize: tokenBase
      };
    },

    token: function(stream, state) {
      if (stream.eatSpace()) return null;
      return state.tokenize(stream, state);
    }
  };
});

CodeMirror.defineMIME("text/x-solr", "solr");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/soy/soy.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"), __webpack_require__("./src/ipywidgets/node_modules/codemirror/mode/htmlmixed/htmlmixed.js"));
  else {}
})(function(CodeMirror) {
  "use strict";

  var paramData = { noEndTag: true, soyState: "param-def" };
  var tags = {
    "alias": { noEndTag: true },
    "delpackage": { noEndTag: true },
    "namespace": { noEndTag: true, soyState: "namespace-def" },
    "@attribute": paramData,
    "@attribute?": paramData,
    "@param": paramData,
    "@param?": paramData,
    "@inject": paramData,
    "@inject?": paramData,
    "@state": paramData,
    "template": { soyState: "templ-def", variableScope: true},
    "literal": { },
    "msg": {},
    "fallbackmsg": { noEndTag: true, reduceIndent: true},
    "select": {},
    "plural": {},
    "let": { soyState: "var-def" },
    "if": {},
    "elseif": { noEndTag: true, reduceIndent: true},
    "else": { noEndTag: true, reduceIndent: true},
    "switch": {},
    "case": { noEndTag: true, reduceIndent: true},
    "default": { noEndTag: true, reduceIndent: true},
    "foreach": { variableScope: true, soyState: "for-loop" },
    "ifempty": { noEndTag: true, reduceIndent: true},
    "for": { variableScope: true, soyState: "for-loop" },
    "call": { soyState: "templ-ref" },
    "param": { soyState: "param-ref"},
    "print": { noEndTag: true },
    "deltemplate": { soyState: "templ-def", variableScope: true},
    "delcall": { soyState: "templ-ref" },
    "log": {},
    "element": { variableScope: true },
  };

  var indentingTags = Object.keys(tags).filter(function(tag) {
    return !tags[tag].noEndTag || tags[tag].reduceIndent;
  });

  CodeMirror.defineMode("soy", function(config) {
    var textMode = CodeMirror.getMode(config, "text/plain");
    var modes = {
      html: CodeMirror.getMode(config, {name: "text/html", multilineTagIndentFactor: 2, multilineTagIndentPastTag: false, allowMissingTagName: true}),
      attributes: textMode,
      text: textMode,
      uri: textMode,
      trusted_resource_uri: textMode,
      css: CodeMirror.getMode(config, "text/css"),
      js: CodeMirror.getMode(config, {name: "text/javascript", statementIndent: 2 * config.indentUnit})
    };

    function last(array) {
      return array[array.length - 1];
    }

    function tokenUntil(stream, state, untilRegExp) {
      if (stream.sol()) {
        for (var indent = 0; indent < state.indent; indent++) {
          if (!stream.eat(/\s/)) break;
        }
        if (indent) return null;
      }
      var oldString = stream.string;
      var match = untilRegExp.exec(oldString.substr(stream.pos));
      if (match) {
        // We don't use backUp because it backs up just the position, not the state.
        // This uses an undocumented API.
        stream.string = oldString.substr(0, stream.pos + match.index);
      }
      var result = stream.hideFirstChars(state.indent, function() {
        var localState = last(state.localStates);
        return localState.mode.token(stream, localState.state);
      });
      stream.string = oldString;
      return result;
    }

    function contains(list, element) {
      while (list) {
        if (list.element === element) return true;
        list = list.next;
      }
      return false;
    }

    function prepend(list, element) {
      return {
        element: element,
        next: list
      };
    }

    function popcontext(state) {
      if (!state.context) return;
      if (state.context.scope) {
        state.variables = state.context.scope;
      }
      state.context = state.context.previousContext;
    }

    // Reference a variable `name` in `list`.
    // Let `loose` be truthy to ignore missing identifiers.
    function ref(list, name, loose) {
      return contains(list, name) ? "variable-2" : (loose ? "variable" : "variable-2 error");
    }

    // Data for an open soy tag.
    function Context(previousContext, tag, scope) {
      this.previousContext = previousContext;
      this.tag = tag;
      this.kind = null;
      this.scope = scope;
    }

    function expression(stream, state) {
      var match;
      if (stream.match(/[[]/)) {
        state.soyState.push("list-literal");
        state.context = new Context(state.context, "list-literal", state.variables);
        state.lookupVariables = false;
        return null;
      } else if (stream.match(/map\b/)) {
        state.soyState.push("map-literal");
        return "keyword";
      } else if (stream.match(/record\b/)) {
        state.soyState.push("record-literal");
        return "keyword";
      } else if (stream.match(/([\w]+)(?=\()/)) {
        return "variable callee";
      } else if (match = stream.match(/^["']/)) {
        state.soyState.push("string");
        state.quoteKind = match[0];
        return "string";
      } else if (stream.match(/^[(]/)) {
        state.soyState.push("open-parentheses");
        return null;
      } else if (stream.match(/(null|true|false)(?!\w)/) ||
          stream.match(/0x([0-9a-fA-F]{2,})/) ||
          stream.match(/-?([0-9]*[.])?[0-9]+(e[0-9]*)?/)) {
        return "atom";
      } else if (stream.match(/(\||[+\-*\/%]|[=!]=|\?:|[<>]=?)/)) {
        // Tokenize filter, binary, null propagator, and equality operators.
        return "operator";
      } else if (match = stream.match(/^\$([\w]+)/)) {
        return ref(state.variables, match[1], !state.lookupVariables);
      } else if (match = stream.match(/^\w+/)) {
        return /^(?:as|and|or|not|in|if)$/.test(match[0]) ? "keyword" : null;
      }

      stream.next();
      return null;
    }

    return {
      startState: function() {
        return {
          soyState: [],
          variables: prepend(null, 'ij'),
          scopes: null,
          indent: 0,
          quoteKind: null,
          context: null,
          lookupVariables: true, // Is unknown variables considered an error
          localStates: [{
            mode: modes.html,
            state: CodeMirror.startState(modes.html)
          }]
        };
      },

      copyState: function(state) {
        return {
          tag: state.tag, // Last seen Soy tag.
          soyState: state.soyState.concat([]),
          variables: state.variables,
          context: state.context,
          indent: state.indent, // Indentation of the following line.
          quoteKind: state.quoteKind,
          lookupVariables: state.lookupVariables,
          localStates: state.localStates.map(function(localState) {
            return {
              mode: localState.mode,
              state: CodeMirror.copyState(localState.mode, localState.state)
            };
          })
        };
      },

      token: function(stream, state) {
        var match;

        switch (last(state.soyState)) {
          case "comment":
            if (stream.match(/^.*?\*\//)) {
              state.soyState.pop();
            } else {
              stream.skipToEnd();
            }
            if (!state.context || !state.context.scope) {
              var paramRe = /@param\??\s+(\S+)/g;
              var current = stream.current();
              for (var match; (match = paramRe.exec(current)); ) {
                state.variables = prepend(state.variables, match[1]);
              }
            }
            return "comment";

          case "string":
            var match = stream.match(/^.*?(["']|\\[\s\S])/);
            if (!match) {
              stream.skipToEnd();
            } else if (match[1] == state.quoteKind) {
              state.quoteKind = null;
              state.soyState.pop();
            }
            return "string";
        }

        if (!state.soyState.length || last(state.soyState) != "literal") {
          if (stream.match(/^\/\*/)) {
            state.soyState.push("comment");
            return "comment";
          } else if (stream.match(stream.sol() ? /^\s*\/\/.*/ : /^\s+\/\/.*/)) {
            return "comment";
          }
        }

        switch (last(state.soyState)) {
          case "templ-def":
            if (match = stream.match(/^\.?([\w]+(?!\.[\w]+)*)/)) {
              state.soyState.pop();
              return "def";
            }
            stream.next();
            return null;

          case "templ-ref":
            if (match = stream.match(/(\.?[a-zA-Z_][a-zA-Z_0-9]+)+/)) {
              state.soyState.pop();
              // If the first character is '.', it can only be a local template.
              if (match[0][0] == '.') {
                return "variable-2"
              }
              // Otherwise
              return "variable";
            }
            if (match = stream.match(/^\$([\w]+)/)) {
              state.soyState.pop();
              return ref(state.variables, match[1], !state.lookupVariables);
            }

            stream.next();
            return null;

          case "namespace-def":
            if (match = stream.match(/^\.?([\w\.]+)/)) {
              state.soyState.pop();
              return "variable";
            }
            stream.next();
            return null;

          case "param-def":
            if (match = stream.match(/^\*/)) {
              state.soyState.pop();
              state.soyState.push("param-type");
              return "type";
            }
            if (match = stream.match(/^\w+/)) {
              state.variables = prepend(state.variables, match[0]);
              state.soyState.pop();
              state.soyState.push("param-type");
              return "def";
            }
            stream.next();
            return null;

          case "param-ref":
            if (match = stream.match(/^\w+/)) {
              state.soyState.pop();
              return "property";
            }
            stream.next();
            return null;

          case "open-parentheses":
            if (stream.match(/[)]/)) {
              state.soyState.pop();
              return null;
            }
            return expression(stream, state);

          case "param-type":
            var peekChar = stream.peek();
            if ("}]=>,".indexOf(peekChar) != -1) {
              state.soyState.pop();
              return null;
            } else if (peekChar == "[") {
              state.soyState.push('param-type-record');
              return null;
            } else if (peekChar == "(") {
              state.soyState.push('param-type-template');
              return null;
            } else if (peekChar == "<") {
              state.soyState.push('param-type-parameter');
              return null;
            } else if (match = stream.match(/^([\w]+|[?])/)) {
              return "type";
            }
            stream.next();
            return null;

          case "param-type-record":
            var peekChar = stream.peek();
            if (peekChar == "]") {
              state.soyState.pop();
              return null;
            }
            if (stream.match(/^\w+/)) {
              state.soyState.push('param-type');
              return "property";
            }
            stream.next();
            return null;

          case "param-type-parameter":
            if (stream.match(/^[>]/)) {
              state.soyState.pop();
              return null;
            }
            if (stream.match(/^[<,]/)) {
              state.soyState.push('param-type');
              return null;
            }
            stream.next();
            return null;

          case "param-type-template":
            if (stream.match(/[>]/)) {
              state.soyState.pop();
              state.soyState.push('param-type');
              return null;
            }
            if (stream.match(/^\w+/)) {
              state.soyState.push('param-type');
              return "def";
            }
            stream.next();
            return null;

          case "var-def":
            if (match = stream.match(/^\$([\w]+)/)) {
              state.variables = prepend(state.variables, match[1]);
              state.soyState.pop();
              return "def";
            }
            stream.next();
            return null;

          case "for-loop":
            if (stream.match(/\bin\b/)) {
              state.soyState.pop();
              return "keyword";
            }
            if (stream.peek() == "$") {
              state.soyState.push('var-def');
              return null;
            }
            stream.next();
            return null;

          case "record-literal":
            if (stream.match(/^[)]/)) {
              state.soyState.pop();
              return null;
            }
            if (stream.match(/[(,]/)) {
              state.soyState.push("map-value")
              state.soyState.push("record-key")
              return null;
            }
            stream.next()
            return null;

          case "map-literal":
            if (stream.match(/^[)]/)) {
              state.soyState.pop();
              return null;
            }
            if (stream.match(/[(,]/)) {
              state.soyState.push("map-value")
              state.soyState.push("map-value")
              return null;
            }
            stream.next()
            return null;

          case "list-literal":
            if (stream.match(']')) {
              state.soyState.pop();
              state.lookupVariables = true;
              popcontext(state);
              return null;
            }
            if (stream.match(/\bfor\b/)) {
              state.lookupVariables = true;
              state.soyState.push('for-loop');
              return "keyword";
            }
            return expression(stream, state);

          case "record-key":
            if (stream.match(/[\w]+/)) {
              return "property";
            }
            if (stream.match(/^[:]/)) {
              state.soyState.pop();
              return null;
            }
            stream.next();
            return null;

          case "map-value":
            if (stream.peek() == ")" || stream.peek() == "," || stream.match(/^[:)]/)) {
              state.soyState.pop();
              return null;
            }
            return expression(stream, state);

          case "import":
            if (stream.eat(";")) {
              state.soyState.pop();
              state.indent -= 2 * config.indentUnit;
              return null;
            }
            if (stream.match(/\w+(?=\s+as)/)) {
              return "variable";
            }
            if (match = stream.match(/\w+/)) {
              return /(from|as)/.test(match[0]) ? "keyword" : "def";
            }
            if (match = stream.match(/^["']/)) {
              state.soyState.push("string");
              state.quoteKind = match[0];
              return "string";
            }
            stream.next();
            return null;

          case "tag":
            var endTag;
            var tagName;
            if (state.tag === undefined) {
              endTag = true;
              tagName = '';
            } else {
              endTag = state.tag[0] == "/";
              tagName = endTag ? state.tag.substring(1) : state.tag;
            }
            var tag = tags[tagName];
            if (stream.match(/^\/?}/)) {
              var selfClosed = stream.current() == "/}";
              if (selfClosed && !endTag) {
                popcontext(state);
              }
              if (state.tag == "/template" || state.tag == "/deltemplate") {
                state.variables = prepend(null, 'ij');
                state.indent = 0;
              } else {
                state.indent -= config.indentUnit *
                    (selfClosed || indentingTags.indexOf(state.tag) == -1 ? 2 : 1);
              }
              state.soyState.pop();
              return "keyword";
            } else if (stream.match(/^([\w?]+)(?==)/)) {
              if (state.context && state.context.tag == tagName && stream.current() == "kind" && (match = stream.match(/^="([^"]+)/, false))) {
                var kind = match[1];
                state.context.kind = kind;
                var mode = modes[kind] || modes.html;
                var localState = last(state.localStates);
                if (localState.mode.indent) {
                  state.indent += localState.mode.indent(localState.state, "", "");
                }
                state.localStates.push({
                  mode: mode,
                  state: CodeMirror.startState(mode)
                });
              }
              return "attribute";
            }
            return expression(stream, state);

          case "template-call-expression":
            if (stream.match(/^([\w-?]+)(?==)/)) {
              return "attribute";
            } else if (stream.eat('>')) {
              state.soyState.pop();
              return "keyword";
            } else if (stream.eat('/>')) {
              state.soyState.pop();
              return "keyword";
            }
            return expression(stream, state);
          case "literal":
            if (stream.match('{/literal}', false)) {
              state.soyState.pop();
              return this.token(stream, state);
            }
            return tokenUntil(stream, state, /\{\/literal}/);
        }

        if (stream.match('{literal}')) {
          state.indent += config.indentUnit;
          state.soyState.push("literal");
          state.context = new Context(state.context, "literal", state.variables);
          return "keyword";

        // A tag-keyword must be followed by whitespace, comment or a closing tag.
        } else if (match = stream.match(/^\{([/@\\]?\w+\??)(?=$|[\s}]|\/[/*])/)) {
          var prevTag = state.tag;
          state.tag = match[1];
          var endTag = state.tag[0] == "/";
          var indentingTag = !!tags[state.tag];
          var tagName = endTag ? state.tag.substring(1) : state.tag;
          var tag = tags[tagName];
          if (state.tag != "/switch")
            state.indent += ((endTag || tag && tag.reduceIndent) && prevTag != "switch" ? 1 : 2) * config.indentUnit;

          state.soyState.push("tag");
          var tagError = false;
          if (tag) {
            if (!endTag) {
              if (tag.soyState) state.soyState.push(tag.soyState);
            }
            // If a new tag, open a new context.
            if (!tag.noEndTag && (indentingTag || !endTag)) {
              state.context = new Context(state.context, state.tag, tag.variableScope ? state.variables : null);
            // Otherwise close the current context.
            } else if (endTag) {
              if (!state.context || state.context.tag != tagName) {
                tagError = true;
              } else if (state.context) {
                if (state.context.kind) {
                  state.localStates.pop();
                  var localState = last(state.localStates);
                  if (localState.mode.indent) {
                    state.indent -= localState.mode.indent(localState.state, "", "");
                  }
                }
                popcontext(state);
              }
            }
          } else if (endTag) {
            // Assume all tags with a closing tag are defined in the config.
            tagError = true;
          }
          return (tagError ? "error " : "") + "keyword";

        // Not a tag-keyword; it's an implicit print tag.
        } else if (stream.eat('{')) {
          state.tag = "print";
          state.indent += 2 * config.indentUnit;
          state.soyState.push("tag");
          return "keyword";
        } else if (!state.context && stream.match(/\bimport\b/)) {
          state.soyState.push("import");
          state.indent += 2 * config.indentUnit;
          return "keyword";
        } else if (match = stream.match('<{')) {
          state.soyState.push("template-call-expression");
          state.indent += 2 * config.indentUnit;
          state.soyState.push("tag");
          return "keyword";
        } else if (match = stream.match('</>')) {
          state.indent -= 1 * config.indentUnit;
          return "keyword";
        }

        return tokenUntil(stream, state, /\{|\s+\/\/|\/\*/);
      },

      indent: function(state, textAfter, line) {
        var indent = state.indent, top = last(state.soyState);
        if (top == "comment") return CodeMirror.Pass;

        if (top == "literal") {
          if (/^\{\/literal}/.test(textAfter)) indent -= config.indentUnit;
        } else {
          if (/^\s*\{\/(template|deltemplate)\b/.test(textAfter)) return 0;
          if (/^\{(\/|(fallbackmsg|elseif|else|ifempty)\b)/.test(textAfter)) indent -= config.indentUnit;
          if (state.tag != "switch" && /^\{(case|default)\b/.test(textAfter)) indent -= config.indentUnit;
          if (/^\{\/switch\b/.test(textAfter)) indent -= config.indentUnit;
        }
        var localState = last(state.localStates);
        if (indent && localState.mode.indent) {
          indent += localState.mode.indent(localState.state, textAfter, line);
        }
        return indent;
      },

      innerMode: function(state) {
        if (state.soyState.length && last(state.soyState) != "literal") return null;
        else return last(state.localStates);
      },

      electricInput: /^\s*\{(\/|\/template|\/deltemplate|\/switch|fallbackmsg|elseif|else|case|default|ifempty|\/literal\})$/,
      lineComment: "//",
      blockCommentStart: "/*",
      blockCommentEnd: "*/",
      blockCommentContinue: " * ",
      useInnerComments: false,
      fold: "indent"
    };
  }, "htmlmixed");

  CodeMirror.registerHelper("wordChars", "soy", /[\w$]/);

  CodeMirror.registerHelper("hintWords", "soy", Object.keys(tags).concat(
      ["css", "debugger"]));

  CodeMirror.defineMIME("text/x-soy", "soy");
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/sparql/sparql.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("sparql", function(config) {
  var indentUnit = config.indentUnit;
  var curPunc;

  function wordRegexp(words) {
    return new RegExp("^(?:" + words.join("|") + ")$", "i");
  }
  var ops = wordRegexp(["str", "lang", "langmatches", "datatype", "bound", "sameterm", "isiri", "isuri",
                        "iri", "uri", "bnode", "count", "sum", "min", "max", "avg", "sample",
                        "group_concat", "rand", "abs", "ceil", "floor", "round", "concat", "substr", "strlen",
                        "replace", "ucase", "lcase", "encode_for_uri", "contains", "strstarts", "strends",
                        "strbefore", "strafter", "year", "month", "day", "hours", "minutes", "seconds",
                        "timezone", "tz", "now", "uuid", "struuid", "md5", "sha1", "sha256", "sha384",
                        "sha512", "coalesce", "if", "strlang", "strdt", "isnumeric", "regex", "exists",
                        "isblank", "isliteral", "a", "bind"]);
  var keywords = wordRegexp(["base", "prefix", "select", "distinct", "reduced", "construct", "describe",
                             "ask", "from", "named", "where", "order", "limit", "offset", "filter", "optional",
                             "graph", "by", "asc", "desc", "as", "having", "undef", "values", "group",
                             "minus", "in", "not", "service", "silent", "using", "insert", "delete", "union",
                             "true", "false", "with",
                             "data", "copy", "to", "move", "add", "create", "drop", "clear", "load"]);
  var operatorChars = /[*+\-<>=&|\^\/!\?]/;

  function tokenBase(stream, state) {
    var ch = stream.next();
    curPunc = null;
    if (ch == "$" || ch == "?") {
      if(ch == "?" && stream.match(/\s/, false)){
        return "operator";
      }
      stream.match(/^[A-Za-z0-9_\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][A-Za-z0-9_\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]*/);
      return "variable-2";
    }
    else if (ch == "<" && !stream.match(/^[\s\u00a0=]/, false)) {
      stream.match(/^[^\s\u00a0>]*>?/);
      return "atom";
    }
    else if (ch == "\"" || ch == "'") {
      state.tokenize = tokenLiteral(ch);
      return state.tokenize(stream, state);
    }
    else if (/[{}\(\),\.;\[\]]/.test(ch)) {
      curPunc = ch;
      return "bracket";
    }
    else if (ch == "#") {
      stream.skipToEnd();
      return "comment";
    }
    else if (ch === "^") {
      ch = stream.peek();
      if (ch === "^") stream.eat("^");
      else stream.eatWhile(operatorChars);
      return "operator";
    }
    else if (operatorChars.test(ch)) {
      stream.eatWhile(operatorChars);
      return "operator";
    }
    else if (ch == ":") {
      eatPnLocal(stream);
      return "atom";
    }
    else if (ch == "@") {
      stream.eatWhile(/[a-z\d\-]/i);
      return "meta";
    }
    else {
      stream.eatWhile(/[_\w\d]/);
      if (stream.eat(":")) {
        eatPnLocal(stream);
        return "atom";
      }
      var word = stream.current();
      if (ops.test(word))
        return "builtin";
      else if (keywords.test(word))
        return "keyword";
      else
        return "variable";
    }
  }

  function eatPnLocal(stream) {
    stream.match(/(\.(?=[\w_\-\\%])|[:\w_-]|\\[-\\_~.!$&'()*+,;=/?#@%]|%[a-f\d][a-f\d])+/i);
  }

  function tokenLiteral(quote) {
    return function(stream, state) {
      var escaped = false, ch;
      while ((ch = stream.next()) != null) {
        if (ch == quote && !escaped) {
          state.tokenize = tokenBase;
          break;
        }
        escaped = !escaped && ch == "\\";
      }
      return "string";
    };
  }

  function pushContext(state, type, col) {
    state.context = {prev: state.context, indent: state.indent, col: col, type: type};
  }
  function popContext(state) {
    state.indent = state.context.indent;
    state.context = state.context.prev;
  }

  return {
    startState: function() {
      return {tokenize: tokenBase,
              context: null,
              indent: 0,
              col: 0};
    },

    token: function(stream, state) {
      if (stream.sol()) {
        if (state.context && state.context.align == null) state.context.align = false;
        state.indent = stream.indentation();
      }
      if (stream.eatSpace()) return null;
      var style = state.tokenize(stream, state);

      if (style != "comment" && state.context && state.context.align == null && state.context.type != "pattern") {
        state.context.align = true;
      }

      if (curPunc == "(") pushContext(state, ")", stream.column());
      else if (curPunc == "[") pushContext(state, "]", stream.column());
      else if (curPunc == "{") pushContext(state, "}", stream.column());
      else if (/[\]\}\)]/.test(curPunc)) {
        while (state.context && state.context.type == "pattern") popContext(state);
        if (state.context && curPunc == state.context.type) {
          popContext(state);
          if (curPunc == "}" && state.context && state.context.type == "pattern")
            popContext(state);
        }
      }
      else if (curPunc == "." && state.context && state.context.type == "pattern") popContext(state);
      else if (/atom|string|variable/.test(style) && state.context) {
        if (/[\}\]]/.test(state.context.type))
          pushContext(state, "pattern", stream.column());
        else if (state.context.type == "pattern" && !state.context.align) {
          state.context.align = true;
          state.context.col = stream.column();
        }
      }

      return style;
    },

    indent: function(state, textAfter) {
      var firstChar = textAfter && textAfter.charAt(0);
      var context = state.context;
      if (/[\]\}]/.test(firstChar))
        while (context && context.type == "pattern") context = context.prev;

      var closing = context && firstChar == context.type;
      if (!context)
        return 0;
      else if (context.type == "pattern")
        return context.col;
      else if (context.align)
        return context.col + (closing ? 0 : 1);
      else
        return context.indent + (closing ? 0 : indentUnit);
    },

    lineComment: "#"
  };
});

CodeMirror.defineMIME("application/sparql-query", "sparql");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/spreadsheet/spreadsheet.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
  "use strict";

  CodeMirror.defineMode("spreadsheet", function () {
    return {
      startState: function () {
        return {
          stringType: null,
          stack: []
        };
      },
      token: function (stream, state) {
        if (!stream) return;

        //check for state changes
        if (state.stack.length === 0) {
          //strings
          if ((stream.peek() == '"') || (stream.peek() == "'")) {
            state.stringType = stream.peek();
            stream.next(); // Skip quote
            state.stack.unshift("string");
          }
        }

        //return state
        //stack has
        switch (state.stack[0]) {
        case "string":
          while (state.stack[0] === "string" && !stream.eol()) {
            if (stream.peek() === state.stringType) {
              stream.next(); // Skip quote
              state.stack.shift(); // Clear flag
            } else if (stream.peek() === "\\") {
              stream.next();
              stream.next();
            } else {
              stream.match(/^.[^\\\"\']*/);
            }
          }
          return "string";

        case "characterClass":
          while (state.stack[0] === "characterClass" && !stream.eol()) {
            if (!(stream.match(/^[^\]\\]+/) || stream.match(/^\\./)))
              state.stack.shift();
          }
          return "operator";
        }

        var peek = stream.peek();

        //no stack
        switch (peek) {
        case "[":
          stream.next();
          state.stack.unshift("characterClass");
          return "bracket";
        case ":":
          stream.next();
          return "operator";
        case "\\":
          if (stream.match(/\\[a-z]+/)) return "string-2";
          else {
            stream.next();
            return "atom";
          }
        case ".":
        case ",":
        case ";":
        case "*":
        case "-":
        case "+":
        case "^":
        case "<":
        case "/":
        case "=":
          stream.next();
          return "atom";
        case "$":
          stream.next();
          return "builtin";
        }

        if (stream.match(/\d+/)) {
          if (stream.match(/^\w+/)) return "error";
          return "number";
        } else if (stream.match(/^[a-zA-Z_]\w*/)) {
          if (stream.match(/(?=[\(.])/, false)) return "keyword";
          return "variable-2";
        } else if (["[", "]", "(", ")", "{", "}"].indexOf(peek) != -1) {
          stream.next();
          return "bracket";
        } else if (!stream.eatSpace()) {
          stream.next();
        }
        return null;
      }
    };
  });

  CodeMirror.defineMIME("text/x-spreadsheet", "spreadsheet");
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/stylus/stylus.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// Stylus mode created by Dmitry Kiselyov http://git.io/AaRB

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
  "use strict";

  CodeMirror.defineMode("stylus", function(config) {
    var indentUnit = config.indentUnit,
        indentUnitString = '',
        tagKeywords = keySet(tagKeywords_),
        tagVariablesRegexp = /^(a|b|i|s|col|em)$/i,
        propertyKeywords = keySet(propertyKeywords_),
        nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_),
        valueKeywords = keySet(valueKeywords_),
        colorKeywords = keySet(colorKeywords_),
        documentTypes = keySet(documentTypes_),
        documentTypesRegexp = wordRegexp(documentTypes_),
        mediaFeatures = keySet(mediaFeatures_),
        mediaTypes = keySet(mediaTypes_),
        fontProperties = keySet(fontProperties_),
        operatorsRegexp = /^\s*([.]{2,3}|&&|\|\||\*\*|[?!=:]?=|[-+*\/%<>]=?|\?:|\~)/,
        wordOperatorKeywordsRegexp = wordRegexp(wordOperatorKeywords_),
        blockKeywords = keySet(blockKeywords_),
        vendorPrefixesRegexp = new RegExp(/^\-(moz|ms|o|webkit)-/i),
        commonAtoms = keySet(commonAtoms_),
        firstWordMatch = "",
        states = {},
        ch,
        style,
        type,
        override;

    while (indentUnitString.length < indentUnit) indentUnitString += ' ';

    /**
     * Tokenizers
     */
    function tokenBase(stream, state) {
      firstWordMatch = stream.string.match(/(^[\w-]+\s*=\s*$)|(^\s*[\w-]+\s*=\s*[\w-])|(^\s*(\.|#|@|\$|\&|\[|\d|\+|::?|\{|\>|~|\/)?\s*[\w-]*([a-z0-9-]|\*|\/\*)(\(|,)?)/);
      state.context.line.firstWord = firstWordMatch ? firstWordMatch[0].replace(/^\s*/, "") : "";
      state.context.line.indent = stream.indentation();
      ch = stream.peek();

      // Line comment
      if (stream.match("//")) {
        stream.skipToEnd();
        return ["comment", "comment"];
      }
      // Block comment
      if (stream.match("/*")) {
        state.tokenize = tokenCComment;
        return tokenCComment(stream, state);
      }
      // String
      if (ch == "\"" || ch == "'") {
        stream.next();
        state.tokenize = tokenString(ch);
        return state.tokenize(stream, state);
      }
      // Def
      if (ch == "@") {
        stream.next();
        stream.eatWhile(/[\w\\-]/);
        return ["def", stream.current()];
      }
      // ID selector or Hex color
      if (ch == "#") {
        stream.next();
        // Hex color
        if (stream.match(/^[0-9a-f]{3}([0-9a-f]([0-9a-f]{2}){0,2})?\b(?!-)/i)) {
          return ["atom", "atom"];
        }
        // ID selector
        if (stream.match(/^[a-z][\w-]*/i)) {
          return ["builtin", "hash"];
        }
      }
      // Vendor prefixes
      if (stream.match(vendorPrefixesRegexp)) {
        return ["meta", "vendor-prefixes"];
      }
      // Numbers
      if (stream.match(/^-?[0-9]?\.?[0-9]/)) {
        stream.eatWhile(/[a-z%]/i);
        return ["number", "unit"];
      }
      // !important|optional
      if (ch == "!") {
        stream.next();
        return [stream.match(/^(important|optional)/i) ? "keyword": "operator", "important"];
      }
      // Class
      if (ch == "." && stream.match(/^\.[a-z][\w-]*/i)) {
        return ["qualifier", "qualifier"];
      }
      // url url-prefix domain regexp
      if (stream.match(documentTypesRegexp)) {
        if (stream.peek() == "(") state.tokenize = tokenParenthesized;
        return ["property", "word"];
      }
      // Mixins / Functions
      if (stream.match(/^[a-z][\w-]*\(/i)) {
        stream.backUp(1);
        return ["keyword", "mixin"];
      }
      // Block mixins
      if (stream.match(/^(\+|-)[a-z][\w-]*\(/i)) {
        stream.backUp(1);
        return ["keyword", "block-mixin"];
      }
      // Parent Reference BEM naming
      if (stream.string.match(/^\s*&/) && stream.match(/^[-_]+[a-z][\w-]*/)) {
        return ["qualifier", "qualifier"];
      }
      // / Root Reference & Parent Reference
      if (stream.match(/^(\/|&)(-|_|:|\.|#|[a-z])/)) {
        stream.backUp(1);
        return ["variable-3", "reference"];
      }
      if (stream.match(/^&{1}\s*$/)) {
        return ["variable-3", "reference"];
      }
      // Word operator
      if (stream.match(wordOperatorKeywordsRegexp)) {
        return ["operator", "operator"];
      }
      // Word
      if (stream.match(/^\$?[-_]*[a-z0-9]+[\w-]*/i)) {
        // Variable
        if (stream.match(/^(\.|\[)[\w-\'\"\]]+/i, false)) {
          if (!wordIsTag(stream.current())) {
            stream.match('.');
            return ["variable-2", "variable-name"];
          }
        }
        return ["variable-2", "word"];
      }
      // Operators
      if (stream.match(operatorsRegexp)) {
        return ["operator", stream.current()];
      }
      // Delimiters
      if (/[:;,{}\[\]\(\)]/.test(ch)) {
        stream.next();
        return [null, ch];
      }
      // Non-detected items
      stream.next();
      return [null, null];
    }

    /**
     * Token comment
     */
    function tokenCComment(stream, state) {
      var maybeEnd = false, ch;
      while ((ch = stream.next()) != null) {
        if (maybeEnd && ch == "/") {
          state.tokenize = null;
          break;
        }
        maybeEnd = (ch == "*");
      }
      return ["comment", "comment"];
    }

    /**
     * Token string
     */
    function tokenString(quote) {
      return function(stream, state) {
        var escaped = false, ch;
        while ((ch = stream.next()) != null) {
          if (ch == quote && !escaped) {
            if (quote == ")") stream.backUp(1);
            break;
          }
          escaped = !escaped && ch == "\\";
        }
        if (ch == quote || !escaped && quote != ")") state.tokenize = null;
        return ["string", "string"];
      };
    }

    /**
     * Token parenthesized
     */
    function tokenParenthesized(stream, state) {
      stream.next(); // Must be "("
      if (!stream.match(/\s*[\"\')]/, false))
        state.tokenize = tokenString(")");
      else
        state.tokenize = null;
      return [null, "("];
    }

    /**
     * Context management
     */
    function Context(type, indent, prev, line) {
      this.type = type;
      this.indent = indent;
      this.prev = prev;
      this.line = line || {firstWord: "", indent: 0};
    }

    function pushContext(state, stream, type, indent) {
      indent = indent >= 0 ? indent : indentUnit;
      state.context = new Context(type, stream.indentation() + indent, state.context);
      return type;
    }

    function popContext(state, currentIndent) {
      var contextIndent = state.context.indent - indentUnit;
      currentIndent = currentIndent || false;
      state.context = state.context.prev;
      if (currentIndent) state.context.indent = contextIndent;
      return state.context.type;
    }

    function pass(type, stream, state) {
      return states[state.context.type](type, stream, state);
    }

    function popAndPass(type, stream, state, n) {
      for (var i = n || 1; i > 0; i--)
        state.context = state.context.prev;
      return pass(type, stream, state);
    }


    /**
     * Parser
     */
    function wordIsTag(word) {
      return word.toLowerCase() in tagKeywords;
    }

    function wordIsProperty(word) {
      word = word.toLowerCase();
      return word in propertyKeywords || word in fontProperties;
    }

    function wordIsBlock(word) {
      return word.toLowerCase() in blockKeywords;
    }

    function wordIsVendorPrefix(word) {
      return word.toLowerCase().match(vendorPrefixesRegexp);
    }

    function wordAsValue(word) {
      var wordLC = word.toLowerCase();
      var override = "variable-2";
      if (wordIsTag(word)) override = "tag";
      else if (wordIsBlock(word)) override = "block-keyword";
      else if (wordIsProperty(word)) override = "property";
      else if (wordLC in valueKeywords || wordLC in commonAtoms) override = "atom";
      else if (wordLC == "return" || wordLC in colorKeywords) override = "keyword";

      // Font family
      else if (word.match(/^[A-Z]/)) override = "string";
      return override;
    }

    function typeIsBlock(type, stream) {
      return ((endOfLine(stream) && (type == "{" || type == "]" || type == "hash" || type == "qualifier")) || type == "block-mixin");
    }

    function typeIsInterpolation(type, stream) {
      return type == "{" && stream.match(/^\s*\$?[\w-]+/i, false);
    }

    function typeIsPseudo(type, stream) {
      return type == ":" && stream.match(/^[a-z-]+/, false);
    }

    function startOfLine(stream) {
      return stream.sol() || stream.string.match(new RegExp("^\\s*" + escapeRegExp(stream.current())));
    }

    function endOfLine(stream) {
      return stream.eol() || stream.match(/^\s*$/, false);
    }

    function firstWordOfLine(line) {
      var re = /^\s*[-_]*[a-z0-9]+[\w-]*/i;
      var result = typeof line == "string" ? line.match(re) : line.string.match(re);
      return result ? result[0].replace(/^\s*/, "") : "";
    }


    /**
     * Block
     */
    states.block = function(type, stream, state) {
      if ((type == "comment" && startOfLine(stream)) ||
          (type == "," && endOfLine(stream)) ||
          type == "mixin") {
        return pushContext(state, stream, "block", 0);
      }
      if (typeIsInterpolation(type, stream)) {
        return pushContext(state, stream, "interpolation");
      }
      if (endOfLine(stream) && type == "]") {
        if (!/^\s*(\.|#|:|\[|\*|&)/.test(stream.string) && !wordIsTag(firstWordOfLine(stream))) {
          return pushContext(state, stream, "block", 0);
        }
      }
      if (typeIsBlock(type, stream)) {
        return pushContext(state, stream, "block");
      }
      if (type == "}" && endOfLine(stream)) {
        return pushContext(state, stream, "block", 0);
      }
      if (type == "variable-name") {
        if (stream.string.match(/^\s?\$[\w-\.\[\]\'\"]+$/) || wordIsBlock(firstWordOfLine(stream))) {
          return pushContext(state, stream, "variableName");
        }
        else {
          return pushContext(state, stream, "variableName", 0);
        }
      }
      if (type == "=") {
        if (!endOfLine(stream) && !wordIsBlock(firstWordOfLine(stream))) {
          return pushContext(state, stream, "block", 0);
        }
        return pushContext(state, stream, "block");
      }
      if (type == "*") {
        if (endOfLine(stream) || stream.match(/\s*(,|\.|#|\[|:|{)/,false)) {
          override = "tag";
          return pushContext(state, stream, "block");
        }
      }
      if (typeIsPseudo(type, stream)) {
        return pushContext(state, stream, "pseudo");
      }
      if (/@(font-face|media|supports|(-moz-)?document)/.test(type)) {
        return pushContext(state, stream, endOfLine(stream) ? "block" : "atBlock");
      }
      if (/@(-(moz|ms|o|webkit)-)?keyframes$/.test(type)) {
        return pushContext(state, stream, "keyframes");
      }
      if (/@extends?/.test(type)) {
        return pushContext(state, stream, "extend", 0);
      }
      if (type && type.charAt(0) == "@") {

        // Property Lookup
        if (stream.indentation() > 0 && wordIsProperty(stream.current().slice(1))) {
          override = "variable-2";
          return "block";
        }
        if (/(@import|@require|@charset)/.test(type)) {
          return pushContext(state, stream, "block", 0);
        }
        return pushContext(state, stream, "block");
      }
      if (type == "reference" && endOfLine(stream)) {
        return pushContext(state, stream, "block");
      }
      if (type == "(") {
        return pushContext(state, stream, "parens");
      }

      if (type == "vendor-prefixes") {
        return pushContext(state, stream, "vendorPrefixes");
      }
      if (type == "word") {
        var word = stream.current();
        override = wordAsValue(word);

        if (override == "property") {
          if (startOfLine(stream)) {
            return pushContext(state, stream, "block", 0);
          } else {
            override = "atom";
            return "block";
          }
        }

        if (override == "tag") {

          // tag is a css value
          if (/embed|menu|pre|progress|sub|table/.test(word)) {
            if (wordIsProperty(firstWordOfLine(stream))) {
              override = "atom";
              return "block";
            }
          }

          // tag is an attribute
          if (stream.string.match(new RegExp("\\[\\s*" + word + "|" + word +"\\s*\\]"))) {
            override = "atom";
            return "block";
          }

          // tag is a variable
          if (tagVariablesRegexp.test(word)) {
            if ((startOfLine(stream) && stream.string.match(/=/)) ||
                (!startOfLine(stream) &&
                 !stream.string.match(/^(\s*\.|#|\&|\[|\/|>|\*)/) &&
                 !wordIsTag(firstWordOfLine(stream)))) {
              override = "variable-2";
              if (wordIsBlock(firstWordOfLine(stream)))  return "block";
              return pushContext(state, stream, "block", 0);
            }
          }

          if (endOfLine(stream)) return pushContext(state, stream, "block");
        }
        if (override == "block-keyword") {
          override = "keyword";

          // Postfix conditionals
          if (stream.current(/(if|unless)/) && !startOfLine(stream)) {
            return "block";
          }
          return pushContext(state, stream, "block");
        }
        if (word == "return") return pushContext(state, stream, "block", 0);

        // Placeholder selector
        if (override == "variable-2" && stream.string.match(/^\s?\$[\w-\.\[\]\'\"]+$/)) {
          return pushContext(state, stream, "block");
        }
      }
      return state.context.type;
    };


    /**
     * Parens
     */
    states.parens = function(type, stream, state) {
      if (type == "(") return pushContext(state, stream, "parens");
      if (type == ")") {
        if (state.context.prev.type == "parens") {
          return popContext(state);
        }
        if ((stream.string.match(/^[a-z][\w-]*\(/i) && endOfLine(stream)) ||
            wordIsBlock(firstWordOfLine(stream)) ||
            /(\.|#|:|\[|\*|&|>|~|\+|\/)/.test(firstWordOfLine(stream)) ||
            (!stream.string.match(/^-?[a-z][\w-\.\[\]\'\"]*\s*=/) &&
             wordIsTag(firstWordOfLine(stream)))) {
          return pushContext(state, stream, "block");
        }
        if (stream.string.match(/^[\$-]?[a-z][\w-\.\[\]\'\"]*\s*=/) ||
            stream.string.match(/^\s*(\(|\)|[0-9])/) ||
            stream.string.match(/^\s+[a-z][\w-]*\(/i) ||
            stream.string.match(/^\s+[\$-]?[a-z]/i)) {
          return pushContext(state, stream, "block", 0);
        }
        if (endOfLine(stream)) return pushContext(state, stream, "block");
        else return pushContext(state, stream, "block", 0);
      }
      if (type && type.charAt(0) == "@" && wordIsProperty(stream.current().slice(1))) {
        override = "variable-2";
      }
      if (type == "word") {
        var word = stream.current();
        override = wordAsValue(word);
        if (override == "tag" && tagVariablesRegexp.test(word)) {
          override = "variable-2";
        }
        if (override == "property" || word == "to") override = "atom";
      }
      if (type == "variable-name") {
        return pushContext(state, stream, "variableName");
      }
      if (typeIsPseudo(type, stream)) {
        return pushContext(state, stream, "pseudo");
      }
      return state.context.type;
    };


    /**
     * Vendor prefixes
     */
    states.vendorPrefixes = function(type, stream, state) {
      if (type == "word") {
        override = "property";
        return pushContext(state, stream, "block", 0);
      }
      return popContext(state);
    };


    /**
     * Pseudo
     */
    states.pseudo = function(type, stream, state) {
      if (!wordIsProperty(firstWordOfLine(stream.string))) {
        stream.match(/^[a-z-]+/);
        override = "variable-3";
        if (endOfLine(stream)) return pushContext(state, stream, "block");
        return popContext(state);
      }
      return popAndPass(type, stream, state);
    };


    /**
     * atBlock
     */
    states.atBlock = function(type, stream, state) {
      if (type == "(") return pushContext(state, stream, "atBlock_parens");
      if (typeIsBlock(type, stream)) {
        return pushContext(state, stream, "block");
      }
      if (typeIsInterpolation(type, stream)) {
        return pushContext(state, stream, "interpolation");
      }
      if (type == "word") {
        var word = stream.current().toLowerCase();
        if (/^(only|not|and|or)$/.test(word))
          override = "keyword";
        else if (documentTypes.hasOwnProperty(word))
          override = "tag";
        else if (mediaTypes.hasOwnProperty(word))
          override = "attribute";
        else if (mediaFeatures.hasOwnProperty(word))
          override = "property";
        else if (nonStandardPropertyKeywords.hasOwnProperty(word))
          override = "string-2";
        else override = wordAsValue(stream.current());
        if (override == "tag" && endOfLine(stream)) {
          return pushContext(state, stream, "block");
        }
      }
      if (type == "operator" && /^(not|and|or)$/.test(stream.current())) {
        override = "keyword";
      }
      return state.context.type;
    };

    states.atBlock_parens = function(type, stream, state) {
      if (type == "{" || type == "}") return state.context.type;
      if (type == ")") {
        if (endOfLine(stream)) return pushContext(state, stream, "block");
        else return pushContext(state, stream, "atBlock");
      }
      if (type == "word") {
        var word = stream.current().toLowerCase();
        override = wordAsValue(word);
        if (/^(max|min)/.test(word)) override = "property";
        if (override == "tag") {
          tagVariablesRegexp.test(word) ? override = "variable-2" : override = "atom";
        }
        return state.context.type;
      }
      return states.atBlock(type, stream, state);
    };


    /**
     * Keyframes
     */
    states.keyframes = function(type, stream, state) {
      if (stream.indentation() == "0" && ((type == "}" && startOfLine(stream)) || type == "]" || type == "hash"
                                          || type == "qualifier" || wordIsTag(stream.current()))) {
        return popAndPass(type, stream, state);
      }
      if (type == "{") return pushContext(state, stream, "keyframes");
      if (type == "}") {
        if (startOfLine(stream)) return popContext(state, true);
        else return pushContext(state, stream, "keyframes");
      }
      if (type == "unit" && /^[0-9]+\%$/.test(stream.current())) {
        return pushContext(state, stream, "keyframes");
      }
      if (type == "word") {
        override = wordAsValue(stream.current());
        if (override == "block-keyword") {
          override = "keyword";
          return pushContext(state, stream, "keyframes");
        }
      }
      if (/@(font-face|media|supports|(-moz-)?document)/.test(type)) {
        return pushContext(state, stream, endOfLine(stream) ? "block" : "atBlock");
      }
      if (type == "mixin") {
        return pushContext(state, stream, "block", 0);
      }
      return state.context.type;
    };


    /**
     * Interpolation
     */
    states.interpolation = function(type, stream, state) {
      if (type == "{") popContext(state) && pushContext(state, stream, "block");
      if (type == "}") {
        if (stream.string.match(/^\s*(\.|#|:|\[|\*|&|>|~|\+|\/)/i) ||
            (stream.string.match(/^\s*[a-z]/i) && wordIsTag(firstWordOfLine(stream)))) {
          return pushContext(state, stream, "block");
        }
        if (!stream.string.match(/^(\{|\s*\&)/) ||
            stream.match(/\s*[\w-]/,false)) {
          return pushContext(state, stream, "block", 0);
        }
        return pushContext(state, stream, "block");
      }
      if (type == "variable-name") {
        return pushContext(state, stream, "variableName", 0);
      }
      if (type == "word") {
        override = wordAsValue(stream.current());
        if (override == "tag") override = "atom";
      }
      return state.context.type;
    };


    /**
     * Extend/s
     */
    states.extend = function(type, stream, state) {
      if (type == "[" || type == "=") return "extend";
      if (type == "]") return popContext(state);
      if (type == "word") {
        override = wordAsValue(stream.current());
        return "extend";
      }
      return popContext(state);
    };


    /**
     * Variable name
     */
    states.variableName = function(type, stream, state) {
      if (type == "string" || type == "[" || type == "]" || stream.current().match(/^(\.|\$)/)) {
        if (stream.current().match(/^\.[\w-]+/i)) override = "variable-2";
        return "variableName";
      }
      return popAndPass(type, stream, state);
    };


    return {
      startState: function(base) {
        return {
          tokenize: null,
          state: "block",
          context: new Context("block", base || 0, null)
        };
      },
      token: function(stream, state) {
        if (!state.tokenize && stream.eatSpace()) return null;
        style = (state.tokenize || tokenBase)(stream, state);
        if (style && typeof style == "object") {
          type = style[1];
          style = style[0];
        }
        override = style;
        state.state = states[state.state](type, stream, state);
        return override;
      },
      indent: function(state, textAfter, line) {

        var cx = state.context,
            ch = textAfter && textAfter.charAt(0),
            indent = cx.indent,
            lineFirstWord = firstWordOfLine(textAfter),
            lineIndent = line.match(/^\s*/)[0].replace(/\t/g, indentUnitString).length,
            prevLineFirstWord = state.context.prev ? state.context.prev.line.firstWord : "",
            prevLineIndent = state.context.prev ? state.context.prev.line.indent : lineIndent;

        if (cx.prev &&
            (ch == "}" && (cx.type == "block" || cx.type == "atBlock" || cx.type == "keyframes") ||
             ch == ")" && (cx.type == "parens" || cx.type == "atBlock_parens") ||
             ch == "{" && (cx.type == "at"))) {
          indent = cx.indent - indentUnit;
        } else if (!(/(\})/.test(ch))) {
          if (/@|\$|\d/.test(ch) ||
              /^\{/.test(textAfter) ||
/^\s*\/(\/|\*)/.test(textAfter) ||
              /^\s*\/\*/.test(prevLineFirstWord) ||
              /^\s*[\w-\.\[\]\'\"]+\s*(\?|:|\+)?=/i.test(textAfter) ||
/^(\+|-)?[a-z][\w-]*\(/i.test(textAfter) ||
/^return/.test(textAfter) ||
              wordIsBlock(lineFirstWord)) {
            indent = lineIndent;
          } else if (/(\.|#|:|\[|\*|&|>|~|\+|\/)/.test(ch) || wordIsTag(lineFirstWord)) {
            if (/\,\s*$/.test(prevLineFirstWord)) {
              indent = prevLineIndent;
            } else if (/^\s+/.test(line) && (/(\.|#|:|\[|\*|&|>|~|\+|\/)/.test(prevLineFirstWord) || wordIsTag(prevLineFirstWord))) {
              indent = lineIndent <= prevLineIndent ? prevLineIndent : prevLineIndent + indentUnit;
            } else {
              indent = lineIndent;
            }
          } else if (!/,\s*$/.test(line) && (wordIsVendorPrefix(lineFirstWord) || wordIsProperty(lineFirstWord))) {
            if (wordIsBlock(prevLineFirstWord)) {
              indent = lineIndent <= prevLineIndent ? prevLineIndent : prevLineIndent + indentUnit;
            } else if (/^\{/.test(prevLineFirstWord)) {
              indent = lineIndent <= prevLineIndent ? lineIndent : prevLineIndent + indentUnit;
            } else if (wordIsVendorPrefix(prevLineFirstWord) || wordIsProperty(prevLineFirstWord)) {
              indent = lineIndent >= prevLineIndent ? prevLineIndent : lineIndent;
            } else if (/^(\.|#|:|\[|\*|&|@|\+|\-|>|~|\/)/.test(prevLineFirstWord) ||
                      /=\s*$/.test(prevLineFirstWord) ||
                      wordIsTag(prevLineFirstWord) ||
                      /^\$[\w-\.\[\]\'\"]/.test(prevLineFirstWord)) {
              indent = prevLineIndent + indentUnit;
            } else {
              indent = lineIndent;
            }
          }
        }
        return indent;
      },
      electricChars: "}",
      blockCommentStart: "/*",
      blockCommentEnd: "*/",
      blockCommentContinue: " * ",
      lineComment: "//",
      fold: "indent"
    };
  });

  // developer.mozilla.org/en-US/docs/Web/HTML/Element
  var tagKeywords_ = ["a","abbr","address","area","article","aside","audio", "b", "base","bdi", "bdo","bgsound","blockquote","body","br","button","canvas","caption","cite", "code","col","colgroup","data","datalist","dd","del","details","dfn","div", "dl","dt","em","embed","fieldset","figcaption","figure","footer","form","h1", "h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","iframe", "img","input","ins","kbd","keygen","label","legend","li","link","main","map", "mark","marquee","menu","menuitem","meta","meter","nav","nobr","noframes", "noscript","object","ol","optgroup","option","output","p","param","pre", "progress","q","rp","rt","ruby","s","samp","script","section","select", "small","source","span","strong","style","sub","summary","sup","table","tbody","td","textarea","tfoot","th","thead","time","tr","track", "u","ul","var","video"];

  // github.com/codemirror/CodeMirror/blob/master/mode/css/css.js
  // Note, "url-prefix" should precede "url" in order to match correctly in documentTypesRegexp
  var documentTypes_ = ["domain", "regexp", "url-prefix", "url"];
  var mediaTypes_ = ["all","aural","braille","handheld","print","projection","screen","tty","tv","embossed"];
  var mediaFeatures_ = ["width","min-width","max-width","height","min-height","max-height","device-width","min-device-width","max-device-width","device-height","min-device-height","max-device-height","aspect-ratio","min-aspect-ratio","max-aspect-ratio","device-aspect-ratio","min-device-aspect-ratio","max-device-aspect-ratio","color","min-color","max-color","color-index","min-color-index","max-color-index","monochrome","min-monochrome","max-monochrome","resolution","min-resolution","max-resolution","scan","grid"];
  var propertyKeywords_ = ["align-content","align-items","align-self","alignment-adjust","alignment-baseline","anchor-point","animation","animation-delay","animation-direction","animation-duration","animation-fill-mode","animation-iteration-count","animation-name","animation-play-state","animation-timing-function","appearance","azimuth","backface-visibility","background","background-attachment","background-clip","background-color","background-image","background-origin","background-position","background-repeat","background-size","baseline-shift","binding","bleed","bookmark-label","bookmark-level","bookmark-state","bookmark-target","border","border-bottom","border-bottom-color","border-bottom-left-radius","border-bottom-right-radius","border-bottom-style","border-bottom-width","border-collapse","border-color","border-image","border-image-outset","border-image-repeat","border-image-slice","border-image-source","border-image-width","border-left","border-left-color","border-left-style","border-left-width","border-radius","border-right","border-right-color","border-right-style","border-right-width","border-spacing","border-style","border-top","border-top-color","border-top-left-radius","border-top-right-radius","border-top-style","border-top-width","border-width","bottom","box-decoration-break","box-shadow","box-sizing","break-after","break-before","break-inside","caption-side","clear","clip","color","color-profile","column-count","column-fill","column-gap","column-rule","column-rule-color","column-rule-style","column-rule-width","column-span","column-width","columns","content","counter-increment","counter-reset","crop","cue","cue-after","cue-before","cursor","direction","display","dominant-baseline","drop-initial-after-adjust","drop-initial-after-align","drop-initial-before-adjust","drop-initial-before-align","drop-initial-size","drop-initial-value","elevation","empty-cells","fit","fit-position","flex","flex-basis","flex-direction","flex-flow","flex-grow","flex-shrink","flex-wrap","float","float-offset","flow-from","flow-into","font","font-feature-settings","font-family","font-kerning","font-language-override","font-size","font-size-adjust","font-stretch","font-style","font-synthesis","font-variant","font-variant-alternates","font-variant-caps","font-variant-east-asian","font-variant-ligatures","font-variant-numeric","font-variant-position","font-weight","grid","grid-area","grid-auto-columns","grid-auto-flow","grid-auto-position","grid-auto-rows","grid-column","grid-column-end","grid-column-start","grid-row","grid-row-end","grid-row-start","grid-template","grid-template-areas","grid-template-columns","grid-template-rows","hanging-punctuation","height","hyphens","icon","image-orientation","image-rendering","image-resolution","inline-box-align","justify-content","left","letter-spacing","line-break","line-height","line-stacking","line-stacking-ruby","line-stacking-shift","line-stacking-strategy","list-style","list-style-image","list-style-position","list-style-type","margin","margin-bottom","margin-left","margin-right","margin-top","marker-offset","marks","marquee-direction","marquee-loop","marquee-play-count","marquee-speed","marquee-style","max-height","max-width","min-height","min-width","move-to","nav-down","nav-index","nav-left","nav-right","nav-up","object-fit","object-position","opacity","order","orphans","outline","outline-color","outline-offset","outline-style","outline-width","overflow","overflow-style","overflow-wrap","overflow-x","overflow-y","padding","padding-bottom","padding-left","padding-right","padding-top","page","page-break-after","page-break-before","page-break-inside","page-policy","pause","pause-after","pause-before","perspective","perspective-origin","pitch","pitch-range","play-during","position","presentation-level","punctuation-trim","quotes","region-break-after","region-break-before","region-break-inside","region-fragment","rendering-intent","resize","rest","rest-after","rest-before","richness","right","rotation","rotation-point","ruby-align","ruby-overhang","ruby-position","ruby-span","shape-image-threshold","shape-inside","shape-margin","shape-outside","size","speak","speak-as","speak-header","speak-numeral","speak-punctuation","speech-rate","stress","string-set","tab-size","table-layout","target","target-name","target-new","target-position","text-align","text-align-last","text-decoration","text-decoration-color","text-decoration-line","text-decoration-skip","text-decoration-style","text-emphasis","text-emphasis-color","text-emphasis-position","text-emphasis-style","text-height","text-indent","text-justify","text-outline","text-overflow","text-shadow","text-size-adjust","text-space-collapse","text-transform","text-underline-position","text-wrap","top","transform","transform-origin","transform-style","transition","transition-delay","transition-duration","transition-property","transition-timing-function","unicode-bidi","vertical-align","visibility","voice-balance","voice-duration","voice-family","voice-pitch","voice-range","voice-rate","voice-stress","voice-volume","volume","white-space","widows","width","will-change","word-break","word-spacing","word-wrap","z-index","clip-path","clip-rule","mask","enable-background","filter","flood-color","flood-opacity","lighting-color","stop-color","stop-opacity","pointer-events","color-interpolation","color-interpolation-filters","color-rendering","fill","fill-opacity","fill-rule","image-rendering","marker","marker-end","marker-mid","marker-start","shape-rendering","stroke","stroke-dasharray","stroke-dashoffset","stroke-linecap","stroke-linejoin","stroke-miterlimit","stroke-opacity","stroke-width","text-rendering","baseline-shift","dominant-baseline","glyph-orientation-horizontal","glyph-orientation-vertical","text-anchor","writing-mode","font-smoothing","osx-font-smoothing"];
  var nonStandardPropertyKeywords_ = ["scrollbar-arrow-color","scrollbar-base-color","scrollbar-dark-shadow-color","scrollbar-face-color","scrollbar-highlight-color","scrollbar-shadow-color","scrollbar-3d-light-color","scrollbar-track-color","shape-inside","searchfield-cancel-button","searchfield-decoration","searchfield-results-button","searchfield-results-decoration","zoom"];
  var fontProperties_ = ["font-family","src","unicode-range","font-variant","font-feature-settings","font-stretch","font-weight","font-style"];
  var colorKeywords_ = ["aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen"];
  var valueKeywords_ = ["above","absolute","activeborder","additive","activecaption","afar","after-white-space","ahead","alias","all","all-scroll","alphabetic","alternate","always","amharic","amharic-abegede","antialiased","appworkspace","arabic-indic","armenian","asterisks","attr","auto","avoid","avoid-column","avoid-page","avoid-region","background","backwards","baseline","below","bidi-override","binary","bengali","blink","block","block-axis","bold","bolder","border","border-box","both","bottom","break","break-all","break-word","bullets","button","button-bevel","buttonface","buttonhighlight","buttonshadow","buttontext","calc","cambodian","capitalize","caps-lock-indicator","caption","captiontext","caret","cell","center","checkbox","circle","cjk-decimal","cjk-earthly-branch","cjk-heavenly-stem","cjk-ideographic","clear","clip","close-quote","col-resize","collapse","column","compact","condensed","contain","content","contents","content-box","context-menu","continuous","copy","counter","counters","cover","crop","cross","crosshair","currentcolor","cursive","cyclic","dashed","decimal","decimal-leading-zero","default","default-button","destination-atop","destination-in","destination-out","destination-over","devanagari","disc","discard","disclosure-closed","disclosure-open","document","dot-dash","dot-dot-dash","dotted","double","down","e-resize","ease","ease-in","ease-in-out","ease-out","element","ellipse","ellipsis","embed","end","ethiopic","ethiopic-abegede","ethiopic-abegede-am-et","ethiopic-abegede-gez","ethiopic-abegede-ti-er","ethiopic-abegede-ti-et","ethiopic-halehame-aa-er","ethiopic-halehame-aa-et","ethiopic-halehame-am-et","ethiopic-halehame-gez","ethiopic-halehame-om-et","ethiopic-halehame-sid-et","ethiopic-halehame-so-et","ethiopic-halehame-ti-er","ethiopic-halehame-ti-et","ethiopic-halehame-tig","ethiopic-numeric","ew-resize","expanded","extends","extra-condensed","extra-expanded","fantasy","fast","fill","fixed","flat","flex","footnotes","forwards","from","geometricPrecision","georgian","graytext","groove","gujarati","gurmukhi","hand","hangul","hangul-consonant","hebrew","help","hidden","hide","higher","highlight","highlighttext","hiragana","hiragana-iroha","horizontal","hsl","hsla","icon","ignore","inactiveborder","inactivecaption","inactivecaptiontext","infinite","infobackground","infotext","inherit","initial","inline","inline-axis","inline-block","inline-flex","inline-table","inset","inside","intrinsic","invert","italic","japanese-formal","japanese-informal","justify","kannada","katakana","katakana-iroha","keep-all","khmer","korean-hangul-formal","korean-hanja-formal","korean-hanja-informal","landscape","lao","large","larger","left","level","lighter","line-through","linear","linear-gradient","lines","list-item","listbox","listitem","local","logical","loud","lower","lower-alpha","lower-armenian","lower-greek","lower-hexadecimal","lower-latin","lower-norwegian","lower-roman","lowercase","ltr","malayalam","match","matrix","matrix3d","media-controls-background","media-current-time-display","media-fullscreen-button","media-mute-button","media-play-button","media-return-to-realtime-button","media-rewind-button","media-seek-back-button","media-seek-forward-button","media-slider","media-sliderthumb","media-time-remaining-display","media-volume-slider","media-volume-slider-container","media-volume-sliderthumb","medium","menu","menulist","menulist-button","menulist-text","menulist-textfield","menutext","message-box","middle","min-intrinsic","mix","mongolian","monospace","move","multiple","myanmar","n-resize","narrower","ne-resize","nesw-resize","no-close-quote","no-drop","no-open-quote","no-repeat","none","normal","not-allowed","nowrap","ns-resize","numbers","numeric","nw-resize","nwse-resize","oblique","octal","open-quote","optimizeLegibility","optimizeSpeed","oriya","oromo","outset","outside","outside-shape","overlay","overline","padding","padding-box","painted","page","paused","persian","perspective","plus-darker","plus-lighter","pointer","polygon","portrait","pre","pre-line","pre-wrap","preserve-3d","progress","push-button","radial-gradient","radio","read-only","read-write","read-write-plaintext-only","rectangle","region","relative","repeat","repeating-linear-gradient","repeating-radial-gradient","repeat-x","repeat-y","reset","reverse","rgb","rgba","ridge","right","rotate","rotate3d","rotateX","rotateY","rotateZ","round","row-resize","rtl","run-in","running","s-resize","sans-serif","scale","scale3d","scaleX","scaleY","scaleZ","scroll","scrollbar","scroll-position","se-resize","searchfield","searchfield-cancel-button","searchfield-decoration","searchfield-results-button","searchfield-results-decoration","semi-condensed","semi-expanded","separate","serif","show","sidama","simp-chinese-formal","simp-chinese-informal","single","skew","skewX","skewY","skip-white-space","slide","slider-horizontal","slider-vertical","sliderthumb-horizontal","sliderthumb-vertical","slow","small","small-caps","small-caption","smaller","solid","somali","source-atop","source-in","source-out","source-over","space","spell-out","square","square-button","start","static","status-bar","stretch","stroke","sub","subpixel-antialiased","super","sw-resize","symbolic","symbols","table","table-caption","table-cell","table-column","table-column-group","table-footer-group","table-header-group","table-row","table-row-group","tamil","telugu","text","text-bottom","text-top","textarea","textfield","thai","thick","thin","threeddarkshadow","threedface","threedhighlight","threedlightshadow","threedshadow","tibetan","tigre","tigrinya-er","tigrinya-er-abegede","tigrinya-et","tigrinya-et-abegede","to","top","trad-chinese-formal","trad-chinese-informal","translate","translate3d","translateX","translateY","translateZ","transparent","ultra-condensed","ultra-expanded","underline","up","upper-alpha","upper-armenian","upper-greek","upper-hexadecimal","upper-latin","upper-norwegian","upper-roman","uppercase","urdu","url","var","vertical","vertical-text","visible","visibleFill","visiblePainted","visibleStroke","visual","w-resize","wait","wave","wider","window","windowframe","windowtext","words","x-large","x-small","xor","xx-large","xx-small","bicubic","optimizespeed","grayscale","row","row-reverse","wrap","wrap-reverse","column-reverse","flex-start","flex-end","space-between","space-around", "unset"];

  var wordOperatorKeywords_ = ["in","and","or","not","is not","is a","is","isnt","defined","if unless"],
      blockKeywords_ = ["for","if","else","unless", "from", "to"],
      commonAtoms_ = ["null","true","false","href","title","type","not-allowed","readonly","disabled"],
      commonDef_ = ["@font-face", "@keyframes", "@media", "@viewport", "@page", "@host", "@supports", "@block", "@css"];

  var hintWords = tagKeywords_.concat(documentTypes_,mediaTypes_,mediaFeatures_,
                                      propertyKeywords_,nonStandardPropertyKeywords_,
                                      colorKeywords_,valueKeywords_,fontProperties_,
                                      wordOperatorKeywords_,blockKeywords_,
                                      commonAtoms_,commonDef_);

  function wordRegexp(words) {
    words = words.sort(function(a,b){return b > a;});
    return new RegExp("^((" + words.join(")|(") + "))\\b");
  }

  function keySet(array) {
    var keys = {};
    for (var i = 0; i < array.length; ++i) keys[array[i]] = true;
    return keys;
  }

  function escapeRegExp(text) {
    return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  }

  CodeMirror.registerHelper("hintWords", "stylus", hintWords);
  CodeMirror.defineMIME("text/x-styl", "stylus");
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/swift/swift.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// Swift mode created by Michael Kaminsky https://github.com/mkaminsky11

(function(mod) {
  if (true)
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"))
  else {}
})(function(CodeMirror) {
  "use strict"

  function wordSet(words) {
    var set = {}
    for (var i = 0; i < words.length; i++) set[words[i]] = true
    return set
  }

  var keywords = wordSet(["_","var","let","class","enum","extension","import","protocol","struct","func","typealias","associatedtype",
                          "open","public","internal","fileprivate","private","deinit","init","new","override","self","subscript","super",
                          "convenience","dynamic","final","indirect","lazy","required","static","unowned","unowned(safe)","unowned(unsafe)","weak","as","is",
                          "break","case","continue","default","else","fallthrough","for","guard","if","in","repeat","switch","where","while",
                          "defer","return","inout","mutating","nonmutating","catch","do","rethrows","throw","throws","try","didSet","get","set","willSet",
                          "assignment","associativity","infix","left","none","operator","postfix","precedence","precedencegroup","prefix","right",
                          "Any","AnyObject","Type","dynamicType","Self","Protocol","__COLUMN__","__FILE__","__FUNCTION__","__LINE__"])
  var definingKeywords = wordSet(["var","let","class","enum","extension","import","protocol","struct","func","typealias","associatedtype","for"])
  var atoms = wordSet(["true","false","nil","self","super","_"])
  var types = wordSet(["Array","Bool","Character","Dictionary","Double","Float","Int","Int8","Int16","Int32","Int64","Never","Optional","Set","String",
                       "UInt8","UInt16","UInt32","UInt64","Void"])
  var operators = "+-/*%=|&<>~^?!"
  var punc = ":;,.(){}[]"
  var binary = /^\-?0b[01][01_]*/
  var octal = /^\-?0o[0-7][0-7_]*/
  var hexadecimal = /^\-?0x[\dA-Fa-f][\dA-Fa-f_]*(?:(?:\.[\dA-Fa-f][\dA-Fa-f_]*)?[Pp]\-?\d[\d_]*)?/
  var decimal = /^\-?\d[\d_]*(?:\.\d[\d_]*)?(?:[Ee]\-?\d[\d_]*)?/
  var identifier = /^\$\d+|(`?)[_A-Za-z][_A-Za-z$0-9]*\1/
  var property = /^\.(?:\$\d+|(`?)[_A-Za-z][_A-Za-z$0-9]*\1)/
  var instruction = /^\#[A-Za-z]+/
  var attribute = /^@(?:\$\d+|(`?)[_A-Za-z][_A-Za-z$0-9]*\1)/
  //var regexp = /^\/(?!\s)(?:\/\/)?(?:\\.|[^\/])+\//

  function tokenBase(stream, state, prev) {
    if (stream.sol()) state.indented = stream.indentation()
    if (stream.eatSpace()) return null

    var ch = stream.peek()
    if (ch == "/") {
      if (stream.match("//")) {
        stream.skipToEnd()
        return "comment"
      }
      if (stream.match("/*")) {
        state.tokenize.push(tokenComment)
        return tokenComment(stream, state)
      }
    }
    if (stream.match(instruction)) return "builtin"
    if (stream.match(attribute)) return "attribute"
    if (stream.match(binary)) return "number"
    if (stream.match(octal)) return "number"
    if (stream.match(hexadecimal)) return "number"
    if (stream.match(decimal)) return "number"
    if (stream.match(property)) return "property"
    if (operators.indexOf(ch) > -1) {
      stream.next()
      return "operator"
    }
    if (punc.indexOf(ch) > -1) {
      stream.next()
      stream.match("..")
      return "punctuation"
    }
    var stringMatch
    if (stringMatch = stream.match(/("""|"|')/)) {
      var tokenize = tokenString.bind(null, stringMatch[0])
      state.tokenize.push(tokenize)
      return tokenize(stream, state)
    }

    if (stream.match(identifier)) {
      var ident = stream.current()
      if (types.hasOwnProperty(ident)) return "variable-2"
      if (atoms.hasOwnProperty(ident)) return "atom"
      if (keywords.hasOwnProperty(ident)) {
        if (definingKeywords.hasOwnProperty(ident))
          state.prev = "define"
        return "keyword"
      }
      if (prev == "define") return "def"
      return "variable"
    }

    stream.next()
    return null
  }

  function tokenUntilClosingParen() {
    var depth = 0
    return function(stream, state, prev) {
      var inner = tokenBase(stream, state, prev)
      if (inner == "punctuation") {
        if (stream.current() == "(") ++depth
        else if (stream.current() == ")") {
          if (depth == 0) {
            stream.backUp(1)
            state.tokenize.pop()
            return state.tokenize[state.tokenize.length - 1](stream, state)
          }
          else --depth
        }
      }
      return inner
    }
  }

  function tokenString(openQuote, stream, state) {
    var singleLine = openQuote.length == 1
    var ch, escaped = false
    while (ch = stream.peek()) {
      if (escaped) {
        stream.next()
        if (ch == "(") {
          state.tokenize.push(tokenUntilClosingParen())
          return "string"
        }
        escaped = false
      } else if (stream.match(openQuote)) {
        state.tokenize.pop()
        return "string"
      } else {
        stream.next()
        escaped = ch == "\\"
      }
    }
    if (singleLine) {
      state.tokenize.pop()
    }
    return "string"
  }

  function tokenComment(stream, state) {
    var ch
    while (true) {
      stream.match(/^[^/*]+/, true)
      ch = stream.next()
      if (!ch) break
      if (ch === "/" && stream.eat("*")) {
        state.tokenize.push(tokenComment)
      } else if (ch === "*" && stream.eat("/")) {
        state.tokenize.pop()
      }
    }
    return "comment"
  }

  function Context(prev, align, indented) {
    this.prev = prev
    this.align = align
    this.indented = indented
  }

  function pushContext(state, stream) {
    var align = stream.match(/^\s*($|\/[\/\*])/, false) ? null : stream.column() + 1
    state.context = new Context(state.context, align, state.indented)
  }

  function popContext(state) {
    if (state.context) {
      state.indented = state.context.indented
      state.context = state.context.prev
    }
  }

  CodeMirror.defineMode("swift", function(config) {
    return {
      startState: function() {
        return {
          prev: null,
          context: null,
          indented: 0,
          tokenize: []
        }
      },

      token: function(stream, state) {
        var prev = state.prev
        state.prev = null
        var tokenize = state.tokenize[state.tokenize.length - 1] || tokenBase
        var style = tokenize(stream, state, prev)
        if (!style || style == "comment") state.prev = prev
        else if (!state.prev) state.prev = style

        if (style == "punctuation") {
          var bracket = /[\(\[\{]|([\]\)\}])/.exec(stream.current())
          if (bracket) (bracket[1] ? popContext : pushContext)(state, stream)
        }

        return style
      },

      indent: function(state, textAfter) {
        var cx = state.context
        if (!cx) return 0
        var closing = /^[\]\}\)]/.test(textAfter)
        if (cx.align != null) return cx.align - (closing ? 1 : 0)
        return cx.indented + (closing ? 0 : config.indentUnit)
      },

      electricInput: /^\s*[\)\}\]]$/,

      lineComment: "//",
      blockCommentStart: "/*",
      blockCommentEnd: "*/",
      fold: "brace",
      closeBrackets: "()[]{}''\"\"``"
    }
  })

  CodeMirror.defineMIME("text/x-swift","swift")
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/tcl/tcl.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

//tcl mode by Ford_Lawnmower :: Based on Velocity mode by Steve O'Hara

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("tcl", function() {
  function parseWords(str) {
    var obj = {}, words = str.split(" ");
    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
    return obj;
  }
  var keywords = parseWords("Tcl safe after append array auto_execok auto_import auto_load " +
        "auto_mkindex auto_mkindex_old auto_qualify auto_reset bgerror " +
        "binary break catch cd close concat continue dde eof encoding error " +
        "eval exec exit expr fblocked fconfigure fcopy file fileevent filename " +
        "filename flush for foreach format gets glob global history http if " +
        "incr info interp join lappend lindex linsert list llength load lrange " +
        "lreplace lsearch lset lsort memory msgcat namespace open package parray " +
        "pid pkg::create pkg_mkIndex proc puts pwd re_syntax read regex regexp " +
        "registry regsub rename resource return scan seek set socket source split " +
        "string subst switch tcl_endOfWord tcl_findLibrary tcl_startOfNextWord " +
        "tcl_wordBreakAfter tcl_startOfPreviousWord tcl_wordBreakBefore tcltest " +
        "tclvars tell time trace unknown unset update uplevel upvar variable " +
    "vwait");
    var functions = parseWords("if elseif else and not or eq ne in ni for foreach while switch");
    var isOperatorChar = /[+\-*&%=<>!?^\/\|]/;
    function chain(stream, state, f) {
      state.tokenize = f;
      return f(stream, state);
    }
    function tokenBase(stream, state) {
      var beforeParams = state.beforeParams;
      state.beforeParams = false;
      var ch = stream.next();
      if ((ch == '"' || ch == "'") && state.inParams) {
        return chain(stream, state, tokenString(ch));
      } else if (/[\[\]{}\(\),;\.]/.test(ch)) {
        if (ch == "(" && beforeParams) state.inParams = true;
        else if (ch == ")") state.inParams = false;
          return null;
      } else if (/\d/.test(ch)) {
        stream.eatWhile(/[\w\.]/);
        return "number";
      } else if (ch == "#") {
        if (stream.eat("*"))
          return chain(stream, state, tokenComment);
        if (ch == "#" && stream.match(/ *\[ *\[/))
          return chain(stream, state, tokenUnparsed);
        stream.skipToEnd();
        return "comment";
      } else if (ch == '"') {
        stream.skipTo(/"/);
        return "comment";
      } else if (ch == "$") {
        stream.eatWhile(/[$_a-z0-9A-Z\.{:]/);
        stream.eatWhile(/}/);
        state.beforeParams = true;
        return "builtin";
      } else if (isOperatorChar.test(ch)) {
        stream.eatWhile(isOperatorChar);
        return "comment";
      } else {
        stream.eatWhile(/[\w\$_{}\xa1-\uffff]/);
        var word = stream.current().toLowerCase();
        if (keywords && keywords.propertyIsEnumerable(word))
          return "keyword";
        if (functions && functions.propertyIsEnumerable(word)) {
          state.beforeParams = true;
          return "keyword";
        }
        return null;
      }
    }
    function tokenString(quote) {
      return function(stream, state) {
      var escaped = false, next, end = false;
      while ((next = stream.next()) != null) {
        if (next == quote && !escaped) {
          end = true;
          break;
        }
        escaped = !escaped && next == "\\";
      }
      if (end) state.tokenize = tokenBase;
        return "string";
      };
    }
    function tokenComment(stream, state) {
      var maybeEnd = false, ch;
      while (ch = stream.next()) {
        if (ch == "#" && maybeEnd) {
          state.tokenize = tokenBase;
          break;
        }
        maybeEnd = (ch == "*");
      }
      return "comment";
    }
    function tokenUnparsed(stream, state) {
      var maybeEnd = 0, ch;
      while (ch = stream.next()) {
        if (ch == "#" && maybeEnd == 2) {
          state.tokenize = tokenBase;
          break;
        }
        if (ch == "]")
          maybeEnd++;
        else if (ch != " ")
          maybeEnd = 0;
      }
      return "meta";
    }
    return {
      startState: function() {
        return {
          tokenize: tokenBase,
          beforeParams: false,
          inParams: false
        };
      },
      token: function(stream, state) {
        if (stream.eatSpace()) return null;
        return state.tokenize(stream, state);
      },
      lineComment: "#"
    };
});
CodeMirror.defineMIME("text/x-tcl", "tcl");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/textile/textile.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) { // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  } else {}
})(function(CodeMirror) {
  "use strict";

  var TOKEN_STYLES = {
    addition: "positive",
    attributes: "attribute",
    bold: "strong",
    cite: "keyword",
    code: "atom",
    definitionList: "number",
    deletion: "negative",
    div: "punctuation",
    em: "em",
    footnote: "variable",
    footCite: "qualifier",
    header: "header",
    html: "comment",
    image: "string",
    italic: "em",
    link: "link",
    linkDefinition: "link",
    list1: "variable-2",
    list2: "variable-3",
    list3: "keyword",
    notextile: "string-2",
    pre: "operator",
    p: "property",
    quote: "bracket",
    span: "quote",
    specialChar: "tag",
    strong: "strong",
    sub: "builtin",
    sup: "builtin",
    table: "variable-3",
    tableHeading: "operator"
  };

  function startNewLine(stream, state) {
    state.mode = Modes.newLayout;
    state.tableHeading = false;

    if (state.layoutType === "definitionList" && state.spanningLayout &&
        stream.match(RE("definitionListEnd"), false))
      state.spanningLayout = false;
  }

  function handlePhraseModifier(stream, state, ch) {
    if (ch === "_") {
      if (stream.eat("_"))
        return togglePhraseModifier(stream, state, "italic", /__/, 2);
      else
        return togglePhraseModifier(stream, state, "em", /_/, 1);
    }

    if (ch === "*") {
      if (stream.eat("*")) {
        return togglePhraseModifier(stream, state, "bold", /\*\*/, 2);
      }
      return togglePhraseModifier(stream, state, "strong", /\*/, 1);
    }

    if (ch === "[") {
      if (stream.match(/\d+\]/)) state.footCite = true;
      return tokenStyles(state);
    }

    if (ch === "(") {
      var spec = stream.match(/^(r|tm|c)\)/);
      if (spec)
        return tokenStylesWith(state, TOKEN_STYLES.specialChar);
    }

    if (ch === "<" && stream.match(/(\w+)[^>]+>[^<]+<\/\1>/))
      return tokenStylesWith(state, TOKEN_STYLES.html);

    if (ch === "?" && stream.eat("?"))
      return togglePhraseModifier(stream, state, "cite", /\?\?/, 2);

    if (ch === "=" && stream.eat("="))
      return togglePhraseModifier(stream, state, "notextile", /==/, 2);

    if (ch === "-" && !stream.eat("-"))
      return togglePhraseModifier(stream, state, "deletion", /-/, 1);

    if (ch === "+")
      return togglePhraseModifier(stream, state, "addition", /\+/, 1);

    if (ch === "~")
      return togglePhraseModifier(stream, state, "sub", /~/, 1);

    if (ch === "^")
      return togglePhraseModifier(stream, state, "sup", /\^/, 1);

    if (ch === "%")
      return togglePhraseModifier(stream, state, "span", /%/, 1);

    if (ch === "@")
      return togglePhraseModifier(stream, state, "code", /@/, 1);

    if (ch === "!") {
      var type = togglePhraseModifier(stream, state, "image", /(?:\([^\)]+\))?!/, 1);
      stream.match(/^:\S+/); // optional Url portion
      return type;
    }
    return tokenStyles(state);
  }

  function togglePhraseModifier(stream, state, phraseModifier, closeRE, openSize) {
    var charBefore = stream.pos > openSize ? stream.string.charAt(stream.pos - openSize - 1) : null;
    var charAfter = stream.peek();
    if (state[phraseModifier]) {
      if ((!charAfter || /\W/.test(charAfter)) && charBefore && /\S/.test(charBefore)) {
        var type = tokenStyles(state);
        state[phraseModifier] = false;
        return type;
      }
    } else if ((!charBefore || /\W/.test(charBefore)) && charAfter && /\S/.test(charAfter) &&
               stream.match(new RegExp("^.*\\S" + closeRE.source + "(?:\\W|$)"), false)) {
      state[phraseModifier] = true;
      state.mode = Modes.attributes;
    }
    return tokenStyles(state);
  };

  function tokenStyles(state) {
    var disabled = textileDisabled(state);
    if (disabled) return disabled;

    var styles = [];
    if (state.layoutType) styles.push(TOKEN_STYLES[state.layoutType]);

    styles = styles.concat(activeStyles(
      state, "addition", "bold", "cite", "code", "deletion", "em", "footCite",
      "image", "italic", "link", "span", "strong", "sub", "sup", "table", "tableHeading"));

    if (state.layoutType === "header")
      styles.push(TOKEN_STYLES.header + "-" + state.header);

    return styles.length ? styles.join(" ") : null;
  }

  function textileDisabled(state) {
    var type = state.layoutType;

    switch(type) {
    case "notextile":
    case "code":
    case "pre":
      return TOKEN_STYLES[type];
    default:
      if (state.notextile)
        return TOKEN_STYLES.notextile + (type ? (" " + TOKEN_STYLES[type]) : "");
      return null;
    }
  }

  function tokenStylesWith(state, extraStyles) {
    var disabled = textileDisabled(state);
    if (disabled) return disabled;

    var type = tokenStyles(state);
    if (extraStyles)
      return type ? (type + " " + extraStyles) : extraStyles;
    else
      return type;
  }

  function activeStyles(state) {
    var styles = [];
    for (var i = 1; i < arguments.length; ++i) {
      if (state[arguments[i]])
        styles.push(TOKEN_STYLES[arguments[i]]);
    }
    return styles;
  }

  function blankLine(state) {
    var spanningLayout = state.spanningLayout, type = state.layoutType;

    for (var key in state) if (state.hasOwnProperty(key))
      delete state[key];

    state.mode = Modes.newLayout;
    if (spanningLayout) {
      state.layoutType = type;
      state.spanningLayout = true;
    }
  }

  var REs = {
    cache: {},
    single: {
      bc: "bc",
      bq: "bq",
      definitionList: /- .*?:=+/,
      definitionListEnd: /.*=:\s*$/,
      div: "div",
      drawTable: /\|.*\|/,
      foot: /fn\d+/,
      header: /h[1-6]/,
      html: /\s*<(?:\/)?(\w+)(?:[^>]+)?>(?:[^<]+<\/\1>)?/,
      link: /[^"]+":\S/,
      linkDefinition: /\[[^\s\]]+\]\S+/,
      list: /(?:#+|\*+)/,
      notextile: "notextile",
      para: "p",
      pre: "pre",
      table: "table",
      tableCellAttributes: /[\/\\]\d+/,
      tableHeading: /\|_\./,
      tableText: /[^"_\*\[\(\?\+~\^%@|-]+/,
      text: /[^!"_=\*\[\(<\?\+~\^%@-]+/
    },
    attributes: {
      align: /(?:<>|<|>|=)/,
      selector: /\([^\(][^\)]+\)/,
      lang: /\[[^\[\]]+\]/,
      pad: /(?:\(+|\)+){1,2}/,
      css: /\{[^\}]+\}/
    },
    createRe: function(name) {
      switch (name) {
      case "drawTable":
        return REs.makeRe("^", REs.single.drawTable, "$");
      case "html":
        return REs.makeRe("^", REs.single.html, "(?:", REs.single.html, ")*", "$");
      case "linkDefinition":
        return REs.makeRe("^", REs.single.linkDefinition, "$");
      case "listLayout":
        return REs.makeRe("^", REs.single.list, RE("allAttributes"), "*\\s+");
      case "tableCellAttributes":
        return REs.makeRe("^", REs.choiceRe(REs.single.tableCellAttributes,
                                            RE("allAttributes")), "+\\.");
      case "type":
        return REs.makeRe("^", RE("allTypes"));
      case "typeLayout":
        return REs.makeRe("^", RE("allTypes"), RE("allAttributes"),
                          "*\\.\\.?", "(\\s+|$)");
      case "attributes":
        return REs.makeRe("^", RE("allAttributes"), "+");

      case "allTypes":
        return REs.choiceRe(REs.single.div, REs.single.foot,
                            REs.single.header, REs.single.bc, REs.single.bq,
                            REs.single.notextile, REs.single.pre, REs.single.table,
                            REs.single.para);

      case "allAttributes":
        return REs.choiceRe(REs.attributes.selector, REs.attributes.css,
                            REs.attributes.lang, REs.attributes.align, REs.attributes.pad);

      default:
        return REs.makeRe("^", REs.single[name]);
      }
    },
    makeRe: function() {
      var pattern = "";
      for (var i = 0; i < arguments.length; ++i) {
        var arg = arguments[i];
        pattern += (typeof arg === "string") ? arg : arg.source;
      }
      return new RegExp(pattern);
    },
    choiceRe: function() {
      var parts = [arguments[0]];
      for (var i = 1; i < arguments.length; ++i) {
        parts[i * 2 - 1] = "|";
        parts[i * 2] = arguments[i];
      }

      parts.unshift("(?:");
      parts.push(")");
      return REs.makeRe.apply(null, parts);
    }
  };

  function RE(name) {
    return (REs.cache[name] || (REs.cache[name] = REs.createRe(name)));
  }

  var Modes = {
    newLayout: function(stream, state) {
      if (stream.match(RE("typeLayout"), false)) {
        state.spanningLayout = false;
        return (state.mode = Modes.blockType)(stream, state);
      }
      var newMode;
      if (!textileDisabled(state)) {
        if (stream.match(RE("listLayout"), false))
          newMode = Modes.list;
        else if (stream.match(RE("drawTable"), false))
          newMode = Modes.table;
        else if (stream.match(RE("linkDefinition"), false))
          newMode = Modes.linkDefinition;
        else if (stream.match(RE("definitionList")))
          newMode = Modes.definitionList;
        else if (stream.match(RE("html"), false))
          newMode = Modes.html;
      }
      return (state.mode = (newMode || Modes.text))(stream, state);
    },

    blockType: function(stream, state) {
      var match, type;
      state.layoutType = null;

      if (match = stream.match(RE("type")))
        type = match[0];
      else
        return (state.mode = Modes.text)(stream, state);

      if (match = type.match(RE("header"))) {
        state.layoutType = "header";
        state.header = parseInt(match[0][1]);
      } else if (type.match(RE("bq"))) {
        state.layoutType = "quote";
      } else if (type.match(RE("bc"))) {
        state.layoutType = "code";
      } else if (type.match(RE("foot"))) {
        state.layoutType = "footnote";
      } else if (type.match(RE("notextile"))) {
        state.layoutType = "notextile";
      } else if (type.match(RE("pre"))) {
        state.layoutType = "pre";
      } else if (type.match(RE("div"))) {
        state.layoutType = "div";
      } else if (type.match(RE("table"))) {
        state.layoutType = "table";
      }

      state.mode = Modes.attributes;
      return tokenStyles(state);
    },

    text: function(stream, state) {
      if (stream.match(RE("text"))) return tokenStyles(state);

      var ch = stream.next();
      if (ch === '"')
        return (state.mode = Modes.link)(stream, state);
      return handlePhraseModifier(stream, state, ch);
    },

    attributes: function(stream, state) {
      state.mode = Modes.layoutLength;

      if (stream.match(RE("attributes")))
        return tokenStylesWith(state, TOKEN_STYLES.attributes);
      else
        return tokenStyles(state);
    },

    layoutLength: function(stream, state) {
      if (stream.eat(".") && stream.eat("."))
        state.spanningLayout = true;

      state.mode = Modes.text;
      return tokenStyles(state);
    },

    list: function(stream, state) {
      var match = stream.match(RE("list"));
      state.listDepth = match[0].length;
      var listMod = (state.listDepth - 1) % 3;
      if (!listMod)
        state.layoutType = "list1";
      else if (listMod === 1)
        state.layoutType = "list2";
      else
        state.layoutType = "list3";

      state.mode = Modes.attributes;
      return tokenStyles(state);
    },

    link: function(stream, state) {
      state.mode = Modes.text;
      if (stream.match(RE("link"))) {
        stream.match(/\S+/);
        return tokenStylesWith(state, TOKEN_STYLES.link);
      }
      return tokenStyles(state);
    },

    linkDefinition: function(stream, state) {
      stream.skipToEnd();
      return tokenStylesWith(state, TOKEN_STYLES.linkDefinition);
    },

    definitionList: function(stream, state) {
      stream.match(RE("definitionList"));

      state.layoutType = "definitionList";

      if (stream.match(/\s*$/))
        state.spanningLayout = true;
      else
        state.mode = Modes.attributes;

      return tokenStyles(state);
    },

    html: function(stream, state) {
      stream.skipToEnd();
      return tokenStylesWith(state, TOKEN_STYLES.html);
    },

    table: function(stream, state) {
      state.layoutType = "table";
      return (state.mode = Modes.tableCell)(stream, state);
    },

    tableCell: function(stream, state) {
      if (stream.match(RE("tableHeading")))
        state.tableHeading = true;
      else
        stream.eat("|");

      state.mode = Modes.tableCellAttributes;
      return tokenStyles(state);
    },

    tableCellAttributes: function(stream, state) {
      state.mode = Modes.tableText;

      if (stream.match(RE("tableCellAttributes")))
        return tokenStylesWith(state, TOKEN_STYLES.attributes);
      else
        return tokenStyles(state);
    },

    tableText: function(stream, state) {
      if (stream.match(RE("tableText")))
        return tokenStyles(state);

      if (stream.peek() === "|") { // end of cell
        state.mode = Modes.tableCell;
        return tokenStyles(state);
      }
      return handlePhraseModifier(stream, state, stream.next());
    }
  };

  CodeMirror.defineMode("textile", function() {
    return {
      startState: function() {
        return { mode: Modes.newLayout };
      },
      token: function(stream, state) {
        if (stream.sol()) startNewLine(stream, state);
        return state.mode(stream, state);
      },
      blankLine: blankLine
    };
  });

  CodeMirror.defineMIME("text/x-textile", "textile");
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/tiddlywiki/tiddlywiki.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

/***
    |''Name''|tiddlywiki.js|
    |''Description''|Enables TiddlyWikiy syntax highlighting using CodeMirror|
    |''Author''|PMario|
    |''Version''|0.1.7|
    |''Status''|''stable''|
    |''Source''|[[GitHub|https://github.com/pmario/CodeMirror2/blob/tw-syntax/mode/tiddlywiki]]|
    |''Documentation''|https://codemirror.tiddlyspace.com/|
    |''License''|[[MIT License|http://www.opensource.org/licenses/mit-license.php]]|
    |''CoreVersion''|2.5.0|
    |''Requires''|codemirror.js|
    |''Keywords''|syntax highlighting color code mirror codemirror|
    ! Info
    CoreVersion parameter is needed for TiddlyWiki only!
***/

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("tiddlywiki", function () {
  // Tokenizer
  var textwords = {};

  var keywords = {
    "allTags": true, "closeAll": true, "list": true,
    "newJournal": true, "newTiddler": true,
    "permaview": true, "saveChanges": true,
    "search": true, "slider": true, "tabs": true,
    "tag": true, "tagging": true, "tags": true,
    "tiddler": true, "timeline": true,
    "today": true, "version": true, "option": true,
    "with": true, "filter": true
  };

  var isSpaceName = /[\w_\-]/i,
      reHR = /^\-\-\-\-+$/,                                 // <hr>
      reWikiCommentStart = /^\/\*\*\*$/,            // /***
      reWikiCommentStop = /^\*\*\*\/$/,             // ***/
      reBlockQuote = /^<<<$/,

      reJsCodeStart = /^\/\/\{\{\{$/,                       // //{{{ js block start
      reJsCodeStop = /^\/\/\}\}\}$/,                        // //}}} js stop
      reXmlCodeStart = /^<!--\{\{\{-->$/,           // xml block start
      reXmlCodeStop = /^<!--\}\}\}-->$/,            // xml stop

      reCodeBlockStart = /^\{\{\{$/,                        // {{{ TW text div block start
      reCodeBlockStop = /^\}\}\}$/,                 // }}} TW text stop

      reUntilCodeStop = /.*?\}\}\}/;

  function chain(stream, state, f) {
    state.tokenize = f;
    return f(stream, state);
  }

  function tokenBase(stream, state) {
    var sol = stream.sol(), ch = stream.peek();

    state.block = false;        // indicates the start of a code block.

    // check start of  blocks
    if (sol && /[<\/\*{}\-]/.test(ch)) {
      if (stream.match(reCodeBlockStart)) {
        state.block = true;
        return chain(stream, state, twTokenCode);
      }
      if (stream.match(reBlockQuote))
        return 'quote';
      if (stream.match(reWikiCommentStart) || stream.match(reWikiCommentStop))
        return 'comment';
      if (stream.match(reJsCodeStart) || stream.match(reJsCodeStop) || stream.match(reXmlCodeStart) || stream.match(reXmlCodeStop))
        return 'comment';
      if (stream.match(reHR))
        return 'hr';
    }

    stream.next();
    if (sol && /[\/\*!#;:>|]/.test(ch)) {
      if (ch == "!") { // tw header
        stream.skipToEnd();
        return "header";
      }
      if (ch == "*") { // tw list
        stream.eatWhile('*');
        return "comment";
      }
      if (ch == "#") { // tw numbered list
        stream.eatWhile('#');
        return "comment";
      }
      if (ch == ";") { // definition list, term
        stream.eatWhile(';');
        return "comment";
      }
      if (ch == ":") { // definition list, description
        stream.eatWhile(':');
        return "comment";
      }
      if (ch == ">") { // single line quote
        stream.eatWhile(">");
        return "quote";
      }
      if (ch == '|')
        return 'header';
    }

    if (ch == '{' && stream.match('{{'))
      return chain(stream, state, twTokenCode);

    // rudimentary html:// file:// link matching. TW knows much more ...
    if (/[hf]/i.test(ch) &&
        /[ti]/i.test(stream.peek()) &&
        stream.match(/\b(ttps?|tp|ile):\/\/[\-A-Z0-9+&@#\/%?=~_|$!:,.;]*[A-Z0-9+&@#\/%=~_|$]/i))
      return "link";

    // just a little string indicator, don't want to have the whole string covered
    if (ch == '"')
      return 'string';

    if (ch == '~')    // _no_ CamelCase indicator should be bold
      return 'brace';

    if (/[\[\]]/.test(ch) && stream.match(ch)) // check for [[..]]
      return 'brace';

    if (ch == "@") {    // check for space link. TODO fix @@...@@ highlighting
      stream.eatWhile(isSpaceName);
      return "link";
    }

    if (/\d/.test(ch)) {        // numbers
      stream.eatWhile(/\d/);
      return "number";
    }

    if (ch == "/") { // tw invisible comment
      if (stream.eat("%")) {
        return chain(stream, state, twTokenComment);
      } else if (stream.eat("/")) { //
        return chain(stream, state, twTokenEm);
      }
    }

    if (ch == "_" && stream.eat("_")) // tw underline
        return chain(stream, state, twTokenUnderline);

    // strikethrough and mdash handling
    if (ch == "-" && stream.eat("-")) {
      // if strikethrough looks ugly, change CSS.
      if (stream.peek() != ' ')
        return chain(stream, state, twTokenStrike);
      // mdash
      if (stream.peek() == ' ')
        return 'brace';
    }

    if (ch == "'" && stream.eat("'")) // tw bold
      return chain(stream, state, twTokenStrong);

    if (ch == "<" && stream.eat("<")) // tw macro
      return chain(stream, state, twTokenMacro);

    // core macro handling
    stream.eatWhile(/[\w\$_]/);
    return textwords.propertyIsEnumerable(stream.current()) ? "keyword" : null
  }

  // tw invisible comment
  function twTokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" && maybeEnd) {
        state.tokenize = tokenBase;
        break;
      }
      maybeEnd = (ch == "%");
    }
    return "comment";
  }

  // tw strong / bold
  function twTokenStrong(stream, state) {
    var maybeEnd = false,
    ch;
    while (ch = stream.next()) {
      if (ch == "'" && maybeEnd) {
        state.tokenize = tokenBase;
        break;
      }
      maybeEnd = (ch == "'");
    }
    return "strong";
  }

  // tw code
  function twTokenCode(stream, state) {
    var sb = state.block;

    if (sb && stream.current()) {
      return "comment";
    }

    if (!sb && stream.match(reUntilCodeStop)) {
      state.tokenize = tokenBase;
      return "comment";
    }

    if (sb && stream.sol() && stream.match(reCodeBlockStop)) {
      state.tokenize = tokenBase;
      return "comment";
    }

    stream.next();
    return "comment";
  }

  // tw em / italic
  function twTokenEm(stream, state) {
    var maybeEnd = false,
    ch;
    while (ch = stream.next()) {
      if (ch == "/" && maybeEnd) {
        state.tokenize = tokenBase;
        break;
      }
      maybeEnd = (ch == "/");
    }
    return "em";
  }

  // tw underlined text
  function twTokenUnderline(stream, state) {
    var maybeEnd = false,
    ch;
    while (ch = stream.next()) {
      if (ch == "_" && maybeEnd) {
        state.tokenize = tokenBase;
        break;
      }
      maybeEnd = (ch == "_");
    }
    return "underlined";
  }

  // tw strike through text looks ugly
  // change CSS if needed
  function twTokenStrike(stream, state) {
    var maybeEnd = false, ch;

    while (ch = stream.next()) {
      if (ch == "-" && maybeEnd) {
        state.tokenize = tokenBase;
        break;
      }
      maybeEnd = (ch == "-");
    }
    return "strikethrough";
  }

  // macro
  function twTokenMacro(stream, state) {
    if (stream.current() == '<<') {
      return 'macro';
    }

    var ch = stream.next();
    if (!ch) {
      state.tokenize = tokenBase;
      return null;
    }
    if (ch == ">") {
      if (stream.peek() == '>') {
        stream.next();
        state.tokenize = tokenBase;
        return "macro";
      }
    }

    stream.eatWhile(/[\w\$_]/);
    return keywords.propertyIsEnumerable(stream.current()) ? "keyword" : null
  }

  // Interface
  return {
    startState: function () {
      return {tokenize: tokenBase};
    },

    token: function (stream, state) {
      if (stream.eatSpace()) return null;
      var style = state.tokenize(stream, state);
      return style;
    }
  };
});

CodeMirror.defineMIME("text/x-tiddlywiki", "tiddlywiki");
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/tiki/tiki.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode('tiki', function(config) {
  function inBlock(style, terminator, returnTokenizer) {
    return function(stream, state) {
      while (!stream.eol()) {
        if (stream.match(terminator)) {
          state.tokenize = inText;
          break;
        }
        stream.next();
      }

      if (returnTokenizer) state.tokenize = returnTokenizer;

      return style;
    };
  }

  function inLine(style) {
    return function(stream, state) {
      while(!stream.eol()) {
        stream.next();
      }
      state.tokenize = inText;
      return style;
    };
  }

  function inText(stream, state) {
    function chain(parser) {
      state.tokenize = parser;
      return parser(stream, state);
    }

    var sol = stream.sol();
    var ch = stream.next();

    //non start of line
    switch (ch) { //switch is generally much faster than if, so it is used here
    case "{": //plugin
      stream.eat("/");
      stream.eatSpace();
      stream.eatWhile(/[^\s\u00a0=\"\'\/?(}]/);
      state.tokenize = inPlugin;
      return "tag";
    case "_": //bold
      if (stream.eat("_"))
        return chain(inBlock("strong", "__", inText));
      break;
    case "'": //italics
      if (stream.eat("'"))
        return chain(inBlock("em", "''", inText));
      break;
    case "(":// Wiki Link
      if (stream.eat("("))
        return chain(inBlock("variable-2", "))", inText));
      break;
    case "[":// Weblink
      return chain(inBlock("variable-3", "]", inText));
      break;
    case "|": //table
      if (stream.eat("|"))
        return chain(inBlock("comment", "||"));
      break;
    case "-":
      if (stream.eat("=")) {//titleBar
        return chain(inBlock("header string", "=-", inText));
      } else if (stream.eat("-")) {//deleted
        return chain(inBlock("error tw-deleted", "--", inText));
      }
      break;
    case "=": //underline
      if (stream.match("=="))
        return chain(inBlock("tw-underline", "===", inText));
      break;
    case ":":
      if (stream.eat(":"))
        return chain(inBlock("comment", "::"));
      break;
    case "^": //box
      return chain(inBlock("tw-box", "^"));
      break;
    case "~": //np
      if (stream.match("np~"))
        return chain(inBlock("meta", "~/np~"));
      break;
    }

    //start of line types
    if (sol) {
      switch (ch) {
      case "!": //header at start of line
        if (stream.match('!!!!!')) {
          return chain(inLine("header string"));
        } else if (stream.match('!!!!')) {
          return chain(inLine("header string"));
        } else if (stream.match('!!!')) {
          return chain(inLine("header string"));
        } else if (stream.match('!!')) {
          return chain(inLine("header string"));
        } else {
          return chain(inLine("header string"));
        }
        break;
      case "*": //unordered list line item, or <li /> at start of line
      case "#": //ordered list line item, or <li /> at start of line
      case "+": //ordered list line item, or <li /> at start of line
        return chain(inLine("tw-listitem bracket"));
        break;
      }
    }

    //stream.eatWhile(/[&{]/); was eating up plugins, turned off to act less like html and more like tiki
    return null;
  }

  var indentUnit = config.indentUnit;

  // Return variables for tokenizers
  var pluginName, type;
  function inPlugin(stream, state) {
    var ch = stream.next();
    var peek = stream.peek();

    if (ch == "}") {
      state.tokenize = inText;
      //type = ch == ")" ? "endPlugin" : "selfclosePlugin"; inPlugin
      return "tag";
    } else if (ch == "(" || ch == ")") {
      return "bracket";
    } else if (ch == "=") {
      type = "equals";

      if (peek == ">") {
        stream.next();
        peek = stream.peek();
      }

      //here we detect values directly after equal character with no quotes
      if (!/[\'\"]/.test(peek)) {
        state.tokenize = inAttributeNoQuote();
      }
      //end detect values

      return "operator";
    } else if (/[\'\"]/.test(ch)) {
      state.tokenize = inAttribute(ch);
      return state.tokenize(stream, state);
    } else {
      stream.eatWhile(/[^\s\u00a0=\"\'\/?]/);
      return "keyword";
    }
  }

  function inAttribute(quote) {
    return function(stream, state) {
      while (!stream.eol()) {
        if (stream.next() == quote) {
          state.tokenize = inPlugin;
          break;
        }
      }
      return "string";
    };
  }

  function inAttributeNoQuote() {
    return function(stream, state) {
      while (!stream.eol()) {
        var ch = stream.next();
        var peek = stream.peek();
        if (ch == " " || ch == "," || /[ )}]/.test(peek)) {
      state.tokenize = inPlugin;
      break;
    }
  }
  return "string";
};
                     }

var curState, setStyle;
function pass() {
  for (var i = arguments.length - 1; i >= 0; i--) curState.cc.push(arguments[i]);
}

function cont() {
  pass.apply(null, arguments);
  return true;
}

function pushContext(pluginName, startOfLine) {
  var noIndent = curState.context && curState.context.noIndent;
  curState.context = {
    prev: curState.context,
    pluginName: pluginName,
    indent: curState.indented,
    startOfLine: startOfLine,
    noIndent: noIndent
  };
}

function popContext() {
  if (curState.context) curState.context = curState.context.prev;
}

function element(type) {
  if (type == "openPlugin") {curState.pluginName = pluginName; return cont(attributes, endplugin(curState.startOfLine));}
  else if (type == "closePlugin") {
    var err = false;
    if (curState.context) {
      err = curState.context.pluginName != pluginName;
      popContext();
    } else {
      err = true;
    }
    if (err) setStyle = "error";
    return cont(endcloseplugin(err));
  }
  else if (type == "string") {
    if (!curState.context || curState.context.name != "!cdata") pushContext("!cdata");
    if (curState.tokenize == inText) popContext();
    return cont();
  }
  else return cont();
}

function endplugin(startOfLine) {
  return function(type) {
    if (
      type == "selfclosePlugin" ||
        type == "endPlugin"
    )
      return cont();
    if (type == "endPlugin") {pushContext(curState.pluginName, startOfLine); return cont();}
    return cont();
  };
}

function endcloseplugin(err) {
  return function(type) {
    if (err) setStyle = "error";
    if (type == "endPlugin") return cont();
    return pass();
  };
}

function attributes(type) {
  if (type == "keyword") {setStyle = "attribute"; return cont(attributes);}
  if (type == "equals") return cont(attvalue, attributes);
  return pass();
}
function attvalue(type) {
  if (type == "keyword") {setStyle = "string"; return cont();}
  if (type == "string") return cont(attvaluemaybe);
  return pass();
}
function attvaluemaybe(type) {
  if (type == "string") return cont(attvaluemaybe);
  else return pass();
}
return {
  startState: function() {
    return {tokenize: inText, cc: [], indented: 0, startOfLine: true, pluginName: null, context: null};
  },
  token: function(stream, state) {
    if (stream.sol()) {
      state.startOfLine = true;
      state.indented = stream.indentation();
    }
    if (stream.eatSpace()) return null;

    setStyle = type = pluginName = null;
    var style = state.tokenize(stream, state);
    if ((style || type) && style != "comment") {
      curState = state;
      while (true) {
        var comb = state.cc.pop() || element;
        if (comb(type || style)) break;
      }
    }
    state.startOfLine = false;
    return setStyle || style;
  },
  indent: function(state, textAfter) {
    var context = state.context;
    if (context && context.noIndent) return 0;
    if (context && /^{\//.test(textAfter))
        context = context.prev;
    while (context && !context.startOfLine)
        context = context.prev;
    if (context) return context.indent + indentUnit;
    else return 0;
  },
  electricChars: "/"
};
});

CodeMirror.defineMIME("text/tiki", "tiki");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/toml/toml.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("toml", function () {
  return {
    startState: function () {
      return {
        inString: false,
        stringType: "",
        lhs: true,
        inArray: 0
      };
    },
    token: function (stream, state) {
      //check for state changes
      if (!state.inString && ((stream.peek() == '"') || (stream.peek() == "'"))) {
        state.stringType = stream.peek();
        stream.next(); // Skip quote
        state.inString = true; // Update state
      }
      if (stream.sol() && state.inArray === 0) {
        state.lhs = true;
      }
      //return state
      if (state.inString) {
        while (state.inString && !stream.eol()) {
          if (stream.peek() === state.stringType) {
            stream.next(); // Skip quote
            state.inString = false; // Clear flag
          } else if (stream.peek() === '\\') {
            stream.next();
            stream.next();
          } else {
            stream.match(/^.[^\\\"\']*/);
          }
        }
        return state.lhs ? "property string" : "string"; // Token style
      } else if (state.inArray && stream.peek() === ']') {
        stream.next();
        state.inArray--;
        return 'bracket';
      } else if (state.lhs && stream.peek() === '[' && stream.skipTo(']')) {
        stream.next();//skip closing ]
        // array of objects has an extra open & close []
        if (stream.peek() === ']') stream.next();
        return "atom";
      } else if (stream.peek() === "#") {
        stream.skipToEnd();
        return "comment";
      } else if (stream.eatSpace()) {
        return null;
      } else if (state.lhs && stream.eatWhile(function (c) { return c != '=' && c != ' '; })) {
        return "property";
      } else if (state.lhs && stream.peek() === "=") {
        stream.next();
        state.lhs = false;
        return null;
      } else if (!state.lhs && stream.match(/^\d\d\d\d[\d\-\:\.T]*Z/)) {
        return 'atom'; //date
      } else if (!state.lhs && (stream.match('true') || stream.match('false'))) {
        return 'atom';
      } else if (!state.lhs && stream.peek() === '[') {
        state.inArray++;
        stream.next();
        return 'bracket';
      } else if (!state.lhs && stream.match(/^\-?\d+(?:\.\d+)?/)) {
        return 'number';
      } else if (!stream.eatSpace()) {
        stream.next();
      }
      return null;
    }
  };
});

CodeMirror.defineMIME('text/x-toml', 'toml');

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/tornado/tornado.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"), __webpack_require__("./src/ipywidgets/node_modules/codemirror/mode/htmlmixed/htmlmixed.js"),
        __webpack_require__("./src/ipywidgets/node_modules/codemirror/addon/mode/overlay.js"));
  else {}
})(function(CodeMirror) {
  "use strict";

  CodeMirror.defineMode("tornado:inner", function() {
    var keywords = ["and","as","assert","autoescape","block","break","class","comment","context",
                    "continue","datetime","def","del","elif","else","end","escape","except",
                    "exec","extends","false","finally","for","from","global","if","import","in",
                    "include","is","json_encode","lambda","length","linkify","load","module",
                    "none","not","or","pass","print","put","raise","raw","return","self","set",
                    "squeeze","super","true","try","url_escape","while","with","without","xhtml_escape","yield"];
    keywords = new RegExp("^((" + keywords.join(")|(") + "))\\b");

    function tokenBase (stream, state) {
      stream.eatWhile(/[^\{]/);
      var ch = stream.next();
      if (ch == "{") {
        if (ch = stream.eat(/\{|%|#/)) {
          state.tokenize = inTag(ch);
          return "tag";
        }
      }
    }
    function inTag (close) {
      if (close == "{") {
        close = "}";
      }
      return function (stream, state) {
        var ch = stream.next();
        if ((ch == close) && stream.eat("}")) {
          state.tokenize = tokenBase;
          return "tag";
        }
        if (stream.match(keywords)) {
          return "keyword";
        }
        return close == "#" ? "comment" : "string";
      };
    }
    return {
      startState: function () {
        return {tokenize: tokenBase};
      },
      token: function (stream, state) {
        return state.tokenize(stream, state);
      }
    };
  });

  CodeMirror.defineMode("tornado", function(config) {
    var htmlBase = CodeMirror.getMode(config, "text/html");
    var tornadoInner = CodeMirror.getMode(config, "tornado:inner");
    return CodeMirror.overlayMode(htmlBase, tornadoInner);
  });

  CodeMirror.defineMIME("text/x-tornado", "tornado");
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/troff/troff.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true)
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode('troff', function() {

  var words = {};

  function tokenBase(stream) {
    if (stream.eatSpace()) return null;

    var sol = stream.sol();
    var ch = stream.next();

    if (ch === '\\') {
      if (stream.match('fB') || stream.match('fR') || stream.match('fI') ||
          stream.match('u')  || stream.match('d')  ||
          stream.match('%')  || stream.match('&')) {
        return 'string';
      }
      if (stream.match('m[')) {
        stream.skipTo(']');
        stream.next();
        return 'string';
      }
      if (stream.match('s+') || stream.match('s-')) {
        stream.eatWhile(/[\d-]/);
        return 'string';
      }
      if (stream.match('\(') || stream.match('*\(')) {
        stream.eatWhile(/[\w-]/);
        return 'string';
      }
      return 'string';
    }
    if (sol && (ch === '.' || ch === '\'')) {
      if (stream.eat('\\') && stream.eat('\"')) {
        stream.skipToEnd();
        return 'comment';
      }
    }
    if (sol && ch === '.') {
      if (stream.match('B ') || stream.match('I ') || stream.match('R ')) {
        return 'attribute';
      }
      if (stream.match('TH ') || stream.match('SH ') || stream.match('SS ') || stream.match('HP ')) {
        stream.skipToEnd();
        return 'quote';
      }
      if ((stream.match(/[A-Z]/) && stream.match(/[A-Z]/)) || (stream.match(/[a-z]/) && stream.match(/[a-z]/))) {
        return 'attribute';
      }
    }
    stream.eatWhile(/[\w-]/);
    var cur = stream.current();
    return words.hasOwnProperty(cur) ? words[cur] : null;
  }

  function tokenize(stream, state) {
    return (state.tokens[0] || tokenBase) (stream, state);
  };

  return {
    startState: function() {return {tokens:[]};},
    token: function(stream, state) {
      return tokenize(stream, state);
    }
  };
});

CodeMirror.defineMIME('text/troff', 'troff');
CodeMirror.defineMIME('text/x-troff', 'troff');
CodeMirror.defineMIME('application/x-troff', 'troff');

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/ttcn-cfg/ttcn-cfg.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
  "use strict";

  CodeMirror.defineMode("ttcn-cfg", function(config, parserConfig) {
    var indentUnit = config.indentUnit,
        keywords = parserConfig.keywords || {},
        fileNCtrlMaskOptions = parserConfig.fileNCtrlMaskOptions || {},
        externalCommands = parserConfig.externalCommands || {},
        multiLineStrings = parserConfig.multiLineStrings,
        indentStatements = parserConfig.indentStatements !== false;
    var isOperatorChar = /[\|]/;
    var curPunc;

    function tokenBase(stream, state) {
      var ch = stream.next();
      if (ch == '"' || ch == "'") {
        state.tokenize = tokenString(ch);
        return state.tokenize(stream, state);
      }
      if (/[:=]/.test(ch)) {
        curPunc = ch;
        return "punctuation";
      }
      if (ch == "#"){
        stream.skipToEnd();
        return "comment";
      }
      if (/\d/.test(ch)) {
        stream.eatWhile(/[\w\.]/);
        return "number";
      }
      if (isOperatorChar.test(ch)) {
        stream.eatWhile(isOperatorChar);
        return "operator";
      }
      if (ch == "["){
        stream.eatWhile(/[\w_\]]/);
        return "number sectionTitle";
      }

      stream.eatWhile(/[\w\$_]/);
      var cur = stream.current();
      if (keywords.propertyIsEnumerable(cur)) return "keyword";
      if (fileNCtrlMaskOptions.propertyIsEnumerable(cur))
        return "negative fileNCtrlMaskOptions";
      if (externalCommands.propertyIsEnumerable(cur)) return "negative externalCommands";

      return "variable";
    }

    function tokenString(quote) {
      return function(stream, state) {
        var escaped = false, next, end = false;
        while ((next = stream.next()) != null) {
          if (next == quote && !escaped){
            var afterNext = stream.peek();
            //look if the character if the quote is like the B in '10100010'B
            if (afterNext){
              afterNext = afterNext.toLowerCase();
              if(afterNext == "b" || afterNext == "h" || afterNext == "o")
                stream.next();
            }
            end = true; break;
          }
          escaped = !escaped && next == "\\";
        }
        if (end || !(escaped || multiLineStrings))
          state.tokenize = null;
        return "string";
      };
    }

    function Context(indented, column, type, align, prev) {
      this.indented = indented;
      this.column = column;
      this.type = type;
      this.align = align;
      this.prev = prev;
    }
    function pushContext(state, col, type) {
      var indent = state.indented;
      if (state.context && state.context.type == "statement")
        indent = state.context.indented;
      return state.context = new Context(indent, col, type, null, state.context);
    }
    function popContext(state) {
      var t = state.context.type;
      if (t == ")" || t == "]" || t == "}")
        state.indented = state.context.indented;
      return state.context = state.context.prev;
    }

    //Interface
    return {
      startState: function(basecolumn) {
        return {
          tokenize: null,
          context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),
          indented: 0,
          startOfLine: true
        };
      },

      token: function(stream, state) {
        var ctx = state.context;
        if (stream.sol()) {
          if (ctx.align == null) ctx.align = false;
          state.indented = stream.indentation();
          state.startOfLine = true;
        }
        if (stream.eatSpace()) return null;
        curPunc = null;
        var style = (state.tokenize || tokenBase)(stream, state);
        if (style == "comment") return style;
        if (ctx.align == null) ctx.align = true;

        if ((curPunc == ";" || curPunc == ":" || curPunc == ",")
            && ctx.type == "statement"){
          popContext(state);
        }
        else if (curPunc == "{") pushContext(state, stream.column(), "}");
        else if (curPunc == "[") pushContext(state, stream.column(), "]");
        else if (curPunc == "(") pushContext(state, stream.column(), ")");
        else if (curPunc == "}") {
          while (ctx.type == "statement") ctx = popContext(state);
          if (ctx.type == "}") ctx = popContext(state);
          while (ctx.type == "statement") ctx = popContext(state);
        }
        else if (curPunc == ctx.type) popContext(state);
        else if (indentStatements && (((ctx.type == "}" || ctx.type == "top")
            && curPunc != ';') || (ctx.type == "statement"
            && curPunc == "newstatement")))
          pushContext(state, stream.column(), "statement");
        state.startOfLine = false;
        return style;
      },

      electricChars: "{}",
      lineComment: "#",
      fold: "brace"
    };
  });

  function words(str) {
    var obj = {}, words = str.split(" ");
    for (var i = 0; i < words.length; ++i)
      obj[words[i]] = true;
    return obj;
  }

  CodeMirror.defineMIME("text/x-ttcn-cfg", {
    name: "ttcn-cfg",
    keywords: words("Yes No LogFile FileMask ConsoleMask AppendFile" +
    " TimeStampFormat LogEventTypes SourceInfoFormat" +
    " LogEntityName LogSourceInfo DiskFullAction" +
    " LogFileNumber LogFileSize MatchingHints Detailed" +
    " Compact SubCategories Stack Single None Seconds" +
    " DateTime Time Stop Error Retry Delete TCPPort KillTimer" +
    " NumHCs UnixSocketsEnabled LocalAddress"),
    fileNCtrlMaskOptions: words("TTCN_EXECUTOR TTCN_ERROR TTCN_WARNING" +
    " TTCN_PORTEVENT TTCN_TIMEROP TTCN_VERDICTOP" +
    " TTCN_DEFAULTOP TTCN_TESTCASE TTCN_ACTION" +
    " TTCN_USER TTCN_FUNCTION TTCN_STATISTICS" +
    " TTCN_PARALLEL TTCN_MATCHING TTCN_DEBUG" +
    " EXECUTOR ERROR WARNING PORTEVENT TIMEROP" +
    " VERDICTOP DEFAULTOP TESTCASE ACTION USER" +
    " FUNCTION STATISTICS PARALLEL MATCHING DEBUG" +
    " LOG_ALL LOG_NOTHING ACTION_UNQUALIFIED" +
    " DEBUG_ENCDEC DEBUG_TESTPORT" +
    " DEBUG_UNQUALIFIED DEFAULTOP_ACTIVATE" +
    " DEFAULTOP_DEACTIVATE DEFAULTOP_EXIT" +
    " DEFAULTOP_UNQUALIFIED ERROR_UNQUALIFIED" +
    " EXECUTOR_COMPONENT EXECUTOR_CONFIGDATA" +
    " EXECUTOR_EXTCOMMAND EXECUTOR_LOGOPTIONS" +
    " EXECUTOR_RUNTIME EXECUTOR_UNQUALIFIED" +
    " FUNCTION_RND FUNCTION_UNQUALIFIED" +
    " MATCHING_DONE MATCHING_MCSUCCESS" +
    " MATCHING_MCUNSUCC MATCHING_MMSUCCESS" +
    " MATCHING_MMUNSUCC MATCHING_PCSUCCESS" +
    " MATCHING_PCUNSUCC MATCHING_PMSUCCESS" +
    " MATCHING_PMUNSUCC MATCHING_PROBLEM" +
    " MATCHING_TIMEOUT MATCHING_UNQUALIFIED" +
    " PARALLEL_PORTCONN PARALLEL_PORTMAP" +
    " PARALLEL_PTC PARALLEL_UNQUALIFIED" +
    " PORTEVENT_DUALRECV PORTEVENT_DUALSEND" +
    " PORTEVENT_MCRECV PORTEVENT_MCSEND" +
    " PORTEVENT_MMRECV PORTEVENT_MMSEND" +
    " PORTEVENT_MQUEUE PORTEVENT_PCIN" +
    " PORTEVENT_PCOUT PORTEVENT_PMIN" +
    " PORTEVENT_PMOUT PORTEVENT_PQUEUE" +
    " PORTEVENT_STATE PORTEVENT_UNQUALIFIED" +
    " STATISTICS_UNQUALIFIED STATISTICS_VERDICT" +
    " TESTCASE_FINISH TESTCASE_START" +
    " TESTCASE_UNQUALIFIED TIMEROP_GUARD" +
    " TIMEROP_READ TIMEROP_START TIMEROP_STOP" +
    " TIMEROP_TIMEOUT TIMEROP_UNQUALIFIED" +
    " USER_UNQUALIFIED VERDICTOP_FINAL" +
    " VERDICTOP_GETVERDICT VERDICTOP_SETVERDICT" +
    " VERDICTOP_UNQUALIFIED WARNING_UNQUALIFIED"),
    externalCommands: words("BeginControlPart EndControlPart BeginTestCase" +
    " EndTestCase"),
    multiLineStrings: true
  });
});

/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/ttcn/ttcn.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
  "use strict";

  CodeMirror.defineMode("ttcn", function(config, parserConfig) {
    var indentUnit = config.indentUnit,
        keywords = parserConfig.keywords || {},
        builtin = parserConfig.builtin || {},
        timerOps = parserConfig.timerOps || {},
        portOps  = parserConfig.portOps || {},
        configOps = parserConfig.configOps || {},
        verdictOps = parserConfig.verdictOps || {},
        sutOps = parserConfig.sutOps || {},
        functionOps = parserConfig.functionOps || {},

        verdictConsts = parserConfig.verdictConsts || {},
        booleanConsts = parserConfig.booleanConsts || {},
        otherConsts   = parserConfig.otherConsts || {},

        types = parserConfig.types || {},
        visibilityModifiers = parserConfig.visibilityModifiers || {},
        templateMatch = parserConfig.templateMatch || {},
        multiLineStrings = parserConfig.multiLineStrings,
        indentStatements = parserConfig.indentStatements !== false;
    var isOperatorChar = /[+\-*&@=<>!\/]/;
    var curPunc;

    function tokenBase(stream, state) {
      var ch = stream.next();

      if (ch == '"' || ch == "'") {
        state.tokenize = tokenString(ch);
        return state.tokenize(stream, state);
      }
      if (/[\[\]{}\(\),;\\:\?\.]/.test(ch)) {
        curPunc = ch;
        return "punctuation";
      }
      if (ch == "#"){
        stream.skipToEnd();
        return "atom preprocessor";
      }
      if (ch == "%"){
        stream.eatWhile(/\b/);
        return "atom ttcn3Macros";
      }
      if (/\d/.test(ch)) {
        stream.eatWhile(/[\w\.]/);
        return "number";
      }
      if (ch == "/") {
        if (stream.eat("*")) {
          state.tokenize = tokenComment;
          return tokenComment(stream, state);
        }
        if (stream.eat("/")) {
          stream.skipToEnd();
          return "comment";
        }
      }
      if (isOperatorChar.test(ch)) {
        if(ch == "@"){
          if(stream.match("try") || stream.match("catch")
              || stream.match("lazy")){
            return "keyword";
          }
        }
        stream.eatWhile(isOperatorChar);
        return "operator";
      }
      stream.eatWhile(/[\w\$_\xa1-\uffff]/);
      var cur = stream.current();

      if (keywords.propertyIsEnumerable(cur)) return "keyword";
      if (builtin.propertyIsEnumerable(cur)) return "builtin";

      if (timerOps.propertyIsEnumerable(cur)) return "def timerOps";
      if (configOps.propertyIsEnumerable(cur)) return "def configOps";
      if (verdictOps.propertyIsEnumerable(cur)) return "def verdictOps";
      if (portOps.propertyIsEnumerable(cur)) return "def portOps";
      if (sutOps.propertyIsEnumerable(cur)) return "def sutOps";
      if (functionOps.propertyIsEnumerable(cur)) return "def functionOps";

      if (verdictConsts.propertyIsEnumerable(cur)) return "string verdictConsts";
      if (booleanConsts.propertyIsEnumerable(cur)) return "string booleanConsts";
      if (otherConsts.propertyIsEnumerable(cur)) return "string otherConsts";

      if (types.propertyIsEnumerable(cur)) return "builtin types";
      if (visibilityModifiers.propertyIsEnumerable(cur))
        return "builtin visibilityModifiers";
      if (templateMatch.propertyIsEnumerable(cur)) return "atom templateMatch";

      return "variable";
    }

    function tokenString(quote) {
      return function(stream, state) {
        var escaped = false, next, end = false;
        while ((next = stream.next()) != null) {
          if (next == quote && !escaped){
            var afterQuote = stream.peek();
            //look if the character after the quote is like the B in '10100010'B
            if (afterQuote){
              afterQuote = afterQuote.toLowerCase();
              if(afterQuote == "b" || afterQuote == "h" || afterQuote == "o")
                stream.next();
            }
            end = true; break;
          }
          escaped = !escaped && next == "\\";
        }
        if (end || !(escaped || multiLineStrings))
          state.tokenize = null;
        return "string";
      };
    }

    function tokenComment(stream, state) {
      var maybeEnd = false, ch;
      while (ch = stream.next()) {
        if (ch == "/" && maybeEnd) {
          state.tokenize = null;
          break;
        }
        maybeEnd = (ch == "*");
      }
      return "comment";
    }

    function Context(indented, column, type, align, prev) {
      this.indented = indented;
      this.column = column;
      this.type = type;
      this.align = align;
      this.prev = prev;
    }

    function pushContext(state, col, type) {
      var indent = state.indented;
      if (state.context && state.context.type == "statement")
        indent = state.context.indented;
      return state.context = new Context(indent, col, type, null, state.context);
    }

    function popContext(state) {
      var t = state.context.type;
      if (t == ")" || t == "]" || t == "}")
        state.indented = state.context.indented;
      return state.context = state.context.prev;
    }

    //Interface
    return {
      startState: function(basecolumn) {
        return {
          tokenize: null,
          context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),
          indented: 0,
          startOfLine: true
        };
      },

      token: function(stream, state) {
        var ctx = state.context;
        if (stream.sol()) {
          if (ctx.align == null) ctx.align = false;
          state.indented = stream.indentation();
          state.startOfLine = true;
        }
        if (stream.eatSpace()) return null;
        curPunc = null;
        var style = (state.tokenize || tokenBase)(stream, state);
        if (style == "comment") return style;
        if (ctx.align == null) ctx.align = true;

        if ((curPunc == ";" || curPunc == ":" || curPunc == ",")
            && ctx.type == "statement"){
          popContext(state);
        }
        else if (curPunc == "{") pushContext(state, stream.column(), "}");
        else if (curPunc == "[") pushContext(state, stream.column(), "]");
        else if (curPunc == "(") pushContext(state, stream.column(), ")");
        else if (curPunc == "}") {
          while (ctx.type == "statement") ctx = popContext(state);
          if (ctx.type == "}") ctx = popContext(state);
          while (ctx.type == "statement") ctx = popContext(state);
        }
        else if (curPunc == ctx.type) popContext(state);
        else if (indentStatements &&
            (((ctx.type == "}" || ctx.type == "top") && curPunc != ';') ||
            (ctx.type == "statement" && curPunc == "newstatement")))
          pushContext(state, stream.column(), "statement");

        state.startOfLine = false;

        return style;
      },

      electricChars: "{}",
      blockCommentStart: "/*",
      blockCommentEnd: "*/",
      lineComment: "//",
      fold: "brace"
    };
  });

  function words(str) {
    var obj = {}, words = str.split(" ");
    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
    return obj;
  }

  function def(mimes, mode) {
    if (typeof mimes == "string") mimes = [mimes];
    var words = [];
    function add(obj) {
      if (obj) for (var prop in obj) if (obj.hasOwnProperty(prop))
        words.push(prop);
    }

    add(mode.keywords);
    add(mode.builtin);
    add(mode.timerOps);
    add(mode.portOps);

    if (words.length) {
      mode.helperType = mimes[0];
      CodeMirror.registerHelper("hintWords", mimes[0], words);
    }

    for (var i = 0; i < mimes.length; ++i)
      CodeMirror.defineMIME(mimes[i], mode);
  }

  def(["text/x-ttcn", "text/x-ttcn3", "text/x-ttcnpp"], {
    name: "ttcn",
    keywords: words("activate address alive all alt altstep and and4b any" +
    " break case component const continue control deactivate" +
    " display do else encode enumerated except exception" +
    " execute extends extension external for from function" +
    " goto group if import in infinity inout interleave" +
    " label language length log match message mixed mod" +
    " modifies module modulepar mtc noblock not not4b nowait" +
    " of on optional or or4b out override param pattern port" +
    " procedure record recursive rem repeat return runs select" +
    " self sender set signature system template testcase to" +
    " type union value valueof var variant while with xor xor4b"),
    builtin: words("bit2hex bit2int bit2oct bit2str char2int char2oct encvalue" +
    " decomp decvalue float2int float2str hex2bit hex2int" +
    " hex2oct hex2str int2bit int2char int2float int2hex" +
    " int2oct int2str int2unichar isbound ischosen ispresent" +
    " isvalue lengthof log2str oct2bit oct2char oct2hex oct2int" +
    " oct2str regexp replace rnd sizeof str2bit str2float" +
    " str2hex str2int str2oct substr unichar2int unichar2char" +
    " enum2int"),
    types: words("anytype bitstring boolean char charstring default float" +
    " hexstring integer objid octetstring universal verdicttype timer"),
    timerOps: words("read running start stop timeout"),
    portOps: words("call catch check clear getcall getreply halt raise receive" +
    " reply send trigger"),
    configOps: words("create connect disconnect done kill killed map unmap"),
    verdictOps: words("getverdict setverdict"),
    sutOps: words("action"),
    functionOps: words("apply derefers refers"),

    verdictConsts: words("error fail inconc none pass"),
    booleanConsts: words("true false"),
    otherConsts: words("null NULL omit"),

    visibilityModifiers: words("private public friend"),
    templateMatch: words("complement ifpresent subset superset permutation"),
    multiLineStrings: true
  });
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/turtle/turtle.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("turtle", function(config) {
  var indentUnit = config.indentUnit;
  var curPunc;

  function wordRegexp(words) {
    return new RegExp("^(?:" + words.join("|") + ")$", "i");
  }
  var ops = wordRegexp([]);
  var keywords = wordRegexp(["@prefix", "@base", "a"]);
  var operatorChars = /[*+\-<>=&|]/;

  function tokenBase(stream, state) {
    var ch = stream.next();
    curPunc = null;
    if (ch == "<" && !stream.match(/^[\s\u00a0=]/, false)) {
      stream.match(/^[^\s\u00a0>]*>?/);
      return "atom";
    }
    else if (ch == "\"" || ch == "'") {
      state.tokenize = tokenLiteral(ch);
      return state.tokenize(stream, state);
    }
    else if (/[{}\(\),\.;\[\]]/.test(ch)) {
      curPunc = ch;
      return null;
    }
    else if (ch == "#") {
      stream.skipToEnd();
      return "comment";
    }
    else if (operatorChars.test(ch)) {
      stream.eatWhile(operatorChars);
      return null;
    }
    else if (ch == ":") {
          return "operator";
        } else {
      stream.eatWhile(/[_\w\d]/);
      if(stream.peek() == ":") {
        return "variable-3";
      } else {
             var word = stream.current();

             if(keywords.test(word)) {
                        return "meta";
             }

             if(ch >= "A" && ch <= "Z") {
                    return "comment";
                 } else {
                        return "keyword";
                 }
      }
      var word = stream.current();
      if (ops.test(word))
        return null;
      else if (keywords.test(word))
        return "meta";
      else
        return "variable";
    }
  }

  function tokenLiteral(quote) {
    return function(stream, state) {
      var escaped = false, ch;
      while ((ch = stream.next()) != null) {
        if (ch == quote && !escaped) {
          state.tokenize = tokenBase;
          break;
        }
        escaped = !escaped && ch == "\\";
      }
      return "string";
    };
  }

  function pushContext(state, type, col) {
    state.context = {prev: state.context, indent: state.indent, col: col, type: type};
  }
  function popContext(state) {
    state.indent = state.context.indent;
    state.context = state.context.prev;
  }

  return {
    startState: function() {
      return {tokenize: tokenBase,
              context: null,
              indent: 0,
              col: 0};
    },

    token: function(stream, state) {
      if (stream.sol()) {
        if (state.context && state.context.align == null) state.context.align = false;
        state.indent = stream.indentation();
      }
      if (stream.eatSpace()) return null;
      var style = state.tokenize(stream, state);

      if (style != "comment" && state.context && state.context.align == null && state.context.type != "pattern") {
        state.context.align = true;
      }

      if (curPunc == "(") pushContext(state, ")", stream.column());
      else if (curPunc == "[") pushContext(state, "]", stream.column());
      else if (curPunc == "{") pushContext(state, "}", stream.column());
      else if (/[\]\}\)]/.test(curPunc)) {
        while (state.context && state.context.type == "pattern") popContext(state);
        if (state.context && curPunc == state.context.type) popContext(state);
      }
      else if (curPunc == "." && state.context && state.context.type == "pattern") popContext(state);
      else if (/atom|string|variable/.test(style) && state.context) {
        if (/[\}\]]/.test(state.context.type))
          pushContext(state, "pattern", stream.column());
        else if (state.context.type == "pattern" && !state.context.align) {
          state.context.align = true;
          state.context.col = stream.column();
        }
      }

      return style;
    },

    indent: function(state, textAfter) {
      var firstChar = textAfter && textAfter.charAt(0);
      var context = state.context;
      if (/[\]\}]/.test(firstChar))
        while (context && context.type == "pattern") context = context.prev;

      var closing = context && firstChar == context.type;
      if (!context)
        return 0;
      else if (context.type == "pattern")
        return context.col;
      else if (context.align)
        return context.col + (closing ? 0 : 1);
      else
        return context.indent + (closing ? 0 : indentUnit);
    },

    lineComment: "#"
  };
});

CodeMirror.defineMIME("text/turtle", "turtle");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/twig/twig.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"),  __webpack_require__("./src/ipywidgets/node_modules/codemirror/addon/mode/multiplex.js"));
  else {}
})(function(CodeMirror) {
  "use strict";

  CodeMirror.defineMode("twig:inner", function() {
    var keywords = ["and", "as", "autoescape", "endautoescape", "block", "do", "endblock", "else", "elseif", "extends", "for", "endfor", "embed", "endembed", "filter", "endfilter", "flush", "from", "if", "endif", "in", "is", "include", "import", "not", "or", "set", "spaceless", "endspaceless", "with", "endwith", "trans", "endtrans", "blocktrans", "endblocktrans", "macro", "endmacro", "use", "verbatim", "endverbatim"],
        operator = /^[+\-*&%=<>!?|~^]/,
        sign = /^[:\[\(\{]/,
        atom = ["true", "false", "null", "empty", "defined", "divisibleby", "divisible by", "even", "odd", "iterable", "sameas", "same as"],
        number = /^(\d[+\-\*\/])?\d+(\.\d+)?/;

    keywords = new RegExp("((" + keywords.join(")|(") + "))\\b");
    atom = new RegExp("((" + atom.join(")|(") + "))\\b");

    function tokenBase (stream, state) {
      var ch = stream.peek();

      //Comment
      if (state.incomment) {
        if (!stream.skipTo("#}")) {
          stream.skipToEnd();
        } else {
          stream.eatWhile(/\#|}/);
          state.incomment = false;
        }
        return "comment";
      //Tag
      } else if (state.intag) {
        //After operator
        if (state.operator) {
          state.operator = false;
          if (stream.match(atom)) {
            return "atom";
          }
          if (stream.match(number)) {
            return "number";
          }
        }
        //After sign
        if (state.sign) {
          state.sign = false;
          if (stream.match(atom)) {
            return "atom";
          }
          if (stream.match(number)) {
            return "number";
          }
        }

        if (state.instring) {
          if (ch == state.instring) {
            state.instring = false;
          }
          stream.next();
          return "string";
        } else if (ch == "'" || ch == '"') {
          state.instring = ch;
          stream.next();
          return "string";
        } else if (stream.match(state.intag + "}") || stream.eat("-") && stream.match(state.intag + "}")) {
          state.intag = false;
          return "tag";
        } else if (stream.match(operator)) {
          state.operator = true;
          return "operator";
        } else if (stream.match(sign)) {
          state.sign = true;
        } else {
          if (stream.eat(" ") || stream.sol()) {
            if (stream.match(keywords)) {
              return "keyword";
            }
            if (stream.match(atom)) {
              return "atom";
            }
            if (stream.match(number)) {
              return "number";
            }
            if (stream.sol()) {
              stream.next();
            }
          } else {
            stream.next();
          }

        }
        return "variable";
      } else if (stream.eat("{")) {
        if (stream.eat("#")) {
          state.incomment = true;
          if (!stream.skipTo("#}")) {
            stream.skipToEnd();
          } else {
            stream.eatWhile(/\#|}/);
            state.incomment = false;
          }
          return "comment";
        //Open tag
        } else if (ch = stream.eat(/\{|%/)) {
          //Cache close tag
          state.intag = ch;
          if (ch == "{") {
            state.intag = "}";
          }
          stream.eat("-");
          return "tag";
        }
      }
      stream.next();
    };

    return {
      startState: function () {
        return {};
      },
      token: function (stream, state) {
        return tokenBase(stream, state);
      }
    };
  });

  CodeMirror.defineMode("twig", function(config, parserConfig) {
    var twigInner = CodeMirror.getMode(config, "twig:inner");
    if (!parserConfig || !parserConfig.base) return twigInner;
    return CodeMirror.multiplexingMode(
      CodeMirror.getMode(config, parserConfig.base), {
        open: /\{[{#%]/, close: /[}#%]\}/, mode: twigInner, parseDelimiters: true
      }
    );
  });
  CodeMirror.defineMIME("text/x-twig", "twig");
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/vb/vb.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("vb", function(conf, parserConf) {
    var ERRORCLASS = 'error';

    function wordRegexp(words) {
        return new RegExp("^((" + words.join(")|(") + "))\\b", "i");
    }

    var singleOperators = new RegExp("^[\\+\\-\\*/%&\\\\|\\^~<>!]");
    var singleDelimiters = new RegExp('^[\\(\\)\\[\\]\\{\\}@,:`=;\\.]');
    var doubleOperators = new RegExp("^((==)|(<>)|(<=)|(>=)|(<>)|(<<)|(>>)|(//)|(\\*\\*))");
    var doubleDelimiters = new RegExp("^((\\+=)|(\\-=)|(\\*=)|(%=)|(/=)|(&=)|(\\|=)|(\\^=))");
    var tripleDelimiters = new RegExp("^((//=)|(>>=)|(<<=)|(\\*\\*=))");
    var identifiers = new RegExp("^[_A-Za-z][_A-Za-z0-9]*");

    var openingKeywords = ['class','module', 'sub','enum','select','while','if','function', 'get','set','property', 'try', 'structure', 'synclock', 'using', 'with'];
    var middleKeywords = ['else','elseif','case', 'catch', 'finally'];
    var endKeywords = ['next','loop'];

    var operatorKeywords = ['and', "andalso", 'or', 'orelse', 'xor', 'in', 'not', 'is', 'isnot', 'like'];
    var wordOperators = wordRegexp(operatorKeywords);

    var commonKeywords = ["#const", "#else", "#elseif", "#end", "#if", "#region", "addhandler", "addressof", "alias", "as", "byref", "byval", "cbool", "cbyte", "cchar", "cdate", "cdbl", "cdec", "cint", "clng", "cobj", "compare", "const", "continue", "csbyte", "cshort", "csng", "cstr", "cuint", "culng", "cushort", "declare", "default", "delegate", "dim", "directcast", "each", "erase", "error", "event", "exit", "explicit", "false", "for", "friend", "gettype", "goto", "handles", "implements", "imports", "infer", "inherits", "interface", "isfalse", "istrue", "lib", "me", "mod", "mustinherit", "mustoverride", "my", "mybase", "myclass", "namespace", "narrowing", "new", "nothing", "notinheritable", "notoverridable", "of", "off", "on", "operator", "option", "optional", "out", "overloads", "overridable", "overrides", "paramarray", "partial", "private", "protected", "public", "raiseevent", "readonly", "redim", "removehandler", "resume", "return", "shadows", "shared", "static", "step", "stop", "strict", "then", "throw", "to", "true", "trycast", "typeof", "until", "until", "when", "widening", "withevents", "writeonly"];

    var commontypes = ['object', 'boolean', 'char', 'string', 'byte', 'sbyte', 'short', 'ushort', 'int16', 'uint16', 'integer', 'uinteger', 'int32', 'uint32', 'long', 'ulong', 'int64', 'uint64', 'decimal', 'single', 'double', 'float', 'date', 'datetime', 'intptr', 'uintptr'];

    var keywords = wordRegexp(commonKeywords);
    var types = wordRegexp(commontypes);
    var stringPrefixes = '"';

    var opening = wordRegexp(openingKeywords);
    var middle = wordRegexp(middleKeywords);
    var closing = wordRegexp(endKeywords);
    var doubleClosing = wordRegexp(['end']);
    var doOpening = wordRegexp(['do']);

    var indentInfo = null;

    CodeMirror.registerHelper("hintWords", "vb", openingKeywords.concat(middleKeywords).concat(endKeywords)
                                .concat(operatorKeywords).concat(commonKeywords).concat(commontypes));

    function indent(_stream, state) {
      state.currentIndent++;
    }

    function dedent(_stream, state) {
      state.currentIndent--;
    }
    // tokenizers
    function tokenBase(stream, state) {
        if (stream.eatSpace()) {
            return null;
        }

        var ch = stream.peek();

        // Handle Comments
        if (ch === "'") {
            stream.skipToEnd();
            return 'comment';
        }


        // Handle Number Literals
        if (stream.match(/^((&H)|(&O))?[0-9\.a-f]/i, false)) {
            var floatLiteral = false;
            // Floats
            if (stream.match(/^\d*\.\d+F?/i)) { floatLiteral = true; }
            else if (stream.match(/^\d+\.\d*F?/)) { floatLiteral = true; }
            else if (stream.match(/^\.\d+F?/)) { floatLiteral = true; }

            if (floatLiteral) {
                // Float literals may be "imaginary"
                stream.eat(/J/i);
                return 'number';
            }
            // Integers
            var intLiteral = false;
            // Hex
            if (stream.match(/^&H[0-9a-f]+/i)) { intLiteral = true; }
            // Octal
            else if (stream.match(/^&O[0-7]+/i)) { intLiteral = true; }
            // Decimal
            else if (stream.match(/^[1-9]\d*F?/)) {
                // Decimal literals may be "imaginary"
                stream.eat(/J/i);
                // TODO - Can you have imaginary longs?
                intLiteral = true;
            }
            // Zero by itself with no other piece of number.
            else if (stream.match(/^0(?![\dx])/i)) { intLiteral = true; }
            if (intLiteral) {
                // Integer literals may be "long"
                stream.eat(/L/i);
                return 'number';
            }
        }

        // Handle Strings
        if (stream.match(stringPrefixes)) {
            state.tokenize = tokenStringFactory(stream.current());
            return state.tokenize(stream, state);
        }

        // Handle operators and Delimiters
        if (stream.match(tripleDelimiters) || stream.match(doubleDelimiters)) {
            return null;
        }
        if (stream.match(doubleOperators)
            || stream.match(singleOperators)
            || stream.match(wordOperators)) {
            return 'operator';
        }
        if (stream.match(singleDelimiters)) {
            return null;
        }
        if (stream.match(doOpening)) {
            indent(stream,state);
            state.doInCurrentLine = true;
            return 'keyword';
        }
        if (stream.match(opening)) {
            if (! state.doInCurrentLine)
              indent(stream,state);
            else
              state.doInCurrentLine = false;
            return 'keyword';
        }
        if (stream.match(middle)) {
            return 'keyword';
        }

        if (stream.match(doubleClosing)) {
            dedent(stream,state);
            dedent(stream,state);
            return 'keyword';
        }
        if (stream.match(closing)) {
            dedent(stream,state);
            return 'keyword';
        }

        if (stream.match(types)) {
            return 'keyword';
        }

        if (stream.match(keywords)) {
            return 'keyword';
        }

        if (stream.match(identifiers)) {
            return 'variable';
        }

        // Handle non-detected items
        stream.next();
        return ERRORCLASS;
    }

    function tokenStringFactory(delimiter) {
        var singleline = delimiter.length == 1;
        var OUTCLASS = 'string';

        return function(stream, state) {
            while (!stream.eol()) {
                stream.eatWhile(/[^'"]/);
                if (stream.match(delimiter)) {
                    state.tokenize = tokenBase;
                    return OUTCLASS;
                } else {
                    stream.eat(/['"]/);
                }
            }
            if (singleline) {
                if (parserConf.singleLineStringErrors) {
                    return ERRORCLASS;
                } else {
                    state.tokenize = tokenBase;
                }
            }
            return OUTCLASS;
        };
    }


    function tokenLexer(stream, state) {
        var style = state.tokenize(stream, state);
        var current = stream.current();

        // Handle '.' connected identifiers
        if (current === '.') {
            style = state.tokenize(stream, state);
            if (style === 'variable') {
                return 'variable';
            } else {
                return ERRORCLASS;
            }
        }


        var delimiter_index = '[({'.indexOf(current);
        if (delimiter_index !== -1) {
            indent(stream, state );
        }
        if (indentInfo === 'dedent') {
            if (dedent(stream, state)) {
                return ERRORCLASS;
            }
        }
        delimiter_index = '])}'.indexOf(current);
        if (delimiter_index !== -1) {
            if (dedent(stream, state)) {
                return ERRORCLASS;
            }
        }

        return style;
    }

    var external = {
        electricChars:"dDpPtTfFeE ",
        startState: function() {
            return {
              tokenize: tokenBase,
              lastToken: null,
              currentIndent: 0,
              nextLineIndent: 0,
              doInCurrentLine: false


          };
        },

        token: function(stream, state) {
            if (stream.sol()) {
              state.currentIndent += state.nextLineIndent;
              state.nextLineIndent = 0;
              state.doInCurrentLine = 0;
            }
            var style = tokenLexer(stream, state);

            state.lastToken = {style:style, content: stream.current()};



            return style;
        },

        indent: function(state, textAfter) {
            var trueText = textAfter.replace(/^\s+|\s+$/g, '') ;
            if (trueText.match(closing) || trueText.match(doubleClosing) || trueText.match(middle)) return conf.indentUnit*(state.currentIndent-1);
            if(state.currentIndent < 0) return 0;
            return state.currentIndent * conf.indentUnit;
        },

        lineComment: "'"
    };
    return external;
});

CodeMirror.defineMIME("text/x-vb", "vb");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/vbscript/vbscript.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

/*
For extra ASP classic objects, initialize CodeMirror instance with this option:
    isASP: true

E.G.:
    var editor = CodeMirror.fromTextArea(document.getElementById("code"), {
        lineNumbers: true,
        isASP: true
      });
*/

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("vbscript", function(conf, parserConf) {
    var ERRORCLASS = 'error';

    function wordRegexp(words) {
        return new RegExp("^((" + words.join(")|(") + "))\\b", "i");
    }

    var singleOperators = new RegExp("^[\\+\\-\\*/&\\\\\\^<>=]");
    var doubleOperators = new RegExp("^((<>)|(<=)|(>=))");
    var singleDelimiters = new RegExp('^[\\.,]');
    var brackets = new RegExp('^[\\(\\)]');
    var identifiers = new RegExp("^[A-Za-z][_A-Za-z0-9]*");

    var openingKeywords = ['class','sub','select','while','if','function', 'property', 'with', 'for'];
    var middleKeywords = ['else','elseif','case'];
    var endKeywords = ['next','loop','wend'];

    var wordOperators = wordRegexp(['and', 'or', 'not', 'xor', 'is', 'mod', 'eqv', 'imp']);
    var commonkeywords = ['dim', 'redim', 'then',  'until', 'randomize',
                          'byval','byref','new','property', 'exit', 'in',
                          'const','private', 'public',
                          'get','set','let', 'stop', 'on error resume next', 'on error goto 0', 'option explicit', 'call', 'me'];

    //This list was from: http://msdn.microsoft.com/en-us/library/f8tbc79x(v=vs.84).aspx
    var atomWords = ['true', 'false', 'nothing', 'empty', 'null'];
    //This list was from: http://msdn.microsoft.com/en-us/library/3ca8tfek(v=vs.84).aspx
    var builtinFuncsWords = ['abs', 'array', 'asc', 'atn', 'cbool', 'cbyte', 'ccur', 'cdate', 'cdbl', 'chr', 'cint', 'clng', 'cos', 'csng', 'cstr', 'date', 'dateadd', 'datediff', 'datepart',
                        'dateserial', 'datevalue', 'day', 'escape', 'eval', 'execute', 'exp', 'filter', 'formatcurrency', 'formatdatetime', 'formatnumber', 'formatpercent', 'getlocale', 'getobject',
                        'getref', 'hex', 'hour', 'inputbox', 'instr', 'instrrev', 'int', 'fix', 'isarray', 'isdate', 'isempty', 'isnull', 'isnumeric', 'isobject', 'join', 'lbound', 'lcase', 'left',
                        'len', 'loadpicture', 'log', 'ltrim', 'rtrim', 'trim', 'maths', 'mid', 'minute', 'month', 'monthname', 'msgbox', 'now', 'oct', 'replace', 'rgb', 'right', 'rnd', 'round',
                        'scriptengine', 'scriptenginebuildversion', 'scriptenginemajorversion', 'scriptengineminorversion', 'second', 'setlocale', 'sgn', 'sin', 'space', 'split', 'sqr', 'strcomp',
                        'string', 'strreverse', 'tan', 'time', 'timer', 'timeserial', 'timevalue', 'typename', 'ubound', 'ucase', 'unescape', 'vartype', 'weekday', 'weekdayname', 'year'];

    //This list was from: http://msdn.microsoft.com/en-us/library/ydz4cfk3(v=vs.84).aspx
    var builtinConsts = ['vbBlack', 'vbRed', 'vbGreen', 'vbYellow', 'vbBlue', 'vbMagenta', 'vbCyan', 'vbWhite', 'vbBinaryCompare', 'vbTextCompare',
                         'vbSunday', 'vbMonday', 'vbTuesday', 'vbWednesday', 'vbThursday', 'vbFriday', 'vbSaturday', 'vbUseSystemDayOfWeek', 'vbFirstJan1', 'vbFirstFourDays', 'vbFirstFullWeek',
                         'vbGeneralDate', 'vbLongDate', 'vbShortDate', 'vbLongTime', 'vbShortTime', 'vbObjectError',
                         'vbOKOnly', 'vbOKCancel', 'vbAbortRetryIgnore', 'vbYesNoCancel', 'vbYesNo', 'vbRetryCancel', 'vbCritical', 'vbQuestion', 'vbExclamation', 'vbInformation', 'vbDefaultButton1', 'vbDefaultButton2',
                         'vbDefaultButton3', 'vbDefaultButton4', 'vbApplicationModal', 'vbSystemModal', 'vbOK', 'vbCancel', 'vbAbort', 'vbRetry', 'vbIgnore', 'vbYes', 'vbNo',
                         'vbCr', 'VbCrLf', 'vbFormFeed', 'vbLf', 'vbNewLine', 'vbNullChar', 'vbNullString', 'vbTab', 'vbVerticalTab', 'vbUseDefault', 'vbTrue', 'vbFalse',
                         'vbEmpty', 'vbNull', 'vbInteger', 'vbLong', 'vbSingle', 'vbDouble', 'vbCurrency', 'vbDate', 'vbString', 'vbObject', 'vbError', 'vbBoolean', 'vbVariant', 'vbDataObject', 'vbDecimal', 'vbByte', 'vbArray'];
    //This list was from: http://msdn.microsoft.com/en-us/library/hkc375ea(v=vs.84).aspx
    var builtinObjsWords = ['WScript', 'err', 'debug', 'RegExp'];
    var knownProperties = ['description', 'firstindex', 'global', 'helpcontext', 'helpfile', 'ignorecase', 'length', 'number', 'pattern', 'source', 'value', 'count'];
    var knownMethods = ['clear', 'execute', 'raise', 'replace', 'test', 'write', 'writeline', 'close', 'open', 'state', 'eof', 'update', 'addnew', 'end', 'createobject', 'quit'];

    var aspBuiltinObjsWords = ['server', 'response', 'request', 'session', 'application'];
    var aspKnownProperties = ['buffer', 'cachecontrol', 'charset', 'contenttype', 'expires', 'expiresabsolute', 'isclientconnected', 'pics', 'status', //response
                              'clientcertificate', 'cookies', 'form', 'querystring', 'servervariables', 'totalbytes', //request
                              'contents', 'staticobjects', //application
                              'codepage', 'lcid', 'sessionid', 'timeout', //session
                              'scripttimeout']; //server
    var aspKnownMethods = ['addheader', 'appendtolog', 'binarywrite', 'end', 'flush', 'redirect', //response
                           'binaryread', //request
                           'remove', 'removeall', 'lock', 'unlock', //application
                           'abandon', //session
                           'getlasterror', 'htmlencode', 'mappath', 'transfer', 'urlencode']; //server

    var knownWords = knownMethods.concat(knownProperties);

    builtinObjsWords = builtinObjsWords.concat(builtinConsts);

    if (conf.isASP){
        builtinObjsWords = builtinObjsWords.concat(aspBuiltinObjsWords);
        knownWords = knownWords.concat(aspKnownMethods, aspKnownProperties);
    };

    var keywords = wordRegexp(commonkeywords);
    var atoms = wordRegexp(atomWords);
    var builtinFuncs = wordRegexp(builtinFuncsWords);
    var builtinObjs = wordRegexp(builtinObjsWords);
    var known = wordRegexp(knownWords);
    var stringPrefixes = '"';

    var opening = wordRegexp(openingKeywords);
    var middle = wordRegexp(middleKeywords);
    var closing = wordRegexp(endKeywords);
    var doubleClosing = wordRegexp(['end']);
    var doOpening = wordRegexp(['do']);
    var noIndentWords = wordRegexp(['on error resume next', 'exit']);
    var comment = wordRegexp(['rem']);


    function indent(_stream, state) {
      state.currentIndent++;
    }

    function dedent(_stream, state) {
      state.currentIndent--;
    }
    // tokenizers
    function tokenBase(stream, state) {
        if (stream.eatSpace()) {
            return 'space';
            //return null;
        }

        var ch = stream.peek();

        // Handle Comments
        if (ch === "'") {
            stream.skipToEnd();
            return 'comment';
        }
        if (stream.match(comment)){
            stream.skipToEnd();
            return 'comment';
        }


        // Handle Number Literals
        if (stream.match(/^((&H)|(&O))?[0-9\.]/i, false) && !stream.match(/^((&H)|(&O))?[0-9\.]+[a-z_]/i, false)) {
            var floatLiteral = false;
            // Floats
            if (stream.match(/^\d*\.\d+/i)) { floatLiteral = true; }
            else if (stream.match(/^\d+\.\d*/)) { floatLiteral = true; }
            else if (stream.match(/^\.\d+/)) { floatLiteral = true; }

            if (floatLiteral) {
                // Float literals may be "imaginary"
                stream.eat(/J/i);
                return 'number';
            }
            // Integers
            var intLiteral = false;
            // Hex
            if (stream.match(/^&H[0-9a-f]+/i)) { intLiteral = true; }
            // Octal
            else if (stream.match(/^&O[0-7]+/i)) { intLiteral = true; }
            // Decimal
            else if (stream.match(/^[1-9]\d*F?/)) {
                // Decimal literals may be "imaginary"
                stream.eat(/J/i);
                // TODO - Can you have imaginary longs?
                intLiteral = true;
            }
            // Zero by itself with no other piece of number.
            else if (stream.match(/^0(?![\dx])/i)) { intLiteral = true; }
            if (intLiteral) {
                // Integer literals may be "long"
                stream.eat(/L/i);
                return 'number';
            }
        }

        // Handle Strings
        if (stream.match(stringPrefixes)) {
            state.tokenize = tokenStringFactory(stream.current());
            return state.tokenize(stream, state);
        }

        // Handle operators and Delimiters
        if (stream.match(doubleOperators)
            || stream.match(singleOperators)
            || stream.match(wordOperators)) {
            return 'operator';
        }
        if (stream.match(singleDelimiters)) {
            return null;
        }

        if (stream.match(brackets)) {
            return "bracket";
        }

        if (stream.match(noIndentWords)) {
            state.doInCurrentLine = true;

            return 'keyword';
        }

        if (stream.match(doOpening)) {
            indent(stream,state);
            state.doInCurrentLine = true;

            return 'keyword';
        }
        if (stream.match(opening)) {
            if (! state.doInCurrentLine)
              indent(stream,state);
            else
              state.doInCurrentLine = false;

            return 'keyword';
        }
        if (stream.match(middle)) {
            return 'keyword';
        }


        if (stream.match(doubleClosing)) {
            dedent(stream,state);
            dedent(stream,state);

            return 'keyword';
        }
        if (stream.match(closing)) {
            if (! state.doInCurrentLine)
              dedent(stream,state);
            else
              state.doInCurrentLine = false;

            return 'keyword';
        }

        if (stream.match(keywords)) {
            return 'keyword';
        }

        if (stream.match(atoms)) {
            return 'atom';
        }

        if (stream.match(known)) {
            return 'variable-2';
        }

        if (stream.match(builtinFuncs)) {
            return 'builtin';
        }

        if (stream.match(builtinObjs)){
            return 'variable-2';
        }

        if (stream.match(identifiers)) {
            return 'variable';
        }

        // Handle non-detected items
        stream.next();
        return ERRORCLASS;
    }

    function tokenStringFactory(delimiter) {
        var singleline = delimiter.length == 1;
        var OUTCLASS = 'string';

        return function(stream, state) {
            while (!stream.eol()) {
                stream.eatWhile(/[^'"]/);
                if (stream.match(delimiter)) {
                    state.tokenize = tokenBase;
                    return OUTCLASS;
                } else {
                    stream.eat(/['"]/);
                }
            }
            if (singleline) {
                if (parserConf.singleLineStringErrors) {
                    return ERRORCLASS;
                } else {
                    state.tokenize = tokenBase;
                }
            }
            return OUTCLASS;
        };
    }


    function tokenLexer(stream, state) {
        var style = state.tokenize(stream, state);
        var current = stream.current();

        // Handle '.' connected identifiers
        if (current === '.') {
            style = state.tokenize(stream, state);

            current = stream.current();
            if (style && (style.substr(0, 8) === 'variable' || style==='builtin' || style==='keyword')){//|| knownWords.indexOf(current.substring(1)) > -1) {
                if (style === 'builtin' || style === 'keyword') style='variable';
                if (knownWords.indexOf(current.substr(1)) > -1) style='variable-2';

                return style;
            } else {
                return ERRORCLASS;
            }
        }

        return style;
    }

    var external = {
        electricChars:"dDpPtTfFeE ",
        startState: function() {
            return {
              tokenize: tokenBase,
              lastToken: null,
              currentIndent: 0,
              nextLineIndent: 0,
              doInCurrentLine: false,
              ignoreKeyword: false


          };
        },

        token: function(stream, state) {
            if (stream.sol()) {
              state.currentIndent += state.nextLineIndent;
              state.nextLineIndent = 0;
              state.doInCurrentLine = 0;
            }
            var style = tokenLexer(stream, state);

            state.lastToken = {style:style, content: stream.current()};

            if (style==='space') style=null;

            return style;
        },

        indent: function(state, textAfter) {
            var trueText = textAfter.replace(/^\s+|\s+$/g, '') ;
            if (trueText.match(closing) || trueText.match(doubleClosing) || trueText.match(middle)) return conf.indentUnit*(state.currentIndent-1);
            if(state.currentIndent < 0) return 0;
            return state.currentIndent * conf.indentUnit;
        }

    };
    return external;
});

CodeMirror.defineMIME("text/vbscript", "vbscript");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/velocity/velocity.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("velocity", function() {
    function parseWords(str) {
        var obj = {}, words = str.split(" ");
        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
        return obj;
    }

    var keywords = parseWords("#end #else #break #stop #[[ #]] " +
                              "#{end} #{else} #{break} #{stop}");
    var functions = parseWords("#if #elseif #foreach #set #include #parse #macro #define #evaluate " +
                               "#{if} #{elseif} #{foreach} #{set} #{include} #{parse} #{macro} #{define} #{evaluate}");
    var specials = parseWords("$foreach.count $foreach.hasNext $foreach.first $foreach.last $foreach.topmost $foreach.parent.count $foreach.parent.hasNext $foreach.parent.first $foreach.parent.last $foreach.parent $velocityCount $!bodyContent $bodyContent");
    var isOperatorChar = /[+\-*&%=<>!?:\/|]/;

    function chain(stream, state, f) {
        state.tokenize = f;
        return f(stream, state);
    }
    function tokenBase(stream, state) {
        var beforeParams = state.beforeParams;
        state.beforeParams = false;
        var ch = stream.next();
        // start of unparsed string?
        if ((ch == "'") && !state.inString && state.inParams) {
            state.lastTokenWasBuiltin = false;
            return chain(stream, state, tokenString(ch));
        }
        // start of parsed string?
        else if ((ch == '"')) {
            state.lastTokenWasBuiltin = false;
            if (state.inString) {
                state.inString = false;
                return "string";
            }
            else if (state.inParams)
                return chain(stream, state, tokenString(ch));
        }
        // is it one of the special signs []{}().,;? Separator?
        else if (/[\[\]{}\(\),;\.]/.test(ch)) {
            if (ch == "(" && beforeParams)
                state.inParams = true;
            else if (ch == ")") {
                state.inParams = false;
                state.lastTokenWasBuiltin = true;
            }
            return null;
        }
        // start of a number value?
        else if (/\d/.test(ch)) {
            state.lastTokenWasBuiltin = false;
            stream.eatWhile(/[\w\.]/);
            return "number";
        }
        // multi line comment?
        else if (ch == "#" && stream.eat("*")) {
            state.lastTokenWasBuiltin = false;
            return chain(stream, state, tokenComment);
        }
        // unparsed content?
        else if (ch == "#" && stream.match(/ *\[ *\[/)) {
            state.lastTokenWasBuiltin = false;
            return chain(stream, state, tokenUnparsed);
        }
        // single line comment?
        else if (ch == "#" && stream.eat("#")) {
            state.lastTokenWasBuiltin = false;
            stream.skipToEnd();
            return "comment";
        }
        // variable?
        else if (ch == "$") {
            stream.eat("!");
            stream.eatWhile(/[\w\d\$_\.{}-]/);
            // is it one of the specials?
            if (specials && specials.propertyIsEnumerable(stream.current())) {
                return "keyword";
            }
            else {
                state.lastTokenWasBuiltin = true;
                state.beforeParams = true;
                return "builtin";
            }
        }
        // is it a operator?
        else if (isOperatorChar.test(ch)) {
            state.lastTokenWasBuiltin = false;
            stream.eatWhile(isOperatorChar);
            return "operator";
        }
        else {
            // get the whole word
            stream.eatWhile(/[\w\$_{}@]/);
            var word = stream.current();
            // is it one of the listed keywords?
            if (keywords && keywords.propertyIsEnumerable(word))
                return "keyword";
            // is it one of the listed functions?
            if (functions && functions.propertyIsEnumerable(word) ||
                    (stream.current().match(/^#@?[a-z0-9_]+ *$/i) && stream.peek()=="(") &&
                     !(functions && functions.propertyIsEnumerable(word.toLowerCase()))) {
                state.beforeParams = true;
                state.lastTokenWasBuiltin = false;
                return "keyword";
            }
            if (state.inString) {
                state.lastTokenWasBuiltin = false;
                return "string";
            }
            if (stream.pos > word.length && stream.string.charAt(stream.pos-word.length-1)=="." && state.lastTokenWasBuiltin)
                return "builtin";
            // default: just a "word"
            state.lastTokenWasBuiltin = false;
            return null;
        }
    }

    function tokenString(quote) {
        return function(stream, state) {
            var escaped = false, next, end = false;
            while ((next = stream.next()) != null) {
                if ((next == quote) && !escaped) {
                    end = true;
                    break;
                }
                if (quote=='"' && stream.peek() == '$' && !escaped) {
                    state.inString = true;
                    end = true;
                    break;
                }
                escaped = !escaped && next == "\\";
            }
            if (end) state.tokenize = tokenBase;
            return "string";
        };
    }

    function tokenComment(stream, state) {
        var maybeEnd = false, ch;
        while (ch = stream.next()) {
            if (ch == "#" && maybeEnd) {
                state.tokenize = tokenBase;
                break;
            }
            maybeEnd = (ch == "*");
        }
        return "comment";
    }

    function tokenUnparsed(stream, state) {
        var maybeEnd = 0, ch;
        while (ch = stream.next()) {
            if (ch == "#" && maybeEnd == 2) {
                state.tokenize = tokenBase;
                break;
            }
            if (ch == "]")
                maybeEnd++;
            else if (ch != " ")
                maybeEnd = 0;
        }
        return "meta";
    }
    // Interface

    return {
        startState: function() {
            return {
                tokenize: tokenBase,
                beforeParams: false,
                inParams: false,
                inString: false,
                lastTokenWasBuiltin: false
            };
        },

        token: function(stream, state) {
            if (stream.eatSpace()) return null;
            return state.tokenize(stream, state);
        },
        blockCommentStart: "#*",
        blockCommentEnd: "*#",
        lineComment: "##",
        fold: "velocity"
    };
});

CodeMirror.defineMIME("text/velocity", "velocity");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/verilog/verilog.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("verilog", function(config, parserConfig) {

  var indentUnit = config.indentUnit,
      statementIndentUnit = parserConfig.statementIndentUnit || indentUnit,
      dontAlignCalls = parserConfig.dontAlignCalls,
      // compilerDirectivesUseRegularIndentation - If set, Compiler directive
      // indentation follows the same rules as everything else. Otherwise if
      // false, compiler directives will track their own indentation.
      // For example, `ifdef nested inside another `ifndef will be indented,
      // but a `ifdef inside a function block may not be indented.
      compilerDirectivesUseRegularIndentation = parserConfig.compilerDirectivesUseRegularIndentation,
      noIndentKeywords = parserConfig.noIndentKeywords || [],
      multiLineStrings = parserConfig.multiLineStrings,
      hooks = parserConfig.hooks || {};

  function words(str) {
    var obj = {}, words = str.split(" ");
    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
    return obj;
  }

  /**
   * Keywords from IEEE 1800-2012
   */
  var keywords = words(
    "accept_on alias always always_comb always_ff always_latch and assert assign assume automatic before begin bind " +
    "bins binsof bit break buf bufif0 bufif1 byte case casex casez cell chandle checker class clocking cmos config " +
    "const constraint context continue cover covergroup coverpoint cross deassign default defparam design disable " +
    "dist do edge else end endcase endchecker endclass endclocking endconfig endfunction endgenerate endgroup " +
    "endinterface endmodule endpackage endprimitive endprogram endproperty endspecify endsequence endtable endtask " +
    "enum event eventually expect export extends extern final first_match for force foreach forever fork forkjoin " +
    "function generate genvar global highz0 highz1 if iff ifnone ignore_bins illegal_bins implements implies import " +
    "incdir include initial inout input inside instance int integer interconnect interface intersect join join_any " +
    "join_none large let liblist library local localparam logic longint macromodule matches medium modport module " +
    "nand negedge nettype new nexttime nmos nor noshowcancelled not notif0 notif1 null or output package packed " +
    "parameter pmos posedge primitive priority program property protected pull0 pull1 pulldown pullup " +
    "pulsestyle_ondetect pulsestyle_onevent pure rand randc randcase randsequence rcmos real realtime ref reg " +
    "reject_on release repeat restrict return rnmos rpmos rtran rtranif0 rtranif1 s_always s_eventually s_nexttime " +
    "s_until s_until_with scalared sequence shortint shortreal showcancelled signed small soft solve specify " +
    "specparam static string strong strong0 strong1 struct super supply0 supply1 sync_accept_on sync_reject_on " +
    "table tagged task this throughout time timeprecision timeunit tran tranif0 tranif1 tri tri0 tri1 triand trior " +
    "trireg type typedef union unique unique0 unsigned until until_with untyped use uwire var vectored virtual void " +
    "wait wait_order wand weak weak0 weak1 while wildcard wire with within wor xnor xor");

  /** Operators from IEEE 1800-2012
     unary_operator ::=
       + | - | ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~
     binary_operator ::=
       + | - | * | / | % | == | != | === | !== | ==? | !=? | && | || | **
       | < | <= | > | >= | & | | | ^ | ^~ | ~^ | >> | << | >>> | <<<
       | -> | <->
     inc_or_dec_operator ::= ++ | --
     unary_module_path_operator ::=
       ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~
     binary_module_path_operator ::=
       == | != | && | || | & | | | ^ | ^~ | ~^
  */
  var isOperatorChar = /[\+\-\*\/!~&|^%=?:<>]/;
  var isBracketChar = /[\[\]{}()]/;

  var unsignedNumber = /\d[0-9_]*/;
  var decimalLiteral = /\d*\s*'s?d\s*\d[0-9_]*/i;
  var binaryLiteral = /\d*\s*'s?b\s*[xz01][xz01_]*/i;
  var octLiteral = /\d*\s*'s?o\s*[xz0-7][xz0-7_]*/i;
  var hexLiteral = /\d*\s*'s?h\s*[0-9a-fxz?][0-9a-fxz?_]*/i;
  var realLiteral = /(\d[\d_]*(\.\d[\d_]*)?E-?[\d_]+)|(\d[\d_]*\.\d[\d_]*)/i;

  var closingBracketOrWord = /^((`?\w+)|[)}\]])/;
  var closingBracket = /[)}\]]/;
  var compilerDirectiveRegex      = new RegExp(
    "^(`(?:ifdef|ifndef|elsif|else|endif|undef|undefineall|define|include|begin_keywords|celldefine|default|" +
    "nettype|end_keywords|endcelldefine|line|nounconnected_drive|pragma|resetall|timescale|unconnected_drive))\\b");
  var compilerDirectiveBeginRegex = /^(`(?:ifdef|ifndef|elsif|else))\b/;
  var compilerDirectiveEndRegex   = /^(`(?:elsif|else|endif))\b/;

  var curPunc;
  var curKeyword;

  // Block openings which are closed by a matching keyword in the form of ("end" + keyword)
  // E.g. "task" => "endtask"
  var blockKeywords = words(
    "case checker class clocking config function generate interface module package " +
    "primitive program property specify sequence table task"
  );

  // Opening/closing pairs
  var openClose = {};
  for (var keyword in blockKeywords) {
    openClose[keyword] = "end" + keyword;
  }
  openClose["begin"] = "end";
  openClose["casex"] = "endcase";
  openClose["casez"] = "endcase";
  openClose["do"   ] = "while";
  openClose["fork" ] = "join;join_any;join_none";
  openClose["covergroup"] = "endgroup";
  openClose["macro_begin"] = "macro_end";

  for (var i in noIndentKeywords) {
    var keyword = noIndentKeywords[i];
    if (openClose[keyword]) {
      openClose[keyword] = undefined;
    }
  }

  // Keywords which open statements that are ended with a semi-colon
  var statementKeywords = words("always always_comb always_ff always_latch assert assign assume else export for foreach forever if import initial repeat while extern typedef");

  function tokenBase(stream, state) {
    var ch = stream.peek(), style;
    if (hooks[ch] && (style = hooks[ch](stream, state)) != false) return style;
    if (hooks.tokenBase && (style = hooks.tokenBase(stream, state)) != false)
      return style;

    if (/[,;:\.]/.test(ch)) {
      curPunc = stream.next();
      return null;
    }
    if (isBracketChar.test(ch)) {
      curPunc = stream.next();
      return "bracket";
    }
    // Macros (tick-defines)
    if (ch == '`') {
      stream.next();
      if (stream.eatWhile(/[\w\$_]/)) {
        var cur = stream.current();
        curKeyword = cur;
        // Macros that end in _begin, are start of block and end with _end
        if (cur.startsWith("`uvm_") && cur.endsWith("_begin")) {
          var keywordClose = curKeyword.substr(0,curKeyword.length - 5) + "end";
          openClose[cur] = keywordClose;
          curPunc = "newblock";
        } else {
          stream.eatSpace();
          if (stream.peek() == '(') {
            // Check if this is a block
            curPunc = "newmacro";
          }
          var withSpace = stream.current();
          // Move the stream back before the spaces
          stream.backUp(withSpace.length - cur.length);
        }
        return "def";
      } else {
        return null;
      }
    }
    // System calls
    if (ch == '$') {
      stream.next();
      if (stream.eatWhile(/[\w\$_]/)) {
        return "meta";
      } else {
        return null;
      }
    }
    // Time literals
    if (ch == '#') {
      stream.next();
      stream.eatWhile(/[\d_.]/);
      return "def";
    }
    // Event
    if (ch == '@') {
      stream.next();
      stream.eatWhile(/[@]/);
      return "def";
    }
    // Strings
    if (ch == '"') {
      stream.next();
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    }
    // Comments
    if (ch == "/") {
      stream.next();
      if (stream.eat("*")) {
        state.tokenize = tokenComment;
        return tokenComment(stream, state);
      }
      if (stream.eat("/")) {
        stream.skipToEnd();
        return "comment";
      }
      stream.backUp(1);
    }

    // Numeric literals
    if (stream.match(realLiteral) ||
        stream.match(decimalLiteral) ||
        stream.match(binaryLiteral) ||
        stream.match(octLiteral) ||
        stream.match(hexLiteral) ||
        stream.match(unsignedNumber) ||
        stream.match(realLiteral)) {
      return "number";
    }

    // Operators
    if (stream.eatWhile(isOperatorChar)) {
      curPunc = stream.current();
      return "meta";
    }

    // Keywords / plain variables
    if (stream.eatWhile(/[\w\$_]/)) {
      var cur = stream.current();
      if (keywords[cur]) {
        if (openClose[cur]) {
          curPunc = "newblock";
          if (cur === "fork") {
            // Fork can be a statement instead of block in cases of:
            // "disable fork;" and "wait fork;" (trailing semicolon)
            stream.eatSpace()
            if (stream.peek() == ';') {
              curPunc = "newstatement";
            }
            stream.backUp(stream.current().length - cur.length);
          }
        }
        if (statementKeywords[cur]) {
          curPunc = "newstatement";
        }
        curKeyword = cur;
        return "keyword";
      }
      return "variable";
    }

    stream.next();
    return null;
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, next, end = false;
      while ((next = stream.next()) != null) {
        if (next == quote && !escaped) {end = true; break;}
        escaped = !escaped && next == "\\";
      }
      if (end || !(escaped || multiLineStrings))
        state.tokenize = tokenBase;
      return "string";
    };
  }

  function tokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" && maybeEnd) {
        state.tokenize = tokenBase;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return "comment";
  }

  function Context(indented, column, type, scopekind, align, prev) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.scopekind = scopekind;
    this.align = align;
    this.prev = prev;
  }
  function pushContext(state, col, type, scopekind) {
    var indent = state.indented;
    var c = new Context(indent, col, type, scopekind ? scopekind : "", null, state.context);
    return state.context = c;
  }
  function popContext(state) {
    var t = state.context.type;
    if (t == ")" || t == "]" || t == "}") {
      state.indented = state.context.indented;
    }
    return state.context = state.context.prev;
  }

  function isClosing(text, contextClosing) {
    if (text == contextClosing) {
      return true;
    } else {
      // contextClosing may be multiple keywords separated by ;
      var closingKeywords = contextClosing.split(";");
      for (var i in closingKeywords) {
        if (text == closingKeywords[i]) {
          return true;
        }
      }
      return false;
    }
  }

  function isInsideScopeKind(ctx, scopekind) {
    if (ctx == null) {
      return false;
    }
    if (ctx.scopekind === scopekind) {
      return true;
    }
    return isInsideScopeKind(ctx.prev, scopekind);
  }

  function buildElectricInputRegEx() {
    // Reindentation should occur on any bracket char: {}()[]
    // or on a match of any of the block closing keywords, at
    // the end of a line
    var allClosings = [];
    for (var i in openClose) {
      if (openClose[i]) {
        var closings = openClose[i].split(";");
        for (var j in closings) {
          allClosings.push(closings[j]);
        }
      }
    }
    var re = new RegExp("[{}()\\[\\]]|(" + allClosings.join("|") + ")$");
    return re;
  }

  // Interface
  return {

    // Regex to force current line to reindent
    electricInput: buildElectricInputRegEx(),

    startState: function(basecolumn) {
      var state = {
        tokenize: null,
        context: new Context((basecolumn || 0) - indentUnit, 0, "top", "top", false),
        indented: 0,
        compilerDirectiveIndented: 0,
        startOfLine: true
      };
      if (hooks.startState) hooks.startState(state);
      return state;
    },

    token: function(stream, state) {
      var ctx = state.context;
      if (stream.sol()) {
        if (ctx.align == null) ctx.align = false;
        state.indented = stream.indentation();
        state.startOfLine = true;
      }
      if (hooks.token) {
        // Call hook, with an optional return value of a style to override verilog styling.
        var style = hooks.token(stream, state);
        if (style !== undefined) {
          return style;
        }
      }
      if (stream.eatSpace()) return null;
      curPunc = null;
      curKeyword = null;
      var style = (state.tokenize || tokenBase)(stream, state);
      if (style == "comment" || style == "meta" || style == "variable") {
        if (((curPunc === "=") || (curPunc === "<=")) && !isInsideScopeKind(ctx, "assignment")) {
          // '<=' could be nonblocking assignment or lessthan-equals (which shouldn't cause indent)
          //      Search through the context to see if we are already in an assignment.
          // '=' could be inside port declaration with comma or ')' afterward, or inside for(;;) block.
          pushContext(state, stream.column() + curPunc.length, "assignment", "assignment");
          if (ctx.align == null) ctx.align = true;
        }
        return style;
      }
      if (ctx.align == null) ctx.align = true;

      var isClosingAssignment = ctx.type == "assignment" &&
        closingBracket.test(curPunc) && ctx.prev && ctx.prev.type === curPunc;
      if (curPunc == ctx.type || isClosingAssignment) {
        if (isClosingAssignment) {
          ctx = popContext(state);
        }
        ctx = popContext(state);
        if (curPunc == ")") {
          // Handle closing macros, assuming they could have a semicolon or begin/end block inside.
          if (ctx && (ctx.type === "macro")) {
            ctx = popContext(state);
            while (ctx && (ctx.type == "statement" || ctx.type == "assignment")) ctx = popContext(state);
          }
        } else if (curPunc == "}") {
          // Handle closing statements like constraint block: "foreach () {}" which
          // do not have semicolon at end.
          if (ctx && (ctx.type === "statement")) {
            while (ctx && (ctx.type == "statement")) ctx = popContext(state);
          }
        }
      } else if (((curPunc == ";" || curPunc == ",") && (ctx.type == "statement" || ctx.type == "assignment")) ||
               (ctx.type && isClosing(curKeyword, ctx.type))) {
        ctx = popContext(state);
        while (ctx && (ctx.type == "statement" || ctx.type == "assignment")) ctx = popContext(state);
      } else if (curPunc == "{") {
        pushContext(state, stream.column(), "}");
      } else if (curPunc == "[") {
        pushContext(state, stream.column(), "]");
      } else if (curPunc == "(") {
        pushContext(state, stream.column(), ")");
      } else if (ctx && ctx.type == "endcase" && curPunc == ":") {
        pushContext(state, stream.column(), "statement", "case");
      } else if (curPunc == "newstatement") {
        pushContext(state, stream.column(), "statement", curKeyword);
      } else if (curPunc == "newblock") {
        if (curKeyword == "function" && ctx && (ctx.type == "statement" || ctx.type == "endgroup")) {
          // The 'function' keyword can appear in some other contexts where it actually does not
          // indicate a function (import/export DPI and covergroup definitions).
          // Do nothing in this case
        } else if (curKeyword == "task" && ctx && ctx.type == "statement") {
          // Same thing for task
        } else if (curKeyword == "class" && ctx && ctx.type == "statement") {
          // Same thing for class (e.g. typedef)
        } else {
          var close = openClose[curKeyword];
          pushContext(state, stream.column(), close, curKeyword);
        }
      } else if (curPunc == "newmacro" || (curKeyword && curKeyword.match(compilerDirectiveRegex))) {
        if (curPunc == "newmacro") {
          // Macros (especially if they have parenthesis) potentially have a semicolon
          // or complete statement/block inside, and should be treated as such.
          pushContext(state, stream.column(), "macro", "macro");
        }
        if (curKeyword.match(compilerDirectiveEndRegex)) {
          state.compilerDirectiveIndented -= statementIndentUnit;
        }
        if (curKeyword.match(compilerDirectiveBeginRegex)) {
          state.compilerDirectiveIndented += statementIndentUnit;
        }
      }

      state.startOfLine = false;
      return style;
    },

    indent: function(state, textAfter) {
      if (state.tokenize != tokenBase && state.tokenize != null) return CodeMirror.Pass;
      if (hooks.indent) {
        var fromHook = hooks.indent(state);
        if (fromHook >= 0) return fromHook;
      }
      var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);
      if (ctx.type == "statement" && firstChar == "}") ctx = ctx.prev;
      var closing = false;
      var possibleClosing = textAfter.match(closingBracketOrWord);
      if (possibleClosing)
        closing = isClosing(possibleClosing[0], ctx.type);
      if (!compilerDirectivesUseRegularIndentation && textAfter.match(compilerDirectiveRegex)) {
        if (textAfter.match(compilerDirectiveEndRegex)) {
          return state.compilerDirectiveIndented - statementIndentUnit;
        }
        return state.compilerDirectiveIndented;
      }
      if (ctx.type == "statement") return ctx.indented + (firstChar == "{" ? 0 : statementIndentUnit);
      else if ((closingBracket.test(ctx.type) || ctx.type == "assignment")
        && ctx.align && !dontAlignCalls) return ctx.column + (closing ? 0 : 1);
      else if (ctx.type == ")" && !closing) return ctx.indented + statementIndentUnit;
      else return ctx.indented + (closing ? 0 : indentUnit);
    },

    blockCommentStart: "/*",
    blockCommentEnd: "*/",
    lineComment: "//",
    fold: "indent"
  };
});

  CodeMirror.defineMIME("text/x-verilog", {
    name: "verilog"
  });

  CodeMirror.defineMIME("text/x-systemverilog", {
    name: "verilog"
  });



  // TL-Verilog mode.
  // See tl-x.org for language spec.
  // See the mode in action at makerchip.com.
  // Contact: steve.hoover@redwoodeda.com

  // TLV Identifier prefixes.
  // Note that sign is not treated separately, so "+/-" versions of numeric identifiers
  // are included.
  var tlvIdentifierStyle = {
    "|": "link",
    ">": "property",  // Should condition this off for > TLV 1c.
    "$": "variable",
    "$$": "variable",
    "?$": "qualifier",
    "?*": "qualifier",
    "-": "hr",
    "/": "property",
    "/-": "property",
    "@": "variable-3",
    "@-": "variable-3",
    "@++": "variable-3",
    "@+=": "variable-3",
    "@+=-": "variable-3",
    "@--": "variable-3",
    "@-=": "variable-3",
    "%+": "tag",
    "%-": "tag",
    "%": "tag",
    ">>": "tag",
    "<<": "tag",
    "<>": "tag",
    "#": "tag",  // Need to choose a style for this.
    "^": "attribute",
    "^^": "attribute",
    "^!": "attribute",
    "*": "variable-2",
    "**": "variable-2",
    "\\": "keyword",
    "\"": "comment"
  };

  // Lines starting with these characters define scope (result in indentation).
  var tlvScopePrefixChars = {
    "/": "beh-hier",
    ">": "beh-hier",
    "-": "phys-hier",
    "|": "pipe",
    "?": "when",
    "@": "stage",
    "\\": "keyword"
  };
  var tlvIndentUnit = 3;
  var tlvTrackStatements = false;
  var tlvIdentMatch = /^([~!@#\$%\^&\*-\+=\?\/\\\|'"<>]+)([\d\w_]*)/;  // Matches an identifier.
  // Note that ':' is excluded, because of it's use in [:].
  var tlvFirstLevelIndentMatch = /^[! ]  /;
  var tlvLineIndentationMatch = /^[! ] */;
  var tlvCommentMatch = /^\/[\/\*]/;


  // Returns a style specific to the scope at the given indentation column.
  // Type is one of: "indent", "scope-ident", "before-scope-ident".
  function tlvScopeStyle(state, indentation, type) {
    // Begin scope.
    var depth = indentation / tlvIndentUnit;  // TODO: Pass this in instead.
    return "tlv-" + state.tlvIndentationStyle[depth] + "-" + type;
  }

  // Return true if the next thing in the stream is an identifier with a mnemonic.
  function tlvIdentNext(stream) {
    var match;
    return (match = stream.match(tlvIdentMatch, false)) && match[2].length > 0;
  }

  CodeMirror.defineMIME("text/x-tlv", {
    name: "verilog",

    hooks: {

      electricInput: false,


      // Return undefined for verilog tokenizing, or style for TLV token (null not used).
      // Standard CM styles are used for most formatting, but some TL-Verilog-specific highlighting
      // can be enabled with the definition of cm-tlv-* styles, including highlighting for:
      //   - M4 tokens
      //   - TLV scope indentation
      //   - Statement delimitation (enabled by tlvTrackStatements)
      token: function(stream, state) {
        var style = undefined;
        var match;  // Return value of pattern matches.

        // Set highlighting mode based on code region (TLV or SV).
        if (stream.sol() && ! state.tlvInBlockComment) {
          // Process region.
          if (stream.peek() == '\\') {
            style = "def";
            stream.skipToEnd();
            if (stream.string.match(/\\SV/)) {
              state.tlvCodeActive = false;
            } else if (stream.string.match(/\\TLV/)){
              state.tlvCodeActive = true;
            }
          }
          // Correct indentation in the face of a line prefix char.
          if (state.tlvCodeActive && stream.pos == 0 &&
              (state.indented == 0) && (match = stream.match(tlvLineIndentationMatch, false))) {
            state.indented = match[0].length;
          }

          // Compute indentation state:
          //   o Auto indentation on next line
          //   o Indentation scope styles
          var indented = state.indented;
          var depth = indented / tlvIndentUnit;
          if (depth <= state.tlvIndentationStyle.length) {
            // not deeper than current scope

            var blankline = stream.string.length == indented;
            var chPos = depth * tlvIndentUnit;
            if (chPos < stream.string.length) {
              var bodyString = stream.string.slice(chPos);
              var ch = bodyString[0];
              if (tlvScopePrefixChars[ch] && ((match = bodyString.match(tlvIdentMatch)) &&
                  tlvIdentifierStyle[match[1]])) {
                // This line begins scope.
                // Next line gets indented one level.
                indented += tlvIndentUnit;
                // Style the next level of indentation (except non-region keyword identifiers,
                //   which are statements themselves)
                if (!(ch == "\\" && chPos > 0)) {
                  state.tlvIndentationStyle[depth] = tlvScopePrefixChars[ch];
                  if (tlvTrackStatements) {state.statementComment = false;}
                  depth++;
                }
              }
            }
            // Clear out deeper indentation levels unless line is blank.
            if (!blankline) {
              while (state.tlvIndentationStyle.length > depth) {
                state.tlvIndentationStyle.pop();
              }
            }
          }
          // Set next level of indentation.
          state.tlvNextIndent = indented;
        }

        if (state.tlvCodeActive) {
          // Highlight as TLV.

          var beginStatement = false;
          if (tlvTrackStatements) {
            // This starts a statement if the position is at the scope level
            // and we're not within a statement leading comment.
            beginStatement =
                   (stream.peek() != " ") &&   // not a space
                   (style === undefined) &&    // not a region identifier
                   !state.tlvInBlockComment && // not in block comment
                   //!stream.match(tlvCommentMatch, false) && // not comment start
                   (stream.column() == state.tlvIndentationStyle.length * tlvIndentUnit);  // at scope level
            if (beginStatement) {
              if (state.statementComment) {
                // statement already started by comment
                beginStatement = false;
              }
              state.statementComment =
                   stream.match(tlvCommentMatch, false); // comment start
            }
          }

          var match;
          if (style !== undefined) {
            // Region line.
            style += " " + tlvScopeStyle(state, 0, "scope-ident")
          } else if (((stream.pos / tlvIndentUnit) < state.tlvIndentationStyle.length) &&
                     (match = stream.match(stream.sol() ? tlvFirstLevelIndentMatch : /^   /))) {
            // Indentation
            style = // make this style distinct from the previous one to prevent
                    // codemirror from combining spans
                    "tlv-indent-" + (((stream.pos % 2) == 0) ? "even" : "odd") +
                    // and style it
                    " " + tlvScopeStyle(state, stream.pos - tlvIndentUnit, "indent");
            // Style the line prefix character.
            if (match[0].charAt(0) == "!") {
              style += " tlv-alert-line-prefix";
            }
            // Place a class before a scope identifier.
            if (tlvIdentNext(stream)) {
              style += " " + tlvScopeStyle(state, stream.pos, "before-scope-ident");
            }
          } else if (state.tlvInBlockComment) {
            // In a block comment.
            if (stream.match(/^.*?\*\//)) {
              // Exit block comment.
              state.tlvInBlockComment = false;
              if (tlvTrackStatements && !stream.eol()) {
                // Anything after comment is assumed to be real statement content.
                state.statementComment = false;
              }
            } else {
              stream.skipToEnd();
            }
            style = "comment";
          } else if ((match = stream.match(tlvCommentMatch)) && !state.tlvInBlockComment) {
            // Start comment.
            if (match[0] == "//") {
              // Line comment.
              stream.skipToEnd();
            } else {
              // Block comment.
              state.tlvInBlockComment = true;
            }
            style = "comment";
          } else if (match = stream.match(tlvIdentMatch)) {
            // looks like an identifier (or identifier prefix)
            var prefix = match[1];
            var mnemonic = match[2];
            if (// is identifier prefix
                tlvIdentifierStyle.hasOwnProperty(prefix) &&
                // has mnemonic or we're at the end of the line (maybe it hasn't been typed yet)
                (mnemonic.length > 0 || stream.eol())) {
              style = tlvIdentifierStyle[prefix];
              if (stream.column() == state.indented) {
                // Begin scope.
                style += " " + tlvScopeStyle(state, stream.column(), "scope-ident")
              }
            } else {
              // Just swallow one character and try again.
              // This enables subsequent identifier match with preceding symbol character, which
              //   is legal within a statement.  (E.g., !$reset).  It also enables detection of
              //   comment start with preceding symbols.
              stream.backUp(stream.current().length - 1);
              style = "tlv-default";
            }
          } else if (stream.match(/^\t+/)) {
            // Highlight tabs, which are illegal.
            style = "tlv-tab";
          } else if (stream.match(/^[\[\]{}\(\);\:]+/)) {
            // [:], (), {}, ;.
            style = "meta";
          } else if (match = stream.match(/^[mM]4([\+_])?[\w\d_]*/)) {
            // m4 pre proc
            style = (match[1] == "+") ? "tlv-m4-plus" : "tlv-m4";
          } else if (stream.match(/^ +/)){
            // Skip over spaces.
            if (stream.eol()) {
              // Trailing spaces.
              style = "error";
            } else {
              // Non-trailing spaces.
              style = "tlv-default";
            }
          } else if (stream.match(/^[\w\d_]+/)) {
            // alpha-numeric token.
            style = "number";
          } else {
            // Eat the next char w/ no formatting.
            stream.next();
            style = "tlv-default";
          }
          if (beginStatement) {
            style += " tlv-statement";
          }
        } else {
          if (stream.match(/^[mM]4([\w\d_]*)/)) {
            // m4 pre proc
            style = "tlv-m4";
          }
        }
        return style;
      },

      indent: function(state) {
        return (state.tlvCodeActive == true) ? state.tlvNextIndent : -1;
      },

      startState: function(state) {
        state.tlvIndentationStyle = [];  // Styles to use for each level of indentation.
        state.tlvCodeActive = true;  // True when we're in a TLV region (and at beginning of file).
        state.tlvNextIndent = -1;    // The number of spaces to autoindent the next line if tlvCodeActive.
        state.tlvInBlockComment = false;  // True inside /**/ comment.
        if (tlvTrackStatements) {
          state.statementComment = false;  // True inside a statement's header comment.
        }
      }

    }
  });
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/vhdl/vhdl.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// Originally written by Alf Nielsen, re-written by Michael Zhou
(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

function words(str) {
  var obj = {}, words = str.split(",");
  for (var i = 0; i < words.length; ++i) {
    var allCaps = words[i].toUpperCase();
    var firstCap = words[i].charAt(0).toUpperCase() + words[i].slice(1);
    obj[words[i]] = true;
    obj[allCaps] = true;
    obj[firstCap] = true;
  }
  return obj;
}

function metaHook(stream) {
  stream.eatWhile(/[\w\$_]/);
  return "meta";
}

CodeMirror.defineMode("vhdl", function(config, parserConfig) {
  var indentUnit = config.indentUnit,
      atoms = parserConfig.atoms || words("null"),
      hooks = parserConfig.hooks || {"`": metaHook, "$": metaHook},
      multiLineStrings = parserConfig.multiLineStrings;

  var keywords = words("abs,access,after,alias,all,and,architecture,array,assert,attribute,begin,block," +
      "body,buffer,bus,case,component,configuration,constant,disconnect,downto,else,elsif,end,end block,end case," +
      "end component,end for,end generate,end if,end loop,end process,end record,end units,entity,exit,file,for," +
      "function,generate,generic,generic map,group,guarded,if,impure,in,inertial,inout,is,label,library,linkage," +
      "literal,loop,map,mod,nand,new,next,nor,null,of,on,open,or,others,out,package,package body,port,port map," +
      "postponed,procedure,process,pure,range,record,register,reject,rem,report,return,rol,ror,select,severity,signal," +
      "sla,sll,sra,srl,subtype,then,to,transport,type,unaffected,units,until,use,variable,wait,when,while,with,xnor,xor");

  var blockKeywords = words("architecture,entity,begin,case,port,else,elsif,end,for,function,if");

  var isOperatorChar = /[&|~><!\)\(*#%@+\/=?\:;}{,\.\^\-\[\]]/;
  var curPunc;

  function tokenBase(stream, state) {
    var ch = stream.next();
    if (hooks[ch]) {
      var result = hooks[ch](stream, state);
      if (result !== false) return result;
    }
    if (ch == '"') {
      state.tokenize = tokenString2(ch);
      return state.tokenize(stream, state);
    }
    if (ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    }
    if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
      curPunc = ch;
      return null;
    }
    if (/[\d']/.test(ch)) {
      stream.eatWhile(/[\w\.']/);
      return "number";
    }
    if (ch == "-") {
      if (stream.eat("-")) {
        stream.skipToEnd();
        return "comment";
      }
    }
    if (isOperatorChar.test(ch)) {
      stream.eatWhile(isOperatorChar);
      return "operator";
    }
    stream.eatWhile(/[\w\$_]/);
    var cur = stream.current();
    if (keywords.propertyIsEnumerable(cur.toLowerCase())) {
      if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
      return "keyword";
    }
    if (atoms.propertyIsEnumerable(cur)) return "atom";
    return "variable";
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, next, end = false;
      while ((next = stream.next()) != null) {
        if (next == quote && !escaped) {end = true; break;}
        escaped = !escaped && next == "--";
      }
      if (end || !(escaped || multiLineStrings))
        state.tokenize = tokenBase;
      return "string";
    };
  }
  function tokenString2(quote) {
    return function(stream, state) {
      var escaped = false, next, end = false;
      while ((next = stream.next()) != null) {
        if (next == quote && !escaped) {end = true; break;}
        escaped = !escaped && next == "--";
      }
      if (end || !(escaped || multiLineStrings))
        state.tokenize = tokenBase;
      return "string-2";
    };
  }

  function Context(indented, column, type, align, prev) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.align = align;
    this.prev = prev;
  }
  function pushContext(state, col, type) {
    return state.context = new Context(state.indented, col, type, null, state.context);
  }
  function popContext(state) {
    var t = state.context.type;
    if (t == ")" || t == "]" || t == "}")
      state.indented = state.context.indented;
    return state.context = state.context.prev;
  }

  // Interface
  return {
    startState: function(basecolumn) {
      return {
        tokenize: null,
        context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),
        indented: 0,
        startOfLine: true
      };
    },

    token: function(stream, state) {
      var ctx = state.context;
      if (stream.sol()) {
        if (ctx.align == null) ctx.align = false;
        state.indented = stream.indentation();
        state.startOfLine = true;
      }
      if (stream.eatSpace()) return null;
      curPunc = null;
      var style = (state.tokenize || tokenBase)(stream, state);
      if (style == "comment" || style == "meta") return style;
      if (ctx.align == null) ctx.align = true;

      if ((curPunc == ";" || curPunc == ":") && ctx.type == "statement") popContext(state);
      else if (curPunc == "{") pushContext(state, stream.column(), "}");
      else if (curPunc == "[") pushContext(state, stream.column(), "]");
      else if (curPunc == "(") pushContext(state, stream.column(), ")");
      else if (curPunc == "}") {
        while (ctx.type == "statement") ctx = popContext(state);
        if (ctx.type == "}") ctx = popContext(state);
        while (ctx.type == "statement") ctx = popContext(state);
      }
      else if (curPunc == ctx.type) popContext(state);
      else if (ctx.type == "}" || ctx.type == "top" || (ctx.type == "statement" && curPunc == "newstatement"))
        pushContext(state, stream.column(), "statement");
      state.startOfLine = false;
      return style;
    },

    indent: function(state, textAfter) {
      if (state.tokenize != tokenBase && state.tokenize != null) return 0;
      var firstChar = textAfter && textAfter.charAt(0), ctx = state.context, closing = firstChar == ctx.type;
      if (ctx.type == "statement") return ctx.indented + (firstChar == "{" ? 0 : indentUnit);
      else if (ctx.align) return ctx.column + (closing ? 0 : 1);
      else return ctx.indented + (closing ? 0 : indentUnit);
    },

    electricChars: "{}"
  };
});

CodeMirror.defineMIME("text/x-vhdl", "vhdl");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/vue/vue.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function (mod) {
  "use strict";
  if (true) {// CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"),
        __webpack_require__("./src/ipywidgets/node_modules/codemirror/addon/mode/overlay.js"),
        __webpack_require__("./src/ipywidgets/node_modules/codemirror/mode/xml/xml.js"),
        __webpack_require__("./src/ipywidgets/node_modules/codemirror/mode/javascript/javascript.js"),
        __webpack_require__("./src/ipywidgets/node_modules/codemirror/mode/coffeescript/coffeescript.js"),
        __webpack_require__("./src/ipywidgets/node_modules/codemirror/mode/css/css.js"),
        __webpack_require__("./src/ipywidgets/node_modules/codemirror/mode/sass/sass.js"),
        __webpack_require__("./src/ipywidgets/node_modules/codemirror/mode/stylus/stylus.js"),
        __webpack_require__("./src/ipywidgets/node_modules/codemirror/mode/pug/pug.js"),
        __webpack_require__("./src/ipywidgets/node_modules/codemirror/mode/handlebars/handlebars.js"));
  } else {}
})(function (CodeMirror) {
  var tagLanguages = {
    script: [
      ["lang", /coffee(script)?/, "coffeescript"],
      ["type", /^(?:text|application)\/(?:x-)?coffee(?:script)?$/, "coffeescript"],
      ["lang", /^babel$/, "javascript"],
      ["type", /^text\/babel$/, "javascript"],
      ["type", /^text\/ecmascript-\d+$/, "javascript"]
    ],
    style: [
      ["lang", /^stylus$/i, "stylus"],
      ["lang", /^sass$/i, "sass"],
      ["lang", /^less$/i, "text/x-less"],
      ["lang", /^scss$/i, "text/x-scss"],
      ["type", /^(text\/)?(x-)?styl(us)?$/i, "stylus"],
      ["type", /^text\/sass/i, "sass"],
      ["type", /^(text\/)?(x-)?scss$/i, "text/x-scss"],
      ["type", /^(text\/)?(x-)?less$/i, "text/x-less"]
    ],
    template: [
      ["lang", /^vue-template$/i, "vue"],
      ["lang", /^pug$/i, "pug"],
      ["lang", /^handlebars$/i, "handlebars"],
      ["type", /^(text\/)?(x-)?pug$/i, "pug"],
      ["type", /^text\/x-handlebars-template$/i, "handlebars"],
      [null, null, "vue-template"]
    ]
  };

  CodeMirror.defineMode("vue-template", function (config, parserConfig) {
    var mustacheOverlay = {
      token: function (stream) {
        if (stream.match(/^\{\{.*?\}\}/)) return "meta mustache";
        while (stream.next() && !stream.match("{{", false)) {}
        return null;
      }
    };
    return CodeMirror.overlayMode(CodeMirror.getMode(config, parserConfig.backdrop || "text/html"), mustacheOverlay);
  });

  CodeMirror.defineMode("vue", function (config) {
    return CodeMirror.getMode(config, {name: "htmlmixed", tags: tagLanguages});
  }, "htmlmixed", "xml", "javascript", "coffeescript", "css", "sass", "stylus", "pug", "handlebars");

  CodeMirror.defineMIME("script/x-vue", "vue");
  CodeMirror.defineMIME("text/x-vue", "vue");
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/wast/wast.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"), __webpack_require__("./src/ipywidgets/node_modules/codemirror/addon/mode/simple.js"));
  else {}
})(function(CodeMirror) {
"use strict";

var kKeywords = [
    "align",
    "block",
    "br(_if|_table|_on_(cast|data|func|i31|null))?",
    "call(_indirect|_ref)?",
    "current_memory",
    "\\bdata\\b",
    "catch(_all)?",
    "delegate",
    "drop",
    "elem",
    "else",
    "end",
    "export",
    "\\bextern\\b",
    "\\bfunc\\b",
    "global(\\.(get|set))?",
    "if",
    "import",
    "local(\\.(get|set|tee))?",
    "loop",
    "module",
    "mut",
    "nop",
    "offset",
    "param",
    "result",
    "rethrow",
    "return(_call(_indirect|_ref)?)?",
    "select",
    "start",
    "table(\\.(size|get|set|size|grow|fill|init|copy))?",
    "then",
    "throw",
    "try",
    "type",
    "unreachable",
    "unwind",

    // Numeric opcodes.
    "i(32|64)\\.(store(8|16)|(load(8|16)_[su]))",
    "i64\\.(load32_[su]|store32)",
    "[fi](32|64)\\.(const|load|store)",
    "f(32|64)\\.(abs|add|ceil|copysign|div|eq|floor|[gl][et]|max|min|mul|nearest|neg?|sqrt|sub|trunc)",
    "i(32|64)\\.(a[dn]d|c[lt]z|(div|rem)_[su]|eqz?|[gl][te]_[su]|mul|ne|popcnt|rot[lr]|sh(l|r_[su])|sub|x?or)",
    "i64\\.extend_[su]_i32",
    "i32\\.wrap_i64",
    "i(32|64)\\.trunc_f(32|64)_[su]",
    "f(32|64)\\.convert_i(32|64)_[su]",
    "f64\\.promote_f32",
    "f32\\.demote_f64",
    "f32\\.reinterpret_i32",
    "i32\\.reinterpret_f32",
    "f64\\.reinterpret_i64",
    "i64\\.reinterpret_f64",
    // Atomics.
    "memory(\\.((atomic\\.(notify|wait(32|64)))|grow|size))?",
    "i64\.atomic\\.(load32_u|store32|rmw32\\.(a[dn]d|sub|x?or|(cmp)?xchg)_u)",
    "i(32|64)\\.atomic\\.(load((8|16)_u)?|store(8|16)?|rmw(\\.(a[dn]d|sub|x?or|(cmp)?xchg)|(8|16)\\.(a[dn]d|sub|x?or|(cmp)?xchg)_u))",
    // SIMD.
    "v128\\.load(8x8|16x4|32x2)_[su]",
    "v128\\.load(8|16|32|64)_splat",
    "v128\\.(load|store)(8|16|32|64)_lane",
    "v128\\.load(32|64)_zero",
    "v128\.(load|store|const|not|andnot|and|or|xor|bitselect|any_true)",
    "i(8x16|16x8)\\.(extract_lane_[su]|(add|sub)_sat_[su]|avgr_u)",
    "i(8x16|16x8|32x4|64x2)\\.(neg|add|sub|abs|shl|shr_[su]|all_true|bitmask|eq|ne|[lg][te]_s)",
    "(i(8x16|16x8|32x4|64x2)|f(32x4|64x2))\.(splat|replace_lane)",
    "i(8x16|16x8|32x4)\\.(([lg][te]_u)|((min|max)_[su]))",
    "f(32x4|64x2)\\.(neg|add|sub|abs|nearest|eq|ne|[lg][te]|sqrt|mul|div|min|max|ceil|floor|trunc)",
    "[fi](32x4|64x2)\\.extract_lane",
    "i8x16\\.(shuffle|swizzle|popcnt|narrow_i16x8_[su])",
    "i16x8\\.(narrow_i32x4_[su]|mul|extadd_pairwise_i8x16_[su]|q15mulr_sat_s)",
    "i16x8\\.(extend|extmul)_(low|high)_i8x16_[su]",
    "i32x4\\.(mul|dot_i16x8_s|trunc_sat_f64x2_[su]_zero)",
    "i32x4\\.((extend|extmul)_(low|high)_i16x8_|trunc_sat_f32x4_|extadd_pairwise_i16x8_)[su]",
    "i64x2\\.(mul|(extend|extmul)_(low|high)_i32x4_[su])",
    "f32x4\\.(convert_i32x4_[su]|demote_f64x2_zero)",
    "f64x2\\.(promote_low_f32x4|convert_low_i32x4_[su])",
    // Reference types, function references, and GC.
    "\\bany\\b",
    "array\\.len",
    "(array|struct)(\\.(new_(default_)?with_rtt|get(_[su])?|set))?",
    "\\beq\\b",
    "field",
    "i31\\.(new|get_[su])",
    "\\bnull\\b",
    "ref(\\.(([ai]s_(data|func|i31))|cast|eq|func|(is_|as_non_)?null|test))?",
    "rtt(\\.(canon|sub))?",
];

CodeMirror.defineSimpleMode('wast', {
  start: [
    {regex: /[+\-]?(?:nan(?::0x[0-9a-fA-F]+)?|infinity|inf|0x[0-9a-fA-F]+\.?[0-9a-fA-F]*p[+\/-]?\d+|\d+(?:\.\d*)?[eE][+\-]?\d*|\d+\.\d*|0x[0-9a-fA-F]+|\d+)/, token: "number"},
    {regex: new RegExp(kKeywords.join('|')), token: "keyword"},
    {regex: /\b((any|data|eq|extern|i31|func)ref|[fi](32|64)|i(8|16))\b/, token: "atom"},
    {regex: /\$([a-zA-Z0-9_`\+\-\*\/\\\^~=<>!\?@#$%&|:\.]+)/, token: "variable-2"},
    {regex: /"(?:[^"\\\x00-\x1f\x7f]|\\[nt\\'"]|\\[0-9a-fA-F][0-9a-fA-F])*"/, token: "string"},
    {regex: /\(;.*?/, token: "comment", next: "comment"},
    {regex: /;;.*$/, token: "comment"},
    {regex: /\(/, indent: true},
    {regex: /\)/, dedent: true},
  ],

  comment: [
    {regex: /.*?;\)/, token: "comment", next: "start"},
    {regex: /.*/, token: "comment"},
  ],

  meta: {
    dontIndentStates: ['comment'],
  },
});

// https://github.com/WebAssembly/design/issues/981 mentions text/webassembly,
// which seems like a reasonable choice, although it's not standard right now.
CodeMirror.defineMIME("text/webassembly", "wast");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/webidl/webidl.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

function wordRegexp(words) {
  return new RegExp("^((" + words.join(")|(") + "))\\b");
};

var builtinArray = [
  "Clamp",
  "Constructor",
  "EnforceRange",
  "Exposed",
  "ImplicitThis",
  "Global", "PrimaryGlobal",
  "LegacyArrayClass",
  "LegacyUnenumerableNamedProperties",
  "LenientThis",
  "NamedConstructor",
  "NewObject",
  "NoInterfaceObject",
  "OverrideBuiltins",
  "PutForwards",
  "Replaceable",
  "SameObject",
  "TreatNonObjectAsNull",
  "TreatNullAs",
    "EmptyString",
  "Unforgeable",
  "Unscopeable"
];
var builtins = wordRegexp(builtinArray);

var typeArray = [
  "unsigned", "short", "long",                  // UnsignedIntegerType
  "unrestricted", "float", "double",            // UnrestrictedFloatType
  "boolean", "byte", "octet",                   // Rest of PrimitiveType
  "Promise",                                    // PromiseType
  "ArrayBuffer", "DataView", "Int8Array", "Int16Array", "Int32Array",
  "Uint8Array", "Uint16Array", "Uint32Array", "Uint8ClampedArray",
  "Float32Array", "Float64Array",               // BufferRelatedType
  "ByteString", "DOMString", "USVString", "sequence", "object", "RegExp",
  "Error", "DOMException", "FrozenArray",       // Rest of NonAnyType
  "any",                                        // Rest of SingleType
  "void"                                        // Rest of ReturnType
];
var types = wordRegexp(typeArray);

var keywordArray = [
  "attribute", "callback", "const", "deleter", "dictionary", "enum", "getter",
  "implements", "inherit", "interface", "iterable", "legacycaller", "maplike",
  "partial", "required", "serializer", "setlike", "setter", "static",
  "stringifier", "typedef",                     // ArgumentNameKeyword except
                                                // "unrestricted"
  "optional", "readonly", "or"
];
var keywords = wordRegexp(keywordArray);

var atomArray = [
  "true", "false",                              // BooleanLiteral
  "Infinity", "NaN",                            // FloatLiteral
  "null"                                        // Rest of ConstValue
];
var atoms = wordRegexp(atomArray);

CodeMirror.registerHelper("hintWords", "webidl",
    builtinArray.concat(typeArray).concat(keywordArray).concat(atomArray));

var startDefArray = ["callback", "dictionary", "enum", "interface"];
var startDefs = wordRegexp(startDefArray);

var endDefArray = ["typedef"];
var endDefs = wordRegexp(endDefArray);

var singleOperators = /^[:<=>?]/;
var integers = /^-?([1-9][0-9]*|0[Xx][0-9A-Fa-f]+|0[0-7]*)/;
var floats = /^-?(([0-9]+\.[0-9]*|[0-9]*\.[0-9]+)([Ee][+-]?[0-9]+)?|[0-9]+[Ee][+-]?[0-9]+)/;
var identifiers = /^_?[A-Za-z][0-9A-Z_a-z-]*/;
var identifiersEnd = /^_?[A-Za-z][0-9A-Z_a-z-]*(?=\s*;)/;
var strings = /^"[^"]*"/;
var multilineComments = /^\/\*.*?\*\//;
var multilineCommentsStart = /^\/\*.*/;
var multilineCommentsEnd = /^.*?\*\//;

function readToken(stream, state) {
  // whitespace
  if (stream.eatSpace()) return null;

  // comment
  if (state.inComment) {
    if (stream.match(multilineCommentsEnd)) {
      state.inComment = false;
      return "comment";
    }
    stream.skipToEnd();
    return "comment";
  }
  if (stream.match("//")) {
    stream.skipToEnd();
    return "comment";
  }
  if (stream.match(multilineComments)) return "comment";
  if (stream.match(multilineCommentsStart)) {
    state.inComment = true;
    return "comment";
  }

  // integer and float
  if (stream.match(/^-?[0-9\.]/, false)) {
    if (stream.match(integers) || stream.match(floats)) return "number";
  }

  // string
  if (stream.match(strings)) return "string";

  // identifier
  if (state.startDef && stream.match(identifiers)) return "def";

  if (state.endDef && stream.match(identifiersEnd)) {
    state.endDef = false;
    return "def";
  }

  if (stream.match(keywords)) return "keyword";

  if (stream.match(types)) {
    var lastToken = state.lastToken;
    var nextToken = (stream.match(/^\s*(.+?)\b/, false) || [])[1];

    if (lastToken === ":" || lastToken === "implements" ||
        nextToken === "implements" || nextToken === "=") {
      // Used as identifier
      return "builtin";
    } else {
      // Used as type
      return "variable-3";
    }
  }

  if (stream.match(builtins)) return "builtin";
  if (stream.match(atoms)) return "atom";
  if (stream.match(identifiers)) return "variable";

  // other
  if (stream.match(singleOperators)) return "operator";

  // unrecognized
  stream.next();
  return null;
};

CodeMirror.defineMode("webidl", function() {
  return {
    startState: function() {
      return {
        // Is in multiline comment
        inComment: false,
        // Last non-whitespace, matched token
        lastToken: "",
        // Next token is a definition
        startDef: false,
        // Last token of the statement is a definition
        endDef: false
      };
    },
    token: function(stream, state) {
      var style = readToken(stream, state);

      if (style) {
        var cur = stream.current();
        state.lastToken = cur;
        if (style === "keyword") {
          state.startDef = startDefs.test(cur);
          state.endDef = state.endDef || endDefs.test(cur);
        } else {
          state.startDef = false;
        }
      }

      return style;
    }
  };
});

CodeMirror.defineMIME("text/x-webidl", "webidl");
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/xquery/xquery.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("xquery", function() {

  // The keywords object is set to the result of this self executing
  // function. Each keyword is a property of the keywords object whose
  // value is {type: atype, style: astyle}
  var keywords = function(){
    // convenience functions used to build keywords object
    function kw(type) {return {type: type, style: "keyword"};}
    var operator = kw("operator")
      , atom = {type: "atom", style: "atom"}
      , punctuation = {type: "punctuation", style: null}
      , qualifier = {type: "axis_specifier", style: "qualifier"};

    // kwObj is what is return from this function at the end
    var kwObj = {
      ',': punctuation
    };

    // a list of 'basic' keywords. For each add a property to kwObj with the value of
    // {type: basic[i], style: "keyword"} e.g. 'after' --> {type: "after", style: "keyword"}
    var basic = ['after', 'all', 'allowing', 'ancestor', 'ancestor-or-self', 'any', 'array', 'as',
    'ascending', 'at', 'attribute', 'base-uri', 'before', 'boundary-space', 'by', 'case', 'cast',
    'castable', 'catch', 'child', 'collation', 'comment', 'construction', 'contains', 'content',
    'context', 'copy', 'copy-namespaces', 'count', 'decimal-format', 'declare', 'default', 'delete',
    'descendant', 'descendant-or-self', 'descending', 'diacritics', 'different', 'distance',
    'document', 'document-node', 'element', 'else', 'empty', 'empty-sequence', 'encoding', 'end',
    'entire', 'every', 'exactly', 'except', 'external', 'first', 'following', 'following-sibling',
    'for', 'from', 'ftand', 'ftnot', 'ft-option', 'ftor', 'function', 'fuzzy', 'greatest', 'group',
    'if', 'import', 'in', 'inherit', 'insensitive', 'insert', 'instance', 'intersect', 'into',
    'invoke', 'is', 'item', 'language', 'last', 'lax', 'least', 'let', 'levels', 'lowercase', 'map',
    'modify', 'module', 'most', 'namespace', 'next', 'no', 'node', 'nodes', 'no-inherit',
    'no-preserve', 'not', 'occurs', 'of', 'only', 'option', 'order', 'ordered', 'ordering',
    'paragraph', 'paragraphs', 'parent', 'phrase', 'preceding', 'preceding-sibling', 'preserve',
    'previous', 'processing-instruction', 'relationship', 'rename', 'replace', 'return',
    'revalidation', 'same', 'satisfies', 'schema', 'schema-attribute', 'schema-element', 'score',
    'self', 'sensitive', 'sentence', 'sentences', 'sequence', 'skip', 'sliding', 'some', 'stable',
    'start', 'stemming', 'stop', 'strict', 'strip', 'switch', 'text', 'then', 'thesaurus', 'times',
    'to', 'transform', 'treat', 'try', 'tumbling', 'type', 'typeswitch', 'union', 'unordered',
    'update', 'updating', 'uppercase', 'using', 'validate', 'value', 'variable', 'version',
    'weight', 'when', 'where', 'wildcards', 'window', 'with', 'without', 'word', 'words', 'xquery'];
    for(var i=0, l=basic.length; i < l; i++) { kwObj[basic[i]] = kw(basic[i]);};

    // a list of types. For each add a property to kwObj with the value of
    // {type: "atom", style: "atom"}
    var types = ['xs:anyAtomicType', 'xs:anySimpleType', 'xs:anyType', 'xs:anyURI',
    'xs:base64Binary', 'xs:boolean', 'xs:byte', 'xs:date', 'xs:dateTime', 'xs:dateTimeStamp',
    'xs:dayTimeDuration', 'xs:decimal', 'xs:double', 'xs:duration', 'xs:ENTITIES', 'xs:ENTITY',
    'xs:float', 'xs:gDay', 'xs:gMonth', 'xs:gMonthDay', 'xs:gYear', 'xs:gYearMonth', 'xs:hexBinary',
    'xs:ID', 'xs:IDREF', 'xs:IDREFS', 'xs:int', 'xs:integer', 'xs:item', 'xs:java', 'xs:language',
    'xs:long', 'xs:Name', 'xs:NCName', 'xs:negativeInteger', 'xs:NMTOKEN', 'xs:NMTOKENS',
    'xs:nonNegativeInteger', 'xs:nonPositiveInteger', 'xs:normalizedString', 'xs:NOTATION',
    'xs:numeric', 'xs:positiveInteger', 'xs:precisionDecimal', 'xs:QName', 'xs:short', 'xs:string',
    'xs:time', 'xs:token', 'xs:unsignedByte', 'xs:unsignedInt', 'xs:unsignedLong',
    'xs:unsignedShort', 'xs:untyped', 'xs:untypedAtomic', 'xs:yearMonthDuration'];
    for(var i=0, l=types.length; i < l; i++) { kwObj[types[i]] = atom;};

    // each operator will add a property to kwObj with value of {type: "operator", style: "keyword"}
    var operators = ['eq', 'ne', 'lt', 'le', 'gt', 'ge', ':=', '=', '>', '>=', '<', '<=', '.', '|', '?', 'and', 'or', 'div', 'idiv', 'mod', '*', '/', '+', '-'];
    for(var i=0, l=operators.length; i < l; i++) { kwObj[operators[i]] = operator;};

    // each axis_specifiers will add a property to kwObj with value of {type: "axis_specifier", style: "qualifier"}
    var axis_specifiers = ["self::", "attribute::", "child::", "descendant::", "descendant-or-self::", "parent::",
    "ancestor::", "ancestor-or-self::", "following::", "preceding::", "following-sibling::", "preceding-sibling::"];
    for(var i=0, l=axis_specifiers.length; i < l; i++) { kwObj[axis_specifiers[i]] = qualifier; };

    return kwObj;
  }();

  function chain(stream, state, f) {
    state.tokenize = f;
    return f(stream, state);
  }

  // the primary mode tokenizer
  function tokenBase(stream, state) {
    var ch = stream.next(),
        mightBeFunction = false,
        isEQName = isEQNameAhead(stream);

    // an XML tag (if not in some sub, chained tokenizer)
    if (ch == "<") {
      if(stream.match("!--", true))
        return chain(stream, state, tokenXMLComment);

      if(stream.match("![CDATA", false)) {
        state.tokenize = tokenCDATA;
        return "tag";
      }

      if(stream.match("?", false)) {
        return chain(stream, state, tokenPreProcessing);
      }

      var isclose = stream.eat("/");
      stream.eatSpace();
      var tagName = "", c;
      while ((c = stream.eat(/[^\s\u00a0=<>\"\'\/?]/))) tagName += c;

      return chain(stream, state, tokenTag(tagName, isclose));
    }
    // start code block
    else if(ch == "{") {
      pushStateStack(state, { type: "codeblock"});
      return null;
    }
    // end code block
    else if(ch == "}") {
      popStateStack(state);
      return null;
    }
    // if we're in an XML block
    else if(isInXmlBlock(state)) {
      if(ch == ">")
        return "tag";
      else if(ch == "/" && stream.eat(">")) {
        popStateStack(state);
        return "tag";
      }
      else
        return "variable";
    }
    // if a number
    else if (/\d/.test(ch)) {
      stream.match(/^\d*(?:\.\d*)?(?:E[+\-]?\d+)?/);
      return "atom";
    }
    // comment start
    else if (ch === "(" && stream.eat(":")) {
      pushStateStack(state, { type: "comment"});
      return chain(stream, state, tokenComment);
    }
    // quoted string
    else if (!isEQName && (ch === '"' || ch === "'"))
      return chain(stream, state, tokenString(ch));
    // variable
    else if(ch === "$") {
      return chain(stream, state, tokenVariable);
    }
    // assignment
    else if(ch ===":" && stream.eat("=")) {
      return "keyword";
    }
    // open paren
    else if(ch === "(") {
      pushStateStack(state, { type: "paren"});
      return null;
    }
    // close paren
    else if(ch === ")") {
      popStateStack(state);
      return null;
    }
    // open paren
    else if(ch === "[") {
      pushStateStack(state, { type: "bracket"});
      return null;
    }
    // close paren
    else if(ch === "]") {
      popStateStack(state);
      return null;
    }
    else {
      var known = keywords.propertyIsEnumerable(ch) && keywords[ch];

      // if there's a EQName ahead, consume the rest of the string portion, it's likely a function
      if(isEQName && ch === '\"') while(stream.next() !== '"'){}
      if(isEQName && ch === '\'') while(stream.next() !== '\''){}

      // gobble up a word if the character is not known
      if(!known) stream.eatWhile(/[\w\$_-]/);

      // gobble a colon in the case that is a lib func type call fn:doc
      var foundColon = stream.eat(":");

      // if there's not a second colon, gobble another word. Otherwise, it's probably an axis specifier
      // which should get matched as a keyword
      if(!stream.eat(":") && foundColon) {
        stream.eatWhile(/[\w\$_-]/);
      }
      // if the next non whitespace character is an open paren, this is probably a function (if not a keyword of other sort)
      if(stream.match(/^[ \t]*\(/, false)) {
        mightBeFunction = true;
      }
      // is the word a keyword?
      var word = stream.current();
      known = keywords.propertyIsEnumerable(word) && keywords[word];

      // if we think it's a function call but not yet known,
      // set style to variable for now for lack of something better
      if(mightBeFunction && !known) known = {type: "function_call", style: "variable def"};

      // if the previous word was element, attribute, axis specifier, this word should be the name of that
      if(isInXmlConstructor(state)) {
        popStateStack(state);
        return "variable";
      }
      // as previously checked, if the word is element,attribute, axis specifier, call it an "xmlconstructor" and
      // push the stack so we know to look for it on the next word
      if(word == "element" || word == "attribute" || known.type == "axis_specifier") pushStateStack(state, {type: "xmlconstructor"});

      // if the word is known, return the details of that else just call this a generic 'word'
      return known ? known.style : "variable";
    }
  }

  // handle comments, including nested
  function tokenComment(stream, state) {
    var maybeEnd = false, maybeNested = false, nestedCount = 0, ch;
    while (ch = stream.next()) {
      if (ch == ")" && maybeEnd) {
        if(nestedCount > 0)
          nestedCount--;
        else {
          popStateStack(state);
          break;
        }
      }
      else if(ch == ":" && maybeNested) {
        nestedCount++;
      }
      maybeEnd = (ch == ":");
      maybeNested = (ch == "(");
    }

    return "comment";
  }

  // tokenizer for string literals
  // optionally pass a tokenizer function to set state.tokenize back to when finished
  function tokenString(quote, f) {
    return function(stream, state) {
      var ch;

      if(isInString(state) && stream.current() == quote) {
        popStateStack(state);
        if(f) state.tokenize = f;
        return "string";
      }

      pushStateStack(state, { type: "string", name: quote, tokenize: tokenString(quote, f) });

      // if we're in a string and in an XML block, allow an embedded code block
      if(stream.match("{", false) && isInXmlAttributeBlock(state)) {
        state.tokenize = tokenBase;
        return "string";
      }


      while (ch = stream.next()) {
        if (ch ==  quote) {
          popStateStack(state);
          if(f) state.tokenize = f;
          break;
        }
        else {
          // if we're in a string and in an XML block, allow an embedded code block in an attribute
          if(stream.match("{", false) && isInXmlAttributeBlock(state)) {
            state.tokenize = tokenBase;
            return "string";
          }

        }
      }

      return "string";
    };
  }

  // tokenizer for variables
  function tokenVariable(stream, state) {
    var isVariableChar = /[\w\$_-]/;

    // a variable may start with a quoted EQName so if the next character is quote, consume to the next quote
    if(stream.eat("\"")) {
      while(stream.next() !== '\"'){};
      stream.eat(":");
    } else {
      stream.eatWhile(isVariableChar);
      if(!stream.match(":=", false)) stream.eat(":");
    }
    stream.eatWhile(isVariableChar);
    state.tokenize = tokenBase;
    return "variable";
  }

  // tokenizer for XML tags
  function tokenTag(name, isclose) {
    return function(stream, state) {
      stream.eatSpace();
      if(isclose && stream.eat(">")) {
        popStateStack(state);
        state.tokenize = tokenBase;
        return "tag";
      }
      // self closing tag without attributes?
      if(!stream.eat("/"))
        pushStateStack(state, { type: "tag", name: name, tokenize: tokenBase});
      if(!stream.eat(">")) {
        state.tokenize = tokenAttribute;
        return "tag";
      }
      else {
        state.tokenize = tokenBase;
      }
      return "tag";
    };
  }

  // tokenizer for XML attributes
  function tokenAttribute(stream, state) {
    var ch = stream.next();

    if(ch == "/" && stream.eat(">")) {
      if(isInXmlAttributeBlock(state)) popStateStack(state);
      if(isInXmlBlock(state)) popStateStack(state);
      return "tag";
    }
    if(ch == ">") {
      if(isInXmlAttributeBlock(state)) popStateStack(state);
      return "tag";
    }
    if(ch == "=")
      return null;
    // quoted string
    if (ch == '"' || ch == "'")
      return chain(stream, state, tokenString(ch, tokenAttribute));

    if(!isInXmlAttributeBlock(state))
      pushStateStack(state, { type: "attribute", tokenize: tokenAttribute});

    stream.eat(/[a-zA-Z_:]/);
    stream.eatWhile(/[-a-zA-Z0-9_:.]/);
    stream.eatSpace();

    // the case where the attribute has not value and the tag was closed
    if(stream.match(">", false) || stream.match("/", false)) {
      popStateStack(state);
      state.tokenize = tokenBase;
    }

    return "attribute";
  }

  // handle comments, including nested
  function tokenXMLComment(stream, state) {
    var ch;
    while (ch = stream.next()) {
      if (ch == "-" && stream.match("->", true)) {
        state.tokenize = tokenBase;
        return "comment";
      }
    }
  }


  // handle CDATA
  function tokenCDATA(stream, state) {
    var ch;
    while (ch = stream.next()) {
      if (ch == "]" && stream.match("]", true)) {
        state.tokenize = tokenBase;
        return "comment";
      }
    }
  }

  // handle preprocessing instructions
  function tokenPreProcessing(stream, state) {
    var ch;
    while (ch = stream.next()) {
      if (ch == "?" && stream.match(">", true)) {
        state.tokenize = tokenBase;
        return "comment meta";
      }
    }
  }


  // functions to test the current context of the state
  function isInXmlBlock(state) { return isIn(state, "tag"); }
  function isInXmlAttributeBlock(state) { return isIn(state, "attribute"); }
  function isInXmlConstructor(state) { return isIn(state, "xmlconstructor"); }
  function isInString(state) { return isIn(state, "string"); }

  function isEQNameAhead(stream) {
    // assume we've already eaten a quote (")
    if(stream.current() === '"')
      return stream.match(/^[^\"]+\"\:/, false);
    else if(stream.current() === '\'')
      return stream.match(/^[^\"]+\'\:/, false);
    else
      return false;
  }

  function isIn(state, type) {
    return (state.stack.length && state.stack[state.stack.length - 1].type == type);
  }

  function pushStateStack(state, newState) {
    state.stack.push(newState);
  }

  function popStateStack(state) {
    state.stack.pop();
    var reinstateTokenize = state.stack.length && state.stack[state.stack.length-1].tokenize;
    state.tokenize = reinstateTokenize || tokenBase;
  }

  // the interface for the mode API
  return {
    startState: function() {
      return {
        tokenize: tokenBase,
        cc: [],
        stack: []
      };
    },

    token: function(stream, state) {
      if (stream.eatSpace()) return null;
      var style = state.tokenize(stream, state);
      return style;
    },

    blockCommentStart: "(:",
    blockCommentEnd: ":)"

  };

});

CodeMirror.defineMIME("application/xquery", "xquery");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/yacas/yacas.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// Yacas mode copyright (c) 2015 by Grzegorz Mazur
// Loosely based on mathematica mode by Calin Barbat

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode('yacas', function(_config, _parserConfig) {

  function words(str) {
    var obj = {}, words = str.split(" ");
    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
    return obj;
  }

  var bodiedOps = words("Assert BackQuote D Defun Deriv For ForEach FromFile " +
                        "FromString Function Integrate InverseTaylor Limit " +
                        "LocalSymbols Macro MacroRule MacroRulePattern " +
                        "NIntegrate Rule RulePattern Subst TD TExplicitSum " +
                        "TSum Taylor Taylor1 Taylor2 Taylor3 ToFile " +
                        "ToStdout ToString TraceRule Until While");

  // patterns
  var pFloatForm  = "(?:(?:\\.\\d+|\\d+\\.\\d*|\\d+)(?:[eE][+-]?\\d+)?)";
  var pIdentifier = "(?:[a-zA-Z\\$'][a-zA-Z0-9\\$']*)";

  // regular expressions
  var reFloatForm    = new RegExp(pFloatForm);
  var reIdentifier   = new RegExp(pIdentifier);
  var rePattern      = new RegExp(pIdentifier + "?_" + pIdentifier);
  var reFunctionLike = new RegExp(pIdentifier + "\\s*\\(");

  function tokenBase(stream, state) {
    var ch;

    // get next character
    ch = stream.next();

    // string
    if (ch === '"') {
      state.tokenize = tokenString;
      return state.tokenize(stream, state);
    }

    // comment
    if (ch === '/') {
      if (stream.eat('*')) {
        state.tokenize = tokenComment;
        return state.tokenize(stream, state);
      }
      if (stream.eat("/")) {
        stream.skipToEnd();
        return "comment";
      }
    }

    // go back one character
    stream.backUp(1);

    // update scope info
    var m = stream.match(/^(\w+)\s*\(/, false);
    if (m !== null && bodiedOps.hasOwnProperty(m[1]))
      state.scopes.push('bodied');

    var scope = currentScope(state);

    if (scope === 'bodied' && ch === '[')
      state.scopes.pop();

    if (ch === '[' || ch === '{' || ch === '(')
      state.scopes.push(ch);

    scope = currentScope(state);

    if (scope === '[' && ch === ']' ||
        scope === '{' && ch === '}' ||
        scope === '(' && ch === ')')
      state.scopes.pop();

    if (ch === ';') {
      while (scope === 'bodied') {
        state.scopes.pop();
        scope = currentScope(state);
      }
    }

    // look for ordered rules
    if (stream.match(/\d+ *#/, true, false)) {
      return 'qualifier';
    }

    // look for numbers
    if (stream.match(reFloatForm, true, false)) {
      return 'number';
    }

    // look for placeholders
    if (stream.match(rePattern, true, false)) {
      return 'variable-3';
    }

    // match all braces separately
    if (stream.match(/(?:\[|\]|{|}|\(|\))/, true, false)) {
      return 'bracket';
    }

    // literals looking like function calls
    if (stream.match(reFunctionLike, true, false)) {
      stream.backUp(1);
      return 'variable';
    }

    // all other identifiers
    if (stream.match(reIdentifier, true, false)) {
      return 'variable-2';
    }

    // operators; note that operators like @@ or /; are matched separately for each symbol.
    if (stream.match(/(?:\\|\+|\-|\*|\/|,|;|\.|:|@|~|=|>|<|&|\||_|`|'|\^|\?|!|%|#)/, true, false)) {
      return 'operator';
    }

    // everything else is an error
    return 'error';
  }

  function tokenString(stream, state) {
    var next, end = false, escaped = false;
    while ((next = stream.next()) != null) {
      if (next === '"' && !escaped) {
        end = true;
        break;
      }
      escaped = !escaped && next === '\\';
    }
    if (end && !escaped) {
      state.tokenize = tokenBase;
    }
    return 'string';
  };

  function tokenComment(stream, state) {
    var prev, next;
    while((next = stream.next()) != null) {
      if (prev === '*' && next === '/') {
        state.tokenize = tokenBase;
        break;
      }
      prev = next;
    }
    return 'comment';
  }

  function currentScope(state) {
    var scope = null;
    if (state.scopes.length > 0)
      scope = state.scopes[state.scopes.length - 1];
    return scope;
  }

  return {
    startState: function() {
      return {
        tokenize: tokenBase,
        scopes: []
      };
    },
    token: function(stream, state) {
      if (stream.eatSpace()) return null;
      return state.tokenize(stream, state);
    },
    indent: function(state, textAfter) {
      if (state.tokenize !== tokenBase && state.tokenize !== null)
        return CodeMirror.Pass;

      var delta = 0;
      if (textAfter === ']' || textAfter === '];' ||
          textAfter === '}' || textAfter === '};' ||
          textAfter === ');')
        delta = -1;

      return (state.scopes.length + delta) * _config.indentUnit;
    },
    electricChars: "{}[]();",
    blockCommentStart: "/*",
    blockCommentEnd: "*/",
    lineComment: "//"
  };
});

CodeMirror.defineMIME('text/x-yacas', {
  name: 'yacas'
});

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/yaml-frontmatter/yaml-frontmatter.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function (mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"), __webpack_require__("./src/ipywidgets/node_modules/codemirror/mode/yaml/yaml.js"))
  else {}
})(function (CodeMirror) {

  var START = 0, FRONTMATTER = 1, BODY = 2

  // a mixed mode for Markdown text with an optional YAML front matter
  CodeMirror.defineMode("yaml-frontmatter", function (config, parserConfig) {
    var yamlMode = CodeMirror.getMode(config, "yaml")
    var innerMode = CodeMirror.getMode(config, parserConfig && parserConfig.base || "gfm")

    function curMode(state) {
      return state.state == BODY ? innerMode : yamlMode
    }

    return {
      startState: function () {
        return {
          state: START,
          inner: CodeMirror.startState(yamlMode)
        }
      },
      copyState: function (state) {
        return {
          state: state.state,
          inner: CodeMirror.copyState(curMode(state), state.inner)
        }
      },
      token: function (stream, state) {
        if (state.state == START) {
          if (stream.match('---', false)) {
            state.state = FRONTMATTER
            return yamlMode.token(stream, state.inner)
          } else {
            state.state = BODY
            state.inner = CodeMirror.startState(innerMode)
            return innerMode.token(stream, state.inner)
          }
        } else if (state.state == FRONTMATTER) {
          var end = stream.sol() && stream.match(/(---|\.\.\.)/, false)
          var style = yamlMode.token(stream, state.inner)
          if (end) {
            state.state = BODY
            state.inner = CodeMirror.startState(innerMode)
          }
          return style
        } else {
          return innerMode.token(stream, state.inner)
        }
      },
      innerMode: function (state) {
        return {mode: curMode(state), state: state.inner}
      },
      indent: function(state, a, b) {
        var mode = curMode(state)
        return mode.indent ? mode.indent(state.inner, a, b) : CodeMirror.Pass
      },
      blankLine: function (state) {
        var mode = curMode(state)
        if (mode.blankLine) return mode.blankLine(state.inner)
      }
    }
  })
});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/yaml/yaml.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("yaml", function() {

  var cons = ['true', 'false', 'on', 'off', 'yes', 'no'];
  var keywordRegex = new RegExp("\\b(("+cons.join(")|(")+"))$", 'i');

  return {
    token: function(stream, state) {
      var ch = stream.peek();
      var esc = state.escaped;
      state.escaped = false;
      /* comments */
      if (ch == "#" && (stream.pos == 0 || /\s/.test(stream.string.charAt(stream.pos - 1)))) {
        stream.skipToEnd();
        return "comment";
      }

      if (stream.match(/^('([^']|\\.)*'?|"([^"]|\\.)*"?)/))
        return "string";

      if (state.literal && stream.indentation() > state.keyCol) {
        stream.skipToEnd(); return "string";
      } else if (state.literal) { state.literal = false; }
      if (stream.sol()) {
        state.keyCol = 0;
        state.pair = false;
        state.pairStart = false;
        /* document start */
        if(stream.match('---')) { return "def"; }
        /* document end */
        if (stream.match('...')) { return "def"; }
        /* array list item */
        if (stream.match(/\s*-\s+/)) { return 'meta'; }
      }
      /* inline pairs/lists */
      if (stream.match(/^(\{|\}|\[|\])/)) {
        if (ch == '{')
          state.inlinePairs++;
        else if (ch == '}')
          state.inlinePairs--;
        else if (ch == '[')
          state.inlineList++;
        else
          state.inlineList--;
        return 'meta';
      }

      /* list separator */
      if (state.inlineList > 0 && !esc && ch == ',') {
        stream.next();
        return 'meta';
      }
      /* pairs separator */
      if (state.inlinePairs > 0 && !esc && ch == ',') {
        state.keyCol = 0;
        state.pair = false;
        state.pairStart = false;
        stream.next();
        return 'meta';
      }

      /* start of value of a pair */
      if (state.pairStart) {
        /* block literals */
        if (stream.match(/^\s*(\||\>)\s*/)) { state.literal = true; return 'meta'; };
        /* references */
        if (stream.match(/^\s*(\&|\*)[a-z0-9\._-]+\b/i)) { return 'variable-2'; }
        /* numbers */
        if (state.inlinePairs == 0 && stream.match(/^\s*-?[0-9\.\,]+\s?$/)) { return 'number'; }
        if (state.inlinePairs > 0 && stream.match(/^\s*-?[0-9\.\,]+\s?(?=(,|}))/)) { return 'number'; }
        /* keywords */
        if (stream.match(keywordRegex)) { return 'keyword'; }
      }

      /* pairs (associative arrays) -> key */
      if (!state.pair && stream.match(/^\s*(?:[,\[\]{}&*!|>'"%@`][^\s'":]|[^,\[\]{}#&*!|>'"%@`])[^#]*?(?=\s*:($|\s))/)) {
        state.pair = true;
        state.keyCol = stream.indentation();
        return "atom";
      }
      if (state.pair && stream.match(/^:\s*/)) { state.pairStart = true; return 'meta'; }

      /* nothing found, continue */
      state.pairStart = false;
      state.escaped = (ch == '\\');
      stream.next();
      return null;
    },
    startState: function() {
      return {
        pair: false,
        pairStart: false,
        keyCol: 0,
        inlinePairs: 0,
        inlineList: 0,
        literal: false,
        escaped: false
      };
    },
    lineComment: "#",
    fold: "indent"
  };
});

CodeMirror.defineMIME("text/x-yaml", "yaml");
CodeMirror.defineMIME("text/yaml", "yaml");

});


/***/ }),

/***/ "./src/ipywidgets/node_modules/codemirror/mode/z80/z80.js":
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (true) // CommonJS
  mod(__webpack_require__("./src/ipywidgets/node_modules/codemirror/lib/codemirror.js"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode('z80', function(_config, parserConfig) {
  var ez80 = parserConfig.ez80;
  var keywords1, keywords2;
  if (ez80) {
    keywords1 = /^(exx?|(ld|cp)([di]r?)?|[lp]ea|pop|push|ad[cd]|cpl|daa|dec|inc|neg|sbc|sub|and|bit|[cs]cf|x?or|res|set|r[lr]c?a?|r[lr]d|s[lr]a|srl|djnz|nop|[de]i|halt|im|in([di]mr?|ir?|irx|2r?)|ot(dmr?|[id]rx|imr?)|out(0?|[di]r?|[di]2r?)|tst(io)?|slp)(\.([sl]?i)?[sl])?\b/i;
    keywords2 = /^(((call|j[pr]|rst|ret[in]?)(\.([sl]?i)?[sl])?)|(rs|st)mix)\b/i;
  } else {
    keywords1 = /^(exx?|(ld|cp|in)([di]r?)?|pop|push|ad[cd]|cpl|daa|dec|inc|neg|sbc|sub|and|bit|[cs]cf|x?or|res|set|r[lr]c?a?|r[lr]d|s[lr]a|srl|djnz|nop|rst|[de]i|halt|im|ot[di]r|out[di]?)\b/i;
    keywords2 = /^(call|j[pr]|ret[in]?|b_?(call|jump))\b/i;
  }

  var variables1 = /^(af?|bc?|c|de?|e|hl?|l|i[xy]?|r|sp)\b/i;
  var variables2 = /^(n?[zc]|p[oe]?|m)\b/i;
  var errors = /^([hl][xy]|i[xy][hl]|slia|sll)\b/i;
  var numbers = /^([\da-f]+h|[0-7]+o|[01]+b|\d+d?)\b/i;

  return {
    startState: function() {
      return {
        context: 0
      };
    },
    token: function(stream, state) {
      if (!stream.column())
        state.context = 0;

      if (stream.eatSpace())
        return null;

      var w;

      if (stream.eatWhile(/\w/)) {
        if (ez80 && stream.eat('.')) {
          stream.eatWhile(/\w/);
        }
        w = stream.current();

        if (stream.indentation()) {
          if ((state.context == 1 || state.context == 4) && variables1.test(w)) {
            state.context = 4;
            return 'var2';
          }

          if (state.context == 2 && variables2.test(w)) {
            state.context = 4;
            return 'var3';
          }

          if (keywords1.test(w)) {
            state.context = 1;
            return 'keyword';
          } else if (keywords2.test(w)) {
            state.context = 2;
            return 'keyword';
          } else if (state.context == 4 && numbers.test(w)) {
            return 'number';
          }

          if (errors.test(w))
            return 'error';
        } else if (stream.match(numbers)) {
          return 'number';
        } else {
          return null;
        }
      } else if (stream.eat(';')) {
        stream.skipToEnd();
        return 'comment';
      } else if (stream.eat('"')) {
        while (w = stream.next()) {
          if (w == '"')
            break;

          if (w == '\\')
            stream.next();
        }
        return 'string';
      } else if (stream.eat('\'')) {
        if (stream.match(/\\?.'/))
          return 'number';
      } else if (stream.eat('.') || stream.sol() && stream.eat('#')) {
        state.context = 5;

        if (stream.eatWhile(/\w/))
          return 'def';
      } else if (stream.eat('$')) {
        if (stream.eatWhile(/[\da-f]/i))
          return 'number';
      } else if (stream.eat('%')) {
        if (stream.eatWhile(/[01]/))
          return 'number';
      } else {
        stream.next();
      }
      return null;
    }
  };
});

CodeMirror.defineMIME("text/x-z80", "z80");
CodeMirror.defineMIME("text/x-ez80", { name: "z80", ez80: true });

});


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1zcmNfaXB5d2lkZ2V0c19ub2RlX21vZHVsZXNfY29kZW1pcnJvcl9tb2RlX2FwbF9hcGxfanMtc3JjX2lweXdpZGdldHNfbm9kZV9tb2R1bGVzX2NvLWViNzU0OS5pcHl3aWRnZXRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTs7QUFFQTtBQUNBLE1BQU0sSUFBdUQ7QUFDN0QsUUFBUSxtQkFBTyxDQUFDLDREQUFzQjtBQUN0QyxPQUFPLEVBR2E7QUFDcEIsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVSxrQ0FBa0M7QUFDNUMsOEJBQThCO0FBQzlCO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7Ozs7Ozs7QUNsTkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLElBQXVEO0FBQzdELFFBQVEsbUJBQU8sQ0FBQyw0REFBc0I7QUFDdEMsT0FBTyxFQUdhO0FBQ3BCLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLFdBQVc7O0FBRXRDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsTUFBTSx5Q0FBeUM7QUFDL0M7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLG9FQUFvRSw2Q0FBNkM7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUM3SUQ7QUFDQTs7QUFFQTtBQUNBLE1BQU0sSUFBdUQ7QUFDN0QsUUFBUSxtQkFBTyxDQUFDLDREQUFzQjtBQUN0QyxPQUFPLEVBR2E7QUFDcEIsQ0FBQztBQUNEOztBQUVBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU0sZ0JBQWdCO0FBQ3RCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLENBQUM7Ozs7Ozs7O0FDNUtEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxNQUFNLElBQXVEO0FBQzdELFFBQVEsbUJBQU8sQ0FBQyw0REFBc0I7QUFDdEMsT0FBTyxFQUdhO0FBQ3BCLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMkJBQTJCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMkJBQTJCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQixhQUFhO0FBQ2IsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLG1CQUFtQjtBQUM5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQyxtQkFBbUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsbUJBQW1CO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7Ozs7Ozs7O0FDbkxEO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLElBQXVEO0FBQzdELFFBQVEsbUJBQU8sQ0FBQyw0REFBc0I7QUFDdEMsT0FBTyxFQUdhO0FBQ3BCLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQzNMRDtBQUNBOztBQUVBO0FBQ0EsTUFBTSxJQUF1RDtBQUM3RCxRQUFRLG1CQUFPLENBQUMsNERBQXNCO0FBQ3RDLE9BQU8sRUFHYTtBQUNwQixDQUFDO0FBQ0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxDQUFDOzs7Ozs7OztBQ3hWRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsRUFBRSw4QkFBOEIsRUFBRTtBQUM1RDs7QUFFQTtBQUNBLE1BQU0sSUFBdUQ7QUFDN0QsUUFBUSxtQkFBTyxDQUFDLDREQUFzQjtBQUN0QyxPQUFPLEVBR2E7QUFDcEIsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDakxEO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLElBQXVEO0FBQzdELFFBQVEsbUJBQU8sQ0FBQyw0REFBc0I7QUFDdEMsT0FBTyxFQUdhO0FBQ3BCLENBQUM7QUFDRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxZQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLHlDQUF5QztBQUNoRTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsc0JBQXNCO0FBQ3RCLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQzFMRDtBQUNBOztBQUVBO0FBQ0EsTUFBTSxJQUF1RDtBQUM3RCxRQUFRLG1CQUFPLENBQUMsNERBQXNCO0FBQ3RDLE9BQU8sRUFHYTtBQUNwQixDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixvQkFBb0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDhCQUE4QjtBQUNuRDtBQUNBLDJCQUEyQix1QkFBdUI7QUFDbEQ7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQiw2Q0FBNkMsWUFBWTtBQUN6RDtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0QkFBNEI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtFQUFrRSxJQUFJO0FBQ3RFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEIsaUNBQWlDO0FBQ2pDLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseUNBQXlDO0FBQ3JFO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQSxLQUFLOztBQUVMLHNCQUFzQjtBQUN0QixvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ3hPRDtBQUNBOztBQUVBO0FBQ0EsTUFBTSxJQUF1RDtBQUM3RCxRQUFRLG1CQUFPLENBQUMsNERBQXNCLEdBQUcsbUJBQU8sQ0FBQyxzRUFBd0IsR0FBRyxtQkFBTyxDQUFDLDREQUFjO0FBQ2xHLE9BQU8sRUFHYTtBQUNwQixDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBLCtDQUErQyxrQkFBa0I7QUFDakU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQixnQ0FBZ0M7QUFDaEMsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHlCQUF5QjtBQUNwRDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOzs7Ozs7OztBQ2hLRDtBQUNBOztBQUVBO0FBQ0EsTUFBTSxJQUF1RDtBQUM3RCxRQUFRLG1CQUFPLENBQUMsNERBQXNCLEdBQUcsbUJBQU8sQ0FBQywrREFBeUIsR0FBRyxtQkFBTyxDQUFDLGtFQUE0QjtBQUNqSCxPQUFPLEVBR2E7QUFDcEIsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQSxRQUFRLFVBQVUsRUFBRSxFQUFFLHlDQUF5QztBQUMvRCxRQUFRLFVBQVUsRUFBRSw4Q0FBOEM7QUFDbEUsUUFBUSxVQUFVLEVBQUUseUNBQXlDO0FBQzdELFFBQVEsVUFBVSxFQUFFO0FBQ3BCO0FBQ0E7QUFDQSxRQUFRLFVBQVUsRUFBRSxFQUFFLDRCQUE0QjtBQUNsRDtBQUNBO0FBQ0EsUUFBUSxVQUFVLEVBQUUsNEJBQTRCOztBQUVoRDtBQUNBLFFBQVEsOENBQThDO0FBQ3RELFFBQVEsOENBQThDOztBQUV0RDtBQUNBLFFBQVEsa0RBQWtEO0FBQzFELFFBQVEsNENBQTRDOztBQUVwRDtBQUNBLFFBQVEsZ0NBQWdDOztBQUV4QztBQUNBLFFBQVEsMENBQTBDOztBQUVsRDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUSxZQUFZLEVBQUUsZ0NBQWdDOztBQUV0RDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUSxVQUFVLEVBQUUsZ0NBQWdDO0FBQ3BELFFBQVE7QUFDUjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1QjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sU0FBUyxhQUFhLEVBQUUsRUFBRTtBQUNqQztBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOzs7Ozs7OztBQ3JFRDtBQUNBOztBQUVBO0FBQ0EsTUFBTSxJQUF1RDtBQUM3RCxRQUFRLG1CQUFPLENBQUMsNERBQXNCLEdBQUcsbUJBQU8sQ0FBQyxrRUFBb0I7QUFDckUsT0FBTyxFQUdZO0FBQ25CLENBQUM7QUFDRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSwrQkFBK0Isd0NBQXdDO0FBQ3ZFO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7Ozs7Ozs7QUMxQ0Q7QUFDQTs7QUFFQTtBQUNBLE1BQU0sSUFBdUQ7QUFDN0QsUUFBUSxtQkFBTyxDQUFDLDREQUFzQjtBQUN0QyxPQUFPLEVBR2E7QUFDcEIsQ0FBQztBQUNEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsTUFBTTtBQUM5QixpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOzs7O0FBSUg7QUFDQSwrQkFBK0IsU0FBUyxjQUFjO0FBQ3RELCtCQUErQixTQUFTLFdBQVc7O0FBRW5EO0FBQ0EsNENBQTRDLGNBQWM7QUFDMUQ7QUFDQTtBQUNBLEtBQUs7O0FBRUwseUJBQXlCO0FBQ3pCLHdCQUF3QjtBQUN4QjtBQUNBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUMzUUQ7QUFDQTs7QUFFQTtBQUNBLE1BQU0sSUFBdUQ7QUFDN0QsUUFBUSxtQkFBTyxDQUFDLDREQUFzQjtBQUN0QyxPQUFPLEVBR2E7QUFDcEIsQ0FBQztBQUNEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCLFFBQVE7QUFDN0I7QUFDQSx5Q0FBeUMsNEJBQTRCLGVBQWU7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0saUJBQWlCLE1BQU07QUFDN0I7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxHQUFHO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9COztBQUUxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxHQUFHO0FBQ3pDO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7O0FBRUEsWUFBWTtBQUNaO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEdBQUc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixNQUFNO0FBQ047QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLHVCQUF1QjtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5QkFBeUIsd0JBQXdCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixFQUFFO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUE4RCx1QkFBdUI7QUFDckY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOERBQThELHVCQUF1QjtBQUNyRixnRUFBZ0U7QUFDaEU7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0EsNkJBQTZCLHdCQUF3QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxpQkFBaUI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHlCQUF5Qix5QkFBeUI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQkFBaUI7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDZCQUE2QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsSUFBSTtBQUM5RjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUNsZ0JEO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLElBQXVEO0FBQzdELFFBQVEsbUJBQU8sQ0FBQyw0REFBc0IsR0FBRyxtQkFBTyxDQUFDLHNFQUF3QjtBQUN6RSxRQUFRLG1CQUFPLENBQUMsa0VBQTRCO0FBQzVDLE9BQU8sRUFJYTtBQUNwQixDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSCw4Q0FBOEMscURBQXFEO0FBQ25HLCtDQUErQyx3REFBd0Q7QUFDdkcsOENBQThDLHNEQUFzRDtBQUNwRyw4Q0FBOEMsK0NBQStDO0FBQzdGLENBQUM7Ozs7Ozs7O0FDcENEO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLElBQXVEO0FBQzdELFFBQVEsbUJBQU8sQ0FBQyw0REFBc0IsR0FBRyxtQkFBTyxDQUFDLDBEQUFZLEdBQUcsbUJBQU8sQ0FBQyx3RUFBMEIsR0FBRyxtQkFBTyxDQUFDLDBEQUFZO0FBQ3pILE9BQU8sRUFHYTtBQUNwQixDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxRQUFRO0FBQ3BFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7Ozs7Ozs7O0FDeEpEO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLElBQXVEO0FBQzdELFFBQVEsbUJBQU8sQ0FBQyw0REFBc0I7QUFDdEMsT0FBTyxFQUdhO0FBQ3BCLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ2hIRDtBQUNBOztBQUVBO0FBQ0EsTUFBTSxJQUF1RDtBQUM3RCxRQUFRLG1CQUFPLENBQUMsNERBQXNCO0FBQ3RDLE9BQU8sRUFHYTtBQUNwQixDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDO0FBQzNDLDJDQUEyQzs7QUFFM0M7QUFDQSxrQ0FBa0M7QUFDbEMsa0NBQWtDO0FBQ2xDLHFDQUFxQzs7QUFFckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7Ozs7Ozs7QUNqU0Q7QUFDQTs7QUFFQTtBQUNBLE1BQU0sSUFBdUQ7QUFDN0QsUUFBUSxtQkFBTyxDQUFDLDREQUFzQjtBQUN0QyxPQUFPLEVBR2E7QUFDcEIsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsVUFBVTtBQUNWLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsUUFBUSwwREFBMEQ7QUFDOUY7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRCxDQUFDOzs7Ozs7OztBQ3RXRDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsTUFBTSxJQUF1RDtBQUM3RCxRQUFRLG1CQUFPLENBQUMsNERBQXNCO0FBQ3RDLE9BQU8sRUFHYTtBQUNwQixDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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LEVBR2E7QUFDcEIsQ0FBQztBQUNEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEOztBQUV4RDtBQUNBLHdEQUF3RDs7QUFFeEQsZ0VBQWdFLHVFQUF1RTtBQUN2SSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRLGlDQUFpQztBQUN6QztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHVDQUF1QyxjQUFjO0FBQ3JEO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNkJBQTZCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUM5a0JEO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLElBQXVEO0FBQzdELFFBQVEsbUJBQU8sQ0FBQyw0REFBc0I7QUFDdEMsT0FBTyxFQUdhO0FBQ3BCLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw0REFBNEQ7O0FBRXRGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQSw2QkFBNkIsc0JBQXNCO0FBQ25ELHFEQUFxRDtBQUNyRCwrREFBK0Q7QUFDL0QsbURBQW1ELElBQUksY0FBYzs7QUFFckU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELElBQUk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixJQUFJO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQzNORDtBQUNBOztBQUVBO0FBQ0EsTUFBTSxJQUF1RDtBQUM3RCxRQUFRLG1CQUFPLENBQUMsNERBQXNCO0FBQ3RDLE9BQU8sRUFHYTtBQUNwQixDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xELHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLE1BQU0sSUFBSTtBQUNqRixnQ0FBZ0MsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLE1BQU0sSUFBSTtBQUMxRCwyQkFBMkIsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLE1BQU0sSUFBSTtBQUNwRCxrQ0FBa0MsRUFBRTtBQUNwQztBQUNBLG9DQUFvQyxFQUFFO0FBQ3RDO0FBQ0EsaUNBQWlDLEVBQUU7QUFDbkMsbUNBQW1DLEVBQUU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixTQUFTO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZUFBZTtBQUN0RCw2QkFBNkIsa0NBQWtDO0FBQy9EO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNCQUFzQjtBQUMvQyxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLENBQUM7Ozs7Ozs7O0FDMUlEO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLElBQXVEO0FBQzdELFFBQVEsbUJBQU8sQ0FBQyw0REFBc0I7QUFDdEMsT0FBTyxFQUdhO0FBQ3BCLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0EsMEdBQTBHLEtBQUssR0FBRyxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsU0FBUyxLQUFLLEdBQUcsR0FBRztBQUNySjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0Msd0NBQXdDO0FBQ3hDO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQsOENBQThDO0FBQzlDLDZEQUE2RDs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7O0FBRTNDO0FBQ0Esc0NBQXNDO0FBQ3RDLHFDQUFxQztBQUNyQzs7QUFFQSxvQ0FBb0MsZ0JBQWdCO0FBQ3BELDZCQUE2QixLQUFLLE1BQU0sZ0JBQWdCLHFCQUFxQixlQUFlOztBQUU1RiwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxzQ0FBc0M7QUFDdEMsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsZUFBZTtBQUN2Qyw0QkFBNEIsaUJBQWlCO0FBQzdDLDRCQUE0QjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDNUdEO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLElBQXVEO0FBQzdELFFBQVEsbUJBQU8sQ0FBQyw0REFBc0IsR0FBRyxtQkFBTyxDQUFDLGdFQUFrQixHQUFHLG1CQUFPLENBQUMsNERBQWMsR0FBRyxtQkFBTyxDQUFDLGdFQUEwQjtBQUNqSSxPQUFPLEVBR2E7QUFDcEIsQ0FBQztBQUNEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0QsSUFBSTtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzREFBc0Q7QUFDdEQsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixNQUFNO0FBQ2xDO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsRUFBRTs7QUFFbkM7QUFDQSxvREFBb0Q7QUFDcEQsaUNBQWlDLEVBQUU7QUFDbkM7QUFDQSx1REFBdUQ7QUFDdkQsNkJBQTZCLEVBQUUsR0FBRyxFQUFFOztBQUVwQztBQUNBO0FBQ0Esa0NBQWtDLEVBQUU7O0FBRXBDO0FBQ0EsMEJBQTBCLG1CQUFtQixFQUFFLE9BQU8sR0FBRztBQUN6RDtBQUNBLG9CQUFvQixFQUFFO0FBQ3RCO0FBQ0EsZUFBZSxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUU7QUFDN0I7QUFDQSxjQUFjLEVBQUUsR0FBRyxFQUFFO0FBQ3JCO0FBQ0EsaUJBQWlCLEVBQUUsSUFBSSxHQUFHLEVBQUUsR0FBRyxFQUFFO0FBQ2pDO0FBQ0EsMEJBQTBCLEVBQUUsUUFBUSxFQUFFO0FBQ3RDO0FBQ0EsaUJBQWlCLEVBQUUsSUFBSSxFQUFFOztBQUV6QjtBQUNBLGlCQUFpQixFQUFFO0FBQ25CO0FBQ0EsMEJBQTBCLEVBQUU7QUFDNUI7QUFDQSxpQkFBaUIsRUFBRTtBQUNuQjtBQUNBLGNBQWMsRUFBRTtBQUNoQjtBQUNBLGVBQWUsRUFBRTs7QUFFakI7QUFDQSxlQUFlLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRTtBQUMxQjtBQUNBLGVBQWUsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFO0FBQzFCO0FBQ0EsZUFBZSxFQUFFLEVBQUUsRUFBRTs7QUFFckIsK0NBQStDLEVBQUU7QUFDakQsaURBQWlELEVBQUU7QUFDbkQscURBQXFELEVBQUU7QUFDdkQsa0RBQWtELEVBQUU7QUFDcEQsa0RBQWtELEVBQUU7QUFDcEQsb0RBQW9ELEVBQUU7QUFDdEQ7QUFDQSwwQ0FBMEMsRUFBRTtBQUM1QywyQ0FBMkMsRUFBRTs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZCxLQUFLOztBQUVMO0FBQ0EsK0JBQStCO0FBQy9CLDBCQUEwQjtBQUMxQjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOzs7Ozs7OztBQzVpQkQ7QUFDQTs7QUFFQTtBQUNBLE1BQU0sSUFBdUQ7QUFDN0QsUUFBUSxtQkFBTyxDQUFDLDREQUFzQjtBQUN0QyxPQUFPLEVBR2E7QUFDcEIsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZLEtBQUs7QUFDaEMsZUFBZSxZQUFZLEtBQUs7O0FBRWhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGtCQUFrQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTSxzRkFBc0Y7QUFDNUY7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sMkRBQTJEO0FBQ2pFO0FBQ0E7QUFDQSxNQUFNLHFCQUFxQixHQUFHO0FBQzlCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRLDRCQUE0QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0IsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSx3QkFBd0IsMENBQTBDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QztBQUN4Qyx5QkFBeUI7QUFDekIsOENBQThDO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUM5U0Q7QUFDQTs7QUFFQTtBQUNBLE1BQU0sSUFBdUQ7QUFDN0QsUUFBUSxtQkFBTyxDQUFDLDREQUFzQixHQUFHLG1CQUFPLENBQUMsK0RBQXlCO0FBQzFFLE9BQU8sRUFHYTtBQUNwQixDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSyw4Q0FBOEM7QUFDbkQ7QUFDQSxLQUFLLG1EQUFtRDtBQUN4RCxLQUFLLDBEQUEwRDtBQUMvRDtBQUNBLEtBQUssNkNBQTZDLEVBQUUsSUFBSSxXQUFXLEVBQUUsRUFBRSx3QkFBd0I7QUFDL0Y7QUFDQSxLQUFLLDZDQUE2QyxFQUFFLHdCQUF3Qjs7QUFFNUUsS0FBSztBQUNMLHFCQUFxQjtBQUNyQixLQUFLLHNIQUFzSDtBQUMzSCxLQUFLLCtUQUErVDtBQUNwVSxLQUFLLGdIQUFnSDtBQUNySCxLQUFLLCtEQUErRDtBQUNwRSxLQUFLO0FBQ0wscUNBQXFDO0FBQ3JDLEtBQUssa0NBQWtDO0FBQ3ZDLEtBQUssa0NBQWtDO0FBQ3ZDLEtBQUssaURBQWlEO0FBQ3RELEtBQUsseUNBQXlDO0FBQzlDLEtBQUssMkNBQTJDO0FBQ2hELEtBQUsseUNBQXlDO0FBQzlDLEtBQUssV0FBVyxxQkFBcUI7QUFDckMsS0FBSyxXQUFXO0FBQ2hCO0FBQ0E7QUFDQSxLQUFLLDJDQUEyQztBQUNoRCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUssMkNBQTJDO0FBQ2hELEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSyw2Q0FBNkM7QUFDbEQsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLLGtEQUFrRDtBQUN2RCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7QUN2RUQ7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLElBQXVEO0FBQzdELFFBQVEsbUJBQU8sQ0FBQyw0REFBc0I7QUFDdEMsT0FBTyxFQUdhO0FBQ3BCLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUMsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxhQUFhLFNBQVM7O0FBRXhEO0FBQ0EsaUNBQWlDLE1BQU07O0FBRXZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyQ0FBMkM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLCtCQUErQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVEsOEJBQThCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwREFBMEQ7QUFDbEU7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBDQUEwQztBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsc0NBQXNDO0FBQ3RDO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix5QkFBeUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvQkFBb0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOzs7Ozs7OztBQzlTRDtBQUNBOztBQUVBO0FBQ0EsTUFBTSxJQUF1RDtBQUM3RCxRQUFRLG1CQUFPLENBQUMsNERBQXNCLEdBQUcsbUJBQU8sQ0FBQywwREFBWTtBQUM3RCxPQUFPLEVBR2E7QUFDcEIsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQsaURBQWlEO0FBQ2pELGlEQUFpRDtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtFQUFrRSxNQUFNLE1BQU07QUFDOUU7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0Q0FBNEM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0JBQXNCO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qix1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUIsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsWUFBWTtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaUNBQWlDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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RUFBRSxtQkFBbUIsRUFBRSxFQUFFLElBQUk7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsRUFBRTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsR0FBRztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDO0FBQy9DOztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLENBQUM7Ozs7Ozs7O0FDM0lEO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLElBQXVELElBQUk7QUFDakUsUUFBUSxtQkFBTyxDQUFDLDREQUFzQjtBQUN0QyxJQUFJLEtBQUssRUFJTjtBQUNILENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsSUFBSTtBQUM1QixjQUFjLElBQUksSUFBSTtBQUN0QixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsQ0FBQzs7Ozs7Ozs7QUNuVEQ7QUFDQTs7QUFFQTtBQUNBLE1BQU0sSUFBdUQ7QUFDN0QsUUFBUSxtQkFBTyxDQUFDLDREQUFzQjtBQUN0QyxPQUFPLEVBR2E7QUFDcEIsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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RDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0dBQXdHO0FBQ3hHO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7O0FBRS9COztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUM3VkQ7QUFDQTs7QUFFQTtBQUNBLE1BQU0sSUFBdUQ7QUFDN0QsUUFBUSxt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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlCQUFpQjtBQUM5QztBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsWUFBWTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVD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QUFPLENBQUMsNERBQXNCO0FBQ3RDLE9BQU8sRUFHYTtBQUNwQixDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsQ0FBQzs7Ozs7Ozs7QUNsTUQ7QUFDQTs7QUFFQTtBQUNBLE1BQU0sSUFBdUQ7QUFDN0QsUUFBUSxtQkFBTyxDQUFDLDREQUFzQjtBQUN0QyxPQUFPLEVBR2E7QUFDcEIsQ0FBQztBQUNEOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0EsZ0JBQWdCO0FBQ2hCLHVCQUF1QjtBQUN2QixxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQ0FBa0Msa0JBQWtCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTyxPQUFPOztBQUUvQztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxPQUFPLE9BQU87O0FBRS9DLGlFQUFpRTtBQUNqRTtBQUNBLHFDQUFxQyxPQUFPLE9BQU87O0FBRW5ELHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0EsMkNBQTJDLE9BQU8sT0FBTzs7QUFFekQ7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQiw4QkFBOEIsa0JBQWtCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZ0JBQWdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixnQkFBZ0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHLHVCQUF1Qjs7QUFFbkk7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4Qiw4REFBOEQ7O0FBRTVGO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNkNBQTZDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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aEUsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2p1cHl0ZXIvLi9zcmMvaXB5d2lkZ2V0cy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL2FwbC9hcGwuanMiLCJ3ZWJwYWNrOi8vanVweXRlci8uL3NyYy9pcHl3aWRnZXRzL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvYXNjaWlhcm1vci9hc2NpaWFybW9yLmpzIiwid2VicGFjazovL2p1cHl0ZXIvLi9zcmMvaXB5d2lkZ2V0cy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL2Fzbi4xL2Fzbi4xLmpzIiwid2VicGFjazovL2p1cHl0ZXIvLi9zcmMvaXB5d2lkZ2V0cy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL2FzdGVyaXNrL2FzdGVyaXNrLmpzIiwid2VicGFjazovL2p1cHl0ZXIvLi9zcmMvaXB5d2lkZ2V0cy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL2JyYWluZnVjay9icmFpbmZ1Y2suanMiLCJ3ZWJwYWNrOi8vanVweXRlci8uL3NyYy9pcHl3aWRnZXRzL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvY2xvanVyZS9jbG9qdXJlLmpzIiwid2VicGFjazovL2p1cHl0ZXIvLi9zcmMvaXB5d2lkZ2V0cy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL2NtYWtlL2NtYWtlLmpzIiwid2VicGFjazovL2p1cHl0ZXIvLi9zcmMvaXB5d2lkZ2V0cy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL2NvYm9sL2NvYm9sLmpzIiwid2VicGFjazovL2p1cHl0ZXIvLi9zcmMvaXB5d2lkZ2V0cy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL2NvZmZlZXNjcmlwdC9jb2ZmZWVzY3JpcHQuanMiLCJ3ZWJwYWNrOi8vanVweXRlci8uL3NyYy9pcHl3aWRnZXRzL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvY29tbW9ubGlzcC9jb21tb25saXNwLmpzIiwid2VicGFjazovL2p1cHl0ZXIvLi9zcmMvaXB5d2lkZ2V0cy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL2NyeXN0YWwvY3J5c3RhbC5qcyIsIndlYnBhY2s6Ly9qdXB5dGVyLy4vc3JjL2lweXdpZGdldHMvbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS9jeXBoZXIvY3lwaGVyLmpzIiwid2VicGFjazovL2p1cHl0ZXIvLi9zcmMvaXB5d2lkZ2V0cy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL2QvZC5qcyIsIndlYnBhY2s6Ly9qdXB5dGVyLy4vc3JjL2lweXdpZGdldHMvbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS9kYXJ0L2RhcnQuanMiLCJ3ZWJwYWNrOi8vanVweXRlci8uL3NyYy9pcHl3aWRnZXRzL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvZGlmZi9kaWZmLmpzIiwid2VicGFjazovL2p1cHl0ZXIvLi9zcmMvaXB5d2lkZ2V0cy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL2RqYW5nby9kamFuZ28uanMiLCJ3ZWJwYWNrOi8vanVweXRlci8uL3NyYy9pcHl3aWRnZXRzL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvZG9ja2VyZmlsZS9kb2NrZXJmaWxlLmpzIiwid2VicGFjazovL2p1cHl0ZXIvLi9zcmMvaXB5d2lkZ2V0cy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL2R0ZC9kdGQuanMiLCJ3ZWJwYWNrOi8vanVweXRlci8uL3NyYy9pcHl3aWRnZXRzL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvZHlsYW4vZHlsYW4uanMiLCJ3ZWJwYWNrOi8vanVweXRlci8uL3NyYy9pcHl3aWRnZXRzL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvZWJuZi9lYm5mLmpzIiwid2VicGFjazovL2p1cHl0ZXIvLi9zcmMvaXB5d2lkZ2V0cy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL2VjbC9lY2wuanMiLCJ3ZWJwYWNrOi8vanVweXRlci8uL3NyYy9pcHl3aWRnZXRzL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvZWlmZmVsL2VpZmZlbC5qcyIsIndlYnBhY2s6Ly9qdXB5dGVyLy4vc3JjL2lweXdpZGdldHMvbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS9lbG0vZWxtLmpzIiwid2VicGFjazovL2p1cHl0ZXIvLi9zcmMvaXB5d2lkZ2V0cy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL2VybGFuZy9lcmxhbmcuanMiLCJ3ZWJwYWNrOi8vanVweXRlci8uL3NyYy9pcHl3aWRnZXRzL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvZmFjdG9yL2ZhY3Rvci5qcyIsIndlYnBhY2s6Ly9qdXB5dGVyLy4vc3JjL2lweXdpZGdldHMvbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS9mY2wvZmNsLmpzIiwid2VicGFjazovL2p1cHl0ZXIvLi9zcmMvaXB5d2lkZ2V0cy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL2ZvcnRoL2ZvcnRoLmpzIiwid2VicGFjazovL2p1cHl0ZXIvLi9zcmMvaXB5d2lkZ2V0cy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL2ZvcnRyYW4vZm9ydHJhbi5qcyIsIndlYnBhY2s6Ly9qdXB5dGVyLy4vc3JjL2lweXdpZGdldHMvbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS9nYXMvZ2FzLmpzIiwid2VicGFjazovL2p1cHl0ZXIvLi9zcmMvaXB5d2lkZ2V0cy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL2doZXJraW4vZ2hlcmtpbi5qcyIsIndlYnBhY2s6Ly9qdXB5dGVyLy4vc3JjL2lweXdpZGdldHMvbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS9nby9nby5qcyIsIndlYnBhY2s6Ly9qdXB5dGVyLy4vc3JjL2lweXdpZGdldHMvbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS9ncm9vdnkvZ3Jvb3Z5LmpzIiwid2VicGFjazovL2p1cHl0ZXIvLi9zcmMvaXB5d2lkZ2V0cy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL2hhbWwvaGFtbC5qcyIsIndlYnBhY2s6Ly9qdXB5dGVyLy4vc3JjL2lweXdpZGdldHMvbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS9oYW5kbGViYXJzL2hhbmRsZWJhcnMuanMiLCJ3ZWJwYWNrOi8vanVweXRlci8uL3NyYy9pcHl3aWRnZXRzL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvaGFza2VsbC1saXRlcmF0ZS9oYXNrZWxsLWxpdGVyYXRlLmpzIiwid2VicGFjazovL2p1cHl0ZXIvLi9zcmMvaXB5d2lkZ2V0cy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL2hhc2tlbGwvaGFza2VsbC5qcyIsIndlYnBhY2s6Ly9qdXB5dGVyLy4vc3JjL2lweXdpZGdldHMvbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS9oYXhlL2hheGUuanMiLCJ3ZWJwYWNrOi8vanVweXRlci8uL3NyYy9pcHl3aWRnZXRzL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvaHRtbGVtYmVkZGVkL2h0bWxlbWJlZGRlZC5qcyIsIndlYnBhY2s6Ly9qdXB5dGVyLy4vc3JjL2lweXdpZGdldHMvbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS9odG1sbWl4ZWQvaHRtbG1peGVkLmpzIiwid2VicGFjazovL2p1cHl0ZXIvLi9zcmMvaXB5d2lkZ2V0cy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL2h0dHAvaHR0cC5qcyIsIndlYnBhY2s6Ly9qdXB5dGVyLy4vc3JjL2lweXdpZGdldHMvbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS9pZGwvaWRsLmpzIiwid2VicGFjazovL2p1cHl0ZXIvLi9zcmMvaXB5d2lkZ2V0cy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL2ppbmphMi9qaW5qYTIuanMiLCJ3ZWJwYWNrOi8vanVweXRlci8uL3NyYy9pcHl3aWRnZXRzL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvanN4L2pzeC5qcyIsIndlYnBhY2s6Ly9qdXB5dGVyLy4vc3JjL2lweXdpZGdldHMvbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS9saXZlc2NyaXB0L2xpdmVzY3JpcHQuanMiLCJ3ZWJwYWNrOi8vanVweXRlci8uL3NyYy9pcHl3aWRnZXRzL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvbHVhL2x1YS5qcyIsIndlYnBhY2s6Ly9qdXB5dGVyLy4vc3JjL2lweXdpZGdldHMvbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS9tYXRoZW1hdGljYS9tYXRoZW1hdGljYS5qcyIsIndlYnBhY2s6Ly9qdXB5dGVyLy4vc3JjL2lweXdpZGdldHMvbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS9tYm94L21ib3guanMiLCJ3ZWJwYWNrOi8vanVweXRlci8uL3NyYy9pcHl3aWRnZXRzL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvbWlyYy9taXJjLmpzIiwid2VicGFjazovL2p1cHl0ZXIvLi9zcmMvaXB5d2lkZ2V0cy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL21sbGlrZS9tbGxpa2UuanMiLCJ3ZWJwYWNrOi8vanVweXRlci8uL3NyYy9pcHl3aWRnZXRzL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvbW9kZWxpY2EvbW9kZWxpY2EuanMiLCJ3ZWJwYWNrOi8vanVweXRlci8uL3NyYy9pcHl3aWRnZXRzL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvbXNjZ2VuL21zY2dlbi5qcyIsIndlYnBhY2s6Ly9qdXB5dGVyLy4vc3JjL2lweXdpZGdldHMvbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS9tdW1wcy9tdW1wcy5qcyIsIndlYnBhY2s6Ly9qdXB5dGVyLy4vc3JjL2lweXdpZGdldHMvbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS9uZ2lueC9uZ2lueC5qcyIsIndlYnBhY2s6Ly9qdXB5dGVyLy4vc3JjL2lweXdpZGdldHMvbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS9uc2lzL25zaXMuanMiLCJ3ZWJwYWNrOi8vanVweXRlci8uL3NyYy9pcHl3aWRnZXRzL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvbnRyaXBsZXMvbnRyaXBsZXMuanMiLCJ3ZWJwYWNrOi8vanVweXRlci8uL3NyYy9pcHl3aWRnZXRzL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvb2N0YXZlL29jdGF2ZS5qcyIsIndlYnBhY2s6Ly9qdXB5dGVyLy4vc3JjL2lweXdpZGdldHMvbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS9vei9vei5qcyIsIndlYnBhY2s6Ly9qdXB5dGVyLy4vc3JjL2lweXdpZGdldHMvbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS9wYXNjYWwvcGFzY2FsLmpzIiwid2VicGFjazovL2p1cHl0ZXIvLi9zcmMvaXB5d2lkZ2V0cy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL3BlZ2pzL3BlZ2pzLmpzIiwid2VicGFjazovL2p1cHl0ZXIvLi9zcmMvaXB5d2lkZ2V0cy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL3BlcmwvcGVybC5qcyIsIndlYnBhY2s6Ly9qdXB5dGVyLy4vc3JjL2lweXdpZGdldHMvbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS9waHAvcGhwLmpzIiwid2VicGFjazovL2p1cHl0ZXIvLi9zcmMvaXB5d2lkZ2V0cy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL3BpZy9waWcuanMiLCJ3ZWJwYWNrOi8vanVweXRlci8uL3NyYy9pcHl3aWRnZXRzL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvcG93ZXJzaGVsbC9wb3dlcnNoZWxsLmpzIiwid2VicGFjazovL2p1cHl0ZXIvLi9zcmMvaXB5d2lkZ2V0cy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL3Byb3BlcnRpZXMvcHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly9qdXB5dGVyLy4vc3JjL2lweXdpZGdldHMvbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS9wcm90b2J1Zi9wcm90b2J1Zi5qcyIsIndlYnBhY2s6Ly9qdXB5dGVyLy4vc3JjL2lweXdpZGdldHMvbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS9wdWcvcHVnLmpzIiwid2VicGFjazovL2p1cHl0ZXIvLi9zcmMvaXB5d2lkZ2V0cy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL3B1cHBldC9wdXBwZXQuanMiLCJ3ZWJwYWNrOi8vanVweXRlci8uL3NyYy9pcHl3aWRnZXRzL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvcS9xLmpzIiwid2VicGFjazovL2p1cHl0ZXIvLi9zcmMvaXB5d2lkZ2V0cy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL3JwbS9ycG0uanMiLCJ3ZWJwYWNrOi8vanVweXRlci8uL3NyYy9pcHl3aWRnZXRzL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvcnN0L3JzdC5qcyIsIndlYnBhY2s6Ly9qdXB5dGVyLy4vc3JjL2lweXdpZGdldHMvbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS9ydWJ5L3J1YnkuanMiLCJ3ZWJwYWNrOi8vanVweXRlci8uL3NyYy9pcHl3aWRnZXRzL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvcnVzdC9ydXN0LmpzIiwid2VicGFjazovL2p1cHl0ZXIvLi9zcmMvaXB5d2lkZ2V0cy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL3Nhcy9zYXMuanMiLCJ3ZWJwYWNrOi8vanVweXRlci8uL3NyYy9pcHl3aWRnZXRzL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvc2Fzcy9zYXNzLmpzIiwid2VicGFjazovL2p1cHl0ZXIvLi9zcmMvaXB5d2lkZ2V0cy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL3NjaGVtZS9zY2hlbWUuanMiLCJ3ZWJwYWNrOi8vanVweXRlci8uL3NyYy9pcHl3aWRnZXRzL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvc2lldmUvc2lldmUuanMiLCJ3ZWJwYWNrOi8vanVweXRlci8uL3NyYy9pcHl3aWRnZXRzL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvc2xpbS9zbGltLmpzIiwid2VicGFjazovL2p1cHl0ZXIvLi9zcmMvaXB5d2lkZ2V0cy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL3NtYWxsdGFsay9zbWFsbHRhbGsuanMiLCJ3ZWJwYWNrOi8vanVweXRlci8uL3NyYy9pcHl3aWRnZXRzL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvc21hcnR5L3NtYXJ0eS5qcyIsIndlYnBhY2s6Ly9qdXB5dGVyLy4vc3JjL2lweXdpZGdldHMvbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS9zb2xyL3NvbHIuanMiLCJ3ZWJwYWNrOi8vanVweXRlci8uL3NyYy9pcHl3aWRnZXRzL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvc295L3NveS5qcyIsIndlYnBhY2s6Ly9qdXB5dGVyLy4vc3JjL2lweXdpZGdldHMvbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS9zcGFycWwvc3BhcnFsLmpzIiwid2VicGFjazovL2p1cHl0ZXIvLi9zcmMvaXB5d2lkZ2V0cy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL3NwcmVhZHNoZWV0L3NwcmVhZHNoZWV0LmpzIiwid2VicGFjazovL2p1cHl0ZXIvLi9zcmMvaXB5d2lkZ2V0cy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL3N0eWx1cy9zdHlsdXMuanMiLCJ3ZWJwYWNrOi8vanVweXRlci8uL3NyYy9pcHl3aWRnZXRzL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvc3dpZnQvc3dpZnQuanMiLCJ3ZWJwYWNrOi8vanVweXRlci8uL3NyYy9pcHl3aWRnZXRzL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvdGNsL3RjbC5qcyIsIndlYnBhY2s6Ly9qdXB5dGVyLy4vc3JjL2lweXdpZGdldHMvbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS90ZXh0aWxlL3RleHRpbGUuanMiLCJ3ZWJwYWNrOi8vanVweXRlci8uL3NyYy9pcHl3aWRnZXRzL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvdGlkZGx5d2lraS90aWRkbHl3aWtpLmpzIiwid2VicGFjazovL2p1cHl0ZXIvLi9zcmMvaXB5d2lkZ2V0cy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL3Rpa2kvdGlraS5qcyIsIndlYnBhY2s6Ly9qdXB5dGVyLy4vc3JjL2lweXdpZGdldHMvbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS90b21sL3RvbWwuanMiLCJ3ZWJwYWNrOi8vanVweXRlci8uL3NyYy9pcHl3aWRnZXRzL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvdG9ybmFkby90b3JuYWRvLmpzIiwid2VicGFjazovL2p1cHl0ZXIvLi9zcmMvaXB5d2lkZ2V0cy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL3Ryb2ZmL3Ryb2ZmLmpzIiwid2VicGFjazovL2p1cHl0ZXIvLi9zcmMvaXB5d2lkZ2V0cy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL3R0Y24tY2ZnL3R0Y24tY2ZnLmpzIiwid2VicGFjazovL2p1cHl0ZXIvLi9zcmMvaXB5d2lkZ2V0cy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL3R0Y24vdHRjbi5qcyIsIndlYnBhY2s6Ly9qdXB5dGVyLy4vc3JjL2lweXdpZGdldHMvbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS90dXJ0bGUvdHVydGxlLmpzIiwid2VicGFjazovL2p1cHl0ZXIvLi9zcmMvaXB5d2lkZ2V0cy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL3R3aWcvdHdpZy5qcyIsIndlYnBhY2s6Ly9qdXB5dGVyLy4vc3JjL2lweXdpZGdldHMvbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS92Yi92Yi5qcyIsIndlYnBhY2s6Ly9qdXB5dGVyLy4vc3JjL2lweXdpZGdldHMvbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS92YnNjcmlwdC92YnNjcmlwdC5qcyIsIndlYnBhY2s6Ly9qdXB5dGVyLy4vc3JjL2lweXdpZGdldHMvbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS92ZWxvY2l0eS92ZWxvY2l0eS5qcyIsIndlYnBhY2s6Ly9qdXB5dGVyLy4vc3JjL2lweXdpZGdldHMvbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS92ZXJpbG9nL3Zlcmlsb2cuanMiLCJ3ZWJwYWNrOi8vanVweXRlci8uL3NyYy9pcHl3aWRnZXRzL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvdmhkbC92aGRsLmpzIiwid2VicGFjazovL2p1cHl0ZXIvLi9zcmMvaXB5d2lkZ2V0cy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL3Z1ZS92dWUuanMiLCJ3ZWJwYWNrOi8vanVweXRlci8uL3NyYy9pcHl3aWRnZXRzL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvd2FzdC93YXN0LmpzIiwid2VicGFjazovL2p1cHl0ZXIvLi9zcmMvaXB5d2lkZ2V0cy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL3dlYmlkbC93ZWJpZGwuanMiLCJ3ZWJwYWNrOi8vanVweXRlci8uL3NyYy9pcHl3aWRnZXRzL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUveHF1ZXJ5L3hxdWVyeS5qcyIsIndlYnBhY2s6Ly9qdXB5dGVyLy4vc3JjL2lweXdpZGdldHMvbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS95YWNhcy95YWNhcy5qcyIsIndlYnBhY2s6Ly9qdXB5dGVyLy4vc3JjL2lweXdpZGdldHMvbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS95YW1sLWZyb250bWF0dGVyL3lhbWwtZnJvbnRtYXR0ZXIuanMiLCJ3ZWJwYWNrOi8vanVweXRlci8uL3NyYy9pcHl3aWRnZXRzL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUveWFtbC95YW1sLmpzIiwid2VicGFjazovL2p1cHl0ZXIvLi9zcmMvaXB5d2lkZ2V0cy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL3o4MC96ODAuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcblwidXNlIHN0cmljdFwiO1xuXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoXCJhcGxcIiwgZnVuY3Rpb24oKSB7XG4gIHZhciBidWlsdEluT3BzID0ge1xuICAgIFwiLlwiOiBcImlubmVyUHJvZHVjdFwiLFxuICAgIFwiXFxcXFwiOiBcInNjYW5cIixcbiAgICBcIi9cIjogXCJyZWR1Y2VcIixcbiAgICBcIuKMv1wiOiBcInJlZHVjZTFBeGlzXCIsXG4gICAgXCLijYBcIjogXCJzY2FuMUF4aXNcIixcbiAgICBcIsKoXCI6IFwiZWFjaFwiLFxuICAgIFwi4o2jXCI6IFwicG93ZXJcIlxuICB9O1xuICB2YXIgYnVpbHRJbkZ1bmNzID0ge1xuICAgIFwiK1wiOiBbXCJjb25qdWdhdGVcIiwgXCJhZGRcIl0sXG4gICAgXCLiiJJcIjogW1wibmVnYXRlXCIsIFwic3VidHJhY3RcIl0sXG4gICAgXCLDl1wiOiBbXCJzaWduT2ZcIiwgXCJtdWx0aXBseVwiXSxcbiAgICBcIsO3XCI6IFtcInJlY2lwcm9jYWxcIiwgXCJkaXZpZGVcIl0sXG4gICAgXCLijIhcIjogW1wiY2VpbGluZ1wiLCBcImdyZWF0ZXJPZlwiXSxcbiAgICBcIuKMilwiOiBbXCJmbG9vclwiLCBcImxlc3Nlck9mXCJdLFxuICAgIFwi4oijXCI6IFtcImFic29sdXRlXCIsIFwicmVzaWR1ZVwiXSxcbiAgICBcIuKNs1wiOiBbXCJpbmRleEdlbmVyYXRlXCIsIFwiaW5kZXhPZlwiXSxcbiAgICBcIj9cIjogW1wicm9sbFwiLCBcImRlYWxcIl0sXG4gICAgXCLii4ZcIjogW1wiZXhwb25lbnRpYXRlXCIsIFwidG9UaGVQb3dlck9mXCJdLFxuICAgIFwi4o2fXCI6IFtcIm5hdHVyYWxMb2dcIiwgXCJsb2dUb1RoZUJhc2VcIl0sXG4gICAgXCLil4tcIjogW1wicGlUaW1lc1wiLCBcImNpcmN1bGFyRnVuY3NcIl0sXG4gICAgXCIhXCI6IFtcImZhY3RvcmlhbFwiLCBcImJpbm9taWFsXCJdLFxuICAgIFwi4oy5XCI6IFtcIm1hdHJpeEludmVyc2VcIiwgXCJtYXRyaXhEaXZpZGVcIl0sXG4gICAgXCI8XCI6IFtudWxsLCBcImxlc3NUaGFuXCJdLFxuICAgIFwi4omkXCI6IFtudWxsLCBcImxlc3NUaGFuT3JFcXVhbFwiXSxcbiAgICBcIj1cIjogW251bGwsIFwiZXF1YWxzXCJdLFxuICAgIFwiPlwiOiBbbnVsbCwgXCJncmVhdGVyVGhhblwiXSxcbiAgICBcIuKJpVwiOiBbbnVsbCwgXCJncmVhdGVyVGhhbk9yRXF1YWxcIl0sXG4gICAgXCLiiaBcIjogW251bGwsIFwibm90RXF1YWxcIl0sXG4gICAgXCLiiaFcIjogW1wiZGVwdGhcIiwgXCJtYXRjaFwiXSxcbiAgICBcIuKJolwiOiBbbnVsbCwgXCJub3RNYXRjaFwiXSxcbiAgICBcIuKIiFwiOiBbXCJlbmxpc3RcIiwgXCJtZW1iZXJzaGlwXCJdLFxuICAgIFwi4o23XCI6IFtudWxsLCBcImZpbmRcIl0sXG4gICAgXCLiiKpcIjogW1widW5pcXVlXCIsIFwidW5pb25cIl0sXG4gICAgXCLiiKlcIjogW251bGwsIFwiaW50ZXJzZWN0aW9uXCJdLFxuICAgIFwi4oi8XCI6IFtcIm5vdFwiLCBcIndpdGhvdXRcIl0sXG4gICAgXCLiiKhcIjogW251bGwsIFwib3JcIl0sXG4gICAgXCLiiKdcIjogW251bGwsIFwiYW5kXCJdLFxuICAgIFwi4o2xXCI6IFtudWxsLCBcIm5vclwiXSxcbiAgICBcIuKNslwiOiBbbnVsbCwgXCJuYW5kXCJdLFxuICAgIFwi4o20XCI6IFtcInNoYXBlT2ZcIiwgXCJyZXNoYXBlXCJdLFxuICAgIFwiLFwiOiBbXCJyYXZlbFwiLCBcImNhdGVuYXRlXCJdLFxuICAgIFwi4o2qXCI6IFtudWxsLCBcImZpcnN0QXhpc0NhdGVuYXRlXCJdLFxuICAgIFwi4oy9XCI6IFtcInJldmVyc2VcIiwgXCJyb3RhdGVcIl0sXG4gICAgXCLiipZcIjogW1wiYXhpczFSZXZlcnNlXCIsIFwiYXhpczFSb3RhdGVcIl0sXG4gICAgXCLijYlcIjogW1widHJhbnNwb3NlXCIsIG51bGxdLFxuICAgIFwi4oaRXCI6IFtcImZpcnN0XCIsIFwidGFrZVwiXSxcbiAgICBcIuKGk1wiOiBbbnVsbCwgXCJkcm9wXCJdLFxuICAgIFwi4oqCXCI6IFtcImVuY2xvc2VcIiwgXCJwYXJ0aXRpb25XaXRoQXhpc1wiXSxcbiAgICBcIuKKg1wiOiBbXCJkaWNsb3NlXCIsIFwicGlja1wiXSxcbiAgICBcIuKMt1wiOiBbbnVsbCwgXCJpbmRleFwiXSxcbiAgICBcIuKNi1wiOiBbXCJncmFkZVVwXCIsIG51bGxdLFxuICAgIFwi4o2SXCI6IFtcImdyYWRlRG93blwiLCBudWxsXSxcbiAgICBcIuKKpFwiOiBbXCJlbmNvZGVcIiwgbnVsbF0sXG4gICAgXCLiiqVcIjogW1wiZGVjb2RlXCIsIG51bGxdLFxuICAgIFwi4o2VXCI6IFtcImZvcm1hdFwiLCBcImZvcm1hdEJ5RXhhbXBsZVwiXSxcbiAgICBcIuKNjlwiOiBbXCJleGVjdXRlXCIsIG51bGxdLFxuICAgIFwi4oqjXCI6IFtcInN0b3BcIiwgXCJsZWZ0XCJdLFxuICAgIFwi4oqiXCI6IFtcInBhc3NcIiwgXCJyaWdodFwiXVxuICB9O1xuXG4gIHZhciBpc09wZXJhdG9yID0gL1tcXC5cXC/ijL/ijYDCqOKNo10vO1xuICB2YXIgaXNOaWxhZGljID0gL+KNrC87XG4gIHZhciBpc0Z1bmN0aW9uID0gL1tcXCviiJLDl8O34oyI4oyK4oij4o2zXFw/4ouG4o2f4peLIeKMuTziiaQ9PuKJpeKJoOKJoeKJouKIiOKNt+KIquKIqeKIvOKIqOKIp+KNseKNsuKNtCzijarijL3iipbijYnihpHihpPiioLiioPijLfijYvijZLiiqTiiqXijZXijY7iiqPiiqJdLztcbiAgdmFyIGlzQXJyb3cgPSAv4oaQLztcbiAgdmFyIGlzQ29tbWVudCA9IC9b4o2dI10uKiQvO1xuXG4gIHZhciBzdHJpbmdFYXRlciA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICB2YXIgcHJldjtcbiAgICBwcmV2ID0gZmFsc2U7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGMpIHtcbiAgICAgIHByZXYgPSBjO1xuICAgICAgaWYgKGMgPT09IHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHByZXYgPT09IFwiXFxcXFwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByZXY6IGZhbHNlLFxuICAgICAgICBmdW5jOiBmYWxzZSxcbiAgICAgICAgb3A6IGZhbHNlLFxuICAgICAgICBzdHJpbmc6IGZhbHNlLFxuICAgICAgICBlc2NhcGU6IGZhbHNlXG4gICAgICB9O1xuICAgIH0sXG4gICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBjaCwgZnVuY05hbWU7XG4gICAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjaCA9IHN0cmVhbS5uZXh0KCk7XG4gICAgICBpZiAoY2ggPT09ICdcIicgfHwgY2ggPT09IFwiJ1wiKSB7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZShzdHJpbmdFYXRlcihjaCkpO1xuICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICBzdGF0ZS5wcmV2ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgICB9XG4gICAgICBpZiAoL1tcXFt7XFwoXS8udGVzdChjaCkpIHtcbiAgICAgICAgc3RhdGUucHJldiA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICgvW1xcXX1cXCldLy50ZXN0KGNoKSkge1xuICAgICAgICBzdGF0ZS5wcmV2ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoaXNOaWxhZGljLnRlc3QoY2gpKSB7XG4gICAgICAgIHN0YXRlLnByZXYgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIFwibmlsYWRpY1wiO1xuICAgICAgfVxuICAgICAgaWYgKC9bwq9cXGRdLy50ZXN0KGNoKSkge1xuICAgICAgICBpZiAoc3RhdGUuZnVuYykge1xuICAgICAgICAgIHN0YXRlLmZ1bmMgPSBmYWxzZTtcbiAgICAgICAgICBzdGF0ZS5wcmV2ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUucHJldiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwuXS8pO1xuICAgICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICAgIH1cbiAgICAgIGlmIChpc09wZXJhdG9yLnRlc3QoY2gpKSB7XG4gICAgICAgIHJldHVybiBcIm9wZXJhdG9yIGFwbC1cIiArIGJ1aWx0SW5PcHNbY2hdO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyb3cudGVzdChjaCkpIHtcbiAgICAgICAgcmV0dXJuIFwiYXBsLWFycm93XCI7XG4gICAgICB9XG4gICAgICBpZiAoaXNGdW5jdGlvbi50ZXN0KGNoKSkge1xuICAgICAgICBmdW5jTmFtZSA9IFwiYXBsLVwiO1xuICAgICAgICBpZiAoYnVpbHRJbkZ1bmNzW2NoXSAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKHN0YXRlLnByZXYpIHtcbiAgICAgICAgICAgIGZ1bmNOYW1lICs9IGJ1aWx0SW5GdW5jc1tjaF1bMV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZ1bmNOYW1lICs9IGJ1aWx0SW5GdW5jc1tjaF1bMF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmZ1bmMgPSB0cnVlO1xuICAgICAgICBzdGF0ZS5wcmV2ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBcImZ1bmN0aW9uIFwiICsgZnVuY05hbWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNDb21tZW50LnRlc3QoY2gpKSB7XG4gICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgICAgfVxuICAgICAgaWYgKGNoID09PSBcIuKImFwiICYmIHN0cmVhbS5wZWVrKCkgPT09IFwiLlwiKSB7XG4gICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIHJldHVybiBcImZ1bmN0aW9uIGpvdC1kb3RcIjtcbiAgICAgIH1cbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcJF9dLyk7XG4gICAgICBzdGF0ZS5wcmV2ID0gdHJ1ZTtcbiAgICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgICB9XG4gIH07XG59KTtcblxuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC9hcGxcIiwgXCJhcGxcIik7XG5cbn0pO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgZnVuY3Rpb24gZXJyb3JJZk5vdEVtcHR5KHN0cmVhbSkge1xuICAgIHZhciBub25XUyA9IHN0cmVhbS5tYXRjaCgvXlxccypcXFMvKTtcbiAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgcmV0dXJuIG5vbldTID8gXCJlcnJvclwiIDogbnVsbDtcbiAgfVxuXG4gIENvZGVNaXJyb3IuZGVmaW5lTW9kZShcImFzY2lpYXJtb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIHZhciBtO1xuICAgICAgICBpZiAoc3RhdGUuc3RhdGUgPT0gXCJ0b3BcIikge1xuICAgICAgICAgIGlmIChzdHJlYW0uc29sKCkgJiYgKG0gPSBzdHJlYW0ubWF0Y2goL14tLS0tLUJFR0lOICguKik/LS0tLS1cXHMqJC8pKSkge1xuICAgICAgICAgICAgc3RhdGUuc3RhdGUgPSBcImhlYWRlcnNcIjtcbiAgICAgICAgICAgIHN0YXRlLnR5cGUgPSBtWzFdO1xuICAgICAgICAgICAgcmV0dXJuIFwidGFnXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBlcnJvcklmTm90RW1wdHkoc3RyZWFtKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5zdGF0ZSA9PSBcImhlYWRlcnNcIikge1xuICAgICAgICAgIGlmIChzdHJlYW0uc29sKCkgJiYgc3RyZWFtLm1hdGNoKC9eXFx3KzovKSkge1xuICAgICAgICAgICAgc3RhdGUuc3RhdGUgPSBcImhlYWRlclwiO1xuICAgICAgICAgICAgcmV0dXJuIFwiYXRvbVwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gZXJyb3JJZk5vdEVtcHR5KHN0cmVhbSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSBzdGF0ZS5zdGF0ZSA9IFwiYm9keVwiO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUuc3RhdGUgPT0gXCJoZWFkZXJcIikge1xuICAgICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgICBzdGF0ZS5zdGF0ZSA9IFwiaGVhZGVyc1wiO1xuICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLnN0YXRlID09IFwiYm9keVwiKSB7XG4gICAgICAgICAgaWYgKHN0cmVhbS5zb2woKSAmJiAobSA9IHN0cmVhbS5tYXRjaCgvXi0tLS0tRU5EICguKik/LS0tLS1cXHMqJC8pKSkge1xuICAgICAgICAgICAgaWYgKG1bMV0gIT0gc3RhdGUudHlwZSkgcmV0dXJuIFwiZXJyb3JcIjtcbiAgICAgICAgICAgIHN0YXRlLnN0YXRlID0gXCJlbmRcIjtcbiAgICAgICAgICAgIHJldHVybiBcInRhZ1wiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3RyZWFtLmVhdFdoaWxlKC9bQS1aYS16MC05K1xcLz1dLykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAgICAgICByZXR1cm4gXCJlcnJvclwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5zdGF0ZSA9PSBcImVuZFwiKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9ySWZOb3RFbXB0eShzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYmxhbmtMaW5lOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUuc3RhdGUgPT0gXCJoZWFkZXJzXCIpIHN0YXRlLnN0YXRlID0gXCJib2R5XCI7XG4gICAgICB9LFxuICAgICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7c3RhdGU6IFwidG9wXCIsIHR5cGU6IG51bGx9O1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcImFwcGxpY2F0aW9uL3BncFwiLCBcImFzY2lpYXJtb3JcIik7XG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcImFwcGxpY2F0aW9uL3BncC1lbmNyeXB0ZWRcIiwgXCJhc2NpaWFybW9yXCIpO1xuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJhcHBsaWNhdGlvbi9wZ3Ata2V5c1wiLCBcImFzY2lpYXJtb3JcIik7XG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcImFwcGxpY2F0aW9uL3BncC1zaWduYXR1cmVcIiwgXCJhc2NpaWFybW9yXCIpO1xufSk7XG4iLCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBDb2RlTWlycm9yLmRlZmluZU1vZGUoXCJhc24uMVwiLCBmdW5jdGlvbihjb25maWcsIHBhcnNlckNvbmZpZykge1xuICAgIHZhciBpbmRlbnRVbml0ID0gY29uZmlnLmluZGVudFVuaXQsXG4gICAgICAgIGtleXdvcmRzID0gcGFyc2VyQ29uZmlnLmtleXdvcmRzIHx8IHt9LFxuICAgICAgICBjbWlwVmVyYnMgPSBwYXJzZXJDb25maWcuY21pcFZlcmJzIHx8IHt9LFxuICAgICAgICBjb21wYXJlVHlwZXMgPSBwYXJzZXJDb25maWcuY29tcGFyZVR5cGVzIHx8IHt9LFxuICAgICAgICBzdGF0dXMgPSBwYXJzZXJDb25maWcuc3RhdHVzIHx8IHt9LFxuICAgICAgICB0YWdzID0gcGFyc2VyQ29uZmlnLnRhZ3MgfHwge30sXG4gICAgICAgIHN0b3JhZ2UgPSBwYXJzZXJDb25maWcuc3RvcmFnZSB8fCB7fSxcbiAgICAgICAgbW9kaWZpZXIgPSBwYXJzZXJDb25maWcubW9kaWZpZXIgfHwge30sXG4gICAgICAgIGFjY2Vzc1R5cGVzID0gcGFyc2VyQ29uZmlnLmFjY2Vzc1R5cGVzfHwge30sXG4gICAgICAgIG11bHRpTGluZVN0cmluZ3MgPSBwYXJzZXJDb25maWcubXVsdGlMaW5lU3RyaW5ncyxcbiAgICAgICAgaW5kZW50U3RhdGVtZW50cyA9IHBhcnNlckNvbmZpZy5pbmRlbnRTdGF0ZW1lbnRzICE9PSBmYWxzZTtcbiAgICB2YXIgaXNPcGVyYXRvckNoYXIgPSAvW1xcfFxcXl0vO1xuICAgIHZhciBjdXJQdW5jO1xuXG4gICAgZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG4gICAgICBpZiAoY2ggPT0gJ1wiJyB8fCBjaCA9PSBcIidcIikge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuU3RyaW5nKGNoKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgfVxuICAgICAgaWYgKC9bXFxbXFxdXFwoXFwpe306PSw7XS8udGVzdChjaCkpIHtcbiAgICAgICAgY3VyUHVuYyA9IGNoO1xuICAgICAgICByZXR1cm4gXCJwdW5jdHVhdGlvblwiO1xuICAgICAgfVxuICAgICAgaWYgKGNoID09IFwiLVwiKXtcbiAgICAgICAgaWYgKHN0cmVhbS5lYXQoXCItXCIpKSB7XG4gICAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKC9cXGQvLnRlc3QoY2gpKSB7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcLl0vKTtcbiAgICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgICB9XG4gICAgICBpZiAoaXNPcGVyYXRvckNoYXIudGVzdChjaCkpIHtcbiAgICAgICAgc3RyZWFtLmVhdFdoaWxlKGlzT3BlcmF0b3JDaGFyKTtcbiAgICAgICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgICAgIH1cblxuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwtXS8pO1xuICAgICAgdmFyIGN1ciA9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAgICBpZiAoa2V5d29yZHMucHJvcGVydHlJc0VudW1lcmFibGUoY3VyKSkgcmV0dXJuIFwia2V5d29yZFwiO1xuICAgICAgaWYgKGNtaXBWZXJicy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSByZXR1cm4gXCJ2YXJpYWJsZSBjbWlwVmVyYnNcIjtcbiAgICAgIGlmIChjb21wYXJlVHlwZXMucHJvcGVydHlJc0VudW1lcmFibGUoY3VyKSkgcmV0dXJuIFwiYXRvbSBjb21wYXJlVHlwZXNcIjtcbiAgICAgIGlmIChzdGF0dXMucHJvcGVydHlJc0VudW1lcmFibGUoY3VyKSkgcmV0dXJuIFwiY29tbWVudCBzdGF0dXNcIjtcbiAgICAgIGlmICh0YWdzLnByb3BlcnR5SXNFbnVtZXJhYmxlKGN1cikpIHJldHVybiBcInZhcmlhYmxlLTMgdGFnc1wiO1xuICAgICAgaWYgKHN0b3JhZ2UucHJvcGVydHlJc0VudW1lcmFibGUoY3VyKSkgcmV0dXJuIFwiYnVpbHRpbiBzdG9yYWdlXCI7XG4gICAgICBpZiAobW9kaWZpZXIucHJvcGVydHlJc0VudW1lcmFibGUoY3VyKSkgcmV0dXJuIFwic3RyaW5nLTIgbW9kaWZpZXJcIjtcbiAgICAgIGlmIChhY2Nlc3NUeXBlcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSByZXR1cm4gXCJhdG9tIGFjY2Vzc1R5cGVzXCI7XG5cbiAgICAgIHJldHVybiBcInZhcmlhYmxlXCI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9rZW5TdHJpbmcocXVvdGUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIHZhciBlc2NhcGVkID0gZmFsc2UsIG5leHQsIGVuZCA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAoKG5leHQgPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKG5leHQgPT0gcXVvdGUgJiYgIWVzY2FwZWQpe1xuICAgICAgICAgICAgdmFyIGFmdGVyTmV4dCA9IHN0cmVhbS5wZWVrKCk7XG4gICAgICAgICAgICAvL2xvb2sgaWYgdGhlIGNoYXJhY3RlciBpZiB0aGUgcXVvdGUgaXMgbGlrZSB0aGUgQiBpbiAnMTAxMDAwMTAnQlxuICAgICAgICAgICAgaWYgKGFmdGVyTmV4dCl7XG4gICAgICAgICAgICAgIGFmdGVyTmV4dCA9IGFmdGVyTmV4dC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICBpZihhZnRlck5leHQgPT0gXCJiXCIgfHwgYWZ0ZXJOZXh0ID09IFwiaFwiIHx8IGFmdGVyTmV4dCA9PSBcIm9cIilcbiAgICAgICAgICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5kID0gdHJ1ZTsgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZCAmJiBuZXh0ID09IFwiXFxcXFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgfHwgIShlc2NhcGVkIHx8IG11bHRpTGluZVN0cmluZ3MpKVxuICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIENvbnRleHQoaW5kZW50ZWQsIGNvbHVtbiwgdHlwZSwgYWxpZ24sIHByZXYpIHtcbiAgICAgIHRoaXMuaW5kZW50ZWQgPSBpbmRlbnRlZDtcbiAgICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgIHRoaXMuYWxpZ24gPSBhbGlnbjtcbiAgICAgIHRoaXMucHJldiA9IHByZXY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hDb250ZXh0KHN0YXRlLCBjb2wsIHR5cGUpIHtcbiAgICAgIHZhciBpbmRlbnQgPSBzdGF0ZS5pbmRlbnRlZDtcbiAgICAgIGlmIChzdGF0ZS5jb250ZXh0ICYmIHN0YXRlLmNvbnRleHQudHlwZSA9PSBcInN0YXRlbWVudFwiKVxuICAgICAgICBpbmRlbnQgPSBzdGF0ZS5jb250ZXh0LmluZGVudGVkO1xuICAgICAgcmV0dXJuIHN0YXRlLmNvbnRleHQgPSBuZXcgQ29udGV4dChpbmRlbnQsIGNvbCwgdHlwZSwgbnVsbCwgc3RhdGUuY29udGV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcENvbnRleHQoc3RhdGUpIHtcbiAgICAgIHZhciB0ID0gc3RhdGUuY29udGV4dC50eXBlO1xuICAgICAgaWYgKHQgPT0gXCIpXCIgfHwgdCA9PSBcIl1cIiB8fCB0ID09IFwifVwiKVxuICAgICAgICBzdGF0ZS5pbmRlbnRlZCA9IHN0YXRlLmNvbnRleHQuaW5kZW50ZWQ7XG4gICAgICByZXR1cm4gc3RhdGUuY29udGV4dCA9IHN0YXRlLmNvbnRleHQucHJldjtcbiAgICB9XG5cbiAgICAvL0ludGVyZmFjZVxuICAgIHJldHVybiB7XG4gICAgICBzdGFydFN0YXRlOiBmdW5jdGlvbihiYXNlY29sdW1uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdG9rZW5pemU6IG51bGwsXG4gICAgICAgICAgY29udGV4dDogbmV3IENvbnRleHQoKGJhc2Vjb2x1bW4gfHwgMCkgLSBpbmRlbnRVbml0LCAwLCBcInRvcFwiLCBmYWxzZSksXG4gICAgICAgICAgaW5kZW50ZWQ6IDAsXG4gICAgICAgICAgc3RhcnRPZkxpbmU6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH0sXG5cbiAgICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIHZhciBjdHggPSBzdGF0ZS5jb250ZXh0O1xuICAgICAgICBpZiAoc3RyZWFtLnNvbCgpKSB7XG4gICAgICAgICAgaWYgKGN0eC5hbGlnbiA9PSBudWxsKSBjdHguYWxpZ24gPSBmYWxzZTtcbiAgICAgICAgICBzdGF0ZS5pbmRlbnRlZCA9IHN0cmVhbS5pbmRlbnRhdGlvbigpO1xuICAgICAgICAgIHN0YXRlLnN0YXJ0T2ZMaW5lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xuICAgICAgICBjdXJQdW5jID0gbnVsbDtcbiAgICAgICAgdmFyIHN0eWxlID0gKHN0YXRlLnRva2VuaXplIHx8IHRva2VuQmFzZSkoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIGlmIChzdHlsZSA9PSBcImNvbW1lbnRcIikgcmV0dXJuIHN0eWxlO1xuICAgICAgICBpZiAoY3R4LmFsaWduID09IG51bGwpIGN0eC5hbGlnbiA9IHRydWU7XG5cbiAgICAgICAgaWYgKChjdXJQdW5jID09IFwiO1wiIHx8IGN1clB1bmMgPT0gXCI6XCIgfHwgY3VyUHVuYyA9PSBcIixcIilcbiAgICAgICAgICAgICYmIGN0eC50eXBlID09IFwic3RhdGVtZW50XCIpe1xuICAgICAgICAgIHBvcENvbnRleHQoc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1clB1bmMgPT0gXCJ7XCIpIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0uY29sdW1uKCksIFwifVwiKTtcbiAgICAgICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBcIltcIikgcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbS5jb2x1bW4oKSwgXCJdXCIpO1xuICAgICAgICBlbHNlIGlmIChjdXJQdW5jID09IFwiKFwiKSBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLmNvbHVtbigpLCBcIilcIik7XG4gICAgICAgIGVsc2UgaWYgKGN1clB1bmMgPT0gXCJ9XCIpIHtcbiAgICAgICAgICB3aGlsZSAoY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIikgY3R4ID0gcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICAgICAgaWYgKGN0eC50eXBlID09IFwifVwiKSBjdHggPSBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgICAgICB3aGlsZSAoY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIikgY3R4ID0gcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBjdHgudHlwZSkgcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICAgIGVsc2UgaWYgKGluZGVudFN0YXRlbWVudHMgJiYgKCgoY3R4LnR5cGUgPT0gXCJ9XCIgfHwgY3R4LnR5cGUgPT0gXCJ0b3BcIilcbiAgICAgICAgICAgICYmIGN1clB1bmMgIT0gJzsnKSB8fCAoY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIlxuICAgICAgICAgICAgJiYgY3VyUHVuYyA9PSBcIm5ld3N0YXRlbWVudFwiKSkpXG4gICAgICAgICAgcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbS5jb2x1bW4oKSwgXCJzdGF0ZW1lbnRcIik7XG5cbiAgICAgICAgc3RhdGUuc3RhcnRPZkxpbmUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgfSxcblxuICAgICAgZWxlY3RyaWNDaGFyczogXCJ7fVwiLFxuICAgICAgbGluZUNvbW1lbnQ6IFwiLS1cIixcbiAgICAgIGZvbGQ6IFwiYnJhY2VcIlxuICAgIH07XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHdvcmRzKHN0cikge1xuICAgIHZhciBvYmogPSB7fSwgd29yZHMgPSBzdHIuc3BsaXQoXCIgXCIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyArK2kpIG9ialt3b3Jkc1tpXV0gPSB0cnVlO1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3gtdHRjbi1hc25cIiwge1xuICAgIG5hbWU6IFwiYXNuLjFcIixcbiAgICBrZXl3b3Jkczogd29yZHMoXCJERUZJTklUSU9OUyBPQkpFQ1RTIElGIERFUklWRUQgSU5GT1JNQVRJT04gQUNUSU9OXCIgK1xuICAgIFwiIFJFUExZIEFOWSBOQU1FRCBDSEFSQUNURVJJWkVEIEJFSEFWSU9VUiBSRUdJU1RFUkVEXCIgK1xuICAgIFwiIFdJVEggQVMgSURFTlRJRklFRCBDT05TVFJBSU5FRCBCWSBQUkVTRU5UIEJFR0lOXCIgK1xuICAgIFwiIElNUE9SVFMgRlJPTSBVTklUUyBTWU5UQVggTUlOLUFDQ0VTUyBNQVgtQUNDRVNTXCIgK1xuICAgIFwiIE1JTkFDQ0VTUyBNQVhBQ0NFU1MgUkVWSVNJT04gU1RBVFVTIERFU0NSSVBUSU9OXCIgK1xuICAgIFwiIFNFUVVFTkNFIFNFVCBDT01QT05FTlRTIE9GIENIT0lDRSBEaXN0aW5ndWlzaGVkTmFtZVwiICtcbiAgICBcIiBFTlVNRVJBVEVEIFNJWkUgTU9EVUxFIEVORCBJTkRFWCBBVUdNRU5UUyBFWFRFTlNJQklMSVRZXCIgK1xuICAgIFwiIElNUExJRUQgRVhQT1JUU1wiKSxcbiAgICBjbWlwVmVyYnM6IHdvcmRzKFwiQUNUSU9OUyBBREQgR0VUIE5PVElGSUNBVElPTlMgUkVQTEFDRSBSRU1PVkVcIiksXG4gICAgY29tcGFyZVR5cGVzOiB3b3JkcyhcIk9QVElPTkFMIERFRkFVTFQgTUFOQUdFRCBNT0RVTEUtVFlQRSBNT0RVTEVfSURFTlRJVFlcIiArXG4gICAgXCIgTU9EVUxFLUNPTVBMSUFOQ0UgT0JKRUNULVRZUEUgT0JKRUNULUlERU5USVRZXCIgK1xuICAgIFwiIE9CSkVDVC1DT01QTElBTkNFIE1PREUgQ09ORklSTUVEIENPTkRJVElPTkFMXCIgK1xuICAgIFwiIFNVQk9SRElOQVRFIFNVUEVSSU9SIENMQVNTIFRSVUUgRkFMU0UgTlVMTFwiICtcbiAgICBcIiBURVhUVUFMLUNPTlZFTlRJT05cIiksXG4gICAgc3RhdHVzOiB3b3JkcyhcImN1cnJlbnQgZGVwcmVjYXRlZCBtYW5kYXRvcnkgb2Jzb2xldGVcIiksXG4gICAgdGFnczogd29yZHMoXCJBUFBMSUNBVElPTiBBVVRPTUFUSUMgRVhQTElDSVQgSU1QTElDSVQgUFJJVkFURSBUQUdTXCIgK1xuICAgIFwiIFVOSVZFUlNBTFwiKSxcbiAgICBzdG9yYWdlOiB3b3JkcyhcIkJPT0xFQU4gSU5URUdFUiBPQkpFQ1QgSURFTlRJRklFUiBCSVQgT0NURVQgU1RSSU5HXCIgK1xuICAgIFwiIFVUQ1RpbWUgSW50ZXJmYWNlSW5kZXggSUFOQWlmVHlwZSBDTUlQLUF0dHJpYnV0ZVwiICtcbiAgICBcIiBSRUFMIFBBQ0tBR0UgUEFDS0FHRVMgSXBBZGRyZXNzIFBoeXNBZGRyZXNzXCIgK1xuICAgIFwiIE5ldHdvcmtBZGRyZXNzIEJJVFMgQk1QU3RyaW5nIFRpbWVTdGFtcCBUaW1lVGlja3NcIiArXG4gICAgXCIgVHJ1dGhWYWx1ZSBSb3dTdGF0dXMgRGlzcGxheVN0cmluZyBHZW5lcmFsU3RyaW5nXCIgK1xuICAgIFwiIEdyYXBoaWNTdHJpbmcgSUE1U3RyaW5nIE51bWVyaWNTdHJpbmdcIiArXG4gICAgXCIgUHJpbnRhYmxlU3RyaW5nIFNubXBBZG1pblN0cmluZyBUZWxldGV4U3RyaW5nXCIgK1xuICAgIFwiIFVURjhTdHJpbmcgVmlkZW90ZXhTdHJpbmcgVmlzaWJsZVN0cmluZyBTdHJpbmdTdG9yZVwiICtcbiAgICBcIiBJU082NDZTdHJpbmcgVDYxU3RyaW5nIFVuaXZlcnNhbFN0cmluZyBVbnNpZ25lZDMyXCIgK1xuICAgIFwiIEludGVnZXIzMiBHYXVnZSBHYXVnZTMyIENvdW50ZXIgQ291bnRlcjMyIENvdW50ZXI2NFwiKSxcbiAgICBtb2RpZmllcjogd29yZHMoXCJBVFRSSUJVVEUgQVRUUklCVVRFUyBNQU5EQVRPUlktR1JPVVAgTUFOREFUT1JZLUdST1VQU1wiICtcbiAgICBcIiBHUk9VUCBHUk9VUFMgRUxFTUVOVFMgRVFVQUxJVFkgT1JERVJJTkcgU1VCU1RSSU5HU1wiICtcbiAgICBcIiBERUZJTkVEXCIpLFxuICAgIGFjY2Vzc1R5cGVzOiB3b3JkcyhcIm5vdC1hY2Nlc3NpYmxlIGFjY2Vzc2libGUtZm9yLW5vdGlmeSByZWFkLW9ubHlcIiArXG4gICAgXCIgcmVhZC1jcmVhdGUgcmVhZC13cml0ZVwiKSxcbiAgICBtdWx0aUxpbmVTdHJpbmdzOiB0cnVlXG4gIH0pO1xufSk7XG4iLCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4vKlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqICAgICAgIEZpbGVuYW1lOiAgbW9kZS9hc3Rlcmlzay9hc3Rlcmlzay5qc1xuICpcbiAqICAgIERlc2NyaXB0aW9uOiAgQ29kZU1pcnJvciBtb2RlIGZvciBBc3RlcmlzayBkaWFscGxhblxuICpcbiAqICAgICAgICBDcmVhdGVkOiAgMDUvMTcvMjAxMiAwOToyMDoyNSBQTVxuICogICAgICAgUmV2aXNpb246ICAwOC8wNS8yMDE5IEFzdExpbnV4IFByb2plY3Q6IFN1cHBvcnQgYmxvY2stY29tbWVudHNcbiAqXG4gKiAgICAgICAgIEF1dGhvcjogIFN0YXMgS29iemFyIChzdGFzQG1vZHVsaXMuY2EpLFxuICogICAgICAgIENvbXBhbnk6ICBNb2R1bGlzLmNhIEluYy5cbiAqXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcblwidXNlIHN0cmljdFwiO1xuXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoXCJhc3Rlcmlza1wiLCBmdW5jdGlvbigpIHtcbiAgdmFyIGF0b21zICAgID0gW1wiZXh0ZW5cIiwgXCJzYW1lXCIsIFwiaW5jbHVkZVwiLFwiaWdub3JlcGF0XCIsXCJzd2l0Y2hcIl0sXG4gICAgICBkcGNtZCAgICA9IFtcIiNpbmNsdWRlXCIsXCIjZXhlY1wiXSxcbiAgICAgIGFwcHMgICAgID0gW1xuICAgICAgICAgICAgICAgICAgXCJhZGRxdWV1ZW1lbWJlclwiLFwiYWRzaXByb2dcIixcImFlbHN1YlwiLFwiYWdlbnRsb2dpblwiLFwiYWdlbnRtb25pdG9yb3V0Z29pbmdcIixcImFnaVwiLFxuICAgICAgICAgICAgICAgICAgXCJhbGFybXJlY2VpdmVyXCIsXCJhbWRcIixcImFuc3dlclwiLFwiYXV0aGVudGljYXRlXCIsXCJiYWNrZ3JvdW5kXCIsXCJiYWNrZ3JvdW5kZGV0ZWN0XCIsXG4gICAgICAgICAgICAgICAgICBcImJyaWRnZVwiLFwiYnVzeVwiLFwiY2FsbGNvbXBsZXRpb25jYW5jZWxcIixcImNhbGxjb21wbGV0aW9ucmVxdWVzdFwiLFwiY2VsZ2VudXNlcmV2ZW50XCIsXG4gICAgICAgICAgICAgICAgICBcImNoYW5nZW1vbml0b3JcIixcImNoYW5pc2F2YWlsXCIsXCJjaGFubmVscmVkaXJlY3RcIixcImNoYW5zcHlcIixcImNsZWFyaGFzaFwiLFwiY29uZmJyaWRnZVwiLFxuICAgICAgICAgICAgICAgICAgXCJjb25nZXN0aW9uXCIsXCJjb250aW51ZXdoaWxlXCIsXCJjb250cm9scGxheWJhY2tcIixcImRhaGRpYWNjZXB0cjJjYWxsXCIsXCJkYWhkaWJhcmdlXCIsXG4gICAgICAgICAgICAgICAgICBcImRhaGRpcmFzXCIsXCJkYWhkaXNjYW5cIixcImRhaGRpc2VuZGNhbGxyZXJvdXRpbmdmYWNpbGl0eVwiLFwiZGFoZGlzZW5ka2V5cGFkZmFjaWxpdHlcIixcbiAgICAgICAgICAgICAgICAgIFwiZGF0ZXRpbWVcIixcImRiZGVsXCIsXCJkYmRlbHRyZWVcIixcImRlYWRhZ2lcIixcImRpYWxcIixcImRpY3RhdGVcIixcImRpcmVjdG9yeVwiLFwiZGlzYVwiLFxuICAgICAgICAgICAgICAgICAgXCJkdW1wY2hhblwiLFwiZWFnaVwiLFwiZWNob1wiLFwiZW5kd2hpbGVcIixcImV4ZWNcIixcImV4ZWNpZlwiLFwiZXhlY2lmdGltZVwiLFwiZXhpdHdoaWxlXCIsXCJleHRlbnNweVwiLFxuICAgICAgICAgICAgICAgICAgXCJleHRlcm5hbGl2clwiLFwiZmVzdGl2YWxcIixcImZsYXNoXCIsXCJmb2xsb3dtZVwiLFwiZm9ya2NkclwiLFwiZ2V0Y3BlaWRcIixcImdvc3ViXCIsXCJnb3N1YmlmXCIsXG4gICAgICAgICAgICAgICAgICBcImdvdG9cIixcImdvdG9pZlwiLFwiZ290b2lmdGltZVwiLFwiaGFuZ3VwXCIsXCJpYXgycHJvdmlzaW9uXCIsXCJpY2VzXCIsXCJpbXBvcnR2YXJcIixcImluY29tcGxldGVcIixcbiAgICAgICAgICAgICAgICAgIFwiaXZyZGVtb1wiLFwiamFiYmVyam9pblwiLFwiamFiYmVybGVhdmVcIixcImphYmJlcnNlbmRcIixcImphYmJlcnNlbmRncm91cFwiLFwiamFiYmVyc3RhdHVzXCIsXG4gICAgICAgICAgICAgICAgICBcImphY2tcIixcImxvZ1wiLFwibWFjcm9cIixcIm1hY3JvZXhjbHVzaXZlXCIsXCJtYWNyb2V4aXRcIixcIm1hY3JvaWZcIixcIm1haWxib3hleGlzdHNcIixcIm1lZXRtZVwiLFxuICAgICAgICAgICAgICAgICAgXCJtZWV0bWVhZG1pblwiLFwibWVldG1lY2hhbm5lbGFkbWluXCIsXCJtZWV0bWVjb3VudFwiLFwibWlsbGl3YXR0XCIsXCJtaW5pdm1hY2NtZXNzXCIsXCJtaW5pdm1kZWxldGVcIixcbiAgICAgICAgICAgICAgICAgIFwibWluaXZtZ3JlZXRcIixcIm1pbml2bW13aVwiLFwibWluaXZtbm90aWZ5XCIsXCJtaW5pdm1yZWNvcmRcIixcIm1peG1vbml0b3JcIixcIm1vbml0b3JcIixcIm1vcnNlY29kZVwiLFxuICAgICAgICAgICAgICAgICAgXCJtcDNwbGF5ZXJcIixcIm1zZXRcIixcIm11c2ljb25ob2xkXCIsXCJuYnNjYXRcIixcIm5vY2RyXCIsXCJub29wXCIsXCJvZGJjXCIsXCJvZGJjXCIsXCJvZGJjZmluaXNoXCIsXG4gICAgICAgICAgICAgICAgICBcIm9yaWdpbmF0ZVwiLFwib3NwYXV0aFwiLFwib3NwZmluaXNoXCIsXCJvc3Bsb29rdXBcIixcIm9zcG5leHRcIixcInBhZ2VcIixcInBhcmtcIixcInBhcmthbmRhbm5vdW5jZVwiLFxuICAgICAgICAgICAgICAgICAgXCJwYXJrZWRjYWxsXCIsXCJwYXVzZW1vbml0b3JcIixcInBhdXNlcXVldWVtZW1iZXJcIixcInBpY2t1cFwiLFwicGlja3VwY2hhblwiLFwicGxheWJhY2tcIixcInBsYXl0b25lc1wiLFxuICAgICAgICAgICAgICAgICAgXCJwcml2YWN5bWFuYWdlclwiLFwicHJvY2VlZGluZ1wiLFwicHJvZ3Jlc3NcIixcInF1ZXVlXCIsXCJxdWV1ZWxvZ1wiLFwicmFpc2VleGNlcHRpb25cIixcInJlYWRcIixcInJlYWRleHRlblwiLFxuICAgICAgICAgICAgICAgICAgXCJyZWFkZmlsZVwiLFwicmVjZWl2ZWZheFwiLFwicmVjZWl2ZWZheFwiLFwicmVjZWl2ZWZheFwiLFwicmVjb3JkXCIsXCJyZW1vdmVxdWV1ZW1lbWJlclwiLFxuICAgICAgICAgICAgICAgICAgXCJyZXNldGNkclwiLFwicmV0cnlkaWFsXCIsXCJyZXR1cm5cIixcInJpbmdpbmdcIixcInNheWFscGhhXCIsXCJzYXljb3VudGVkYWRqXCIsXCJzYXljb3VudGVkbm91blwiLFxuICAgICAgICAgICAgICAgICAgXCJzYXljb3VudHBsXCIsXCJzYXlkaWdpdHNcIixcInNheW51bWJlclwiLFwic2F5cGhvbmV0aWNcIixcInNheXVuaXh0aW1lXCIsXCJzZW5kZHRtZlwiLFwic2VuZGZheFwiLFxuICAgICAgICAgICAgICAgICAgXCJzZW5kZmF4XCIsXCJzZW5kZmF4XCIsXCJzZW5kaW1hZ2VcIixcInNlbmR0ZXh0XCIsXCJzZW5kdXJsXCIsXCJzZXRcIixcInNldGFtYWZsYWdzXCIsXG4gICAgICAgICAgICAgICAgICBcInNldGNhbGxlcnByZXNcIixcInNldG11c2ljb25ob2xkXCIsXCJzaXBhZGRoZWFkZXJcIixcInNpcGR0bWZtb2RlXCIsXCJzaXByZW1vdmVoZWFkZXJcIixcInNrZWxcIixcbiAgICAgICAgICAgICAgICAgIFwic2xhc3RhdGlvblwiLFwic2xhdHJ1bmtcIixcInNtc1wiLFwic29mdGhhbmd1cFwiLFwic3BlZWNoYWN0aXZhdGVncmFtbWFyXCIsXCJzcGVlY2hiYWNrZ3JvdW5kXCIsXG4gICAgICAgICAgICAgICAgICBcInNwZWVjaGNyZWF0ZVwiLFwic3BlZWNoZGVhY3RpdmF0ZWdyYW1tYXJcIixcInNwZWVjaGRlc3Ryb3lcIixcInNwZWVjaGxvYWRncmFtbWFyXCIsXCJzcGVlY2hwcm9jZXNzaW5nc291bmRcIixcbiAgICAgICAgICAgICAgICAgIFwic3BlZWNoc3RhcnRcIixcInNwZWVjaHVubG9hZGdyYW1tYXJcIixcInN0YWNrcG9wXCIsXCJzdGFydG11c2ljb25ob2xkXCIsXCJzdG9wbWl4bW9uaXRvclwiLFwic3RvcG1vbml0b3JcIixcbiAgICAgICAgICAgICAgICAgIFwic3RvcG11c2ljb25ob2xkXCIsXCJzdG9wcGxheXRvbmVzXCIsXCJzeXN0ZW1cIixcInRlc3RjbGllbnRcIixcInRlc3RzZXJ2ZXJcIixcInRyYW5zZmVyXCIsXCJ0cnlleGVjXCIsXG4gICAgICAgICAgICAgICAgICBcInRyeXN5c3RlbVwiLFwidW5wYXVzZW1vbml0b3JcIixcInVucGF1c2VxdWV1ZW1lbWJlclwiLFwidXNlcmV2ZW50XCIsXCJ2ZXJib3NlXCIsXCJ2bWF1dGhlbnRpY2F0ZVwiLFxuICAgICAgICAgICAgICAgICAgXCJ2bXNheW5hbWVcIixcInZvaWNlbWFpbFwiLFwidm9pY2VtYWlsbWFpblwiLFwid2FpdFwiLFwid2FpdGV4dGVuXCIsXCJ3YWl0Zm9ybm9pc2VcIixcIndhaXRmb3JyaW5nXCIsXG4gICAgICAgICAgICAgICAgICBcIndhaXRmb3JzaWxlbmNlXCIsXCJ3YWl0bXVzaWNvbmhvbGRcIixcIndhaXR1bnRpbFwiLFwid2hpbGVcIixcInphcGF0ZWxsZXJcIlxuICAgICAgICAgICAgICAgICBdO1xuXG4gIGZ1bmN0aW9uIGJhc2ljVG9rZW4oc3RyZWFtLHN0YXRlKXtcbiAgICB2YXIgY3VyID0gJyc7XG4gICAgdmFyIGNoID0gc3RyZWFtLm5leHQoKTtcbiAgICAvLyBjb21tZW50XG4gICAgaWYgKHN0YXRlLmJsb2NrQ29tbWVudCkge1xuICAgICAgaWYgKGNoID09IFwiLVwiICYmIHN0cmVhbS5tYXRjaChcIi07XCIsIHRydWUpKSB7XG4gICAgICAgIHN0YXRlLmJsb2NrQ29tbWVudCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChzdHJlYW0uc2tpcFRvKFwiLS07XCIpKSB7XG4gICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIHN0YXRlLmJsb2NrQ29tbWVudCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgIH1cbiAgICBpZihjaCA9PSBcIjtcIikge1xuICAgICAgaWYgKHN0cmVhbS5tYXRjaChcIi0tXCIsIHRydWUpKSB7XG4gICAgICAgIGlmICghc3RyZWFtLm1hdGNoKFwiLVwiLCBmYWxzZSkpIHsgIC8vIEV4Y2VwdCA7LS0tIGlzIG5vdCBhIGJsb2NrIGNvbW1lbnRcbiAgICAgICAgICBzdGF0ZS5ibG9ja0NvbW1lbnQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgIH1cbiAgICAvLyBjb250ZXh0XG4gICAgaWYoY2ggPT0gJ1snKSB7XG4gICAgICBzdHJlYW0uc2tpcFRvKCddJyk7XG4gICAgICBzdHJlYW0uZWF0KCddJyk7XG4gICAgICByZXR1cm4gXCJoZWFkZXJcIjtcbiAgICB9XG4gICAgLy8gc3RyaW5nXG4gICAgaWYoY2ggPT0gJ1wiJykge1xuICAgICAgc3RyZWFtLnNraXBUbygnXCInKTtcbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH1cbiAgICBpZihjaCA9PSBcIidcIikge1xuICAgICAgc3RyZWFtLnNraXBUbyhcIidcIik7XG4gICAgICByZXR1cm4gXCJzdHJpbmctMlwiO1xuICAgIH1cbiAgICAvLyBkaWFscGxhbiBjb21tYW5kc1xuICAgIGlmKGNoID09ICcjJykge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9cXHcvKTtcbiAgICAgIGN1ciA9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAgICBpZihkcGNtZC5pbmRleE9mKGN1cikgIT09IC0xKSB7XG4gICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgcmV0dXJuIFwic3Ryb25nXCI7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGFwcGxpY2F0aW9uIGFyZ3NcbiAgICBpZihjaCA9PSAnJCcpe1xuICAgICAgdmFyIGNoMSA9IHN0cmVhbS5wZWVrKCk7XG4gICAgICBpZihjaDEgPT0gJ3snKXtcbiAgICAgICAgc3RyZWFtLnNraXBUbygnfScpO1xuICAgICAgICBzdHJlYW0uZWF0KCd9Jyk7XG4gICAgICAgIHJldHVybiBcInZhcmlhYmxlLTNcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZXh0ZW5zaW9uXG4gICAgc3RyZWFtLmVhdFdoaWxlKC9cXHcvKTtcbiAgICBjdXIgPSBzdHJlYW0uY3VycmVudCgpO1xuICAgIGlmKGF0b21zLmluZGV4T2YoY3VyKSAhPT0gLTEpIHtcbiAgICAgIHN0YXRlLmV4dGVuU3RhcnQgPSB0cnVlO1xuICAgICAgc3dpdGNoKGN1cikge1xuICAgICAgICBjYXNlICdzYW1lJzogc3RhdGUuZXh0ZW5TYW1lID0gdHJ1ZTsgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2luY2x1ZGUnOlxuICAgICAgICBjYXNlICdzd2l0Y2gnOlxuICAgICAgICBjYXNlICdpZ25vcmVwYXQnOlxuICAgICAgICAgIHN0YXRlLmV4dGVuSW5jbHVkZSA9IHRydWU7YnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6YnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJhdG9tXCI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJsb2NrQ29tbWVudDogZmFsc2UsXG4gICAgICAgIGV4dGVuU3RhcnQ6IGZhbHNlLFxuICAgICAgICBleHRlblNhbWU6ICBmYWxzZSxcbiAgICAgICAgZXh0ZW5JbmNsdWRlOiBmYWxzZSxcbiAgICAgICAgZXh0ZW5FeHRlbjogZmFsc2UsXG4gICAgICAgIGV4dGVuUHJpb3JpdHk6IGZhbHNlLFxuICAgICAgICBleHRlbkFwcGxpY2F0aW9uOiBmYWxzZVxuICAgICAgfTtcbiAgICB9LFxuICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG5cbiAgICAgIHZhciBjdXIgPSAnJztcbiAgICAgIGlmKHN0cmVhbS5lYXRTcGFjZSgpKSByZXR1cm4gbnVsbDtcbiAgICAgIC8vIGV4dGVuc2lvbiBzdGFydGVkXG4gICAgICBpZihzdGF0ZS5leHRlblN0YXJ0KXtcbiAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXlxcc10vKTtcbiAgICAgICAgY3VyID0gc3RyZWFtLmN1cnJlbnQoKTtcbiAgICAgICAgaWYoL149Pj8kLy50ZXN0KGN1cikpe1xuICAgICAgICAgIHN0YXRlLmV4dGVuRXh0ZW4gPSB0cnVlO1xuICAgICAgICAgIHN0YXRlLmV4dGVuU3RhcnQgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gXCJzdHJvbmdcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS5leHRlblN0YXJ0ID0gZmFsc2U7XG4gICAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICAgIHJldHVybiBcImVycm9yXCI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZihzdGF0ZS5leHRlbkV4dGVuKSB7XG4gICAgICAgIC8vIHNldCBleHRlbiBhbmQgcHJpb3JpdHlcbiAgICAgICAgc3RhdGUuZXh0ZW5FeHRlbiA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5leHRlblByaW9yaXR5ID0gdHJ1ZTtcbiAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXixdLyk7XG4gICAgICAgIGlmKHN0YXRlLmV4dGVuSW5jbHVkZSkge1xuICAgICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgICBzdGF0ZS5leHRlblByaW9yaXR5ID0gZmFsc2U7XG4gICAgICAgICAgc3RhdGUuZXh0ZW5JbmNsdWRlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYoc3RhdGUuZXh0ZW5TYW1lKSB7XG4gICAgICAgICAgc3RhdGUuZXh0ZW5Qcmlvcml0eSA9IGZhbHNlO1xuICAgICAgICAgIHN0YXRlLmV4dGVuU2FtZSA9IGZhbHNlO1xuICAgICAgICAgIHN0YXRlLmV4dGVuQXBwbGljYXRpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcInRhZ1wiO1xuICAgICAgfSBlbHNlIGlmKHN0YXRlLmV4dGVuUHJpb3JpdHkpIHtcbiAgICAgICAgc3RhdGUuZXh0ZW5Qcmlvcml0eSA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5leHRlbkFwcGxpY2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgc3RyZWFtLm5leHQoKTsgLy8gZ2V0IGNvbW1hXG4gICAgICAgIGlmKHN0YXRlLmV4dGVuU2FtZSkgcmV0dXJuIG51bGw7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW14sXS8pO1xuICAgICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICAgIH0gZWxzZSBpZihzdGF0ZS5leHRlbkFwcGxpY2F0aW9uKSB7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvLC8pO1xuICAgICAgICBjdXIgPSBzdHJlYW0uY3VycmVudCgpO1xuICAgICAgICBpZihjdXIgPT09ICcsJykgcmV0dXJuIG51bGw7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvXFx3Lyk7XG4gICAgICAgIGN1ciA9IHN0cmVhbS5jdXJyZW50KCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgc3RhdGUuZXh0ZW5BcHBsaWNhdGlvbiA9IGZhbHNlO1xuICAgICAgICBpZihhcHBzLmluZGV4T2YoY3VyKSAhPT0gLTEpe1xuICAgICAgICAgIHJldHVybiBcImRlZiBzdHJvbmdcIjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNle1xuICAgICAgICByZXR1cm4gYmFzaWNUb2tlbihzdHJlYW0sc3RhdGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgYmxvY2tDb21tZW50U3RhcnQ6IFwiOy0tXCIsXG4gICAgYmxvY2tDb21tZW50RW5kOiBcIi0tO1wiLFxuICAgIGxpbmVDb21tZW50OiBcIjtcIlxuICB9O1xufSk7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQveC1hc3Rlcmlza1wiLCBcImFzdGVyaXNrXCIpO1xuXG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbi8vIEJyYWluZnVjayBtb2RlIGNyZWF0ZWQgYnkgTWljaGFlbCBLYW1pbnNreSBodHRwczovL2dpdGh1Yi5jb20vbWthbWluc2t5MTFcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSlcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZClcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZClcbiAgZWxzZVxuICAgIG1vZChDb2RlTWlycm9yKVxufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuICBcInVzZSBzdHJpY3RcIlxuICB2YXIgcmVzZXJ2ZSA9IFwiPjwrLS4sW11cIi5zcGxpdChcIlwiKTtcbiAgLypcbiAgY29tbWVudHMgY2FuIGJlIGVpdGhlcjpcbiAgcGxhY2VkIGJlaGluZCBsaW5lc1xuXG4gICAgICAgICsrKyAgICB0aGlzIGlzIGEgY29tbWVudFxuXG4gIHdoZXJlIHJlc2VydmVkIGNoYXJhY3RlcnMgY2Fubm90IGJlIHVzZWRcbiAgb3IgaW4gYSBsb29wXG4gIFtcbiAgICB0aGlzIGlzIG9rIHRvIHVzZSBbIF0gYW5kIHN0dWZmXG4gIF1cbiAgb3IgcHJlY2VkZWQgYnkgI1xuICAqL1xuICBDb2RlTWlycm9yLmRlZmluZU1vZGUoXCJicmFpbmZ1Y2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvbW1lbnRMaW5lOiBmYWxzZSxcbiAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICAgIGNvbW1lbnRMb29wOiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSByZXR1cm4gbnVsbFxuICAgICAgICBpZihzdHJlYW0uc29sKCkpe1xuICAgICAgICAgIHN0YXRlLmNvbW1lbnRMaW5lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoID0gc3RyZWFtLm5leHQoKS50b1N0cmluZygpO1xuICAgICAgICBpZihyZXNlcnZlLmluZGV4T2YoY2gpICE9PSAtMSl7XG4gICAgICAgICAgaWYoc3RhdGUuY29tbWVudExpbmUgPT09IHRydWUpe1xuICAgICAgICAgICAgaWYoc3RyZWFtLmVvbCgpKXtcbiAgICAgICAgICAgICAgc3RhdGUuY29tbWVudExpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoY2ggPT09IFwiXVwiIHx8IGNoID09PSBcIltcIil7XG4gICAgICAgICAgICBpZihjaCA9PT0gXCJbXCIpe1xuICAgICAgICAgICAgICBzdGF0ZS5sZWZ0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICBzdGF0ZS5yaWdodCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFwiYnJhY2tldFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmKGNoID09PSBcIitcIiB8fCBjaCA9PT0gXCItXCIpe1xuICAgICAgICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmKGNoID09PSBcIjxcIiB8fCBjaCA9PT0gXCI+XCIpe1xuICAgICAgICAgICAgcmV0dXJuIFwiYXRvbVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmKGNoID09PSBcIi5cIiB8fCBjaCA9PT0gXCIsXCIpe1xuICAgICAgICAgICAgcmV0dXJuIFwiZGVmXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgc3RhdGUuY29tbWVudExpbmUgPSB0cnVlO1xuICAgICAgICAgIGlmKHN0cmVhbS5lb2woKSl7XG4gICAgICAgICAgICBzdGF0ZS5jb21tZW50TGluZSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYoc3RyZWFtLmVvbCgpKXtcbiAgICAgICAgICBzdGF0ZS5jb21tZW50TGluZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3gtYnJhaW5mdWNrXCIsXCJicmFpbmZ1Y2tcIilcbn0pO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcblwidXNlIHN0cmljdFwiO1xuXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoXCJjbG9qdXJlXCIsIGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBhdG9tcyA9IFtcImZhbHNlXCIsIFwibmlsXCIsIFwidHJ1ZVwiXTtcbiAgdmFyIHNwZWNpYWxGb3JtcyA9IFtcIi5cIiwgXCJjYXRjaFwiLCBcImRlZlwiLCBcImRvXCIsIFwiaWZcIiwgXCJtb25pdG9yLWVudGVyXCIsXG4gICAgICBcIm1vbml0b3ItZXhpdFwiLCBcIm5ld1wiLCBcInF1b3RlXCIsIFwicmVjdXJcIiwgXCJzZXQhXCIsIFwidGhyb3dcIiwgXCJ0cnlcIiwgXCJ2YXJcIl07XG4gIHZhciBjb3JlU3ltYm9scyA9IFtcIipcIiwgXCIqJ1wiLCBcIioxXCIsIFwiKjJcIiwgXCIqM1wiLCBcIiphZ2VudCpcIixcbiAgICAgIFwiKmFsbG93LXVucmVzb2x2ZWQtdmFycypcIiwgXCIqYXNzZXJ0KlwiLCBcIipjbG9qdXJlLXZlcnNpb24qXCIsXG4gICAgICBcIipjb21tYW5kLWxpbmUtYXJncypcIiwgXCIqY29tcGlsZS1maWxlcypcIiwgXCIqY29tcGlsZS1wYXRoKlwiLFxuICAgICAgXCIqY29tcGlsZXItb3B0aW9ucypcIiwgXCIqZGF0YS1yZWFkZXJzKlwiLCBcIipkZWZhdWx0LWRhdGEtcmVhZGVyLWZuKlwiLCBcIiplXCIsXG4gICAgICBcIiplcnIqXCIsIFwiKmZpbGUqXCIsIFwiKmZsdXNoLW9uLW5ld2xpbmUqXCIsIFwiKmZuLWxvYWRlcipcIiwgXCIqaW4qXCIsXG4gICAgICBcIiptYXRoLWNvbnRleHQqXCIsIFwiKm5zKlwiLCBcIipvdXQqXCIsIFwiKnByaW50LWR1cCpcIiwgXCIqcHJpbnQtbGVuZ3RoKlwiLFxuICAgICAgXCIqcHJpbnQtbGV2ZWwqXCIsIFwiKnByaW50LW1ldGEqXCIsIFwiKnByaW50LW5hbWVzcGFjZS1tYXBzKlwiLFxuICAgICAgXCIqcHJpbnQtcmVhZGFibHkqXCIsIFwiKnJlYWQtZXZhbCpcIiwgXCIqcmVhZGVyLXJlc29sdmVyKlwiLCBcIipzb3VyY2UtcGF0aCpcIixcbiAgICAgIFwiKnN1cHByZXNzLXJlYWQqXCIsIFwiKnVuY2hlY2tlZC1tYXRoKlwiLCBcIip1c2UtY29udGV4dC1jbGFzc2xvYWRlcipcIixcbiAgICAgIFwiKnZlcmJvc2UtZGVmcmVjb3JkcypcIiwgXCIqd2Fybi1vbi1yZWZsZWN0aW9uKlwiLCBcIitcIiwgXCIrJ1wiLCBcIi1cIiwgXCItJ1wiLFxuICAgICAgXCItPlwiLCBcIi0+PlwiLCBcIi0+QXJyYXlDaHVua1wiLCBcIi0+RWR1Y3Rpb25cIiwgXCItPlZlY1wiLCBcIi0+VmVjTm9kZVwiLFxuICAgICAgXCItPlZlY1NlcVwiLCBcIi1jYWNoZS1wcm90b2NvbC1mblwiLCBcIi1yZXNldC1tZXRob2RzXCIsIFwiLi5cIiwgXCIvXCIsIFwiPFwiLCBcIjw9XCIsXG4gICAgICBcIj1cIiwgXCI9PVwiLCBcIj5cIiwgXCI+PVwiLCBcIkVNUFRZLU5PREVcIiwgXCJJbnN0XCIsIFwiU3RhY2tUcmFjZUVsZW1lbnQtPnZlY1wiLFxuICAgICAgXCJUaHJvd2FibGUtPm1hcFwiLCBcImFjY2Vzc29yXCIsIFwiYWNsb25lXCIsIFwiYWRkLWNsYXNzcGF0aFwiLCBcImFkZC13YXRjaFwiLFxuICAgICAgXCJhZ2VudFwiLCBcImFnZW50LWVycm9yXCIsIFwiYWdlbnQtZXJyb3JzXCIsIFwiYWdldFwiLCBcImFsZW5ndGhcIiwgXCJhbGlhc1wiLFxuICAgICAgXCJhbGwtbnNcIiwgXCJhbHRlclwiLCBcImFsdGVyLW1ldGEhXCIsIFwiYWx0ZXItdmFyLXJvb3RcIiwgXCJhbWFwXCIsIFwiYW5jZXN0b3JzXCIsXG4gICAgICBcImFuZFwiLCBcImFueT9cIiwgXCJhcHBseVwiLCBcImFyZWR1Y2VcIiwgXCJhcnJheS1tYXBcIiwgXCJhcy0+XCIsIFwiYXNldFwiLFxuICAgICAgXCJhc2V0LWJvb2xlYW5cIiwgXCJhc2V0LWJ5dGVcIiwgXCJhc2V0LWNoYXJcIiwgXCJhc2V0LWRvdWJsZVwiLCBcImFzZXQtZmxvYXRcIixcbiAgICAgIFwiYXNldC1pbnRcIiwgXCJhc2V0LWxvbmdcIiwgXCJhc2V0LXNob3J0XCIsIFwiYXNzZXJ0XCIsIFwiYXNzb2NcIiwgXCJhc3NvYyFcIixcbiAgICAgIFwiYXNzb2MtaW5cIiwgXCJhc3NvY2lhdGl2ZT9cIiwgXCJhdG9tXCIsIFwiYXdhaXRcIiwgXCJhd2FpdC1mb3JcIiwgXCJhd2FpdDFcIixcbiAgICAgIFwiYmFzZXNcIiwgXCJiZWFuXCIsIFwiYmlnZGVjXCIsIFwiYmlnaW50XCIsIFwiYmlnaW50ZWdlclwiLCBcImJpbmRpbmdcIiwgXCJiaXQtYW5kXCIsXG4gICAgICBcImJpdC1hbmQtbm90XCIsIFwiYml0LWNsZWFyXCIsIFwiYml0LWZsaXBcIiwgXCJiaXQtbm90XCIsIFwiYml0LW9yXCIsIFwiYml0LXNldFwiLFxuICAgICAgXCJiaXQtc2hpZnQtbGVmdFwiLCBcImJpdC1zaGlmdC1yaWdodFwiLCBcImJpdC10ZXN0XCIsIFwiYml0LXhvclwiLCBcImJvb2xlYW5cIixcbiAgICAgIFwiYm9vbGVhbi1hcnJheVwiLCBcImJvb2xlYW4/XCIsIFwiYm9vbGVhbnNcIiwgXCJib3VuZC1mblwiLCBcImJvdW5kLWZuKlwiLFxuICAgICAgXCJib3VuZD9cIiwgXCJib3VuZGVkLWNvdW50XCIsIFwiYnV0bGFzdFwiLCBcImJ5dGVcIiwgXCJieXRlLWFycmF5XCIsIFwiYnl0ZXNcIixcbiAgICAgIFwiYnl0ZXM/XCIsIFwiY2FzZVwiLCBcImNhc3RcIiwgXCJjYXRcIiwgXCJjaGFyXCIsIFwiY2hhci1hcnJheVwiLFxuICAgICAgXCJjaGFyLWVzY2FwZS1zdHJpbmdcIiwgXCJjaGFyLW5hbWUtc3RyaW5nXCIsIFwiY2hhcj9cIiwgXCJjaGFyc1wiLCBcImNodW5rXCIsXG4gICAgICBcImNodW5rLWFwcGVuZFwiLCBcImNodW5rLWJ1ZmZlclwiLCBcImNodW5rLWNvbnNcIiwgXCJjaHVuay1maXJzdFwiLCBcImNodW5rLW5leHRcIixcbiAgICAgIFwiY2h1bmstcmVzdFwiLCBcImNodW5rZWQtc2VxP1wiLCBcImNsYXNzXCIsIFwiY2xhc3M/XCIsIFwiY2xlYXItYWdlbnQtZXJyb3JzXCIsXG4gICAgICBcImNsb2p1cmUtdmVyc2lvblwiLCBcImNvbGw/XCIsIFwiY29tbWVudFwiLCBcImNvbW11dGVcIiwgXCJjb21wXCIsIFwiY29tcGFyYXRvclwiLFxuICAgICAgXCJjb21wYXJlXCIsIFwiY29tcGFyZS1hbmQtc2V0IVwiLCBcImNvbXBpbGVcIiwgXCJjb21wbGVtZW50XCIsIFwiY29tcGxldGluZ1wiLFxuICAgICAgXCJjb25jYXRcIiwgXCJjb25kXCIsIFwiY29uZC0+XCIsIFwiY29uZC0+PlwiLCBcImNvbmRwXCIsIFwiY29ualwiLCBcImNvbmohXCIsIFwiY29uc1wiLFxuICAgICAgXCJjb25zdGFudGx5XCIsIFwiY29uc3RydWN0LXByb3h5XCIsIFwiY29udGFpbnM/XCIsIFwiY291bnRcIiwgXCJjb3VudGVkP1wiLFxuICAgICAgXCJjcmVhdGUtbnNcIiwgXCJjcmVhdGUtc3RydWN0XCIsIFwiY3ljbGVcIiwgXCJkZWNcIiwgXCJkZWMnXCIsIFwiZGVjaW1hbD9cIixcbiAgICAgIFwiZGVjbGFyZVwiLCBcImRlZHVwZVwiLCBcImRlZmF1bHQtZGF0YS1yZWFkZXJzXCIsIFwiZGVmaW5saW5lXCIsIFwiZGVmaW50ZXJmYWNlXCIsXG4gICAgICBcImRlZm1hY3JvXCIsIFwiZGVmbWV0aG9kXCIsIFwiZGVmbXVsdGlcIiwgXCJkZWZuXCIsIFwiZGVmbi1cIiwgXCJkZWZvbmNlXCIsXG4gICAgICBcImRlZnByb3RvY29sXCIsIFwiZGVmcmVjb3JkXCIsIFwiZGVmc3RydWN0XCIsIFwiZGVmdHlwZVwiLCBcImRlbGF5XCIsIFwiZGVsYXk/XCIsXG4gICAgICBcImRlbGl2ZXJcIiwgXCJkZW5vbWluYXRvclwiLCBcImRlcmVmXCIsIFwiZGVyaXZlXCIsIFwiZGVzY2VuZGFudHNcIiwgXCJkZXN0cnVjdHVyZVwiLFxuICAgICAgXCJkaXNqXCIsIFwiZGlzaiFcIiwgXCJkaXNzb2NcIiwgXCJkaXNzb2MhXCIsIFwiZGlzdGluY3RcIiwgXCJkaXN0aW5jdD9cIiwgXCJkb2FsbFwiLFxuICAgICAgXCJkb3J1blwiLCBcImRvc2VxXCIsIFwiZG9zeW5jXCIsIFwiZG90aW1lc1wiLCBcImRvdG9cIiwgXCJkb3VibGVcIiwgXCJkb3VibGUtYXJyYXlcIixcbiAgICAgIFwiZG91YmxlP1wiLCBcImRvdWJsZXNcIiwgXCJkcm9wXCIsIFwiZHJvcC1sYXN0XCIsIFwiZHJvcC13aGlsZVwiLCBcImVkdWN0aW9uXCIsXG4gICAgICBcImVtcHR5XCIsIFwiZW1wdHk/XCIsIFwiZW5zdXJlXCIsIFwiZW5zdXJlLXJlZHVjZWRcIiwgXCJlbnVtZXJhdGlvbi1zZXFcIixcbiAgICAgIFwiZXJyb3ItaGFuZGxlclwiLCBcImVycm9yLW1vZGVcIiwgXCJldmFsXCIsIFwiZXZlbj9cIiwgXCJldmVyeS1wcmVkXCIsIFwiZXZlcnk/XCIsXG4gICAgICBcImV4LWRhdGFcIiwgXCJleC1pbmZvXCIsIFwiZXh0ZW5kXCIsIFwiZXh0ZW5kLXByb3RvY29sXCIsIFwiZXh0ZW5kLXR5cGVcIixcbiAgICAgIFwiZXh0ZW5kZXJzXCIsIFwiZXh0ZW5kcz9cIiwgXCJmYWxzZT9cIiwgXCJmZmlyc3RcIiwgXCJmaWxlLXNlcVwiLCBcImZpbHRlclwiLFxuICAgICAgXCJmaWx0ZXJ2XCIsIFwiZmluZFwiLCBcImZpbmQta2V5d29yZFwiLCBcImZpbmQtbnNcIiwgXCJmaW5kLXByb3RvY29sLWltcGxcIixcbiAgICAgIFwiZmluZC1wcm90b2NvbC1tZXRob2RcIiwgXCJmaW5kLXZhclwiLCBcImZpcnN0XCIsIFwiZmxhdHRlblwiLCBcImZsb2F0XCIsXG4gICAgICBcImZsb2F0LWFycmF5XCIsIFwiZmxvYXQ/XCIsIFwiZmxvYXRzXCIsIFwiZmx1c2hcIiwgXCJmblwiLCBcImZuP1wiLCBcImZuZXh0XCIsIFwiZm5pbFwiLFxuICAgICAgXCJmb3JcIiwgXCJmb3JjZVwiLCBcImZvcm1hdFwiLCBcImZyZXF1ZW5jaWVzXCIsIFwiZnV0dXJlXCIsIFwiZnV0dXJlLWNhbGxcIixcbiAgICAgIFwiZnV0dXJlLWNhbmNlbFwiLCBcImZ1dHVyZS1jYW5jZWxsZWQ/XCIsIFwiZnV0dXJlLWRvbmU/XCIsIFwiZnV0dXJlP1wiLFxuICAgICAgXCJnZW4tY2xhc3NcIiwgXCJnZW4taW50ZXJmYWNlXCIsIFwiZ2Vuc3ltXCIsIFwiZ2V0XCIsIFwiZ2V0LWluXCIsIFwiZ2V0LW1ldGhvZFwiLFxuICAgICAgXCJnZXQtcHJveHktY2xhc3NcIiwgXCJnZXQtdGhyZWFkLWJpbmRpbmdzXCIsIFwiZ2V0LXZhbGlkYXRvclwiLCBcImdyb3VwLWJ5XCIsXG4gICAgICBcImhhbHQtd2hlblwiLCBcImhhc2hcIiwgXCJoYXNoLWNvbWJpbmVcIiwgXCJoYXNoLW1hcFwiLCBcImhhc2gtb3JkZXJlZC1jb2xsXCIsXG4gICAgICBcImhhc2gtc2V0XCIsIFwiaGFzaC11bm9yZGVyZWQtY29sbFwiLCBcImlkZW50P1wiLCBcImlkZW50aWNhbD9cIiwgXCJpZGVudGl0eVwiLFxuICAgICAgXCJpZi1sZXRcIiwgXCJpZi1ub3RcIiwgXCJpZi1zb21lXCIsIFwiaWZuP1wiLCBcImltcG9ydFwiLCBcImluLW5zXCIsIFwiaW5jXCIsIFwiaW5jJ1wiLFxuICAgICAgXCJpbmRleGVkP1wiLCBcImluaXQtcHJveHlcIiwgXCJpbnN0LW1zXCIsIFwiaW5zdC1tcypcIiwgXCJpbnN0P1wiLCBcImluc3RhbmNlP1wiLFxuICAgICAgXCJpbnRcIiwgXCJpbnQtYXJyYXlcIiwgXCJpbnQ/XCIsIFwiaW50ZWdlcj9cIiwgXCJpbnRlcmxlYXZlXCIsIFwiaW50ZXJuXCIsXG4gICAgICBcImludGVycG9zZVwiLCBcImludG9cIiwgXCJpbnRvLWFycmF5XCIsIFwiaW50c1wiLCBcImlvIVwiLCBcImlzYT9cIiwgXCJpdGVyYXRlXCIsXG4gICAgICBcIml0ZXJhdG9yLXNlcVwiLCBcImp1eHRcIiwgXCJrZWVwXCIsIFwia2VlcC1pbmRleGVkXCIsIFwia2V5XCIsIFwia2V5c1wiLCBcImtleXdvcmRcIixcbiAgICAgIFwia2V5d29yZD9cIiwgXCJsYXN0XCIsIFwibGF6eS1jYXRcIiwgXCJsYXp5LXNlcVwiLCBcImxldFwiLCBcImxldGZuXCIsIFwibGluZS1zZXFcIixcbiAgICAgIFwibGlzdFwiLCBcImxpc3QqXCIsIFwibGlzdD9cIiwgXCJsb2FkXCIsIFwibG9hZC1maWxlXCIsIFwibG9hZC1yZWFkZXJcIixcbiAgICAgIFwibG9hZC1zdHJpbmdcIiwgXCJsb2FkZWQtbGlic1wiLCBcImxvY2tpbmdcIiwgXCJsb25nXCIsIFwibG9uZy1hcnJheVwiLCBcImxvbmdzXCIsXG4gICAgICBcImxvb3BcIiwgXCJtYWNyb2V4cGFuZFwiLCBcIm1hY3JvZXhwYW5kLTFcIiwgXCJtYWtlLWFycmF5XCIsIFwibWFrZS1oaWVyYXJjaHlcIixcbiAgICAgIFwibWFwXCIsIFwibWFwLWVudHJ5P1wiLCBcIm1hcC1pbmRleGVkXCIsIFwibWFwP1wiLCBcIm1hcGNhdFwiLCBcIm1hcHZcIiwgXCJtYXhcIixcbiAgICAgIFwibWF4LWtleVwiLCBcIm1lbWZuXCIsIFwibWVtb2l6ZVwiLCBcIm1lcmdlXCIsIFwibWVyZ2Utd2l0aFwiLCBcIm1ldGFcIixcbiAgICAgIFwibWV0aG9kLXNpZ1wiLCBcIm1ldGhvZHNcIiwgXCJtaW5cIiwgXCJtaW4ta2V5XCIsIFwibWl4LWNvbGxlY3Rpb24taGFzaFwiLCBcIm1vZFwiLFxuICAgICAgXCJtdW5nZVwiLCBcIm5hbWVcIiwgXCJuYW1lc3BhY2VcIiwgXCJuYW1lc3BhY2UtbXVuZ2VcIiwgXCJuYXQtaW50P1wiLCBcIm5lZy1pbnQ/XCIsXG4gICAgICBcIm5lZz9cIiwgXCJuZXdsaW5lXCIsIFwibmV4dFwiLCBcIm5maXJzdFwiLCBcIm5pbD9cIiwgXCJubmV4dFwiLCBcIm5vdFwiLCBcIm5vdC1hbnk/XCIsXG4gICAgICBcIm5vdC1lbXB0eVwiLCBcIm5vdC1ldmVyeT9cIiwgXCJub3Q9XCIsIFwibnNcIiwgXCJucy1hbGlhc2VzXCIsIFwibnMtaW1wb3J0c1wiLFxuICAgICAgXCJucy1pbnRlcm5zXCIsIFwibnMtbWFwXCIsIFwibnMtbmFtZVwiLCBcIm5zLXB1YmxpY3NcIiwgXCJucy1yZWZlcnNcIixcbiAgICAgIFwibnMtcmVzb2x2ZVwiLCBcIm5zLXVuYWxpYXNcIiwgXCJucy11bm1hcFwiLCBcIm50aFwiLCBcIm50aG5leHRcIiwgXCJudGhyZXN0XCIsXG4gICAgICBcIm51bVwiLCBcIm51bWJlcj9cIiwgXCJudW1lcmF0b3JcIiwgXCJvYmplY3QtYXJyYXlcIiwgXCJvZGQ/XCIsIFwib3JcIiwgXCJwYXJlbnRzXCIsXG4gICAgICBcInBhcnRpYWxcIiwgXCJwYXJ0aXRpb25cIiwgXCJwYXJ0aXRpb24tYWxsXCIsIFwicGFydGl0aW9uLWJ5XCIsIFwicGNhbGxzXCIsIFwicGVla1wiLFxuICAgICAgXCJwZXJzaXN0ZW50IVwiLCBcInBtYXBcIiwgXCJwb3BcIiwgXCJwb3AhXCIsIFwicG9wLXRocmVhZC1iaW5kaW5nc1wiLCBcInBvcy1pbnQ/XCIsXG4gICAgICBcInBvcz9cIiwgXCJwclwiLCBcInByLXN0clwiLCBcInByZWZlci1tZXRob2RcIiwgXCJwcmVmZXJzXCIsXG4gICAgICBcInByaW1pdGl2ZXMtY2xhc3NuYW1lc1wiLCBcInByaW50XCIsIFwicHJpbnQtY3RvclwiLCBcInByaW50LWR1cFwiLFxuICAgICAgXCJwcmludC1tZXRob2RcIiwgXCJwcmludC1zaW1wbGVcIiwgXCJwcmludC1zdHJcIiwgXCJwcmludGZcIiwgXCJwcmludGxuXCIsXG4gICAgICBcInByaW50bG4tc3RyXCIsIFwicHJuXCIsIFwicHJuLXN0clwiLCBcInByb21pc2VcIiwgXCJwcm94eVwiLFxuICAgICAgXCJwcm94eS1jYWxsLXdpdGgtc3VwZXJcIiwgXCJwcm94eS1tYXBwaW5nc1wiLCBcInByb3h5LW5hbWVcIiwgXCJwcm94eS1zdXBlclwiLFxuICAgICAgXCJwdXNoLXRocmVhZC1iaW5kaW5nc1wiLCBcInB2YWx1ZXNcIiwgXCJxdWFsaWZpZWQtaWRlbnQ/XCIsXG4gICAgICBcInF1YWxpZmllZC1rZXl3b3JkP1wiLCBcInF1YWxpZmllZC1zeW1ib2w/XCIsIFwicXVvdFwiLCBcInJhbmRcIiwgXCJyYW5kLWludFwiLFxuICAgICAgXCJyYW5kLW50aFwiLCBcInJhbmRvbS1zYW1wbGVcIiwgXCJyYW5nZVwiLCBcInJhdGlvP1wiLCBcInJhdGlvbmFsP1wiLFxuICAgICAgXCJyYXRpb25hbGl6ZVwiLCBcInJlLWZpbmRcIiwgXCJyZS1ncm91cHNcIiwgXCJyZS1tYXRjaGVyXCIsIFwicmUtbWF0Y2hlc1wiLFxuICAgICAgXCJyZS1wYXR0ZXJuXCIsIFwicmUtc2VxXCIsIFwicmVhZFwiLCBcInJlYWQtbGluZVwiLCBcInJlYWQtc3RyaW5nXCIsXG4gICAgICBcInJlYWRlci1jb25kaXRpb25hbFwiLCBcInJlYWRlci1jb25kaXRpb25hbD9cIiwgXCJyZWFsaXplZD9cIiwgXCJyZWNvcmQ/XCIsXG4gICAgICBcInJlZHVjZVwiLCBcInJlZHVjZS1rdlwiLCBcInJlZHVjZWRcIiwgXCJyZWR1Y2VkP1wiLCBcInJlZHVjdGlvbnNcIiwgXCJyZWZcIixcbiAgICAgIFwicmVmLWhpc3RvcnktY291bnRcIiwgXCJyZWYtbWF4LWhpc3RvcnlcIiwgXCJyZWYtbWluLWhpc3RvcnlcIiwgXCJyZWYtc2V0XCIsXG4gICAgICBcInJlZmVyXCIsIFwicmVmZXItY2xvanVyZVwiLCBcInJlaWZ5XCIsIFwicmVsZWFzZS1wZW5kaW5nLXNlbmRzXCIsIFwicmVtXCIsXG4gICAgICBcInJlbW92ZVwiLCBcInJlbW92ZS1hbGwtbWV0aG9kc1wiLCBcInJlbW92ZS1tZXRob2RcIiwgXCJyZW1vdmUtbnNcIixcbiAgICAgIFwicmVtb3ZlLXdhdGNoXCIsIFwicmVwZWF0XCIsIFwicmVwZWF0ZWRseVwiLCBcInJlcGxhY2VcIiwgXCJyZXBsaWNhdGVcIiwgXCJyZXF1aXJlXCIsXG4gICAgICBcInJlc2V0IVwiLCBcInJlc2V0LW1ldGEhXCIsIFwicmVzZXQtdmFscyFcIiwgXCJyZXNvbHZlXCIsIFwicmVzdFwiLFxuICAgICAgXCJyZXN0YXJ0LWFnZW50XCIsIFwicmVzdWx0c2V0LXNlcVwiLCBcInJldmVyc2VcIiwgXCJyZXZlcnNpYmxlP1wiLCBcInJzZXFcIixcbiAgICAgIFwicnN1YnNlcVwiLCBcInJ1biFcIiwgXCJzYXRpc2ZpZXM/XCIsIFwic2Vjb25kXCIsIFwic2VsZWN0LWtleXNcIiwgXCJzZW5kXCIsXG4gICAgICBcInNlbmQtb2ZmXCIsIFwic2VuZC12aWFcIiwgXCJzZXFcIiwgXCJzZXE/XCIsIFwic2VxYWJsZT9cIiwgXCJzZXF1ZVwiLCBcInNlcXVlbmNlXCIsXG4gICAgICBcInNlcXVlbnRpYWw/XCIsIFwic2V0XCIsIFwic2V0LWFnZW50LXNlbmQtZXhlY3V0b3IhXCIsXG4gICAgICBcInNldC1hZ2VudC1zZW5kLW9mZi1leGVjdXRvciFcIiwgXCJzZXQtZXJyb3ItaGFuZGxlciFcIiwgXCJzZXQtZXJyb3ItbW9kZSFcIixcbiAgICAgIFwic2V0LXZhbGlkYXRvciFcIiwgXCJzZXQ/XCIsIFwic2hvcnRcIiwgXCJzaG9ydC1hcnJheVwiLCBcInNob3J0c1wiLCBcInNodWZmbGVcIixcbiAgICAgIFwic2h1dGRvd24tYWdlbnRzXCIsIFwic2ltcGxlLWlkZW50P1wiLCBcInNpbXBsZS1rZXl3b3JkP1wiLCBcInNpbXBsZS1zeW1ib2w/XCIsXG4gICAgICBcInNsdXJwXCIsIFwic29tZVwiLCBcInNvbWUtPlwiLCBcInNvbWUtPj5cIiwgXCJzb21lLWZuXCIsIFwic29tZT9cIiwgXCJzb3J0XCIsXG4gICAgICBcInNvcnQtYnlcIiwgXCJzb3J0ZWQtbWFwXCIsIFwic29ydGVkLW1hcC1ieVwiLCBcInNvcnRlZC1zZXRcIiwgXCJzb3J0ZWQtc2V0LWJ5XCIsXG4gICAgICBcInNvcnRlZD9cIiwgXCJzcGVjaWFsLXN5bWJvbD9cIiwgXCJzcGl0XCIsIFwic3BsaXQtYXRcIiwgXCJzcGxpdC13aXRoXCIsIFwic3RyXCIsXG4gICAgICBcInN0cmluZz9cIiwgXCJzdHJ1Y3RcIiwgXCJzdHJ1Y3QtbWFwXCIsIFwic3Vic1wiLCBcInN1YnNlcVwiLCBcInN1YnZlY1wiLCBcInN1cGVyc1wiLFxuICAgICAgXCJzd2FwIVwiLCBcInN3YXAtdmFscyFcIiwgXCJzeW1ib2xcIiwgXCJzeW1ib2w/XCIsIFwic3luY1wiLCBcInRhZ2dlZC1saXRlcmFsXCIsXG4gICAgICBcInRhZ2dlZC1saXRlcmFsP1wiLCBcInRha2VcIiwgXCJ0YWtlLWxhc3RcIiwgXCJ0YWtlLW50aFwiLCBcInRha2Utd2hpbGVcIiwgXCJ0ZXN0XCIsXG4gICAgICBcInRoZS1uc1wiLCBcInRocmVhZC1ib3VuZD9cIiwgXCJ0aW1lXCIsIFwidG8tYXJyYXlcIiwgXCJ0by1hcnJheS0yZFwiLFxuICAgICAgXCJ0cmFtcG9saW5lXCIsIFwidHJhbnNkdWNlXCIsIFwidHJhbnNpZW50XCIsIFwidHJlZS1zZXFcIiwgXCJ0cnVlP1wiLCBcInR5cGVcIixcbiAgICAgIFwidW5jaGVja2VkLWFkZFwiLCBcInVuY2hlY2tlZC1hZGQtaW50XCIsIFwidW5jaGVja2VkLWJ5dGVcIiwgXCJ1bmNoZWNrZWQtY2hhclwiLFxuICAgICAgXCJ1bmNoZWNrZWQtZGVjXCIsIFwidW5jaGVja2VkLWRlYy1pbnRcIiwgXCJ1bmNoZWNrZWQtZGl2aWRlLWludFwiLFxuICAgICAgXCJ1bmNoZWNrZWQtZG91YmxlXCIsIFwidW5jaGVja2VkLWZsb2F0XCIsIFwidW5jaGVja2VkLWluY1wiLFxuICAgICAgXCJ1bmNoZWNrZWQtaW5jLWludFwiLCBcInVuY2hlY2tlZC1pbnRcIiwgXCJ1bmNoZWNrZWQtbG9uZ1wiLFxuICAgICAgXCJ1bmNoZWNrZWQtbXVsdGlwbHlcIiwgXCJ1bmNoZWNrZWQtbXVsdGlwbHktaW50XCIsIFwidW5jaGVja2VkLW5lZ2F0ZVwiLFxuICAgICAgXCJ1bmNoZWNrZWQtbmVnYXRlLWludFwiLCBcInVuY2hlY2tlZC1yZW1haW5kZXItaW50XCIsIFwidW5jaGVja2VkLXNob3J0XCIsXG4gICAgICBcInVuY2hlY2tlZC1zdWJ0cmFjdFwiLCBcInVuY2hlY2tlZC1zdWJ0cmFjdC1pbnRcIiwgXCJ1bmRlcml2ZVwiLCBcInVucXVvdGVcIixcbiAgICAgIFwidW5xdW90ZS1zcGxpY2luZ1wiLCBcInVucmVkdWNlZFwiLCBcInVuc2lnbmVkLWJpdC1zaGlmdC1yaWdodFwiLCBcInVwZGF0ZVwiLFxuICAgICAgXCJ1cGRhdGUtaW5cIiwgXCJ1cGRhdGUtcHJveHlcIiwgXCJ1cmk/XCIsIFwidXNlXCIsIFwidXVpZD9cIiwgXCJ2YWxcIiwgXCJ2YWxzXCIsXG4gICAgICBcInZhci1nZXRcIiwgXCJ2YXItc2V0XCIsIFwidmFyP1wiLCBcInZhcnktbWV0YVwiLCBcInZlY1wiLCBcInZlY3RvclwiLCBcInZlY3Rvci1vZlwiLFxuICAgICAgXCJ2ZWN0b3I/XCIsIFwidm9sYXRpbGUhXCIsIFwidm9sYXRpbGU/XCIsIFwidnJlc2V0IVwiLCBcInZzd2FwIVwiLCBcIndoZW5cIixcbiAgICAgIFwid2hlbi1maXJzdFwiLCBcIndoZW4tbGV0XCIsIFwid2hlbi1ub3RcIiwgXCJ3aGVuLXNvbWVcIiwgXCJ3aGlsZVwiLFxuICAgICAgXCJ3aXRoLWJpbmRpbmdzXCIsIFwid2l0aC1iaW5kaW5ncypcIiwgXCJ3aXRoLWluLXN0clwiLCBcIndpdGgtbG9hZGluZy1jb250ZXh0XCIsXG4gICAgICBcIndpdGgtbG9jYWwtdmFyc1wiLCBcIndpdGgtbWV0YVwiLCBcIndpdGgtb3BlblwiLCBcIndpdGgtb3V0LXN0clwiLFxuICAgICAgXCJ3aXRoLXByZWNpc2lvblwiLCBcIndpdGgtcmVkZWZzXCIsIFwid2l0aC1yZWRlZnMtZm5cIiwgXCJ4bWwtc2VxXCIsIFwiemVybz9cIixcbiAgICAgIFwiemlwbWFwXCJdO1xuICB2YXIgaGF2ZUJvZHlQYXJhbWV0ZXIgPSBbXG4gICAgICBcIi0+XCIsIFwiLT4+XCIsIFwiYXMtPlwiLCBcImJpbmRpbmdcIiwgXCJib3VuZC1mblwiLCBcImNhc2VcIiwgXCJjYXRjaFwiLCBcImNvbW1lbnRcIixcbiAgICAgIFwiY29uZFwiLCBcImNvbmQtPlwiLCBcImNvbmQtPj5cIiwgXCJjb25kcFwiLCBcImRlZlwiLCBcImRlZmludGVyZmFjZVwiLCBcImRlZm1ldGhvZFwiLFxuICAgICAgXCJkZWZuXCIsIFwiZGVmbWFjcm9cIiwgXCJkZWZwcm90b2NvbFwiLCBcImRlZnJlY29yZFwiLCBcImRlZnN0cnVjdFwiLCBcImRlZnR5cGVcIixcbiAgICAgIFwiZG9cIiwgXCJkb3NlcVwiLCBcImRvdGltZXNcIiwgXCJkb3RvXCIsIFwiZXh0ZW5kXCIsIFwiZXh0ZW5kLXByb3RvY29sXCIsXG4gICAgICBcImV4dGVuZC10eXBlXCIsIFwiZm5cIiwgXCJmb3JcIiwgXCJmdXR1cmVcIiwgXCJpZlwiLCBcImlmLWxldFwiLCBcImlmLW5vdFwiLCBcImlmLXNvbWVcIixcbiAgICAgIFwibGV0XCIsIFwibGV0Zm5cIiwgXCJsb2NraW5nXCIsIFwibG9vcFwiLCBcIm5zXCIsIFwicHJveHlcIiwgXCJyZWlmeVwiLCBcInN0cnVjdC1tYXBcIixcbiAgICAgIFwic29tZS0+XCIsIFwic29tZS0+PlwiLCBcInRyeVwiLCBcIndoZW5cIiwgXCJ3aGVuLWZpcnN0XCIsIFwid2hlbi1sZXRcIiwgXCJ3aGVuLW5vdFwiLFxuICAgICAgXCJ3aGVuLXNvbWVcIiwgXCJ3aGlsZVwiLCBcIndpdGgtYmluZGluZ3NcIiwgXCJ3aXRoLWJpbmRpbmdzKlwiLCBcIndpdGgtaW4tc3RyXCIsXG4gICAgICBcIndpdGgtbG9hZGluZy1jb250ZXh0XCIsIFwid2l0aC1sb2NhbC12YXJzXCIsIFwid2l0aC1tZXRhXCIsIFwid2l0aC1vcGVuXCIsXG4gICAgICBcIndpdGgtb3V0LXN0clwiLCBcIndpdGgtcHJlY2lzaW9uXCIsIFwid2l0aC1yZWRlZnNcIiwgXCJ3aXRoLXJlZGVmcy1mblwiXTtcblxuICBDb2RlTWlycm9yLnJlZ2lzdGVySGVscGVyKFwiaGludFdvcmRzXCIsIFwiY2xvanVyZVwiLFxuICAgIFtdLmNvbmNhdChhdG9tcywgc3BlY2lhbEZvcm1zLCBjb3JlU3ltYm9scykpO1xuXG4gIHZhciBhdG9tID0gY3JlYXRlTG9va3VwTWFwKGF0b21zKTtcbiAgdmFyIHNwZWNpYWxGb3JtID0gY3JlYXRlTG9va3VwTWFwKHNwZWNpYWxGb3Jtcyk7XG4gIHZhciBjb3JlU3ltYm9sID0gY3JlYXRlTG9va3VwTWFwKGNvcmVTeW1ib2xzKTtcbiAgdmFyIGhhc0JvZHlQYXJhbWV0ZXIgPSBjcmVhdGVMb29rdXBNYXAoaGF2ZUJvZHlQYXJhbWV0ZXIpO1xuICB2YXIgZGVsaW1pdGVyID0gL14oPzpbXFxcXFxcW1xcXVxcc1wiKCksO0BeYHt9fl18JCkvO1xuICB2YXIgbnVtYmVyTGl0ZXJhbCA9IC9eKD86WytcXC1dP1xcZCsoPzooPzpOfCg/OltlRV1bK1xcLV0/XFxkKykpfCg/OlxcLj9cXGQqKD86TXwoPzpbZUVdWytcXC1dP1xcZCspKT8pfFxcL1xcZCt8W3hYXVswLTlhLWZBLUZdK3xyWzAtOWEtekEtWl0rKT8oPz1bXFxcXFxcW1xcXVxcc1wiIycoKSw7QF5ge31+XXwkKSkvO1xuICB2YXIgY2hhcmFjdGVyTGl0ZXJhbCA9IC9eKD86XFxcXCg/OmJhY2tzcGFjZXxmb3JtZmVlZHxuZXdsaW5lfHJldHVybnxzcGFjZXx0YWJ8b1swLTddezN9fHVbMC05QS1GYS1mXXs0fXx4WzAtOUEtRmEtZl17NH18Lik/KD89W1xcXFxcXFtcXF1cXHNcIigpLDtAXmB7fX5dfCQpKS87XG5cbiAgLy8gc2ltcGxlLW5hbWVzcGFjZSA6PSAvXlteXFxcXFxcL1xcW1xcXVxcZFxcc1wiIycoKSw7QF5ge31+Ll1bXlxcXFxcXFtcXF1cXHNcIigpLDtAXmB7fX4uXFwvXSovXG4gIC8vIHNpbXBsZS1zeW1ib2wgICAgOj0gL14oPzpcXC98W15cXFxcXFwvXFxbXFxdXFxkXFxzXCIjJygpLDtAXmB7fX5dW15cXFxcXFxbXFxdXFxzXCIoKSw7QF5ge31+XSopL1xuICAvLyBxdWFsaWZpZWQtc3ltYm9sIDo9ICg8c2ltcGxlLW5hbWVzcGFjZT4oPC4+PHNpbXBsZS1uYW1lc3BhY2U+KSo8Lz4pPzxzaW1wbGUtc3ltYm9sPlxuICB2YXIgcXVhbGlmaWVkU3ltYm9sID0gL14oPzooPzpbXlxcXFxcXC9cXFtcXF1cXGRcXHNcIiMnKCksO0BeYHt9fi5dW15cXFxcXFxbXFxdXFxzXCIoKSw7QF5ge31+LlxcL10qKD86XFwuW15cXFxcXFwvXFxbXFxdXFxkXFxzXCIjJygpLDtAXmB7fX4uXVteXFxcXFxcW1xcXVxcc1wiKCksO0BeYHt9fi5cXC9dKikqXFwvKT8oPzpcXC98W15cXFxcXFwvXFxbXFxdXFxkXFxzXCIjJygpLDtAXmB7fX5dW15cXFxcXFxbXFxdXFxzXCIoKSw7QF5ge31+XSopKig/PVtcXFxcXFxbXFxdXFxzXCIoKSw7QF5ge31+XXwkKSkvO1xuXG4gIGZ1bmN0aW9uIGJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSB8fCBzdHJlYW0uZWF0KFwiLFwiKSkgcmV0dXJuIFtcInNwYWNlXCIsIG51bGxdO1xuICAgIGlmIChzdHJlYW0ubWF0Y2gobnVtYmVyTGl0ZXJhbCkpIHJldHVybiBbbnVsbCwgXCJudW1iZXJcIl07XG4gICAgaWYgKHN0cmVhbS5tYXRjaChjaGFyYWN0ZXJMaXRlcmFsKSkgcmV0dXJuIFtudWxsLCBcInN0cmluZy0yXCJdO1xuICAgIGlmIChzdHJlYW0uZWF0KC9eXCIvKSkgcmV0dXJuIChzdGF0ZS50b2tlbml6ZSA9IGluU3RyaW5nKShzdHJlYW0sIHN0YXRlKTtcbiAgICBpZiAoc3RyZWFtLmVhdCgvXlsoXFxbe10vKSkgcmV0dXJuIFtcIm9wZW5cIiwgXCJicmFja2V0XCJdO1xuICAgIGlmIChzdHJlYW0uZWF0KC9eWylcXF19XS8pKSByZXR1cm4gW1wiY2xvc2VcIiwgXCJicmFja2V0XCJdO1xuICAgIGlmIChzdHJlYW0uZWF0KC9eOy8pKSB7c3RyZWFtLnNraXBUb0VuZCgpOyByZXR1cm4gW1wic3BhY2VcIiwgXCJjb21tZW50XCJdO31cbiAgICBpZiAoc3RyZWFtLmVhdCgvXlsjJ0BeYH5dLykpIHJldHVybiBbbnVsbCwgXCJtZXRhXCJdO1xuXG4gICAgdmFyIG1hdGNoZXMgPSBzdHJlYW0ubWF0Y2gocXVhbGlmaWVkU3ltYm9sKTtcbiAgICB2YXIgc3ltYm9sID0gbWF0Y2hlcyAmJiBtYXRjaGVzWzBdO1xuXG4gICAgaWYgKCFzeW1ib2wpIHtcbiAgICAgIC8vIGFkdmFuY2Ugc3RyZWFtIGJ5IGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIgc28gd2UgZG9uJ3QgZ2V0IHN0dWNrLlxuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZShmdW5jdGlvbiAoYykge3JldHVybiAhaXMoYywgZGVsaW1pdGVyKTt9KTtcbiAgICAgIHJldHVybiBbbnVsbCwgXCJlcnJvclwiXTtcbiAgICB9XG5cbiAgICBpZiAoc3ltYm9sID09PSBcImNvbW1lbnRcIiAmJiBzdGF0ZS5sYXN0VG9rZW4gPT09IFwiKFwiKVxuICAgICAgcmV0dXJuIChzdGF0ZS50b2tlbml6ZSA9IGluQ29tbWVudCkoc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKGlzKHN5bWJvbCwgYXRvbSkgfHwgc3ltYm9sLmNoYXJBdCgwKSA9PT0gXCI6XCIpIHJldHVybiBbXCJzeW1ib2xcIiwgXCJhdG9tXCJdO1xuICAgIGlmIChpcyhzeW1ib2wsIHNwZWNpYWxGb3JtKSB8fCBpcyhzeW1ib2wsIGNvcmVTeW1ib2wpKSByZXR1cm4gW1wic3ltYm9sXCIsIFwia2V5d29yZFwiXTtcbiAgICBpZiAoc3RhdGUubGFzdFRva2VuID09PSBcIihcIikgcmV0dXJuIFtcInN5bWJvbFwiLCBcImJ1aWx0aW5cIl07IC8vIG90aGVyIG9wZXJhdG9yXG5cbiAgICByZXR1cm4gW1wic3ltYm9sXCIsIFwidmFyaWFibGVcIl07XG4gIH1cblxuICBmdW5jdGlvbiBpblN0cmluZyhzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGVzY2FwZWQgPSBmYWxzZSwgbmV4dDtcblxuICAgIHdoaWxlIChuZXh0ID0gc3RyZWFtLm5leHQoKSkge1xuICAgICAgaWYgKG5leHQgPT09IFwiXFxcIlwiICYmICFlc2NhcGVkKSB7c3RhdGUudG9rZW5pemUgPSBiYXNlOyBicmVhazt9XG4gICAgICBlc2NhcGVkID0gIWVzY2FwZWQgJiYgbmV4dCA9PT0gXCJcXFxcXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtudWxsLCBcInN0cmluZ1wiXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIHBhcmVudGhlc2lzQ291bnQgPSAxO1xuICAgIHZhciBuZXh0O1xuXG4gICAgd2hpbGUgKG5leHQgPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgICBpZiAobmV4dCA9PT0gXCIpXCIpIHBhcmVudGhlc2lzQ291bnQtLTtcbiAgICAgIGlmIChuZXh0ID09PSBcIihcIikgcGFyZW50aGVzaXNDb3VudCsrO1xuICAgICAgaWYgKHBhcmVudGhlc2lzQ291bnQgPT09IDApIHtcbiAgICAgICAgc3RyZWFtLmJhY2tVcCgxKTtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSBiYXNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW1wic3BhY2VcIiwgXCJjb21tZW50XCJdO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTG9va3VwTWFwKHdvcmRzKSB7XG4gICAgdmFyIG9iaiA9IHt9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7ICsraSkgb2JqW3dvcmRzW2ldXSA9IHRydWU7XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgZnVuY3Rpb24gaXModmFsdWUsIHRlc3QpIHtcbiAgICBpZiAodGVzdCBpbnN0YW5jZW9mIFJlZ0V4cCkgcmV0dXJuIHRlc3QudGVzdCh2YWx1ZSk7XG4gICAgaWYgKHRlc3QgaW5zdGFuY2VvZiBPYmplY3QpIHJldHVybiB0ZXN0LnByb3BlcnR5SXNFbnVtZXJhYmxlKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY3R4OiB7cHJldjogbnVsbCwgc3RhcnQ6IDAsIGluZGVudFRvOiAwfSxcbiAgICAgICAgbGFzdFRva2VuOiBudWxsLFxuICAgICAgICB0b2tlbml6ZTogYmFzZVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgdG9rZW46IGZ1bmN0aW9uIChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAoc3RyZWFtLnNvbCgpICYmICh0eXBlb2Ygc3RhdGUuY3R4LmluZGVudFRvICE9PSBcIm51bWJlclwiKSlcbiAgICAgICAgc3RhdGUuY3R4LmluZGVudFRvID0gc3RhdGUuY3R4LnN0YXJ0ICsgMTtcblxuICAgICAgdmFyIHR5cGVTdHlsZVBhaXIgPSBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgIHZhciB0eXBlID0gdHlwZVN0eWxlUGFpclswXTtcbiAgICAgIHZhciBzdHlsZSA9IHR5cGVTdHlsZVBhaXJbMV07XG4gICAgICB2YXIgY3VycmVudCA9IHN0cmVhbS5jdXJyZW50KCk7XG5cbiAgICAgIGlmICh0eXBlICE9PSBcInNwYWNlXCIpIHtcbiAgICAgICAgaWYgKHN0YXRlLmxhc3RUb2tlbiA9PT0gXCIoXCIgJiYgc3RhdGUuY3R4LmluZGVudFRvID09PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IFwic3ltYm9sXCIgJiYgaXMoY3VycmVudCwgaGFzQm9keVBhcmFtZXRlcikpXG4gICAgICAgICAgICBzdGF0ZS5jdHguaW5kZW50VG8gPSBzdGF0ZS5jdHguc3RhcnQgKyBvcHRpb25zLmluZGVudFVuaXQ7XG4gICAgICAgICAgZWxzZSBzdGF0ZS5jdHguaW5kZW50VG8gPSBcIm5leHRcIjtcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5jdHguaW5kZW50VG8gPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgc3RhdGUuY3R4LmluZGVudFRvID0gc3RyZWFtLmNvbHVtbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUubGFzdFRva2VuID0gY3VycmVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09IFwib3BlblwiKVxuICAgICAgICBzdGF0ZS5jdHggPSB7cHJldjogc3RhdGUuY3R4LCBzdGFydDogc3RyZWFtLmNvbHVtbigpLCBpbmRlbnRUbzogbnVsbH07XG4gICAgICBlbHNlIGlmICh0eXBlID09PSBcImNsb3NlXCIpIHN0YXRlLmN0eCA9IHN0YXRlLmN0eC5wcmV2IHx8IHN0YXRlLmN0eDtcblxuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH0sXG5cbiAgICBpbmRlbnQ6IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgdmFyIGkgPSBzdGF0ZS5jdHguaW5kZW50VG87XG5cbiAgICAgIHJldHVybiAodHlwZW9mIGkgPT09IFwibnVtYmVyXCIpID9cbiAgICAgICAgaSA6XG4gICAgICAgIHN0YXRlLmN0eC5zdGFydCArIDE7XG4gICAgfSxcblxuICAgIGNsb3NlQnJhY2tldHM6IHtwYWlyczogXCIoKVtde31cXFwiXFxcIlwifSxcbiAgICBsaW5lQ29tbWVudDogXCI7O1wiXG4gIH07XG59KTtcblxuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LWNsb2p1cmVcIiwgXCJjbG9qdXJlXCIpO1xuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LWNsb2p1cmVzY3JpcHRcIiwgXCJjbG9qdXJlXCIpO1xuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwiYXBwbGljYXRpb24vZWRuXCIsIFwiY2xvanVyZVwiKTtcblxufSk7XG4iLCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIilcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZClcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2VcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwiY21ha2VcIiwgZnVuY3Rpb24gKCkge1xuICB2YXIgdmFyaWFibGVfcmVnZXggPSAvKHspP1thLXpBLVowLTlfXSsofSk/LztcblxuICBmdW5jdGlvbiB0b2tlblN0cmluZyhzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGN1cnJlbnQsIHByZXYsIGZvdW5kX3ZhciA9IGZhbHNlO1xuICAgIHdoaWxlICghc3RyZWFtLmVvbCgpICYmIChjdXJyZW50ID0gc3RyZWFtLm5leHQoKSkgIT0gc3RhdGUucGVuZGluZykge1xuICAgICAgaWYgKGN1cnJlbnQgPT09ICckJyAmJiBwcmV2ICE9ICdcXFxcJyAmJiBzdGF0ZS5wZW5kaW5nID09ICdcIicpIHtcbiAgICAgICAgZm91bmRfdmFyID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBwcmV2ID0gY3VycmVudDtcbiAgICB9XG4gICAgaWYgKGZvdW5kX3Zhcikge1xuICAgICAgc3RyZWFtLmJhY2tVcCgxKTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnQgPT0gc3RhdGUucGVuZGluZykge1xuICAgICAgc3RhdGUuY29udGludWVTdHJpbmcgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29udGludWVTdHJpbmcgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuaXplKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuXG4gICAgLy8gSGF2ZSB3ZSBmb3VuZCBhIHZhcmlhYmxlP1xuICAgIGlmIChjaCA9PT0gJyQnKSB7XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKHZhcmlhYmxlX3JlZ2V4KSkge1xuICAgICAgICByZXR1cm4gJ3ZhcmlhYmxlLTInO1xuICAgICAgfVxuICAgICAgcmV0dXJuICd2YXJpYWJsZSc7XG4gICAgfVxuICAgIC8vIFNob3VsZCB3ZSBzdGlsbCBiZSBsb29raW5nIGZvciB0aGUgZW5kIG9mIGEgc3RyaW5nP1xuICAgIGlmIChzdGF0ZS5jb250aW51ZVN0cmluZykge1xuICAgICAgLy8gSWYgc28sIGdvIHRocm91Z2ggdGhlIGxvb3AgYWdhaW5cbiAgICAgIHN0cmVhbS5iYWNrVXAoMSk7XG4gICAgICByZXR1cm4gdG9rZW5TdHJpbmcoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICAgIC8vIERvIHdlIGp1c3QgaGF2ZSBhIGZ1bmN0aW9uIG9uIG91ciBoYW5kcz9cbiAgICAvLyBJbiAnY21ha2VfbWluaW11bV9yZXF1aXJlZCAoVkVSU0lPTiAyLjguOCknLCAnY21ha2VfbWluaW11bV9yZXF1aXJlZCcgaXMgbWF0Y2hlZFxuICAgIGlmIChzdHJlYW0ubWF0Y2goLyhcXHMrKT9cXHcrXFwoLykgfHwgc3RyZWFtLm1hdGNoKC8oXFxzKyk/XFx3K1xcIFxcKC8pKSB7XG4gICAgICBzdHJlYW0uYmFja1VwKDEpO1xuICAgICAgcmV0dXJuICdkZWYnO1xuICAgIH1cbiAgICBpZiAoY2ggPT0gXCIjXCIpIHtcbiAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICB9XG4gICAgLy8gSGF2ZSB3ZSBmb3VuZCBhIHN0cmluZz9cbiAgICBpZiAoY2ggPT0gXCInXCIgfHwgY2ggPT0gJ1wiJykge1xuICAgICAgLy8gU3RvcmUgdGhlIHR5cGUgKHNpbmdsZSBvciBkb3VibGUpXG4gICAgICBzdGF0ZS5wZW5kaW5nID0gY2g7XG4gICAgICAvLyBQZXJmb3JtIHRoZSBsb29waW5nIGZ1bmN0aW9uIHRvIGZpbmQgdGhlIGVuZFxuICAgICAgcmV0dXJuIHRva2VuU3RyaW5nKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgICBpZiAoY2ggPT0gJygnIHx8IGNoID09ICcpJykge1xuICAgICAgcmV0dXJuICdicmFja2V0JztcbiAgICB9XG4gICAgaWYgKGNoLm1hdGNoKC9bMC05XS8pKSB7XG4gICAgICByZXR1cm4gJ251bWJlcic7XG4gICAgfVxuICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcdy1dLyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdGFydFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RhdGUgPSB7fTtcbiAgICAgIHN0YXRlLmluRGVmaW5pdGlvbiA9IGZhbHNlO1xuICAgICAgc3RhdGUuaW5JbmNsdWRlID0gZmFsc2U7XG4gICAgICBzdGF0ZS5jb250aW51ZVN0cmluZyA9IGZhbHNlO1xuICAgICAgc3RhdGUucGVuZGluZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG4gICAgdG9rZW46IGZ1bmN0aW9uIChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xuICAgICAgcmV0dXJuIHRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfTtcbn0pO1xuXG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3gtY21ha2VcIiwgXCJjbWFrZVwiKTtcblxufSk7XG4iLCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4vKipcbiAqIEF1dGhvcjogR2F1dGFtIE1laHRhXG4gKiBCcmFuY2hlZCBmcm9tIENvZGVNaXJyb3IncyBTY2hlbWUgbW9kZVxuICovXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTW9kZShcImNvYm9sXCIsIGZ1bmN0aW9uICgpIHtcbiAgdmFyIEJVSUxUSU4gPSBcImJ1aWx0aW5cIiwgQ09NTUVOVCA9IFwiY29tbWVudFwiLCBTVFJJTkcgPSBcInN0cmluZ1wiLFxuICAgICAgQVRPTSA9IFwiYXRvbVwiLCBOVU1CRVIgPSBcIm51bWJlclwiLCBLRVlXT1JEID0gXCJrZXl3b3JkXCIsIE1PRFRBRyA9IFwiaGVhZGVyXCIsXG4gICAgICBDT0JPTExJTkVOVU0gPSBcImRlZlwiLCBQRVJJT0QgPSBcImxpbmtcIjtcbiAgZnVuY3Rpb24gbWFrZUtleXdvcmRzKHN0cikge1xuICAgIHZhciBvYmogPSB7fSwgd29yZHMgPSBzdHIuc3BsaXQoXCIgXCIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyArK2kpIG9ialt3b3Jkc1tpXV0gPSB0cnVlO1xuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgdmFyIGF0b21zID0gbWFrZUtleXdvcmRzKFwiVFJVRSBGQUxTRSBaRVJPRVMgWkVST1MgWkVSTyBTUEFDRVMgU1BBQ0UgTE9XLVZBTFVFIExPVy1WQUxVRVMgXCIpO1xuICB2YXIga2V5d29yZHMgPSBtYWtlS2V5d29yZHMoXG4gICAgICBcIkFDQ0VQVCBBQ0NFU1MgQUNRVUlSRSBBREQgQUREUkVTUyBcIiArXG4gICAgICBcIkFEVkFOQ0lORyBBRlRFUiBBTElBUyBBTEwgQUxQSEFCRVQgXCIgK1xuICAgICAgXCJBTFBIQUJFVElDIEFMUEhBQkVUSUMtTE9XRVIgQUxQSEFCRVRJQy1VUFBFUiBBTFBIQU5VTUVSSUMgQUxQSEFOVU1FUklDLUVESVRFRCBcIiArXG4gICAgICBcIkFMU08gQUxURVIgQUxURVJOQVRFIEFORCBBTlkgXCIgK1xuICAgICAgXCJBUkUgQVJFQSBBUkVBUyBBUklUSE1FVElDIEFTQ0VORElORyBcIiArXG4gICAgICBcIkFTU0lHTiBBVCBBVFRSSUJVVEUgQVVUSE9SIEFVVE8gXCIgK1xuICAgICAgXCJBVVRPLVNLSVAgQVVUT01BVElDIEItQU5EIEItRVhPUiBCLUxFU1MgXCIgK1xuICAgICAgXCJCLU5PVCBCLU9SIEJBQ0tHUk9VTkQtQ09MT1IgQkFDS0dST1VORC1DT0xPVVIgQkVFUCBcIiArXG4gICAgICBcIkJFRk9SRSBCRUxMIEJJTkFSWSBCSVQgQklUUyBcIiArXG4gICAgICBcIkJMQU5LIEJMSU5LIEJMT0NLIEJPT0xFQU4gQk9UVE9NIFwiICtcbiAgICAgIFwiQlkgQ0FMTCBDQU5DRUwgQ0QgQ0YgXCIgK1xuICAgICAgXCJDSCBDSEFSQUNURVIgQ0hBUkFDVEVSUyBDTEFTUyBDTE9DSy1VTklUUyBcIiArXG4gICAgICBcIkNMT1NFIENPQk9MIENPREUgQ09ERS1TRVQgQ09MIFwiICtcbiAgICAgIFwiQ09MTEFUSU5HIENPTFVNTiBDT01NQSBDT01NSVQgQ09NTUlUTUVOVCBcIiArXG4gICAgICBcIkNPTU1PTiBDT01NVU5JQ0FUSU9OIENPTVAgQ09NUC0wIENPTVAtMSBcIiArXG4gICAgICBcIkNPTVAtMiBDT01QLTMgQ09NUC00IENPTVAtNSBDT01QLTYgXCIgK1xuICAgICAgXCJDT01QLTcgQ09NUC04IENPTVAtOSBDT01QVVRBVElPTkFMIENPTVBVVEFUSU9OQUwtMCBcIiArXG4gICAgICBcIkNPTVBVVEFUSU9OQUwtMSBDT01QVVRBVElPTkFMLTIgQ09NUFVUQVRJT05BTC0zIENPTVBVVEFUSU9OQUwtNCBDT01QVVRBVElPTkFMLTUgXCIgK1xuICAgICAgXCJDT01QVVRBVElPTkFMLTYgQ09NUFVUQVRJT05BTC03IENPTVBVVEFUSU9OQUwtOCBDT01QVVRBVElPTkFMLTkgQ09NUFVURSBcIiArXG4gICAgICBcIkNPTkZJR1VSQVRJT04gQ09OTkVDVCBDT05TT0xFIENPTlRBSU5FRCBDT05UQUlOUyBcIiArXG4gICAgICBcIkNPTlRFTlQgQ09OVElOVUUgQ09OVFJPTCBDT05UUk9MLUFSRUEgQ09OVFJPTFMgXCIgK1xuICAgICAgXCJDT05WRVJUSU5HIENPUFkgQ09SUiBDT1JSRVNQT05ESU5HIENPVU5UIFwiICtcbiAgICAgIFwiQ1JUIENSVC1VTkRFUiBDVVJSRU5DWSBDVVJSRU5UIENVUlNPUiBcIiArXG4gICAgICBcIkRBVEEgREFURSBEQVRFLUNPTVBJTEVEIERBVEUtV1JJVFRFTiBEQVkgXCIgK1xuICAgICAgXCJEQVktT0YtV0VFSyBEQiBEQi1BQ0NFU1MtQ09OVFJPTC1LRVkgREItREFUQS1OQU1FIERCLUVYQ0VQVElPTiBcIiArXG4gICAgICBcIkRCLUZPUk1BVC1OQU1FIERCLVJFQ09SRC1OQU1FIERCLVNFVC1OQU1FIERCLVNUQVRVUyBEQkNTIFwiICtcbiAgICAgIFwiREJDUy1FRElURUQgREUgREVCVUctQ09OVEVOVFMgREVCVUctSVRFTSBERUJVRy1MSU5FIFwiICtcbiAgICAgIFwiREVCVUctTkFNRSBERUJVRy1TVUItMSBERUJVRy1TVUItMiBERUJVRy1TVUItMyBERUJVR0dJTkcgXCIgK1xuICAgICAgXCJERUNJTUFMLVBPSU5UIERFQ0xBUkFUSVZFUyBERUZBVUxUIERFTEVURSBERUxJTUlURUQgXCIgK1xuICAgICAgXCJERUxJTUlURVIgREVQRU5ESU5HIERFU0NFTkRJTkcgREVTQ1JJQkVEIERFU1RJTkFUSU9OIFwiICtcbiAgICAgIFwiREVUQUlMIERJU0FCTEUgRElTQ09OTkVDVCBESVNQTEFZIERJU1BMQVktMSBcIiArXG4gICAgICBcIkRJU1BMQVktMiBESVNQTEFZLTMgRElTUExBWS00IERJU1BMQVktNSBESVNQTEFZLTYgXCIgK1xuICAgICAgXCJESVNQTEFZLTcgRElTUExBWS04IERJU1BMQVktOSBESVZJREUgRElWSVNJT04gXCIgK1xuICAgICAgXCJET1dOIERST1AgRFVQTElDQVRFIERVUExJQ0FURVMgRFlOQU1JQyBcIiArXG4gICAgICBcIkVCQ0RJQyBFR0kgRUpFQ1QgRUxTRSBFTUkgXCIgK1xuICAgICAgXCJFTVBUWSBFTVBUWS1DSEVDSyBFTkFCTEUgRU5EIEVORC4gRU5ELUFDQ0VQVCBFTkQtQUNDRVBULiBcIiArXG4gICAgICBcIkVORC1BREQgRU5ELUNBTEwgRU5ELUNPTVBVVEUgRU5ELURFTEVURSBFTkQtRElTUExBWSBcIiArXG4gICAgICBcIkVORC1ESVZJREUgRU5ELUVWQUxVQVRFIEVORC1JRiBFTkQtSU5WT0tFIEVORC1NVUxUSVBMWSBcIiArXG4gICAgICBcIkVORC1PRi1QQUdFIEVORC1QRVJGT1JNIEVORC1SRUFEIEVORC1SRUNFSVZFIEVORC1SRVRVUk4gXCIgK1xuICAgICAgXCJFTkQtUkVXUklURSBFTkQtU0VBUkNIIEVORC1TVEFSVCBFTkQtU1RSSU5HIEVORC1TVUJUUkFDVCBcIiArXG4gICAgICBcIkVORC1VTlNUUklORyBFTkQtV1JJVEUgRU5ELVhNTCBFTlRFUiBFTlRSWSBcIiArXG4gICAgICBcIkVOVklST05NRU5UIEVPUCBFUVVBTCBFUVVBTFMgRVJBU0UgXCIgK1xuICAgICAgXCJFUlJPUiBFU0kgRVZBTFVBVEUgRVZFUlkgRVhDRUVEUyBcIiArXG4gICAgICBcIkVYQ0VQVElPTiBFWENMVVNJVkUgRVhJVCBFWFRFTkQgRVhURVJOQUwgXCIgK1xuICAgICAgXCJFWFRFUk5BTExZLURFU0NSSUJFRC1LRVkgRkQgRkVUQ0ggRklMRSBGSUxFLUNPTlRST0wgXCIgK1xuICAgICAgXCJGSUxFLVNUUkVBTSBGSUxFUyBGSUxMRVIgRklOQUwgRklORCBcIiArXG4gICAgICBcIkZJTklTSCBGSVJTVCBGT09USU5HIEZPUiBGT1JFR1JPVU5ELUNPTE9SIFwiICtcbiAgICAgIFwiRk9SRUdST1VORC1DT0xPVVIgRk9STUFUIEZSRUUgRlJPTSBGVUxMIFwiICtcbiAgICAgIFwiRlVOQ1RJT04gR0VORVJBVEUgR0VUIEdJVklORyBHTE9CQUwgXCIgK1xuICAgICAgXCJHTyBHT0JBQ0sgR1JFQVRFUiBHUk9VUCBIRUFESU5HIFwiICtcbiAgICAgIFwiSElHSC1WQUxVRSBISUdILVZBTFVFUyBISUdITElHSFQgSS1PIEktTy1DT05UUk9MIFwiICtcbiAgICAgIFwiSUQgSURFTlRJRklDQVRJT04gSUYgSU4gSU5ERVggXCIgK1xuICAgICAgXCJJTkRFWC0xIElOREVYLTIgSU5ERVgtMyBJTkRFWC00IElOREVYLTUgXCIgK1xuICAgICAgXCJJTkRFWC02IElOREVYLTcgSU5ERVgtOCBJTkRFWC05IElOREVYRUQgXCIgK1xuICAgICAgXCJJTkRJQyBJTkRJQ0FURSBJTkRJQ0FUT1IgSU5ESUNBVE9SUyBJTklUSUFMIFwiICtcbiAgICAgIFwiSU5JVElBTElaRSBJTklUSUFURSBJTlBVVCBJTlBVVC1PVVRQVVQgSU5TUEVDVCBcIiArXG4gICAgICBcIklOU1RBTExBVElPTiBJTlRPIElOVkFMSUQgSU5WT0tFIElTIFwiICtcbiAgICAgIFwiSlVTVCBKVVNUSUZJRUQgS0FOSkkgS0VFUCBLRVkgXCIgK1xuICAgICAgXCJMQUJFTCBMQVNUIExEIExFQURJTkcgTEVGVCBcIiArXG4gICAgICBcIkxFRlQtSlVTVElGWSBMRU5HVEggTEVOR1RILUNIRUNLIExFU1MgTElCUkFSWSBcIiArXG4gICAgICBcIkxJS0UgTElNSVQgTElNSVRTIExJTkFHRSBMSU5BR0UtQ09VTlRFUiBcIiArXG4gICAgICBcIkxJTkUgTElORS1DT1VOVEVSIExJTkVTIExJTktBR0UgTE9DQUwtU1RPUkFHRSBcIiArXG4gICAgICBcIkxPQ0FMRSBMT0NBTExZIExPQ0sgXCIgK1xuICAgICAgXCJNRU1CRVIgTUVNT1JZIE1FUkdFIE1FU1NBR0UgTUVUQUNMQVNTIFwiICtcbiAgICAgIFwiTU9ERSBNT0RJRklFRCBNT0RJRlkgTU9EVUxFUyBNT1ZFIFwiICtcbiAgICAgIFwiTVVMVElQTEUgTVVMVElQTFkgTkFUSU9OQUwgTkFUSVZFIE5FR0FUSVZFIFwiICtcbiAgICAgIFwiTkVYVCBOTyBOTy1FQ0hPIE5PTkUgTk9UIFwiICtcbiAgICAgIFwiTlVMTCBOVUxMLUtFWS1NQVAgTlVMTC1NQVAgTlVMTFMgTlVNQkVSIFwiICtcbiAgICAgIFwiTlVNRVJJQyBOVU1FUklDLUVESVRFRCBPQkpFQ1QgT0JKRUNULUNPTVBVVEVSIE9DQ1VSUyBcIiArXG4gICAgICBcIk9GIE9GRiBPTUlUVEVEIE9OIE9OTFkgXCIgK1xuICAgICAgXCJPUEVOIE9QVElPTkFMIE9SIE9SREVSIE9SR0FOSVpBVElPTiBcIiArXG4gICAgICBcIk9USEVSIE9VVFBVVCBPVkVSRkxPVyBPV05FUiBQQUNLRUQtREVDSU1BTCBcIiArXG4gICAgICBcIlBBRERJTkcgUEFHRSBQQUdFLUNPVU5URVIgUEFSU0UgUEVSRk9STSBcIiArXG4gICAgICBcIlBGIFBIIFBJQyBQSUNUVVJFIFBMVVMgXCIgK1xuICAgICAgXCJQT0lOVEVSIFBPU0lUSU9OIFBPU0lUSVZFIFBSRUZJWCBQUkVTRU5UIFwiICtcbiAgICAgIFwiUFJJTlRJTkcgUFJJT1IgUFJPQ0VEVVJFIFBST0NFRFVSRS1QT0lOVEVSIFBST0NFRFVSRVMgXCIgK1xuICAgICAgXCJQUk9DRUVEIFBST0NFU1MgUFJPQ0VTU0lORyBQUk9HUkFNIFBST0dSQU0tSUQgXCIgK1xuICAgICAgXCJQUk9NUFQgUFJPVEVDVEVEIFBVUkdFIFFVRVVFIFFVT1RFIFwiICtcbiAgICAgIFwiUVVPVEVTIFJBTkRPTSBSRCBSRUFEIFJFQURZIFwiICtcbiAgICAgIFwiUkVBTE0gUkVDRUlWRSBSRUNPTk5FQ1QgUkVDT1JEIFJFQ09SRC1OQU1FIFwiICtcbiAgICAgIFwiUkVDT1JEUyBSRUNVUlNJVkUgUkVERUZJTkVTIFJFRUwgUkVGRVJFTkNFIFwiICtcbiAgICAgIFwiUkVGRVJFTkNFLU1PTklUT1IgUkVGRVJFTkNFUyBSRUxBVElPTiBSRUxBVElWRSBSRUxFQVNFIFwiICtcbiAgICAgIFwiUkVNQUlOREVSIFJFTU9WQUwgUkVOQU1FUyBSRVBFQVRFRCBSRVBMQUNFIFwiICtcbiAgICAgIFwiUkVQTEFDSU5HIFJFUE9SVCBSRVBPUlRJTkcgUkVQT1JUUyBSRVBPU0lUT1JZIFwiICtcbiAgICAgIFwiUkVRVUlSRUQgUkVSVU4gUkVTRVJWRSBSRVNFVCBSRVRBSU5JTkcgXCIgK1xuICAgICAgXCJSRVRSSUVWQUwgUkVUVVJOIFJFVFVSTi1DT0RFIFJFVFVSTklORyBSRVZFUlNFLVZJREVPIFwiICtcbiAgICAgIFwiUkVWRVJTRUQgUkVXSU5EIFJFV1JJVEUgUkYgUkggXCIgK1xuICAgICAgXCJSSUdIVCBSSUdIVC1KVVNUSUZZIFJPTExCQUNLIFJPTExJTkcgUk9VTkRFRCBcIiArXG4gICAgICBcIlJVTiBTQU1FIFNDUkVFTiBTRCBTRUFSQ0ggXCIgK1xuICAgICAgXCJTRUNUSU9OIFNFQ1VSRSBTRUNVUklUWSBTRUdNRU5UIFNFR01FTlQtTElNSVQgXCIgK1xuICAgICAgXCJTRUxFQ1QgU0VORCBTRU5URU5DRSBTRVBBUkFURSBTRVFVRU5DRSBcIiArXG4gICAgICBcIlNFUVVFTlRJQUwgU0VUIFNIQVJFRCBTSUdOIFNJWkUgXCIgK1xuICAgICAgXCJTS0lQMSBTS0lQMiBTS0lQMyBTT1JUIFNPUlQtTUVSR0UgXCIgK1xuICAgICAgXCJTT1JULVJFVFVSTiBTT1VSQ0UgU09VUkNFLUNPTVBVVEVSIFNQQUNFLUZJTEwgXCIgK1xuICAgICAgXCJTUEVDSUFMLU5BTUVTIFNUQU5EQVJEIFNUQU5EQVJELTEgU1RBTkRBUkQtMiBcIiArXG4gICAgICBcIlNUQVJUIFNUQVJUSU5HIFNUQVRVUyBTVE9QIFNUT1JFIFwiICtcbiAgICAgIFwiU1RSSU5HIFNVQi1RVUVVRS0xIFNVQi1RVUVVRS0yIFNVQi1RVUVVRS0zIFNVQi1TQ0hFTUEgXCIgK1xuICAgICAgXCJTVUJGSUxFIFNVQlNUSVRVVEUgU1VCVFJBQ1QgU1VNIFNVUFBSRVNTIFwiICtcbiAgICAgIFwiU1lNQk9MSUMgU1lOQyBTWU5DSFJPTklaRUQgU1lTSU4gU1lTT1VUIFwiICtcbiAgICAgIFwiVEFCTEUgVEFMTFlJTkcgVEFQRSBURU5BTlQgVEVSTUlOQUwgXCIgK1xuICAgICAgXCJURVJNSU5BVEUgVEVTVCBURVhUIFRIQU4gVEhFTiBcIiArXG4gICAgICBcIlRIUk9VR0ggVEhSVSBUSU1FIFRJTUVTIFRJVExFIFwiICtcbiAgICAgIFwiVE8gVE9QIFRSQUlMSU5HIFRSQUlMSU5HLVNJR04gVFJBTlNBQ1RJT04gXCIgK1xuICAgICAgXCJUWVBFIFRZUEVERUYgVU5ERVJMSU5FIFVORVFVQUwgVU5JVCBcIiArXG4gICAgICBcIlVOU1RSSU5HIFVOVElMIFVQIFVQREFURSBVUE9OIFwiICtcbiAgICAgIFwiVVNBR0UgVVNBR0UtTU9ERSBVU0UgVVNJTkcgVkFMSUQgXCIgK1xuICAgICAgXCJWQUxJREFURSBWQUxVRSBWQUxVRVMgVkFSWUlORyBWTFIgXCIgK1xuICAgICAgXCJXQUlUIFdIRU4gV0hFTi1DT01QSUxFRCBXSVRIIFdJVEhJTiBcIiArXG4gICAgICBcIldPUkRTIFdPUktJTkctU1RPUkFHRSBXUklURSBYTUwgWE1MLUNPREUgXCIgK1xuICAgICAgXCJYTUwtRVZFTlQgWE1MLU5URVhUIFhNTC1URVhUIFpFUk8gWkVSTy1GSUxMIFwiICk7XG5cbiAgdmFyIGJ1aWx0aW5zID0gbWFrZUtleXdvcmRzKFwiLSAqICoqIC8gKyA8IDw9ID0gPiA+PSBcIik7XG4gIHZhciB0ZXN0cyA9IHtcbiAgICBkaWdpdDogL1xcZC8sXG4gICAgZGlnaXRfb3JfY29sb246IC9bXFxkOl0vLFxuICAgIGhleDogL1swLTlhLWZdL2ksXG4gICAgc2lnbjogL1srLV0vLFxuICAgIGV4cG9uZW50OiAvZS9pLFxuICAgIGtleXdvcmRfY2hhcjogL1teXFxzXFwoXFxbXFw7XFwpXFxdXS8sXG4gICAgc3ltYm9sOiAvW1xcdyorXFwtXS9cbiAgfTtcbiAgZnVuY3Rpb24gaXNOdW1iZXIoY2gsIHN0cmVhbSl7XG4gICAgLy8gaGV4XG4gICAgaWYgKCBjaCA9PT0gJzAnICYmIHN0cmVhbS5lYXQoL3gvaSkgKSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUodGVzdHMuaGV4KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBsZWFkaW5nIHNpZ25cbiAgICBpZiAoICggY2ggPT0gJysnIHx8IGNoID09ICctJyApICYmICggdGVzdHMuZGlnaXQudGVzdChzdHJlYW0ucGVlaygpKSApICkge1xuICAgICAgc3RyZWFtLmVhdCh0ZXN0cy5zaWduKTtcbiAgICAgIGNoID0gc3RyZWFtLm5leHQoKTtcbiAgICB9XG4gICAgaWYgKCB0ZXN0cy5kaWdpdC50ZXN0KGNoKSApIHtcbiAgICAgIHN0cmVhbS5lYXQoY2gpO1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKHRlc3RzLmRpZ2l0KTtcbiAgICAgIGlmICggJy4nID09IHN0cmVhbS5wZWVrKCkpIHtcbiAgICAgICAgc3RyZWFtLmVhdCgnLicpO1xuICAgICAgICBzdHJlYW0uZWF0V2hpbGUodGVzdHMuZGlnaXQpO1xuICAgICAgfVxuICAgICAgaWYgKCBzdHJlYW0uZWF0KHRlc3RzLmV4cG9uZW50KSApIHtcbiAgICAgICAgc3RyZWFtLmVhdCh0ZXN0cy5zaWduKTtcbiAgICAgICAgc3RyZWFtLmVhdFdoaWxlKHRlc3RzLmRpZ2l0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdGFydFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbmRlbnRTdGFjazogbnVsbCxcbiAgICAgICAgaW5kZW50YXRpb246IDAsXG4gICAgICAgIG1vZGU6IGZhbHNlXG4gICAgICB9O1xuICAgIH0sXG4gICAgdG9rZW46IGZ1bmN0aW9uIChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAoc3RhdGUuaW5kZW50U3RhY2sgPT0gbnVsbCAmJiBzdHJlYW0uc29sKCkpIHtcbiAgICAgICAgLy8gdXBkYXRlIGluZGVudGF0aW9uLCBidXQgb25seSBpZiBpbmRlbnRTdGFjayBpcyBlbXB0eVxuICAgICAgICBzdGF0ZS5pbmRlbnRhdGlvbiA9IDYgOyAvL3N0cmVhbS5pbmRlbnRhdGlvbigpO1xuICAgICAgfVxuICAgICAgLy8gc2tpcCBzcGFjZXNcbiAgICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciByZXR1cm5UeXBlID0gbnVsbDtcbiAgICAgIHN3aXRjaChzdGF0ZS5tb2RlKXtcbiAgICAgIGNhc2UgXCJzdHJpbmdcIjogLy8gbXVsdGktbGluZSBzdHJpbmcgcGFyc2luZyBtb2RlXG4gICAgICAgIHZhciBuZXh0ID0gZmFsc2U7XG4gICAgICAgIHdoaWxlICgobmV4dCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAobmV4dCA9PSBcIlxcXCJcIiB8fCBuZXh0ID09IFwiXFwnXCIpIHtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm5UeXBlID0gU1RSSU5HOyAvLyBjb250aW51ZSBvbiBpbiBzdHJpbmcgbW9kZVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IC8vIGRlZmF1bHQgcGFyc2luZyBtb2RlXG4gICAgICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIHZhciBjb2wgPSBzdHJlYW0uY29sdW1uKCk7XG4gICAgICAgIGlmIChjb2wgPj0gMCAmJiBjb2wgPD0gNSkge1xuICAgICAgICAgIHJldHVyblR5cGUgPSBDT0JPTExJTkVOVU07XG4gICAgICAgIH0gZWxzZSBpZiAoY29sID49IDcyICYmIGNvbCA8PSA3OSkge1xuICAgICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgICByZXR1cm5UeXBlID0gTU9EVEFHO1xuICAgICAgICB9IGVsc2UgaWYgKGNoID09IFwiKlwiICYmIGNvbCA9PSA2KSB7IC8vIGNvbW1lbnRcbiAgICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7IC8vIHJlc3Qgb2YgdGhlIGxpbmUgaXMgYSBjb21tZW50XG4gICAgICAgICAgcmV0dXJuVHlwZSA9IENPTU1FTlQ7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCJcXFwiXCIgfHwgY2ggPT0gXCJcXCdcIikge1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBcInN0cmluZ1wiO1xuICAgICAgICAgIHJldHVyblR5cGUgPSBTVFJJTkc7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCInXCIgJiYgISggdGVzdHMuZGlnaXRfb3JfY29sb24udGVzdChzdHJlYW0ucGVlaygpKSApKSB7XG4gICAgICAgICAgcmV0dXJuVHlwZSA9IEFUT007XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCIuXCIpIHtcbiAgICAgICAgICByZXR1cm5UeXBlID0gUEVSSU9EO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGNoLHN0cmVhbSkpe1xuICAgICAgICAgIHJldHVyblR5cGUgPSBOVU1CRVI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHN0cmVhbS5jdXJyZW50KCkubWF0Y2godGVzdHMuc3ltYm9sKSkge1xuICAgICAgICAgICAgd2hpbGUgKGNvbCA8IDcxKSB7XG4gICAgICAgICAgICAgIGlmIChzdHJlYW0uZWF0KHRlc3RzLnN5bWJvbCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbCsrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChrZXl3b3JkcyAmJiBrZXl3b3Jkcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShzdHJlYW0uY3VycmVudCgpLnRvVXBwZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICByZXR1cm5UeXBlID0gS0VZV09SRDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGJ1aWx0aW5zICYmIGJ1aWx0aW5zLnByb3BlcnR5SXNFbnVtZXJhYmxlKHN0cmVhbS5jdXJyZW50KCkudG9VcHBlckNhc2UoKSkpIHtcbiAgICAgICAgICAgIHJldHVyblR5cGUgPSBCVUlMVElOO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYXRvbXMgJiYgYXRvbXMucHJvcGVydHlJc0VudW1lcmFibGUoc3RyZWFtLmN1cnJlbnQoKS50b1VwcGVyQ2FzZSgpKSkge1xuICAgICAgICAgICAgcmV0dXJuVHlwZSA9IEFUT007XG4gICAgICAgICAgfSBlbHNlIHJldHVyblR5cGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0dXJuVHlwZTtcbiAgICB9LFxuICAgIGluZGVudDogZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICBpZiAoc3RhdGUuaW5kZW50U3RhY2sgPT0gbnVsbCkgcmV0dXJuIHN0YXRlLmluZGVudGF0aW9uO1xuICAgICAgcmV0dXJuIHN0YXRlLmluZGVudFN0YWNrLmluZGVudDtcbiAgICB9XG4gIH07XG59KTtcblxuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LWNvYm9sXCIsIFwiY29ib2xcIik7XG5cbn0pO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuLyoqXG4gKiBMaW5rIHRvIHRoZSBwcm9qZWN0J3MgR2l0SHViIHBhZ2U6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vcGlja2hhcmR0L2NvZmZlZXNjcmlwdC1jb2RlbWlycm9yLW1vZGVcbiAqL1xuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcblwidXNlIHN0cmljdFwiO1xuXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoXCJjb2ZmZWVzY3JpcHRcIiwgZnVuY3Rpb24oY29uZiwgcGFyc2VyQ29uZikge1xuICB2YXIgRVJST1JDTEFTUyA9IFwiZXJyb3JcIjtcblxuICBmdW5jdGlvbiB3b3JkUmVnZXhwKHdvcmRzKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoXCJeKChcIiArIHdvcmRzLmpvaW4oXCIpfChcIikgKyBcIikpXFxcXGJcIik7XG4gIH1cblxuICB2YXIgb3BlcmF0b3JzID0gL14oPzotPnw9PnxcXCtbKz1dP3wtW1xcLT1dP3xcXCpbXFwqPV0/fFxcL1tcXC89XT98Wz0hXT18PFs+PF0/PT98Pj4/PT98JT0/fCY9P3xcXHw9P3xcXF49P3xcXH58IXxcXD98KG9yfGFuZHxcXHxcXHx8JiZ8XFw/KT0pLztcbiAgdmFyIGRlbGltaXRlcnMgPSAvXig/OlsoKVxcW1xcXXt9LDpgPTtdfFxcLlxcLj9cXC4/KS87XG4gIHZhciBpZGVudGlmaWVycyA9IC9eW19BLVphLXokXVtfQS1aYS16JDAtOV0qLztcbiAgdmFyIGF0UHJvcCA9IC9eQFtfQS1aYS16JF1bX0EtWmEteiQwLTldKi87XG5cbiAgdmFyIHdvcmRPcGVyYXRvcnMgPSB3b3JkUmVnZXhwKFtcImFuZFwiLCBcIm9yXCIsIFwibm90XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpc1wiLCBcImlzbnRcIiwgXCJpblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaW5zdGFuY2VvZlwiLCBcInR5cGVvZlwiXSk7XG4gIHZhciBpbmRlbnRLZXl3b3JkcyA9IFtcImZvclwiLCBcIndoaWxlXCIsIFwibG9vcFwiLCBcImlmXCIsIFwidW5sZXNzXCIsIFwiZWxzZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJzd2l0Y2hcIiwgXCJ0cnlcIiwgXCJjYXRjaFwiLCBcImZpbmFsbHlcIiwgXCJjbGFzc1wiXTtcbiAgdmFyIGNvbW1vbktleXdvcmRzID0gW1wiYnJlYWtcIiwgXCJieVwiLCBcImNvbnRpbnVlXCIsIFwiZGVidWdnZXJcIiwgXCJkZWxldGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZG9cIiwgXCJpblwiLCBcIm9mXCIsIFwibmV3XCIsIFwicmV0dXJuXCIsIFwidGhlblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0aGlzXCIsIFwiQFwiLCBcInRocm93XCIsIFwid2hlblwiLCBcInVudGlsXCIsIFwiZXh0ZW5kc1wiXTtcblxuICB2YXIga2V5d29yZHMgPSB3b3JkUmVnZXhwKGluZGVudEtleXdvcmRzLmNvbmNhdChjb21tb25LZXl3b3JkcykpO1xuXG4gIGluZGVudEtleXdvcmRzID0gd29yZFJlZ2V4cChpbmRlbnRLZXl3b3Jkcyk7XG5cblxuICB2YXIgc3RyaW5nUHJlZml4ZXMgPSAvXignezN9fFxcXCJ7M318WydcXFwiXSkvO1xuICB2YXIgcmVnZXhQcmVmaXhlcyA9IC9eKFxcL3szfXxcXC8pLztcbiAgdmFyIGNvbW1vbkNvbnN0YW50cyA9IFtcIkluZmluaXR5XCIsIFwiTmFOXCIsIFwidW5kZWZpbmVkXCIsIFwibnVsbFwiLCBcInRydWVcIiwgXCJmYWxzZVwiLCBcIm9uXCIsIFwib2ZmXCIsIFwieWVzXCIsIFwibm9cIl07XG4gIHZhciBjb25zdGFudHMgPSB3b3JkUmVnZXhwKGNvbW1vbkNvbnN0YW50cyk7XG5cbiAgLy8gVG9rZW5pemVyc1xuICBmdW5jdGlvbiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuICAgIC8vIEhhbmRsZSBzY29wZSBjaGFuZ2VzXG4gICAgaWYgKHN0cmVhbS5zb2woKSkge1xuICAgICAgaWYgKHN0YXRlLnNjb3BlLmFsaWduID09PSBudWxsKSBzdGF0ZS5zY29wZS5hbGlnbiA9IGZhbHNlO1xuICAgICAgdmFyIHNjb3BlT2Zmc2V0ID0gc3RhdGUuc2NvcGUub2Zmc2V0O1xuICAgICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSB7XG4gICAgICAgIHZhciBsaW5lT2Zmc2V0ID0gc3RyZWFtLmluZGVudGF0aW9uKCk7XG4gICAgICAgIGlmIChsaW5lT2Zmc2V0ID4gc2NvcGVPZmZzZXQgJiYgc3RhdGUuc2NvcGUudHlwZSA9PSBcImNvZmZlZVwiKSB7XG4gICAgICAgICAgcmV0dXJuIFwiaW5kZW50XCI7XG4gICAgICAgIH0gZWxzZSBpZiAobGluZU9mZnNldCA8IHNjb3BlT2Zmc2V0KSB7XG4gICAgICAgICAgcmV0dXJuIFwiZGVkZW50XCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc2NvcGVPZmZzZXQgPiAwKSB7XG4gICAgICAgICAgZGVkZW50KHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGNoID0gc3RyZWFtLnBlZWsoKTtcblxuICAgIC8vIEhhbmRsZSBkb2NjbyB0aXRsZSBjb21tZW50IChzaW5nbGUgbGluZSlcbiAgICBpZiAoc3RyZWFtLm1hdGNoKFwiIyMjI1wiKSkge1xuICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBtdWx0aSBsaW5lIGNvbW1lbnRzXG4gICAgaWYgKHN0cmVhbS5tYXRjaChcIiMjI1wiKSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSBsb25nQ29tbWVudDtcbiAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICAvLyBTaW5nbGUgbGluZSBjb21tZW50XG4gICAgaWYgKGNoID09PSBcIiNcIikge1xuICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBudW1iZXIgbGl0ZXJhbHNcbiAgICBpZiAoc3RyZWFtLm1hdGNoKC9eLT9bMC05XFwuXS8sIGZhbHNlKSkge1xuICAgICAgdmFyIGZsb2F0TGl0ZXJhbCA9IGZhbHNlO1xuICAgICAgLy8gRmxvYXRzXG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eLT9cXGQqXFwuXFxkKyhlW1xcK1xcLV0/XFxkKyk/L2kpKSB7XG4gICAgICAgIGZsb2F0TGl0ZXJhbCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eLT9cXGQrXFwuXFxkKi8pKSB7XG4gICAgICAgIGZsb2F0TGl0ZXJhbCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eLT9cXC5cXGQrLykpIHtcbiAgICAgICAgZmxvYXRMaXRlcmFsID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZsb2F0TGl0ZXJhbCkge1xuICAgICAgICAvLyBwcmV2ZW50IGZyb20gZ2V0dGluZyBleHRyYSAuIG9uIDEuLlxuICAgICAgICBpZiAoc3RyZWFtLnBlZWsoKSA9PSBcIi5cIil7XG4gICAgICAgICAgc3RyZWFtLmJhY2tVcCgxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICAgIH1cbiAgICAgIC8vIEludGVnZXJzXG4gICAgICB2YXIgaW50TGl0ZXJhbCA9IGZhbHNlO1xuICAgICAgLy8gSGV4XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eLT8weFswLTlhLWZdKy9pKSkge1xuICAgICAgICBpbnRMaXRlcmFsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vIERlY2ltYWxcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goL14tP1sxLTldXFxkKihlW1xcK1xcLV0/XFxkKyk/LykpIHtcbiAgICAgICAgaW50TGl0ZXJhbCA9IHRydWU7XG4gICAgICB9XG4gICAgICAvLyBaZXJvIGJ5IGl0c2VsZiB3aXRoIG5vIG90aGVyIHBpZWNlIG9mIG51bWJlci5cbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goL14tPzAoPyFbXFxkeF0pL2kpKSB7XG4gICAgICAgIGludExpdGVyYWwgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGludExpdGVyYWwpIHtcbiAgICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHN0cmluZ3NcbiAgICBpZiAoc3RyZWFtLm1hdGNoKHN0cmluZ1ByZWZpeGVzKSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkZhY3Rvcnkoc3RyZWFtLmN1cnJlbnQoKSwgZmFsc2UsIFwic3RyaW5nXCIpO1xuICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgICAvLyBIYW5kbGUgcmVnZXggbGl0ZXJhbHNcbiAgICBpZiAoc3RyZWFtLm1hdGNoKHJlZ2V4UHJlZml4ZXMpKSB7XG4gICAgICBpZiAoc3RyZWFtLmN1cnJlbnQoKSAhPSBcIi9cIiB8fCBzdHJlYW0ubWF0Y2goL14uKlxcLy8sIGZhbHNlKSkgeyAvLyBwcmV2ZW50IGhpZ2hsaWdodCBvZiBkaXZpc2lvblxuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuRmFjdG9yeShzdHJlYW0uY3VycmVudCgpLCB0cnVlLCBcInN0cmluZy0yXCIpO1xuICAgICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJlYW0uYmFja1VwKDEpO1xuICAgICAgfVxuICAgIH1cblxuXG5cbiAgICAvLyBIYW5kbGUgb3BlcmF0b3JzIGFuZCBkZWxpbWl0ZXJzXG4gICAgaWYgKHN0cmVhbS5tYXRjaChvcGVyYXRvcnMpIHx8IHN0cmVhbS5tYXRjaCh3b3JkT3BlcmF0b3JzKSkge1xuICAgICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgICB9XG4gICAgaWYgKHN0cmVhbS5tYXRjaChkZWxpbWl0ZXJzKSkge1xuICAgICAgcmV0dXJuIFwicHVuY3R1YXRpb25cIjtcbiAgICB9XG5cbiAgICBpZiAoc3RyZWFtLm1hdGNoKGNvbnN0YW50cykpIHtcbiAgICAgIHJldHVybiBcImF0b21cIjtcbiAgICB9XG5cbiAgICBpZiAoc3RyZWFtLm1hdGNoKGF0UHJvcCkgfHwgc3RhdGUucHJvcCAmJiBzdHJlYW0ubWF0Y2goaWRlbnRpZmllcnMpKSB7XG4gICAgICByZXR1cm4gXCJwcm9wZXJ0eVwiO1xuICAgIH1cblxuICAgIGlmIChzdHJlYW0ubWF0Y2goa2V5d29yZHMpKSB7XG4gICAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gICAgfVxuXG4gICAgaWYgKHN0cmVhbS5tYXRjaChpZGVudGlmaWVycykpIHtcbiAgICAgIHJldHVybiBcInZhcmlhYmxlXCI7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIG5vbi1kZXRlY3RlZCBpdGVtc1xuICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgcmV0dXJuIEVSUk9SQ0xBU1M7XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlbkZhY3RvcnkoZGVsaW1pdGVyLCBzaW5nbGVsaW5lLCBvdXRjbGFzcykge1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1teJ1wiXFwvXFxcXF0vKTtcbiAgICAgICAgaWYgKHN0cmVhbS5lYXQoXCJcXFxcXCIpKSB7XG4gICAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgICBpZiAoc2luZ2xlbGluZSAmJiBzdHJlYW0uZW9sKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBvdXRjbGFzcztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKGRlbGltaXRlcikpIHtcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgICAgICByZXR1cm4gb3V0Y2xhc3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyZWFtLmVhdCgvWydcIlxcL10vKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNpbmdsZWxpbmUpIHtcbiAgICAgICAgaWYgKHBhcnNlckNvbmYuc2luZ2xlTGluZVN0cmluZ0Vycm9ycykge1xuICAgICAgICAgIG91dGNsYXNzID0gRVJST1JDTEFTUztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG91dGNsYXNzO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBsb25nQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gICAgd2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW14jXS8pO1xuICAgICAgaWYgKHN0cmVhbS5tYXRjaChcIiMjI1wiKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoXCIjXCIpO1xuICAgIH1cbiAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gIH1cblxuICBmdW5jdGlvbiBpbmRlbnQoc3RyZWFtLCBzdGF0ZSwgdHlwZSkge1xuICAgIHR5cGUgPSB0eXBlIHx8IFwiY29mZmVlXCI7XG4gICAgdmFyIG9mZnNldCA9IDAsIGFsaWduID0gZmFsc2UsIGFsaWduT2Zmc2V0ID0gbnVsbDtcbiAgICBmb3IgKHZhciBzY29wZSA9IHN0YXRlLnNjb3BlOyBzY29wZTsgc2NvcGUgPSBzY29wZS5wcmV2KSB7XG4gICAgICBpZiAoc2NvcGUudHlwZSA9PT0gXCJjb2ZmZWVcIiB8fCBzY29wZS50eXBlID09IFwifVwiKSB7XG4gICAgICAgIG9mZnNldCA9IHNjb3BlLm9mZnNldCArIGNvbmYuaW5kZW50VW5pdDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlICE9PSBcImNvZmZlZVwiKSB7XG4gICAgICBhbGlnbiA9IG51bGw7XG4gICAgICBhbGlnbk9mZnNldCA9IHN0cmVhbS5jb2x1bW4oKSArIHN0cmVhbS5jdXJyZW50KCkubGVuZ3RoO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuc2NvcGUuYWxpZ24pIHtcbiAgICAgIHN0YXRlLnNjb3BlLmFsaWduID0gZmFsc2U7XG4gICAgfVxuICAgIHN0YXRlLnNjb3BlID0ge1xuICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgcHJldjogc3RhdGUuc2NvcGUsXG4gICAgICBhbGlnbjogYWxpZ24sXG4gICAgICBhbGlnbk9mZnNldDogYWxpZ25PZmZzZXRcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZGVkZW50KHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoIXN0YXRlLnNjb3BlLnByZXYpIHJldHVybjtcbiAgICBpZiAoc3RhdGUuc2NvcGUudHlwZSA9PT0gXCJjb2ZmZWVcIikge1xuICAgICAgdmFyIF9pbmRlbnQgPSBzdHJlYW0uaW5kZW50YXRpb24oKTtcbiAgICAgIHZhciBtYXRjaGVkID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBzY29wZSA9IHN0YXRlLnNjb3BlOyBzY29wZTsgc2NvcGUgPSBzY29wZS5wcmV2KSB7XG4gICAgICAgIGlmIChfaW5kZW50ID09PSBzY29wZS5vZmZzZXQpIHtcbiAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFtYXRjaGVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgd2hpbGUgKHN0YXRlLnNjb3BlLnByZXYgJiYgc3RhdGUuc2NvcGUub2Zmc2V0ICE9PSBfaW5kZW50KSB7XG4gICAgICAgIHN0YXRlLnNjb3BlID0gc3RhdGUuc2NvcGUucHJldjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuc2NvcGUgPSBzdGF0ZS5zY29wZS5wcmV2O1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuTGV4ZXIoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBzdHlsZSA9IHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIHZhciBjdXJyZW50ID0gc3RyZWFtLmN1cnJlbnQoKTtcblxuICAgIC8vIEhhbmRsZSBzY29wZSBjaGFuZ2VzLlxuICAgIGlmIChjdXJyZW50ID09PSBcInJldHVyblwiKSB7XG4gICAgICBzdGF0ZS5kZWRlbnQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoKChjdXJyZW50ID09PSBcIi0+XCIgfHwgY3VycmVudCA9PT0gXCI9PlwiKSAmJiBzdHJlYW0uZW9sKCkpXG4gICAgICAgIHx8IHN0eWxlID09PSBcImluZGVudFwiKSB7XG4gICAgICBpbmRlbnQoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICAgIHZhciBkZWxpbWl0ZXJfaW5kZXggPSBcIlsoe1wiLmluZGV4T2YoY3VycmVudCk7XG4gICAgaWYgKGRlbGltaXRlcl9pbmRleCAhPT0gLTEpIHtcbiAgICAgIGluZGVudChzdHJlYW0sIHN0YXRlLCBcIl0pfVwiLnNsaWNlKGRlbGltaXRlcl9pbmRleCwgZGVsaW1pdGVyX2luZGV4KzEpKTtcbiAgICB9XG4gICAgaWYgKGluZGVudEtleXdvcmRzLmV4ZWMoY3VycmVudCkpe1xuICAgICAgaW5kZW50KHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgICBpZiAoY3VycmVudCA9PSBcInRoZW5cIil7XG4gICAgICBkZWRlbnQoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG5cbiAgICBpZiAoc3R5bGUgPT09IFwiZGVkZW50XCIpIHtcbiAgICAgIGlmIChkZWRlbnQoc3RyZWFtLCBzdGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIEVSUk9SQ0xBU1M7XG4gICAgICB9XG4gICAgfVxuICAgIGRlbGltaXRlcl9pbmRleCA9IFwiXSl9XCIuaW5kZXhPZihjdXJyZW50KTtcbiAgICBpZiAoZGVsaW1pdGVyX2luZGV4ICE9PSAtMSkge1xuICAgICAgd2hpbGUgKHN0YXRlLnNjb3BlLnR5cGUgPT0gXCJjb2ZmZWVcIiAmJiBzdGF0ZS5zY29wZS5wcmV2KVxuICAgICAgICBzdGF0ZS5zY29wZSA9IHN0YXRlLnNjb3BlLnByZXY7XG4gICAgICBpZiAoc3RhdGUuc2NvcGUudHlwZSA9PSBjdXJyZW50KVxuICAgICAgICBzdGF0ZS5zY29wZSA9IHN0YXRlLnNjb3BlLnByZXY7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5kZWRlbnQgJiYgc3RyZWFtLmVvbCgpKSB7XG4gICAgICBpZiAoc3RhdGUuc2NvcGUudHlwZSA9PSBcImNvZmZlZVwiICYmIHN0YXRlLnNjb3BlLnByZXYpXG4gICAgICAgIHN0YXRlLnNjb3BlID0gc3RhdGUuc2NvcGUucHJldjtcbiAgICAgIHN0YXRlLmRlZGVudCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuXG4gIHZhciBleHRlcm5hbCA9IHtcbiAgICBzdGFydFN0YXRlOiBmdW5jdGlvbihiYXNlY29sdW1uKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b2tlbml6ZTogdG9rZW5CYXNlLFxuICAgICAgICBzY29wZToge29mZnNldDpiYXNlY29sdW1uIHx8IDAsIHR5cGU6XCJjb2ZmZWVcIiwgcHJldjogbnVsbCwgYWxpZ246IGZhbHNlfSxcbiAgICAgICAgcHJvcDogZmFsc2UsXG4gICAgICAgIGRlZGVudDogMFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBmaWxsQWxpZ24gPSBzdGF0ZS5zY29wZS5hbGlnbiA9PT0gbnVsbCAmJiBzdGF0ZS5zY29wZTtcbiAgICAgIGlmIChmaWxsQWxpZ24gJiYgc3RyZWFtLnNvbCgpKSBmaWxsQWxpZ24uYWxpZ24gPSBmYWxzZTtcblxuICAgICAgdmFyIHN0eWxlID0gdG9rZW5MZXhlcihzdHJlYW0sIHN0YXRlKTtcbiAgICAgIGlmIChzdHlsZSAmJiBzdHlsZSAhPSBcImNvbW1lbnRcIikge1xuICAgICAgICBpZiAoZmlsbEFsaWduKSBmaWxsQWxpZ24uYWxpZ24gPSB0cnVlO1xuICAgICAgICBzdGF0ZS5wcm9wID0gc3R5bGUgPT0gXCJwdW5jdHVhdGlvblwiICYmIHN0cmVhbS5jdXJyZW50KCkgPT0gXCIuXCJcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH0sXG5cbiAgICBpbmRlbnQ6IGZ1bmN0aW9uKHN0YXRlLCB0ZXh0KSB7XG4gICAgICBpZiAoc3RhdGUudG9rZW5pemUgIT0gdG9rZW5CYXNlKSByZXR1cm4gMDtcbiAgICAgIHZhciBzY29wZSA9IHN0YXRlLnNjb3BlO1xuICAgICAgdmFyIGNsb3NlciA9IHRleHQgJiYgXCJdKX1cIi5pbmRleE9mKHRleHQuY2hhckF0KDApKSA+IC0xO1xuICAgICAgaWYgKGNsb3Nlcikgd2hpbGUgKHNjb3BlLnR5cGUgPT0gXCJjb2ZmZWVcIiAmJiBzY29wZS5wcmV2KSBzY29wZSA9IHNjb3BlLnByZXY7XG4gICAgICB2YXIgY2xvc2VzID0gY2xvc2VyICYmIHNjb3BlLnR5cGUgPT09IHRleHQuY2hhckF0KDApO1xuICAgICAgaWYgKHNjb3BlLmFsaWduKVxuICAgICAgICByZXR1cm4gc2NvcGUuYWxpZ25PZmZzZXQgLSAoY2xvc2VzID8gMSA6IDApO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gKGNsb3NlcyA/IHNjb3BlLnByZXYgOiBzY29wZSkub2Zmc2V0O1xuICAgIH0sXG5cbiAgICBsaW5lQ29tbWVudDogXCIjXCIsXG4gICAgZm9sZDogXCJpbmRlbnRcIlxuICB9O1xuICByZXR1cm4gZXh0ZXJuYWw7XG59KTtcblxuLy8gSUFOQSByZWdpc3RlcmVkIG1lZGlhIHR5cGVcbi8vIGh0dHBzOi8vd3d3LmlhbmEub3JnL2Fzc2lnbm1lbnRzL21lZGlhLXR5cGVzL1xuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwiYXBwbGljYXRpb24vdm5kLmNvZmZlZXNjcmlwdFwiLCBcImNvZmZlZXNjcmlwdFwiKTtcblxuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LWNvZmZlZXNjcmlwdFwiLCBcImNvZmZlZXNjcmlwdFwiKTtcbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQvY29mZmVlc2NyaXB0XCIsIFwiY29mZmVlc2NyaXB0XCIpO1xuXG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwiY29tbW9ubGlzcFwiLCBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHZhciBzcGVjaWFsRm9ybSA9IC9eKGJsb2NrfGxldCp8cmV0dXJuLWZyb218Y2F0Y2h8bG9hZC10aW1lLXZhbHVlfHNldHF8ZXZhbC13aGVufGxvY2FsbHl8c3ltYm9sLW1hY3JvbGV0fGZsZXR8bWFjcm9sZXR8dGFnYm9keXxmdW5jdGlvbnxtdWx0aXBsZS12YWx1ZS1jYWxsfHRoZXxnb3xtdWx0aXBsZS12YWx1ZS1wcm9nMXx0aHJvd3xpZnxwcm9nbnx1bndpbmQtcHJvdGVjdHxsYWJlbHN8cHJvZ3Z8bGV0fHF1b3RlKSQvO1xuICB2YXIgYXNzdW1lQm9keSA9IC9ed2l0aHxeZGVmfF5kb3xecHJvZ3xjYXNlJHxeY29uZCR8YmluZCR8d2hlbiR8dW5sZXNzJC87XG4gIHZhciBudW1MaXRlcmFsID0gL14oPzpbK1xcLV0/KD86XFxkK3xcXGQqXFwuXFxkKykoPzpbZWZkXVsrXFwtXT9cXGQrKT98WytcXC1dP1xcZCsoPzpcXC9bK1xcLV0/XFxkKyk/fCNiWytcXC1dP1swMV0rfCNvWytcXC1dP1swLTddK3wjeFsrXFwtXT9bXFxkYS1mXSspLztcbiAgdmFyIHN5bWJvbCA9IC9bXlxccydgLEAoKVxcW1xcXVwiO10vO1xuICB2YXIgdHlwZTtcblxuICBmdW5jdGlvbiByZWFkU3ltKHN0cmVhbSkge1xuICAgIHZhciBjaDtcbiAgICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgICBpZiAoY2ggPT0gXCJcXFxcXCIpIHN0cmVhbS5uZXh0KCk7XG4gICAgICBlbHNlIGlmICghc3ltYm9sLnRlc3QoY2gpKSB7IHN0cmVhbS5iYWNrVXAoMSk7IGJyZWFrOyB9XG4gICAgfVxuICAgIHJldHVybiBzdHJlYW0uY3VycmVudCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gYmFzZShzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSB7dHlwZSA9IFwid3NcIjsgcmV0dXJuIG51bGw7fVxuICAgIGlmIChzdHJlYW0ubWF0Y2gobnVtTGl0ZXJhbCkpIHJldHVybiBcIm51bWJlclwiO1xuICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG4gICAgaWYgKGNoID09IFwiXFxcXFwiKSBjaCA9IHN0cmVhbS5uZXh0KCk7XG5cbiAgICBpZiAoY2ggPT0gJ1wiJykgcmV0dXJuIChzdGF0ZS50b2tlbml6ZSA9IGluU3RyaW5nKShzdHJlYW0sIHN0YXRlKTtcbiAgICBlbHNlIGlmIChjaCA9PSBcIihcIikgeyB0eXBlID0gXCJvcGVuXCI7IHJldHVybiBcImJyYWNrZXRcIjsgfVxuICAgIGVsc2UgaWYgKGNoID09IFwiKVwiIHx8IGNoID09IFwiXVwiKSB7IHR5cGUgPSBcImNsb3NlXCI7IHJldHVybiBcImJyYWNrZXRcIjsgfVxuICAgIGVsc2UgaWYgKGNoID09IFwiO1wiKSB7IHN0cmVhbS5za2lwVG9FbmQoKTsgdHlwZSA9IFwid3NcIjsgcmV0dXJuIFwiY29tbWVudFwiOyB9XG4gICAgZWxzZSBpZiAoL1snYCxAXS8udGVzdChjaCkpIHJldHVybiBudWxsO1xuICAgIGVsc2UgaWYgKGNoID09IFwifFwiKSB7XG4gICAgICBpZiAoc3RyZWFtLnNraXBUbyhcInxcIikpIHsgc3RyZWFtLm5leHQoKTsgcmV0dXJuIFwic3ltYm9sXCI7IH1cbiAgICAgIGVsc2UgeyBzdHJlYW0uc2tpcFRvRW5kKCk7IHJldHVybiBcImVycm9yXCI7IH1cbiAgICB9IGVsc2UgaWYgKGNoID09IFwiI1wiKSB7XG4gICAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICAgICAgaWYgKGNoID09IFwiKFwiKSB7IHR5cGUgPSBcIm9wZW5cIjsgcmV0dXJuIFwiYnJhY2tldFwiOyB9XG4gICAgICBlbHNlIGlmICgvWytcXC09XFwuJ10vLnRlc3QoY2gpKSByZXR1cm4gbnVsbDtcbiAgICAgIGVsc2UgaWYgKC9cXGQvLnRlc3QoY2gpICYmIHN0cmVhbS5tYXRjaCgvXlxcZCojLykpIHJldHVybiBudWxsO1xuICAgICAgZWxzZSBpZiAoY2ggPT0gXCJ8XCIpIHJldHVybiAoc3RhdGUudG9rZW5pemUgPSBpbkNvbW1lbnQpKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgZWxzZSBpZiAoY2ggPT0gXCI6XCIpIHsgcmVhZFN5bShzdHJlYW0pOyByZXR1cm4gXCJtZXRhXCI7IH1cbiAgICAgIGVsc2UgaWYgKGNoID09IFwiXFxcXFwiKSB7IHN0cmVhbS5uZXh0KCk7IHJlYWRTeW0oc3RyZWFtKTsgcmV0dXJuIFwic3RyaW5nLTJcIiB9XG4gICAgICBlbHNlIHJldHVybiBcImVycm9yXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBuYW1lID0gcmVhZFN5bShzdHJlYW0pO1xuICAgICAgaWYgKG5hbWUgPT0gXCIuXCIpIHJldHVybiBudWxsO1xuICAgICAgdHlwZSA9IFwic3ltYm9sXCI7XG4gICAgICBpZiAobmFtZSA9PSBcIm5pbFwiIHx8IG5hbWUgPT0gXCJ0XCIgfHwgbmFtZS5jaGFyQXQoMCkgPT0gXCI6XCIpIHJldHVybiBcImF0b21cIjtcbiAgICAgIGlmIChzdGF0ZS5sYXN0VHlwZSA9PSBcIm9wZW5cIiAmJiAoc3BlY2lhbEZvcm0udGVzdChuYW1lKSB8fCBhc3N1bWVCb2R5LnRlc3QobmFtZSkpKSByZXR1cm4gXCJrZXl3b3JkXCI7XG4gICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT0gXCImXCIpIHJldHVybiBcInZhcmlhYmxlLTJcIjtcbiAgICAgIHJldHVybiBcInZhcmlhYmxlXCI7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5TdHJpbmcoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBlc2NhcGVkID0gZmFsc2UsIG5leHQ7XG4gICAgd2hpbGUgKG5leHQgPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgICBpZiAobmV4dCA9PSAnXCInICYmICFlc2NhcGVkKSB7IHN0YXRlLnRva2VuaXplID0gYmFzZTsgYnJlYWs7IH1cbiAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZCAmJiBuZXh0ID09IFwiXFxcXFwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIG5leHQsIGxhc3Q7XG4gICAgd2hpbGUgKG5leHQgPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgICBpZiAobmV4dCA9PSBcIiNcIiAmJiBsYXN0ID09IFwifFwiKSB7IHN0YXRlLnRva2VuaXplID0gYmFzZTsgYnJlYWs7IH1cbiAgICAgIGxhc3QgPSBuZXh0O1xuICAgIH1cbiAgICB0eXBlID0gXCJ3c1wiO1xuICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtjdHg6IHtwcmV2OiBudWxsLCBzdGFydDogMCwgaW5kZW50VG86IDB9LCBsYXN0VHlwZTogbnVsbCwgdG9rZW5pemU6IGJhc2V9O1xuICAgIH0sXG5cbiAgICB0b2tlbjogZnVuY3Rpb24gKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmIChzdHJlYW0uc29sKCkgJiYgdHlwZW9mIHN0YXRlLmN0eC5pbmRlbnRUbyAhPSBcIm51bWJlclwiKVxuICAgICAgICBzdGF0ZS5jdHguaW5kZW50VG8gPSBzdGF0ZS5jdHguc3RhcnQgKyAxO1xuXG4gICAgICB0eXBlID0gbnVsbDtcbiAgICAgIHZhciBzdHlsZSA9IHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgaWYgKHR5cGUgIT0gXCJ3c1wiKSB7XG4gICAgICAgIGlmIChzdGF0ZS5jdHguaW5kZW50VG8gPT0gbnVsbCkge1xuICAgICAgICAgIGlmICh0eXBlID09IFwic3ltYm9sXCIgJiYgYXNzdW1lQm9keS50ZXN0KHN0cmVhbS5jdXJyZW50KCkpKVxuICAgICAgICAgICAgc3RhdGUuY3R4LmluZGVudFRvID0gc3RhdGUuY3R4LnN0YXJ0ICsgY29uZmlnLmluZGVudFVuaXQ7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgc3RhdGUuY3R4LmluZGVudFRvID0gXCJuZXh0XCI7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUuY3R4LmluZGVudFRvID09IFwibmV4dFwiKSB7XG4gICAgICAgICAgc3RhdGUuY3R4LmluZGVudFRvID0gc3RyZWFtLmNvbHVtbigpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmxhc3RUeXBlID0gdHlwZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09IFwib3BlblwiKSBzdGF0ZS5jdHggPSB7cHJldjogc3RhdGUuY3R4LCBzdGFydDogc3RyZWFtLmNvbHVtbigpLCBpbmRlbnRUbzogbnVsbH07XG4gICAgICBlbHNlIGlmICh0eXBlID09IFwiY2xvc2VcIikgc3RhdGUuY3R4ID0gc3RhdGUuY3R4LnByZXYgfHwgc3RhdGUuY3R4O1xuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH0sXG5cbiAgICBpbmRlbnQ6IGZ1bmN0aW9uIChzdGF0ZSwgX3RleHRBZnRlcikge1xuICAgICAgdmFyIGkgPSBzdGF0ZS5jdHguaW5kZW50VG87XG4gICAgICByZXR1cm4gdHlwZW9mIGkgPT0gXCJudW1iZXJcIiA/IGkgOiBzdGF0ZS5jdHguc3RhcnQgKyAxO1xuICAgIH0sXG5cbiAgICBjbG9zZUJyYWNrZXRzOiB7cGFpcnM6IFwiKClbXXt9XFxcIlxcXCJcIn0sXG4gICAgbGluZUNvbW1lbnQ6IFwiOztcIixcbiAgICBibG9ja0NvbW1lbnRTdGFydDogXCIjfFwiLFxuICAgIGJsb2NrQ29tbWVudEVuZDogXCJ8I1wiXG4gIH07XG59KTtcblxuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LWNvbW1vbi1saXNwXCIsIFwiY29tbW9ubGlzcFwiKTtcblxufSk7XG4iLCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBDb2RlTWlycm9yLmRlZmluZU1vZGUoXCJjcnlzdGFsXCIsIGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIGZ1bmN0aW9uIHdvcmRSZWdFeHAod29yZHMsIGVuZCkge1xuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoKGVuZCA/IFwiXCIgOiBcIl5cIikgKyBcIig/OlwiICsgd29yZHMuam9pbihcInxcIikgKyBcIilcIiArIChlbmQgPyBcIiRcIiA6IFwiXFxcXGJcIikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoYWluKHRva2VuaXplLCBzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZS5wdXNoKHRva2VuaXplKTtcbiAgICAgIHJldHVybiB0b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICB2YXIgb3BlcmF0b3JzID0gL14oPzpbLSsvJXwmXl18XFwqXFwqP3xbPD5dezJ9KS87XG4gICAgdmFyIGNvbmRpdGlvbmFsT3BlcmF0b3JzID0gL14oPzpbPSFdfnw9PT18PD0+fFs8Pj0hXT0/fFt8Jl17Mn18fikvO1xuICAgIHZhciBpbmRleGluZ09wZXJhdG9ycyA9IC9eKD86XFxbXFxdWz89XT8pLztcbiAgICB2YXIgYW5vdGhlck9wZXJhdG9ycyA9IC9eKD86XFwuKD86XFwuezJ9KT98LT58Wz86XSkvO1xuICAgIHZhciBpZGVudHMgPSAvXlthLXpfXFx1MDA5Ri1cXHVGRkZGXVthLXpBLVowLTlfXFx1MDA5Ri1cXHVGRkZGXSovO1xuICAgIHZhciB0eXBlcyA9IC9eW0EtWl9cXHUwMDlGLVxcdUZGRkZdW2EtekEtWjAtOV9cXHUwMDlGLVxcdUZGRkZdKi87XG4gICAgdmFyIGtleXdvcmRzID0gd29yZFJlZ0V4cChbXG4gICAgICBcImFic3RyYWN0XCIsIFwiYWxpYXNcIiwgXCJhc1wiLCBcImFzbVwiLCBcImJlZ2luXCIsIFwiYnJlYWtcIiwgXCJjYXNlXCIsIFwiY2xhc3NcIiwgXCJkZWZcIiwgXCJkb1wiLFxuICAgICAgXCJlbHNlXCIsIFwiZWxzaWZcIiwgXCJlbmRcIiwgXCJlbnN1cmVcIiwgXCJlbnVtXCIsIFwiZXh0ZW5kXCIsIFwiZm9yXCIsIFwiZnVuXCIsIFwiaWZcIixcbiAgICAgIFwiaW5jbHVkZVwiLCBcImluc3RhbmNlX3NpemVvZlwiLCBcImxpYlwiLCBcIm1hY3JvXCIsIFwibW9kdWxlXCIsIFwibmV4dFwiLCBcIm9mXCIsIFwib3V0XCIsIFwicG9pbnRlcm9mXCIsXG4gICAgICBcInByaXZhdGVcIiwgXCJwcm90ZWN0ZWRcIiwgXCJyZXNjdWVcIiwgXCJyZXR1cm5cIiwgXCJyZXF1aXJlXCIsIFwic2VsZWN0XCIsIFwic2l6ZW9mXCIsIFwic3RydWN0XCIsXG4gICAgICBcInN1cGVyXCIsIFwidGhlblwiLCBcInR5cGVcIiwgXCJ0eXBlb2ZcIiwgXCJ1bmluaXRpYWxpemVkXCIsIFwidW5pb25cIiwgXCJ1bmxlc3NcIiwgXCJ1bnRpbFwiLCBcIndoZW5cIiwgXCJ3aGlsZVwiLCBcIndpdGhcIixcbiAgICAgIFwieWllbGRcIiwgXCJfX0RJUl9fXCIsIFwiX19FTkRfTElORV9fXCIsIFwiX19GSUxFX19cIiwgXCJfX0xJTkVfX1wiXG4gICAgXSk7XG4gICAgdmFyIGF0b21Xb3JkcyA9IHdvcmRSZWdFeHAoW1widHJ1ZVwiLCBcImZhbHNlXCIsIFwibmlsXCIsIFwic2VsZlwiXSk7XG4gICAgdmFyIGluZGVudEtleXdvcmRzQXJyYXkgPSBbXG4gICAgICBcImRlZlwiLCBcImZ1blwiLCBcIm1hY3JvXCIsXG4gICAgICBcImNsYXNzXCIsIFwibW9kdWxlXCIsIFwic3RydWN0XCIsIFwibGliXCIsIFwiZW51bVwiLCBcInVuaW9uXCIsXG4gICAgICBcImRvXCIsIFwiZm9yXCJcbiAgICBdO1xuICAgIHZhciBpbmRlbnRLZXl3b3JkcyA9IHdvcmRSZWdFeHAoaW5kZW50S2V5d29yZHNBcnJheSk7XG4gICAgdmFyIGluZGVudEV4cHJlc3Npb25LZXl3b3Jkc0FycmF5ID0gW1wiaWZcIiwgXCJ1bmxlc3NcIiwgXCJjYXNlXCIsIFwid2hpbGVcIiwgXCJ1bnRpbFwiLCBcImJlZ2luXCIsIFwidGhlblwiXTtcbiAgICB2YXIgaW5kZW50RXhwcmVzc2lvbktleXdvcmRzID0gd29yZFJlZ0V4cChpbmRlbnRFeHByZXNzaW9uS2V5d29yZHNBcnJheSk7XG4gICAgdmFyIGRlZGVudEtleXdvcmRzQXJyYXkgPSBbXCJlbmRcIiwgXCJlbHNlXCIsIFwiZWxzaWZcIiwgXCJyZXNjdWVcIiwgXCJlbnN1cmVcIl07XG4gICAgdmFyIGRlZGVudEtleXdvcmRzID0gd29yZFJlZ0V4cChkZWRlbnRLZXl3b3Jkc0FycmF5KTtcbiAgICB2YXIgZGVkZW50UHVuY3R1YWxzQXJyYXkgPSBbXCJcXFxcKVwiLCBcIlxcXFx9XCIsIFwiXFxcXF1cIl07XG4gICAgdmFyIGRlZGVudFB1bmN0dWFscyA9IG5ldyBSZWdFeHAoXCJeKD86XCIgKyBkZWRlbnRQdW5jdHVhbHNBcnJheS5qb2luKFwifFwiKSArIFwiKSRcIik7XG4gICAgdmFyIG5leHRUb2tlbml6ZXIgPSB7XG4gICAgICBcImRlZlwiOiB0b2tlbkZvbGxvd0lkZW50LCBcImZ1blwiOiB0b2tlbkZvbGxvd0lkZW50LCBcIm1hY3JvXCI6IHRva2VuTWFjcm9EZWYsXG4gICAgICBcImNsYXNzXCI6IHRva2VuRm9sbG93VHlwZSwgXCJtb2R1bGVcIjogdG9rZW5Gb2xsb3dUeXBlLCBcInN0cnVjdFwiOiB0b2tlbkZvbGxvd1R5cGUsXG4gICAgICBcImxpYlwiOiB0b2tlbkZvbGxvd1R5cGUsIFwiZW51bVwiOiB0b2tlbkZvbGxvd1R5cGUsIFwidW5pb25cIjogdG9rZW5Gb2xsb3dUeXBlXG4gICAgfTtcbiAgICB2YXIgbWF0Y2hpbmcgPSB7XCJbXCI6IFwiXVwiLCBcIntcIjogXCJ9XCIsIFwiKFwiOiBcIilcIiwgXCI8XCI6IFwiPlwifTtcblxuICAgIGZ1bmN0aW9uIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIE1hY3Jvc1xuICAgICAgaWYgKHN0YXRlLmxhc3RUb2tlbiAhPSBcIlxcXFxcIiAmJiBzdHJlYW0ubWF0Y2goXCJ7JVwiLCBmYWxzZSkpIHtcbiAgICAgICAgcmV0dXJuIGNoYWluKHRva2VuTWFjcm8oXCIlXCIsIFwiJVwiKSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZS5sYXN0VG9rZW4gIT0gXCJcXFxcXCIgJiYgc3RyZWFtLm1hdGNoKFwie3tcIiwgZmFsc2UpKSB7XG4gICAgICAgIHJldHVybiBjaGFpbih0b2tlbk1hY3JvKFwie1wiLCBcIn1cIiksIHN0cmVhbSwgc3RhdGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBDb21tZW50c1xuICAgICAgaWYgKHN0cmVhbS5wZWVrKCkgPT0gXCIjXCIpIHtcbiAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgICB9XG5cbiAgICAgIC8vIFZhcmlhYmxlcyBhbmQga2V5d29yZHNcbiAgICAgIHZhciBtYXRjaGVkO1xuICAgICAgaWYgKHN0cmVhbS5tYXRjaChpZGVudHMpKSB7XG4gICAgICAgIHN0cmVhbS5lYXQoL1s/IV0vKTtcblxuICAgICAgICBtYXRjaGVkID0gc3RyZWFtLmN1cnJlbnQoKTtcbiAgICAgICAgaWYgKHN0cmVhbS5lYXQoXCI6XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFwiYXRvbVwiO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLmxhc3RUb2tlbiA9PSBcIi5cIikge1xuICAgICAgICAgIHJldHVybiBcInByb3BlcnR5XCI7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5d29yZHMudGVzdChtYXRjaGVkKSkge1xuICAgICAgICAgIGlmIChpbmRlbnRLZXl3b3Jkcy50ZXN0KG1hdGNoZWQpKSB7XG4gICAgICAgICAgICBpZiAoIShtYXRjaGVkID09IFwiZnVuXCIgJiYgc3RhdGUuYmxvY2tzLmluZGV4T2YoXCJsaWJcIikgPj0gMCkgJiYgIShtYXRjaGVkID09IFwiZGVmXCIgJiYgc3RhdGUubGFzdFRva2VuID09IFwiYWJzdHJhY3RcIikpIHtcbiAgICAgICAgICAgICAgc3RhdGUuYmxvY2tzLnB1c2gobWF0Y2hlZCk7XG4gICAgICAgICAgICAgIHN0YXRlLmN1cnJlbnRJbmRlbnQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKChzdGF0ZS5sYXN0U3R5bGUgPT0gXCJvcGVyYXRvclwiIHx8ICFzdGF0ZS5sYXN0U3R5bGUpICYmIGluZGVudEV4cHJlc3Npb25LZXl3b3Jkcy50ZXN0KG1hdGNoZWQpKSB7XG4gICAgICAgICAgICBzdGF0ZS5ibG9ja3MucHVzaChtYXRjaGVkKTtcbiAgICAgICAgICAgIHN0YXRlLmN1cnJlbnRJbmRlbnQgKz0gMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoZWQgPT0gXCJlbmRcIikge1xuICAgICAgICAgICAgc3RhdGUuYmxvY2tzLnBvcCgpO1xuICAgICAgICAgICAgc3RhdGUuY3VycmVudEluZGVudCAtPSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChuZXh0VG9rZW5pemVyLmhhc093blByb3BlcnR5KG1hdGNoZWQpKSB7XG4gICAgICAgICAgICBzdGF0ZS50b2tlbml6ZS5wdXNoKG5leHRUb2tlbml6ZXJbbWF0Y2hlZF0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgICAgICAgfSBlbHNlIGlmIChhdG9tV29yZHMudGVzdChtYXRjaGVkKSkge1xuICAgICAgICAgIHJldHVybiBcImF0b21cIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBcInZhcmlhYmxlXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIENsYXNzIHZhcmlhYmxlcyBhbmQgaW5zdGFuY2UgdmFyaWFibGVzXG4gICAgICAvLyBvciBhdHRyaWJ1dGVzXG4gICAgICBpZiAoc3RyZWFtLmVhdChcIkBcIikpIHtcbiAgICAgICAgaWYgKHN0cmVhbS5wZWVrKCkgPT0gXCJbXCIpIHtcbiAgICAgICAgICByZXR1cm4gY2hhaW4odG9rZW5OZXN0KFwiW1wiLCBcIl1cIiwgXCJtZXRhXCIpLCBzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0cmVhbS5lYXQoXCJAXCIpO1xuICAgICAgICBzdHJlYW0ubWF0Y2goaWRlbnRzKSB8fCBzdHJlYW0ubWF0Y2godHlwZXMpO1xuICAgICAgICByZXR1cm4gXCJ2YXJpYWJsZS0yXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIENvbnN0YW50cyBhbmQgdHlwZXNcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2godHlwZXMpKSB7XG4gICAgICAgIHJldHVybiBcInRhZ1wiO1xuICAgICAgfVxuXG4gICAgICAvLyBTeW1ib2xzIG9yICc6JyBvcGVyYXRvclxuICAgICAgaWYgKHN0cmVhbS5lYXQoXCI6XCIpKSB7XG4gICAgICAgIGlmIChzdHJlYW0uZWF0KFwiXFxcIlwiKSkge1xuICAgICAgICAgIHJldHVybiBjaGFpbih0b2tlblF1b3RlKFwiXFxcIlwiLCBcImF0b21cIiwgZmFsc2UpLCBzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goaWRlbnRzKSB8fCBzdHJlYW0ubWF0Y2godHlwZXMpIHx8XG4gICAgICAgICAgICAgICAgICAgc3RyZWFtLm1hdGNoKG9wZXJhdG9ycykgfHwgc3RyZWFtLm1hdGNoKGNvbmRpdGlvbmFsT3BlcmF0b3JzKSB8fCBzdHJlYW0ubWF0Y2goaW5kZXhpbmdPcGVyYXRvcnMpKSB7XG4gICAgICAgICAgcmV0dXJuIFwiYXRvbVwiO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5lYXQoXCI6XCIpO1xuICAgICAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICAgICAgfVxuXG4gICAgICAvLyBTdHJpbmdzXG4gICAgICBpZiAoc3RyZWFtLmVhdChcIlxcXCJcIikpIHtcbiAgICAgICAgcmV0dXJuIGNoYWluKHRva2VuUXVvdGUoXCJcXFwiXCIsIFwic3RyaW5nXCIsIHRydWUpLCBzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgLy8gU3RyaW5ncyBvciByZWdleHBzIG9yIG1hY3JvIHZhcmlhYmxlcyBvciAnJScgb3BlcmF0b3JcbiAgICAgIGlmIChzdHJlYW0ucGVlaygpID09IFwiJVwiKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IFwic3RyaW5nXCI7XG4gICAgICAgIHZhciBlbWJlZCA9IHRydWU7XG4gICAgICAgIHZhciBkZWxpbTtcblxuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKFwiJXJcIikpIHtcbiAgICAgICAgICAvLyBSZWdleHBzXG4gICAgICAgICAgc3R5bGUgPSBcInN0cmluZy0yXCI7XG4gICAgICAgICAgZGVsaW0gPSBzdHJlYW0ubmV4dCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaChcIiV3XCIpKSB7XG4gICAgICAgICAgZW1iZWQgPSBmYWxzZTtcbiAgICAgICAgICBkZWxpbSA9IHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKFwiJXFcIikpIHtcbiAgICAgICAgICBlbWJlZCA9IGZhbHNlO1xuICAgICAgICAgIGRlbGltID0gc3RyZWFtLm5leHQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZihkZWxpbSA9IHN0cmVhbS5tYXRjaCgvXiUoW15cXHdcXHM9XSkvKSkge1xuICAgICAgICAgICAgZGVsaW0gPSBkZWxpbVsxXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaCgvXiVbYS16QS1aX1xcdTAwOUYtXFx1RkZGRl1bXFx3XFx1MDA5Ri1cXHVGRkZGXSovKSkge1xuICAgICAgICAgICAgLy8gTWFjcm8gdmFyaWFibGVzXG4gICAgICAgICAgICByZXR1cm4gXCJtZXRhXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0uZWF0KCclJykpIHtcbiAgICAgICAgICAgIC8vICclJyBvcGVyYXRvclxuICAgICAgICAgICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2hpbmcuaGFzT3duUHJvcGVydHkoZGVsaW0pKSB7XG4gICAgICAgICAgZGVsaW0gPSBtYXRjaGluZ1tkZWxpbV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYWluKHRva2VuUXVvdGUoZGVsaW0sIHN0eWxlLCBlbWJlZCksIHN0cmVhbSwgc3RhdGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBIZXJlIERvY3NcbiAgICAgIGlmIChtYXRjaGVkID0gc3RyZWFtLm1hdGNoKC9ePDwtKCc/KShbQS1aXVxcdyopXFwxLykpIHtcbiAgICAgICAgcmV0dXJuIGNoYWluKHRva2VuSGVyZURvYyhtYXRjaGVkWzJdLCAhbWF0Y2hlZFsxXSksIHN0cmVhbSwgc3RhdGUpXG4gICAgICB9XG5cbiAgICAgIC8vIENoYXJhY3RlcnNcbiAgICAgIGlmIChzdHJlYW0uZWF0KFwiJ1wiKSkge1xuICAgICAgICBzdHJlYW0ubWF0Y2goL14oPzpbXiddfFxcXFwoPzpbYmVmbnJ0djAnXCJdfFswLTddezN9fHUoPzpbMC05YS1mQS1GXXs0fXxcXHtbMC05YS1mQS1GXXsxLDZ9XFx9KSkpLyk7XG4gICAgICAgIHN0cmVhbS5lYXQoXCInXCIpO1xuICAgICAgICByZXR1cm4gXCJhdG9tXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIE51bWJlcnNcbiAgICAgIGlmIChzdHJlYW0uZWF0KFwiMFwiKSkge1xuICAgICAgICBpZiAoc3RyZWFtLmVhdChcInhcIikpIHtcbiAgICAgICAgICBzdHJlYW0ubWF0Y2goL15bMC05YS1mQS1GX10rLyk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLmVhdChcIm9cIikpIHtcbiAgICAgICAgICBzdHJlYW0ubWF0Y2goL15bMC03X10rLyk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLmVhdChcImJcIikpIHtcbiAgICAgICAgICBzdHJlYW0ubWF0Y2goL15bMDFfXSsvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0cmVhbS5lYXQoL15cXGQvKSkge1xuICAgICAgICBzdHJlYW0ubWF0Y2goL15bXFxkX10qKD86XFwuW1xcZF9dKyk/KD86W2VFXVsrLV0/XFxkKyk/Lyk7XG4gICAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgICAgfVxuXG4gICAgICAvLyBPcGVyYXRvcnNcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2gob3BlcmF0b3JzKSkge1xuICAgICAgICBzdHJlYW0uZWF0KFwiPVwiKTsgLy8gT3BlcmF0b3JzIGNhbiBmb2xsb3cgYXNzaWduIHN5bWJvbC5cbiAgICAgICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0cmVhbS5tYXRjaChjb25kaXRpb25hbE9wZXJhdG9ycykgfHwgc3RyZWFtLm1hdGNoKGFub3RoZXJPcGVyYXRvcnMpKSB7XG4gICAgICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIFBhcmVucyBhbmQgYnJhY2VzXG4gICAgICBpZiAobWF0Y2hlZCA9IHN0cmVhbS5tYXRjaCgvWyh7W10vLCBmYWxzZSkpIHtcbiAgICAgICAgbWF0Y2hlZCA9IG1hdGNoZWRbMF07XG4gICAgICAgIHJldHVybiBjaGFpbih0b2tlbk5lc3QobWF0Y2hlZCwgbWF0Y2hpbmdbbWF0Y2hlZF0sIG51bGwpLCBzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgLy8gRXNjYXBlc1xuICAgICAgaWYgKHN0cmVhbS5lYXQoXCJcXFxcXCIpKSB7XG4gICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIHJldHVybiBcIm1ldGFcIjtcbiAgICAgIH1cblxuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRva2VuTmVzdChiZWdpbiwgZW5kLCBzdHlsZSwgc3RhcnRlZCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIGlmICghc3RhcnRlZCAmJiBzdHJlYW0ubWF0Y2goYmVnaW4pKSB7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemVbc3RhdGUudG9rZW5pemUubGVuZ3RoIC0gMV0gPSB0b2tlbk5lc3QoYmVnaW4sIGVuZCwgc3R5bGUsIHRydWUpO1xuICAgICAgICAgIHN0YXRlLmN1cnJlbnRJbmRlbnQgKz0gMTtcbiAgICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV4dFN0eWxlID0gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICBpZiAoc3RyZWFtLmN1cnJlbnQoKSA9PT0gZW5kKSB7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemUucG9wKCk7XG4gICAgICAgICAgc3RhdGUuY3VycmVudEluZGVudCAtPSAxO1xuICAgICAgICAgIG5leHRTdHlsZSA9IHN0eWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5leHRTdHlsZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9rZW5NYWNybyhiZWdpbiwgZW5kLCBzdGFydGVkKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgaWYgKCFzdGFydGVkICYmIHN0cmVhbS5tYXRjaChcIntcIiArIGJlZ2luKSkge1xuICAgICAgICAgIHN0YXRlLmN1cnJlbnRJbmRlbnQgKz0gMTtcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZVtzdGF0ZS50b2tlbml6ZS5sZW5ndGggLSAxXSA9IHRva2VuTWFjcm8oYmVnaW4sIGVuZCwgdHJ1ZSk7XG4gICAgICAgICAgcmV0dXJuIFwibWV0YVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaChlbmQgKyBcIn1cIikpIHtcbiAgICAgICAgICBzdGF0ZS5jdXJyZW50SW5kZW50IC09IDE7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemUucG9wKCk7XG4gICAgICAgICAgcmV0dXJuIFwibWV0YVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9rZW5NYWNyb0RlZihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXRjaGVkO1xuICAgICAgaWYgKG1hdGNoZWQgPSBzdHJlYW0ubWF0Y2goaWRlbnRzKSkge1xuICAgICAgICBpZiAobWF0Y2hlZCA9PSBcImRlZlwiKSB7XG4gICAgICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5lYXQoL1s/IV0vKTtcbiAgICAgIH1cblxuICAgICAgc3RhdGUudG9rZW5pemUucG9wKCk7XG4gICAgICByZXR1cm4gXCJkZWZcIjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b2tlbkZvbGxvd0lkZW50KHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0cmVhbS5tYXRjaChpZGVudHMpKSB7XG4gICAgICAgIHN0cmVhbS5lYXQoL1shP10vKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmVhbS5tYXRjaChvcGVyYXRvcnMpIHx8IHN0cmVhbS5tYXRjaChjb25kaXRpb25hbE9wZXJhdG9ycykgfHwgc3RyZWFtLm1hdGNoKGluZGV4aW5nT3BlcmF0b3JzKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnRva2VuaXplLnBvcCgpO1xuICAgICAgcmV0dXJuIFwiZGVmXCI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9rZW5Gb2xsb3dUeXBlKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgc3RyZWFtLm1hdGNoKHR5cGVzKTtcbiAgICAgIHN0YXRlLnRva2VuaXplLnBvcCgpO1xuICAgICAgcmV0dXJuIFwiZGVmXCI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9rZW5RdW90ZShlbmQsIHN0eWxlLCBlbWJlZCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIHZhciBlc2NhcGVkID0gZmFsc2U7XG5cbiAgICAgICAgd2hpbGUgKHN0cmVhbS5wZWVrKCkpIHtcbiAgICAgICAgICBpZiAoIWVzY2FwZWQpIHtcbiAgICAgICAgICAgIGlmIChzdHJlYW0ubWF0Y2goXCJ7JVwiLCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgc3RhdGUudG9rZW5pemUucHVzaCh0b2tlbk1hY3JvKFwiJVwiLCBcIiVcIikpO1xuICAgICAgICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdHJlYW0ubWF0Y2goXCJ7e1wiLCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgc3RhdGUudG9rZW5pemUucHVzaCh0b2tlbk1hY3JvKFwie1wiLCBcIn1cIikpO1xuICAgICAgICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbWJlZCAmJiBzdHJlYW0ubWF0Y2goXCIje1wiLCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgc3RhdGUudG9rZW5pemUucHVzaCh0b2tlbk5lc3QoXCIje1wiLCBcIn1cIiwgXCJtZXRhXCIpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuXG4gICAgICAgICAgICBpZiAoY2ggPT0gZW5kKSB7XG4gICAgICAgICAgICAgIHN0YXRlLnRva2VuaXplLnBvcCgpO1xuICAgICAgICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVzY2FwZWQgPSBlbWJlZCAmJiBjaCA9PSBcIlxcXFxcIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgICAgIGVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRva2VuSGVyZURvYyhwaHJhc2UsIGVtYmVkKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgaWYgKHN0cmVhbS5zb2woKSkge1xuICAgICAgICAgIHN0cmVhbS5lYXRTcGFjZSgpXG4gICAgICAgICAgaWYgKHN0cmVhbS5tYXRjaChwaHJhc2UpKSB7XG4gICAgICAgICAgICBzdGF0ZS50b2tlbml6ZS5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlc2NhcGVkID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChzdHJlYW0ucGVlaygpKSB7XG4gICAgICAgICAgaWYgKCFlc2NhcGVkKSB7XG4gICAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKFwieyVcIiwgZmFsc2UpKSB7XG4gICAgICAgICAgICAgIHN0YXRlLnRva2VuaXplLnB1c2godG9rZW5NYWNybyhcIiVcIiwgXCIlXCIpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdHJlYW0ubWF0Y2goXCJ7e1wiLCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgc3RhdGUudG9rZW5pemUucHVzaCh0b2tlbk1hY3JvKFwie1wiLCBcIn1cIikpO1xuICAgICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVtYmVkICYmIHN0cmVhbS5tYXRjaChcIiN7XCIsIGZhbHNlKSkge1xuICAgICAgICAgICAgICBzdGF0ZS50b2tlbml6ZS5wdXNoKHRva2VuTmVzdChcIiN7XCIsIFwifVwiLCBcIm1ldGFcIikpO1xuICAgICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXNjYXBlZCA9IGVtYmVkICYmIHN0cmVhbS5uZXh0KCkgPT0gXCJcXFxcXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgICAgICBlc2NhcGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0b2tlbml6ZTogW3Rva2VuQmFzZV0sXG4gICAgICAgICAgY3VycmVudEluZGVudDogMCxcbiAgICAgICAgICBsYXN0VG9rZW46IG51bGwsXG4gICAgICAgICAgbGFzdFN0eWxlOiBudWxsLFxuICAgICAgICAgIGJsb2NrczogW11cbiAgICAgICAgfTtcbiAgICAgIH0sXG5cbiAgICAgIHRva2VuOiBmdW5jdGlvbiAoc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgICB2YXIgc3R5bGUgPSBzdGF0ZS50b2tlbml6ZVtzdGF0ZS50b2tlbml6ZS5sZW5ndGggLSAxXShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgdmFyIHRva2VuID0gc3RyZWFtLmN1cnJlbnQoKTtcblxuICAgICAgICBpZiAoc3R5bGUgJiYgc3R5bGUgIT0gXCJjb21tZW50XCIpIHtcbiAgICAgICAgICBzdGF0ZS5sYXN0VG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICBzdGF0ZS5sYXN0U3R5bGUgPSBzdHlsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgIH0sXG5cbiAgICAgIGluZGVudDogZnVuY3Rpb24gKHN0YXRlLCB0ZXh0QWZ0ZXIpIHtcbiAgICAgICAgdGV4dEFmdGVyID0gdGV4dEFmdGVyLnJlcGxhY2UoL15cXHMqKD86XFx7JSk/XFxzKnxcXHMqKD86JVxcfSk/XFxzKiQvZywgXCJcIik7XG5cbiAgICAgICAgaWYgKGRlZGVudEtleXdvcmRzLnRlc3QodGV4dEFmdGVyKSB8fCBkZWRlbnRQdW5jdHVhbHMudGVzdCh0ZXh0QWZ0ZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbmZpZy5pbmRlbnRVbml0ICogKHN0YXRlLmN1cnJlbnRJbmRlbnQgLSAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25maWcuaW5kZW50VW5pdCAqIHN0YXRlLmN1cnJlbnRJbmRlbnQ7XG4gICAgICB9LFxuXG4gICAgICBmb2xkOiBcImluZGVudFwiLFxuICAgICAgZWxlY3RyaWNJbnB1dDogd29yZFJlZ0V4cChkZWRlbnRQdW5jdHVhbHNBcnJheS5jb25jYXQoZGVkZW50S2V5d29yZHNBcnJheSksIHRydWUpLFxuICAgICAgbGluZUNvbW1lbnQ6ICcjJ1xuICAgIH07XG4gIH0pO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQveC1jcnlzdGFsXCIsIFwiY3J5c3RhbFwiKTtcbn0pO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuLy8gQnkgdGhlIE5lbzRqIFRlYW0gYW5kIGNvbnRyaWJ1dG9ycy5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9uZW80ai1jb250cmliL0NvZGVNaXJyb3JcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciB3b3JkUmVnZXhwID0gZnVuY3Rpb24od29yZHMpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChcIl4oPzpcIiArIHdvcmRzLmpvaW4oXCJ8XCIpICsgXCIpJFwiLCBcImlcIik7XG4gIH07XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwiY3lwaGVyXCIsIGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHZhciB0b2tlbkJhc2UgPSBmdW5jdGlvbihzdHJlYW0vKiwgc3RhdGUqLykge1xuICAgICAgdmFyIGNoID0gc3RyZWFtLm5leHQoKTtcbiAgICAgIGlmIChjaCA9PT0nXCInKSB7XG4gICAgICAgIHN0cmVhbS5tYXRjaCgvXlteXCJdKlwiLyk7XG4gICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgfVxuICAgICAgaWYgKGNoID09PSBcIidcIikge1xuICAgICAgICBzdHJlYW0ubWF0Y2goL15bXiddKicvKTtcbiAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgICB9XG4gICAgICBpZiAoL1t7fVxcKFxcKSxcXC47XFxbXFxdXS8udGVzdChjaCkpIHtcbiAgICAgICAgY3VyUHVuYyA9IGNoO1xuICAgICAgICByZXR1cm4gXCJub2RlXCI7XG4gICAgICB9IGVsc2UgaWYgKGNoID09PSBcIi9cIiAmJiBzdHJlYW0uZWF0KFwiL1wiKSkge1xuICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICAgIH0gZWxzZSBpZiAob3BlcmF0b3JDaGFycy50ZXN0KGNoKSkge1xuICAgICAgICBzdHJlYW0uZWF0V2hpbGUob3BlcmF0b3JDaGFycyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bX1xcd1xcZF0vKTtcbiAgICAgICAgaWYgKHN0cmVhbS5lYXQoXCI6XCIpKSB7XG4gICAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFxkX1xcLV0vKTtcbiAgICAgICAgICByZXR1cm4gXCJhdG9tXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdvcmQgPSBzdHJlYW0uY3VycmVudCgpO1xuICAgICAgICBpZiAoZnVuY3MudGVzdCh3b3JkKSkgcmV0dXJuIFwiYnVpbHRpblwiO1xuICAgICAgICBpZiAocHJlZHMudGVzdCh3b3JkKSkgcmV0dXJuIFwiZGVmXCI7XG4gICAgICAgIGlmIChrZXl3b3Jkcy50ZXN0KHdvcmQpIHx8IHN5c3RlbUtleXdvcmRzLnRlc3Qod29yZCkpIHJldHVybiBcImtleXdvcmRcIjtcbiAgICAgICAgcmV0dXJuIFwidmFyaWFibGVcIjtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwdXNoQ29udGV4dCA9IGZ1bmN0aW9uKHN0YXRlLCB0eXBlLCBjb2wpIHtcbiAgICAgIHJldHVybiBzdGF0ZS5jb250ZXh0ID0ge1xuICAgICAgICBwcmV2OiBzdGF0ZS5jb250ZXh0LFxuICAgICAgICBpbmRlbnQ6IHN0YXRlLmluZGVudCxcbiAgICAgICAgY29sOiBjb2wsXG4gICAgICAgIHR5cGU6IHR5cGVcbiAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgcG9wQ29udGV4dCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICBzdGF0ZS5pbmRlbnQgPSBzdGF0ZS5jb250ZXh0LmluZGVudDtcbiAgICAgIHJldHVybiBzdGF0ZS5jb250ZXh0ID0gc3RhdGUuY29udGV4dC5wcmV2O1xuICAgIH07XG4gICAgdmFyIGluZGVudFVuaXQgPSBjb25maWcuaW5kZW50VW5pdDtcbiAgICB2YXIgY3VyUHVuYztcbiAgICB2YXIgZnVuY3MgPSB3b3JkUmVnZXhwKFtcImFic1wiLCBcImFjb3NcIiwgXCJhbGxTaG9ydGVzdFBhdGhzXCIsIFwiYXNpblwiLCBcImF0YW5cIiwgXCJhdGFuMlwiLCBcImF2Z1wiLCBcImNlaWxcIiwgXCJjb2FsZXNjZVwiLCBcImNvbGxlY3RcIiwgXCJjb3NcIiwgXCJjb3RcIiwgXCJjb3VudFwiLCBcImRlZ3JlZXNcIiwgXCJlXCIsIFwiZW5kbm9kZVwiLCBcImV4cFwiLCBcImV4dHJhY3RcIiwgXCJmaWx0ZXJcIiwgXCJmbG9vclwiLCBcImhhdmVyc2luXCIsIFwiaGVhZFwiLCBcImlkXCIsIFwia2V5c1wiLCBcImxhYmVsc1wiLCBcImxhc3RcIiwgXCJsZWZ0XCIsIFwibGVuZ3RoXCIsIFwibG9nXCIsIFwibG9nMTBcIiwgXCJsb3dlclwiLCBcImx0cmltXCIsIFwibWF4XCIsIFwibWluXCIsIFwibm9kZVwiLCBcIm5vZGVzXCIsIFwicGVyY2VudGlsZUNvbnRcIiwgXCJwZXJjZW50aWxlRGlzY1wiLCBcInBpXCIsIFwicmFkaWFuc1wiLCBcInJhbmRcIiwgXCJyYW5nZVwiLCBcInJlZHVjZVwiLCBcInJlbFwiLCBcInJlbGF0aW9uc2hpcFwiLCBcInJlbGF0aW9uc2hpcHNcIiwgXCJyZXBsYWNlXCIsIFwicmV2ZXJzZVwiLCBcInJpZ2h0XCIsIFwicm91bmRcIiwgXCJydHJpbVwiLCBcInNob3J0ZXN0UGF0aFwiLCBcInNpZ25cIiwgXCJzaW5cIiwgXCJzaXplXCIsIFwic3BsaXRcIiwgXCJzcXJ0XCIsIFwic3RhcnRub2RlXCIsIFwic3RkZXZcIiwgXCJzdGRldnBcIiwgXCJzdHJcIiwgXCJzdWJzdHJpbmdcIiwgXCJzdW1cIiwgXCJ0YWlsXCIsIFwidGFuXCIsIFwidGltZXN0YW1wXCIsIFwidG9GbG9hdFwiLCBcInRvSW50XCIsIFwidG9TdHJpbmdcIiwgXCJ0cmltXCIsIFwidHlwZVwiLCBcInVwcGVyXCJdKTtcbiAgICB2YXIgcHJlZHMgPSB3b3JkUmVnZXhwKFtcImFsbFwiLCBcImFuZFwiLCBcImFueVwiLCBcImNvbnRhaW5zXCIsIFwiZXhpc3RzXCIsIFwiaGFzXCIsIFwiaW5cIiwgXCJub25lXCIsIFwibm90XCIsIFwib3JcIiwgXCJzaW5nbGVcIiwgXCJ4b3JcIl0pO1xuICAgIHZhciBrZXl3b3JkcyA9IHdvcmRSZWdleHAoW1wiYXNcIiwgXCJhc2NcIiwgXCJhc2NlbmRpbmdcIiwgXCJhc3NlcnRcIiwgXCJieVwiLCBcImNhc2VcIiwgXCJjb21taXRcIiwgXCJjb25zdHJhaW50XCIsIFwiY3JlYXRlXCIsIFwiY3N2XCIsIFwiY3lwaGVyXCIsIFwiZGVsZXRlXCIsIFwiZGVzY1wiLCBcImRlc2NlbmRpbmdcIiwgXCJkZXRhY2hcIiwgXCJkaXN0aW5jdFwiLCBcImRyb3BcIiwgXCJlbHNlXCIsIFwiZW5kXCIsIFwiZW5kc1wiLCBcImV4cGxhaW5cIiwgXCJmYWxzZVwiLCBcImZpZWxkdGVybWluYXRvclwiLCBcImZvcmVhY2hcIiwgXCJmcm9tXCIsIFwiaGVhZGVyc1wiLCBcImluXCIsIFwiaW5kZXhcIiwgXCJpc1wiLCBcImpvaW5cIiwgXCJsaW1pdFwiLCBcImxvYWRcIiwgXCJtYXRjaFwiLCBcIm1lcmdlXCIsIFwibnVsbFwiLCBcIm9uXCIsIFwib3B0aW9uYWxcIiwgXCJvcmRlclwiLCBcInBlcmlvZGljXCIsIFwicHJvZmlsZVwiLCBcInJlbW92ZVwiLCBcInJldHVyblwiLCBcInNjYW5cIiwgXCJzZXRcIiwgXCJza2lwXCIsIFwic3RhcnRcIiwgXCJzdGFydHNcIiwgXCJ0aGVuXCIsIFwidHJ1ZVwiLCBcInVuaW9uXCIsIFwidW5pcXVlXCIsIFwidW53aW5kXCIsIFwidXNpbmdcIiwgXCJ3aGVuXCIsIFwid2hlcmVcIiwgXCJ3aXRoXCIsIFwiY2FsbFwiLCBcInlpZWxkXCJdKTtcbiAgICB2YXIgc3lzdGVtS2V5d29yZHMgPSB3b3JkUmVnZXhwKFtcImFjY2Vzc1wiLCBcImFjdGl2ZVwiLCBcImFzc2lnblwiLCBcImFsbFwiLCBcImFsdGVyXCIsIFwiYXNcIiwgXCJjYXRhbG9nXCIsIFwiY2hhbmdlXCIsIFwiY29weVwiLCBcImNyZWF0ZVwiLCBcImNvbnN0cmFpbnRcIiwgXCJjb25zdHJhaW50c1wiLCBcImN1cnJlbnRcIiwgXCJkYXRhYmFzZVwiLCBcImRhdGFiYXNlc1wiLCBcImRibXNcIiwgXCJkZWZhdWx0XCIsIFwiZGVueVwiLCBcImRyb3BcIiwgXCJlbGVtZW50XCIsIFwiZWxlbWVudHNcIiwgXCJleGlzdHNcIiwgXCJmcm9tXCIsIFwiZ3JhbnRcIiwgXCJncmFwaFwiLCBcImdyYXBoc1wiLCBcImlmXCIsIFwiaW5kZXhcIiwgXCJpbmRleGVzXCIsIFwibGFiZWxcIiwgXCJsYWJlbHNcIiwgXCJtYW5hZ2VtZW50XCIsIFwibWF0Y2hcIiwgXCJuYW1lXCIsIFwibmFtZXNcIiwgXCJuZXdcIiwgXCJub2RlXCIsIFwibm9kZXNcIiwgXCJub3RcIiwgXCJvZlwiLCBcIm9uXCIsIFwib3JcIiwgXCJwYXNzd29yZFwiLCBcInBvcHVsYXRlZFwiLCBcInByaXZpbGVnZXNcIiwgXCJwcm9wZXJ0eVwiLCBcInJlYWRcIiwgXCJyZWxhdGlvbnNoaXBcIiwgXCJyZWxhdGlvbnNoaXBzXCIsIFwicmVtb3ZlXCIsIFwicmVwbGFjZVwiLCBcInJlcXVpcmVkXCIsIFwicmV2b2tlXCIsIFwicm9sZVwiLCBcInJvbGVzXCIsIFwic2V0XCIsIFwic2hvd1wiLCBcInN0YXJ0XCIsIFwic3RhdHVzXCIsIFwic3RvcFwiLCBcInN1c3BlbmRlZFwiLCBcInRvXCIsIFwidHJhdmVyc2VcIiwgXCJ0eXBlXCIsIFwidHlwZXNcIiwgXCJ1c2VyXCIsIFwidXNlcnNcIiwgXCJ3aXRoXCIsIFwid3JpdGVcIl0pO1xuICAgIHZhciBvcGVyYXRvckNoYXJzID0gL1sqK1xcLTw+PSZ8fiVeXS87XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oLypiYXNlKi8pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0b2tlbml6ZTogdG9rZW5CYXNlLFxuICAgICAgICAgIGNvbnRleHQ6IG51bGwsXG4gICAgICAgICAgaW5kZW50OiAwLFxuICAgICAgICAgIGNvbDogMFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIGlmIChzdHJlYW0uc29sKCkpIHtcbiAgICAgICAgICBpZiAoc3RhdGUuY29udGV4dCAmJiAoc3RhdGUuY29udGV4dC5hbGlnbiA9PSBudWxsKSkge1xuICAgICAgICAgICAgc3RhdGUuY29udGV4dC5hbGlnbiA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGF0ZS5pbmRlbnQgPSBzdHJlYW0uaW5kZW50YXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3R5bGUgPSBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgaWYgKHN0eWxlICE9PSBcImNvbW1lbnRcIiAmJiBzdGF0ZS5jb250ZXh0ICYmIChzdGF0ZS5jb250ZXh0LmFsaWduID09IG51bGwpICYmIHN0YXRlLmNvbnRleHQudHlwZSAhPT0gXCJwYXR0ZXJuXCIpIHtcbiAgICAgICAgICBzdGF0ZS5jb250ZXh0LmFsaWduID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VyUHVuYyA9PT0gXCIoXCIpIHtcbiAgICAgICAgICBwdXNoQ29udGV4dChzdGF0ZSwgXCIpXCIsIHN0cmVhbS5jb2x1bW4oKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VyUHVuYyA9PT0gXCJbXCIpIHtcbiAgICAgICAgICBwdXNoQ29udGV4dChzdGF0ZSwgXCJdXCIsIHN0cmVhbS5jb2x1bW4oKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VyUHVuYyA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICBwdXNoQ29udGV4dChzdGF0ZSwgXCJ9XCIsIHN0cmVhbS5jb2x1bW4oKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoL1tcXF1cXH1cXCldLy50ZXN0KGN1clB1bmMpKSB7XG4gICAgICAgICAgd2hpbGUgKHN0YXRlLmNvbnRleHQgJiYgc3RhdGUuY29udGV4dC50eXBlID09PSBcInBhdHRlcm5cIikge1xuICAgICAgICAgICAgcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5jb250ZXh0ICYmIGN1clB1bmMgPT09IHN0YXRlLmNvbnRleHQudHlwZSkge1xuICAgICAgICAgICAgcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGN1clB1bmMgPT09IFwiLlwiICYmIHN0YXRlLmNvbnRleHQgJiYgc3RhdGUuY29udGV4dC50eXBlID09PSBcInBhdHRlcm5cIikge1xuICAgICAgICAgIHBvcENvbnRleHQoc3RhdGUpO1xuICAgICAgICB9IGVsc2UgaWYgKC9hdG9tfHN0cmluZ3x2YXJpYWJsZS8udGVzdChzdHlsZSkgJiYgc3RhdGUuY29udGV4dCkge1xuICAgICAgICAgIGlmICgvW1xcfVxcXV0vLnRlc3Qoc3RhdGUuY29udGV4dC50eXBlKSkge1xuICAgICAgICAgICAgcHVzaENvbnRleHQoc3RhdGUsIFwicGF0dGVyblwiLCBzdHJlYW0uY29sdW1uKCkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUuY29udGV4dC50eXBlID09PSBcInBhdHRlcm5cIiAmJiAhc3RhdGUuY29udGV4dC5hbGlnbikge1xuICAgICAgICAgICAgc3RhdGUuY29udGV4dC5hbGlnbiA9IHRydWU7XG4gICAgICAgICAgICBzdGF0ZS5jb250ZXh0LmNvbCA9IHN0cmVhbS5jb2x1bW4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgfSxcbiAgICAgIGluZGVudDogZnVuY3Rpb24oc3RhdGUsIHRleHRBZnRlcikge1xuICAgICAgICB2YXIgZmlyc3RDaGFyID0gdGV4dEFmdGVyICYmIHRleHRBZnRlci5jaGFyQXQoMCk7XG4gICAgICAgIHZhciBjb250ZXh0ID0gc3RhdGUuY29udGV4dDtcbiAgICAgICAgaWYgKC9bXFxdXFx9XS8udGVzdChmaXJzdENoYXIpKSB7XG4gICAgICAgICAgd2hpbGUgKGNvbnRleHQgJiYgY29udGV4dC50eXBlID09PSBcInBhdHRlcm5cIikge1xuICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQucHJldjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNsb3NpbmcgPSBjb250ZXh0ICYmIGZpcnN0Q2hhciA9PT0gY29udGV4dC50eXBlO1xuICAgICAgICBpZiAoIWNvbnRleHQpIHJldHVybiAwO1xuICAgICAgICBpZiAoY29udGV4dC50eXBlID09PSBcImtleXdvcmRzXCIpIHJldHVybiBDb2RlTWlycm9yLmNvbW1hbmRzLm5ld2xpbmVBbmRJbmRlbnQ7XG4gICAgICAgIGlmIChjb250ZXh0LmFsaWduKSByZXR1cm4gY29udGV4dC5jb2wgKyAoY2xvc2luZyA/IDAgOiAxKTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuaW5kZW50ICsgKGNsb3NpbmcgPyAwIDogaW5kZW50VW5pdCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG5cbiAgQ29kZU1pcnJvci5tb2RlRXh0ZW5zaW9uc1tcImN5cGhlclwiXSA9IHtcbiAgICBhdXRvRm9ybWF0TGluZUJyZWFrczogZnVuY3Rpb24odGV4dCkge1xuICAgICAgdmFyIGksIGxpbmVzLCByZVByb2Nlc3NlZFBvcnRpb247XG4gICAgICB2YXIgbGluZXMgPSB0ZXh0LnNwbGl0KFwiXFxuXCIpO1xuICAgICAgdmFyIHJlUHJvY2Vzc2VkUG9ydGlvbiA9IC9cXHMrXFxiKHJldHVybnx3aGVyZXxvcmRlciBieXxtYXRjaHx3aXRofHNraXB8bGltaXR8Y3JlYXRlfGRlbGV0ZXxzZXQpXFxiXFxzL2c7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKVxuICAgICAgICBsaW5lc1tpXSA9IGxpbmVzW2ldLnJlcGxhY2UocmVQcm9jZXNzZWRQb3J0aW9uLCBcIiBcXG4kMSBcIikudHJpbSgpO1xuICAgICAgcmV0dXJuIGxpbmVzLmpvaW4oXCJcXG5cIik7XG4gICAgfVxuICB9O1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcImFwcGxpY2F0aW9uL3gtY3lwaGVyLXF1ZXJ5XCIsIFwiY3lwaGVyXCIpO1xuXG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwiZFwiLCBmdW5jdGlvbihjb25maWcsIHBhcnNlckNvbmZpZykge1xuICB2YXIgaW5kZW50VW5pdCA9IGNvbmZpZy5pbmRlbnRVbml0LFxuICAgICAgc3RhdGVtZW50SW5kZW50VW5pdCA9IHBhcnNlckNvbmZpZy5zdGF0ZW1lbnRJbmRlbnRVbml0IHx8IGluZGVudFVuaXQsXG4gICAgICBrZXl3b3JkcyA9IHBhcnNlckNvbmZpZy5rZXl3b3JkcyB8fCB7fSxcbiAgICAgIGJ1aWx0aW4gPSBwYXJzZXJDb25maWcuYnVpbHRpbiB8fCB7fSxcbiAgICAgIGJsb2NrS2V5d29yZHMgPSBwYXJzZXJDb25maWcuYmxvY2tLZXl3b3JkcyB8fCB7fSxcbiAgICAgIGF0b21zID0gcGFyc2VyQ29uZmlnLmF0b21zIHx8IHt9LFxuICAgICAgaG9va3MgPSBwYXJzZXJDb25maWcuaG9va3MgfHwge30sXG4gICAgICBtdWx0aUxpbmVTdHJpbmdzID0gcGFyc2VyQ29uZmlnLm11bHRpTGluZVN0cmluZ3M7XG4gIHZhciBpc09wZXJhdG9yQ2hhciA9IC9bK1xcLSomJT08PiE/fFxcL10vO1xuXG4gIHZhciBjdXJQdW5jO1xuXG4gIGZ1bmN0aW9uIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGNoID0gc3RyZWFtLm5leHQoKTtcbiAgICBpZiAoaG9va3NbY2hdKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gaG9va3NbY2hdKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgaWYgKHJlc3VsdCAhPT0gZmFsc2UpIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmIChjaCA9PSAnXCInIHx8IGNoID09IFwiJ1wiIHx8IGNoID09IFwiYFwiKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuU3RyaW5nKGNoKTtcbiAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gICAgaWYgKC9bXFxbXFxde31cXChcXCksO1xcOlxcLl0vLnRlc3QoY2gpKSB7XG4gICAgICBjdXJQdW5jID0gY2g7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKC9cXGQvLnRlc3QoY2gpKSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXC5dLyk7XG4gICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICB9XG4gICAgaWYgKGNoID09IFwiL1wiKSB7XG4gICAgICBpZiAoc3RyZWFtLmVhdChcIitcIikpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbk5lc3RlZENvbW1lbnQ7XG4gICAgICAgIHJldHVybiB0b2tlbk5lc3RlZENvbW1lbnQoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyZWFtLmVhdChcIipcIikpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkNvbW1lbnQ7XG4gICAgICAgIHJldHVybiB0b2tlbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyZWFtLmVhdChcIi9cIikpIHtcbiAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc09wZXJhdG9yQ2hhci50ZXN0KGNoKSkge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKGlzT3BlcmF0b3JDaGFyKTtcbiAgICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gICAgfVxuICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcJF9cXHhhMS1cXHVmZmZmXS8pO1xuICAgIHZhciBjdXIgPSBzdHJlYW0uY3VycmVudCgpO1xuICAgIGlmIChrZXl3b3Jkcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSB7XG4gICAgICBpZiAoYmxvY2tLZXl3b3Jkcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSBjdXJQdW5jID0gXCJuZXdzdGF0ZW1lbnRcIjtcbiAgICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgICB9XG4gICAgaWYgKGJ1aWx0aW4ucHJvcGVydHlJc0VudW1lcmFibGUoY3VyKSkge1xuICAgICAgaWYgKGJsb2NrS2V5d29yZHMucHJvcGVydHlJc0VudW1lcmFibGUoY3VyKSkgY3VyUHVuYyA9IFwibmV3c3RhdGVtZW50XCI7XG4gICAgICByZXR1cm4gXCJidWlsdGluXCI7XG4gICAgfVxuICAgIGlmIChhdG9tcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSByZXR1cm4gXCJhdG9tXCI7XG4gICAgcmV0dXJuIFwidmFyaWFibGVcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuU3RyaW5nKHF1b3RlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBlc2NhcGVkID0gZmFsc2UsIG5leHQsIGVuZCA9IGZhbHNlO1xuICAgICAgd2hpbGUgKChuZXh0ID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgICBpZiAobmV4dCA9PSBxdW90ZSAmJiAhZXNjYXBlZCkge2VuZCA9IHRydWU7IGJyZWFrO31cbiAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkICYmIG5leHQgPT0gXCJcXFxcXCI7XG4gICAgICB9XG4gICAgICBpZiAoZW5kIHx8ICEoZXNjYXBlZCB8fCBtdWx0aUxpbmVTdHJpbmdzKSlcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSBudWxsO1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIG1heWJlRW5kID0gZmFsc2UsIGNoO1xuICAgIHdoaWxlIChjaCA9IHN0cmVhbS5uZXh0KCkpIHtcbiAgICAgIGlmIChjaCA9PSBcIi9cIiAmJiBtYXliZUVuZCkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbWF5YmVFbmQgPSAoY2ggPT0gXCIqXCIpO1xuICAgIH1cbiAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlbk5lc3RlZENvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBtYXliZUVuZCA9IGZhbHNlLCBjaDtcbiAgICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgICBpZiAoY2ggPT0gXCIvXCIgJiYgbWF5YmVFbmQpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG1heWJlRW5kID0gKGNoID09IFwiK1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dChpbmRlbnRlZCwgY29sdW1uLCB0eXBlLCBhbGlnbiwgcHJldikge1xuICAgIHRoaXMuaW5kZW50ZWQgPSBpbmRlbnRlZDtcbiAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuYWxpZ24gPSBhbGlnbjtcbiAgICB0aGlzLnByZXYgPSBwcmV2O1xuICB9XG4gIGZ1bmN0aW9uIHB1c2hDb250ZXh0KHN0YXRlLCBjb2wsIHR5cGUpIHtcbiAgICB2YXIgaW5kZW50ID0gc3RhdGUuaW5kZW50ZWQ7XG4gICAgaWYgKHN0YXRlLmNvbnRleHQgJiYgc3RhdGUuY29udGV4dC50eXBlID09IFwic3RhdGVtZW50XCIpXG4gICAgICBpbmRlbnQgPSBzdGF0ZS5jb250ZXh0LmluZGVudGVkO1xuICAgIHJldHVybiBzdGF0ZS5jb250ZXh0ID0gbmV3IENvbnRleHQoaW5kZW50LCBjb2wsIHR5cGUsIG51bGwsIHN0YXRlLmNvbnRleHQpO1xuICB9XG4gIGZ1bmN0aW9uIHBvcENvbnRleHQoc3RhdGUpIHtcbiAgICB2YXIgdCA9IHN0YXRlLmNvbnRleHQudHlwZTtcbiAgICBpZiAodCA9PSBcIilcIiB8fCB0ID09IFwiXVwiIHx8IHQgPT0gXCJ9XCIpXG4gICAgICBzdGF0ZS5pbmRlbnRlZCA9IHN0YXRlLmNvbnRleHQuaW5kZW50ZWQ7XG4gICAgcmV0dXJuIHN0YXRlLmNvbnRleHQgPSBzdGF0ZS5jb250ZXh0LnByZXY7XG4gIH1cblxuICAvLyBJbnRlcmZhY2VcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKGJhc2Vjb2x1bW4pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRva2VuaXplOiBudWxsLFxuICAgICAgICBjb250ZXh0OiBuZXcgQ29udGV4dCgoYmFzZWNvbHVtbiB8fCAwKSAtIGluZGVudFVuaXQsIDAsIFwidG9wXCIsIGZhbHNlKSxcbiAgICAgICAgaW5kZW50ZWQ6IDAsXG4gICAgICAgIHN0YXJ0T2ZMaW5lOiB0cnVlXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIGN0eCA9IHN0YXRlLmNvbnRleHQ7XG4gICAgICBpZiAoc3RyZWFtLnNvbCgpKSB7XG4gICAgICAgIGlmIChjdHguYWxpZ24gPT0gbnVsbCkgY3R4LmFsaWduID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmluZGVudGVkID0gc3RyZWFtLmluZGVudGF0aW9uKCk7XG4gICAgICAgIHN0YXRlLnN0YXJ0T2ZMaW5lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkgcmV0dXJuIG51bGw7XG4gICAgICBjdXJQdW5jID0gbnVsbDtcbiAgICAgIHZhciBzdHlsZSA9IChzdGF0ZS50b2tlbml6ZSB8fCB0b2tlbkJhc2UpKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgaWYgKHN0eWxlID09IFwiY29tbWVudFwiIHx8IHN0eWxlID09IFwibWV0YVwiKSByZXR1cm4gc3R5bGU7XG4gICAgICBpZiAoY3R4LmFsaWduID09IG51bGwpIGN0eC5hbGlnbiA9IHRydWU7XG5cbiAgICAgIGlmICgoY3VyUHVuYyA9PSBcIjtcIiB8fCBjdXJQdW5jID09IFwiOlwiIHx8IGN1clB1bmMgPT0gXCIsXCIpICYmIGN0eC50eXBlID09IFwic3RhdGVtZW50XCIpIHBvcENvbnRleHQoc3RhdGUpO1xuICAgICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBcIntcIikgcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbS5jb2x1bW4oKSwgXCJ9XCIpO1xuICAgICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBcIltcIikgcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbS5jb2x1bW4oKSwgXCJdXCIpO1xuICAgICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBcIihcIikgcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbS5jb2x1bW4oKSwgXCIpXCIpO1xuICAgICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBcIn1cIikge1xuICAgICAgICB3aGlsZSAoY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIikgY3R4ID0gcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICAgIGlmIChjdHgudHlwZSA9PSBcIn1cIikgY3R4ID0gcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICAgIHdoaWxlIChjdHgudHlwZSA9PSBcInN0YXRlbWVudFwiKSBjdHggPSBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGN1clB1bmMgPT0gY3R4LnR5cGUpIHBvcENvbnRleHQoc3RhdGUpO1xuICAgICAgZWxzZSBpZiAoKChjdHgudHlwZSA9PSBcIn1cIiB8fCBjdHgudHlwZSA9PSBcInRvcFwiKSAmJiBjdXJQdW5jICE9ICc7JykgfHwgKGN0eC50eXBlID09IFwic3RhdGVtZW50XCIgJiYgY3VyUHVuYyA9PSBcIm5ld3N0YXRlbWVudFwiKSlcbiAgICAgICAgcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbS5jb2x1bW4oKSwgXCJzdGF0ZW1lbnRcIik7XG4gICAgICBzdGF0ZS5zdGFydE9mTGluZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH0sXG5cbiAgICBpbmRlbnQ6IGZ1bmN0aW9uKHN0YXRlLCB0ZXh0QWZ0ZXIpIHtcbiAgICAgIGlmIChzdGF0ZS50b2tlbml6ZSAhPSB0b2tlbkJhc2UgJiYgc3RhdGUudG9rZW5pemUgIT0gbnVsbCkgcmV0dXJuIENvZGVNaXJyb3IuUGFzcztcbiAgICAgIHZhciBjdHggPSBzdGF0ZS5jb250ZXh0LCBmaXJzdENoYXIgPSB0ZXh0QWZ0ZXIgJiYgdGV4dEFmdGVyLmNoYXJBdCgwKTtcbiAgICAgIGlmIChjdHgudHlwZSA9PSBcInN0YXRlbWVudFwiICYmIGZpcnN0Q2hhciA9PSBcIn1cIikgY3R4ID0gY3R4LnByZXY7XG4gICAgICB2YXIgY2xvc2luZyA9IGZpcnN0Q2hhciA9PSBjdHgudHlwZTtcbiAgICAgIGlmIChjdHgudHlwZSA9PSBcInN0YXRlbWVudFwiKSByZXR1cm4gY3R4LmluZGVudGVkICsgKGZpcnN0Q2hhciA9PSBcIntcIiA/IDAgOiBzdGF0ZW1lbnRJbmRlbnRVbml0KTtcbiAgICAgIGVsc2UgaWYgKGN0eC5hbGlnbikgcmV0dXJuIGN0eC5jb2x1bW4gKyAoY2xvc2luZyA/IDAgOiAxKTtcbiAgICAgIGVsc2UgcmV0dXJuIGN0eC5pbmRlbnRlZCArIChjbG9zaW5nID8gMCA6IGluZGVudFVuaXQpO1xuICAgIH0sXG5cbiAgICBlbGVjdHJpY0NoYXJzOiBcInt9XCIsXG4gICAgYmxvY2tDb21tZW50U3RhcnQ6IFwiLypcIixcbiAgICBibG9ja0NvbW1lbnRFbmQ6IFwiKi9cIixcbiAgICBibG9ja0NvbW1lbnRDb250aW51ZTogXCIgKiBcIixcbiAgICBsaW5lQ29tbWVudDogXCIvL1wiLFxuICAgIGZvbGQ6IFwiYnJhY2VcIlxuICB9O1xufSk7XG5cbiAgZnVuY3Rpb24gd29yZHMoc3RyKSB7XG4gICAgdmFyIG9iaiA9IHt9LCB3b3JkcyA9IHN0ci5zcGxpdChcIiBcIik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7ICsraSkgb2JqW3dvcmRzW2ldXSA9IHRydWU7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciBibG9ja0tleXdvcmRzID0gXCJib2R5IGNhdGNoIGNsYXNzIGRvIGVsc2UgZW51bSBmb3IgZm9yZWFjaCBmb3JlYWNoX3JldmVyc2UgaWYgaW4gaW50ZXJmYWNlIG1peGluIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICBcIm91dCBzY29wZSBzdHJ1Y3Qgc3dpdGNoIHRyeSB1bmlvbiB1bml0dGVzdCB2ZXJzaW9uIHdoaWxlIHdpdGhcIjtcblxuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3gtZFwiLCB7XG4gICAgbmFtZTogXCJkXCIsXG4gICAga2V5d29yZHM6IHdvcmRzKFwiYWJzdHJhY3QgYWxpYXMgYWxpZ24gYXNtIGFzc2VydCBhdXRvIGJyZWFrIGNhc2UgY2FzdCBjZG91YmxlIGNlbnQgY2Zsb2F0IGNvbnN0IGNvbnRpbnVlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJkZWJ1ZyBkZWZhdWx0IGRlbGVnYXRlIGRlbGV0ZSBkZXByZWNhdGVkIGV4cG9ydCBleHRlcm4gZmluYWwgZmluYWxseSBmdW5jdGlvbiBnb3RvIGltbXV0YWJsZSBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiaW1wb3J0IGlub3V0IGludmFyaWFudCBpcyBsYXp5IG1hY3JvIG1vZHVsZSBuZXcgbm90aHJvdyBvdmVycmlkZSBwYWNrYWdlIHByYWdtYSBwcml2YXRlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJwcm90ZWN0ZWQgcHVibGljIHB1cmUgcmVmIHJldHVybiBzaGFyZWQgc2hvcnQgc3RhdGljIHN1cGVyIHN5bmNocm9uaXplZCB0ZW1wbGF0ZSB0aGlzIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJ0aHJvdyB0eXBlZGVmIHR5cGVpZCB0eXBlb2Ygdm9sYXRpbGUgX19GSUxFX18gX19MSU5FX18gX19nc2hhcmVkIF9fdHJhaXRzIF9fdmVjdG9yIF9fcGFyYW1ldGVycyBcIiArXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrS2V5d29yZHMpLFxuICAgIGJsb2NrS2V5d29yZHM6IHdvcmRzKGJsb2NrS2V5d29yZHMpLFxuICAgIGJ1aWx0aW46IHdvcmRzKFwiYm9vbCBieXRlIGNoYXIgY3JlYWwgZGNoYXIgZG91YmxlIGZsb2F0IGlkb3VibGUgaWZsb2F0IGludCBpcmVhbCBsb25nIHJlYWwgc2hvcnQgdWJ5dGUgXCIgK1xuICAgICAgICAgICAgICAgICAgIFwidWNlbnQgdWludCB1bG9uZyB1c2hvcnQgd2NoYXIgd3N0cmluZyB2b2lkIHNpemVfdCBzaXplZGlmZl90XCIpLFxuICAgIGF0b21zOiB3b3JkcyhcImV4aXQgZmFpbHVyZSBzdWNjZXNzIHRydWUgZmFsc2UgbnVsbFwiKSxcbiAgICBob29rczoge1xuICAgICAgXCJAXCI6IGZ1bmN0aW9uKHN0cmVhbSwgX3N0YXRlKSB7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcJF9dLyk7XG4gICAgICAgIHJldHVybiBcIm1ldGFcIjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIiksIHJlcXVpcmUoXCIuLi9jbGlrZS9jbGlrZVwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiLCBcIi4uL2NsaWtlL2NsaWtlXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIga2V5d29yZHMgPSAoXCJ0aGlzIHN1cGVyIHN0YXRpYyBmaW5hbCBjb25zdCBhYnN0cmFjdCBjbGFzcyBleHRlbmRzIGV4dGVybmFsIGZhY3RvcnkgXCIgK1xuICAgIFwiaW1wbGVtZW50cyBtaXhpbiBnZXQgbmF0aXZlIHNldCB0eXBlZGVmIHdpdGggZW51bSB0aHJvdyByZXRocm93IFwiICtcbiAgICBcImFzc2VydCBicmVhayBjYXNlIGNvbnRpbnVlIGRlZmF1bHQgaW4gcmV0dXJuIG5ldyBkZWZlcnJlZCBhc3luYyBhd2FpdCBjb3ZhcmlhbnQgXCIgK1xuICAgIFwidHJ5IGNhdGNoIGZpbmFsbHkgZG8gZWxzZSBmb3IgaWYgc3dpdGNoIHdoaWxlIGltcG9ydCBsaWJyYXJ5IGV4cG9ydCBcIiArXG4gICAgXCJwYXJ0IG9mIHNob3cgaGlkZSBpcyBhcyBleHRlbnNpb24gb24geWllbGQgbGF0ZSByZXF1aXJlZFwiKS5zcGxpdChcIiBcIik7XG4gIHZhciBibG9ja0tleXdvcmRzID0gXCJ0cnkgY2F0Y2ggZmluYWxseSBkbyBlbHNlIGZvciBpZiBzd2l0Y2ggd2hpbGVcIi5zcGxpdChcIiBcIik7XG4gIHZhciBhdG9tcyA9IFwidHJ1ZSBmYWxzZSBudWxsXCIuc3BsaXQoXCIgXCIpO1xuICB2YXIgYnVpbHRpbnMgPSBcInZvaWQgYm9vbCBudW0gaW50IGRvdWJsZSBkeW5hbWljIHZhciBTdHJpbmcgTnVsbCBOZXZlclwiLnNwbGl0KFwiIFwiKTtcblxuICBmdW5jdGlvbiBzZXQod29yZHMpIHtcbiAgICB2YXIgb2JqID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7ICsraSkgb2JqW3dvcmRzW2ldXSA9IHRydWU7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hJbnRlcnBvbGF0aW9uU3RhY2soc3RhdGUpIHtcbiAgICAoc3RhdGUuaW50ZXJwb2xhdGlvblN0YWNrIHx8IChzdGF0ZS5pbnRlcnBvbGF0aW9uU3RhY2sgPSBbXSkpLnB1c2goc3RhdGUudG9rZW5pemUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wSW50ZXJwb2xhdGlvblN0YWNrKHN0YXRlKSB7XG4gICAgcmV0dXJuIChzdGF0ZS5pbnRlcnBvbGF0aW9uU3RhY2sgfHwgKHN0YXRlLmludGVycG9sYXRpb25TdGFjayA9IFtdKSkucG9wKCk7XG4gIH1cblxuICBmdW5jdGlvbiBzaXplSW50ZXJwb2xhdGlvblN0YWNrKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLmludGVycG9sYXRpb25TdGFjayA/IHN0YXRlLmludGVycG9sYXRpb25TdGFjay5sZW5ndGggOiAwO1xuICB9XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwiYXBwbGljYXRpb24vZGFydFwiLCB7XG4gICAgbmFtZTogXCJjbGlrZVwiLFxuICAgIGtleXdvcmRzOiBzZXQoa2V5d29yZHMpLFxuICAgIGJsb2NrS2V5d29yZHM6IHNldChibG9ja0tleXdvcmRzKSxcbiAgICBidWlsdGluOiBzZXQoYnVpbHRpbnMpLFxuICAgIGF0b21zOiBzZXQoYXRvbXMpLFxuICAgIGhvb2tzOiB7XG4gICAgICBcIkBcIjogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcJF9cXC5dLyk7XG4gICAgICAgIHJldHVybiBcIm1ldGFcIjtcbiAgICAgIH0sXG5cbiAgICAgIC8vIGN1c3RvbSBzdHJpbmcgaGFuZGxpbmcgdG8gZGVhbCB3aXRoIHRyaXBsZS1xdW90ZWQgc3RyaW5ncyBhbmQgc3RyaW5nIGludGVycG9sYXRpb25cbiAgICAgIFwiJ1wiOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIHJldHVybiB0b2tlblN0cmluZyhcIidcIiwgc3RyZWFtLCBzdGF0ZSwgZmFsc2UpO1xuICAgICAgfSxcbiAgICAgIFwiXFxcIlwiOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIHJldHVybiB0b2tlblN0cmluZyhcIlxcXCJcIiwgc3RyZWFtLCBzdGF0ZSwgZmFsc2UpO1xuICAgICAgfSxcbiAgICAgIFwiclwiOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIHZhciBwZWVrID0gc3RyZWFtLnBlZWsoKTtcbiAgICAgICAgaWYgKHBlZWsgPT0gXCInXCIgfHwgcGVlayA9PSBcIlxcXCJcIikge1xuICAgICAgICAgIHJldHVybiB0b2tlblN0cmluZyhzdHJlYW0ubmV4dCgpLCBzdHJlYW0sIHN0YXRlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuXG4gICAgICBcIn1cIjogZnVuY3Rpb24oX3N0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgLy8gXCJ9XCIgaXMgZW5kIG9mIGludGVycG9sYXRpb24sIGlmIGludGVycG9sYXRpb24gc3RhY2sgaXMgbm9uLWVtcHR5XG4gICAgICAgIGlmIChzaXplSW50ZXJwb2xhdGlvblN0YWNrKHN0YXRlKSA+IDApIHtcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHBvcEludGVycG9sYXRpb25TdGFjayhzdGF0ZSk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcblxuICAgICAgXCIvXCI6IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgaWYgKCFzdHJlYW0uZWF0KFwiKlwiKSkgcmV0dXJuIGZhbHNlXG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5OZXN0ZWRDb21tZW50KDEpXG4gICAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKVxuICAgICAgfSxcbiAgICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIF8sIHN0eWxlKSB7XG4gICAgICAgIGlmIChzdHlsZSA9PSBcInZhcmlhYmxlXCIpIHtcbiAgICAgICAgICAvLyBBc3N1bWUgdXBwZXJjYXNlIHN5bWJvbHMgYXJlIGNsYXNzZXMgdXNpbmcgdmFyaWFibGUtMlxuICAgICAgICAgIHZhciBpc1VwcGVyID0gUmVnRXhwKCdeW18kXSpbQS1aXVthLXpBLVowLTlfJF0qJCcsJ2cnKTtcbiAgICAgICAgICBpZiAoaXNVcHBlci50ZXN0KHN0cmVhbS5jdXJyZW50KCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3ZhcmlhYmxlLTInO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gdG9rZW5TdHJpbmcocXVvdGUsIHN0cmVhbSwgc3RhdGUsIHJhdykge1xuICAgIHZhciB0cmlwbGVRdW90ZWQgPSBmYWxzZTtcbiAgICBpZiAoc3RyZWFtLmVhdChxdW90ZSkpIHtcbiAgICAgIGlmIChzdHJlYW0uZWF0KHF1b3RlKSkgdHJpcGxlUXVvdGVkID0gdHJ1ZTtcbiAgICAgIGVsc2UgcmV0dXJuIFwic3RyaW5nXCI7IC8vZW1wdHkgc3RyaW5nXG4gICAgfVxuICAgIGZ1bmN0aW9uIHRva2VuU3RyaW5nSGVscGVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBlc2NhcGVkID0gZmFsc2U7XG4gICAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuICAgICAgICBpZiAoIXJhdyAmJiAhZXNjYXBlZCAmJiBzdHJlYW0ucGVlaygpID09IFwiJFwiKSB7XG4gICAgICAgICAgcHVzaEludGVycG9sYXRpb25TdGFjayhzdGF0ZSk7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkludGVycG9sYXRpb247XG4gICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5leHQgPSBzdHJlYW0ubmV4dCgpO1xuICAgICAgICBpZiAobmV4dCA9PSBxdW90ZSAmJiAhZXNjYXBlZCAmJiAoIXRyaXBsZVF1b3RlZCB8fCBzdHJlYW0ubWF0Y2gocXVvdGUgKyBxdW90ZSkpKSB7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVzY2FwZWQgPSAhcmF3ICYmICFlc2NhcGVkICYmIG5leHQgPT0gXCJcXFxcXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICB9XG4gICAgc3RhdGUudG9rZW5pemUgPSB0b2tlblN0cmluZ0hlbHBlcjtcbiAgICByZXR1cm4gdG9rZW5TdHJpbmdIZWxwZXIoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlbkludGVycG9sYXRpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIHN0cmVhbS5lYXQoXCIkXCIpO1xuICAgIGlmIChzdHJlYW0uZWF0KFwie1wiKSkge1xuICAgICAgLy8gbGV0IGNsaWtlIGhhbmRsZSB0aGUgY29udGVudCBvZiAkey4uLn0sXG4gICAgICAvLyB3ZSB0YWtlIG92ZXIgYWdhaW4gd2hlbiBcIn1cIiBhcHBlYXJzIChzZWUgaG9va3MpLlxuICAgICAgc3RhdGUudG9rZW5pemUgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuSW50ZXJwb2xhdGlvbklkZW50aWZpZXI7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5JbnRlcnBvbGF0aW9uSWRlbnRpZmllcihzdHJlYW0sIHN0YXRlKSB7XG4gICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3X10vKTtcbiAgICBzdGF0ZS50b2tlbml6ZSA9IHBvcEludGVycG9sYXRpb25TdGFjayhzdGF0ZSk7XG4gICAgcmV0dXJuIFwidmFyaWFibGVcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuTmVzdGVkQ29tbWVudChkZXB0aCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIGNoXG4gICAgICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgICAgIGlmIChjaCA9PSBcIipcIiAmJiBzdHJlYW0uZWF0KFwiL1wiKSkge1xuICAgICAgICAgIGlmIChkZXB0aCA9PSAxKSB7XG4gICAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IG51bGxcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5OZXN0ZWRDb21tZW50KGRlcHRoIC0gMSlcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PSBcIi9cIiAmJiBzdHJlYW0uZWF0KFwiKlwiKSkge1xuICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5OZXN0ZWRDb21tZW50KGRlcHRoICsgMSlcbiAgICAgICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFwiY29tbWVudFwiXG4gICAgfVxuICB9XG5cbiAgQ29kZU1pcnJvci5yZWdpc3RlckhlbHBlcihcImhpbnRXb3Jkc1wiLCBcImFwcGxpY2F0aW9uL2RhcnRcIiwga2V5d29yZHMuY29uY2F0KGF0b21zKS5jb25jYXQoYnVpbHRpbnMpKTtcblxuICAvLyBUaGlzIGlzIG5lZWRlZCB0byBtYWtlIGxvYWRpbmcgdGhyb3VnaCBtZXRhLmpzIHdvcmsuXG4gIENvZGVNaXJyb3IuZGVmaW5lTW9kZShcImRhcnRcIiwgZnVuY3Rpb24oY29uZikge1xuICAgIHJldHVybiBDb2RlTWlycm9yLmdldE1vZGUoY29uZiwgXCJhcHBsaWNhdGlvbi9kYXJ0XCIpO1xuICB9LCBcImNsaWtlXCIpO1xufSk7XG4iLCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTW9kZShcImRpZmZcIiwgZnVuY3Rpb24oKSB7XG5cbiAgdmFyIFRPS0VOX05BTUVTID0ge1xuICAgICcrJzogJ3Bvc2l0aXZlJyxcbiAgICAnLSc6ICduZWdhdGl2ZScsXG4gICAgJ0AnOiAnbWV0YSdcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgIHZhciB0d19wb3MgPSBzdHJlYW0uc3RyaW5nLnNlYXJjaCgvW1xcdCBdKz8kLyk7XG5cbiAgICAgIGlmICghc3RyZWFtLnNvbCgpIHx8IHR3X3BvcyA9PT0gMCkge1xuICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgIHJldHVybiAoXCJlcnJvciBcIiArIChcbiAgICAgICAgICBUT0tFTl9OQU1FU1tzdHJlYW0uc3RyaW5nLmNoYXJBdCgwKV0gfHwgJycpKS5yZXBsYWNlKC8gJC8sICcnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRva2VuX25hbWUgPSBUT0tFTl9OQU1FU1tzdHJlYW0ucGVlaygpXSB8fCBzdHJlYW0uc2tpcFRvRW5kKCk7XG5cbiAgICAgIGlmICh0d19wb3MgPT09IC0xKSB7XG4gICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmVhbS5wb3MgPSB0d19wb3M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0b2tlbl9uYW1lO1xuICAgIH1cbiAgfTtcbn0pO1xuXG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3gtZGlmZlwiLCBcImRpZmZcIik7XG5cbn0pO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSwgcmVxdWlyZShcIi4uL2h0bWxtaXhlZC9odG1sbWl4ZWRcIiksXG4gICAgICAgIHJlcXVpcmUoXCIuLi8uLi9hZGRvbi9tb2RlL292ZXJsYXlcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIiwgXCIuLi9odG1sbWl4ZWQvaHRtbG1peGVkXCIsXG4gICAgICAgICAgICBcIi4uLy4uL2FkZG9uL21vZGUvb3ZlcmxheVwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwiZGphbmdvOmlubmVyXCIsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBrZXl3b3JkcyA9IFtcImJsb2NrXCIsIFwiZW5kYmxvY2tcIiwgXCJmb3JcIiwgXCJlbmRmb3JcIiwgXCJ0cnVlXCIsIFwiZmFsc2VcIiwgXCJmaWx0ZXJcIiwgXCJlbmRmaWx0ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJsb29wXCIsIFwibm9uZVwiLCBcInNlbGZcIiwgXCJzdXBlclwiLCBcImlmXCIsIFwiZWxpZlwiLCBcImVuZGlmXCIsIFwiYXNcIiwgXCJlbHNlXCIsIFwiaW1wb3J0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwid2l0aFwiLCBcImVuZHdpdGhcIiwgXCJ3aXRob3V0XCIsIFwiY29udGV4dFwiLCBcImlmZXF1YWxcIiwgXCJlbmRpZmVxdWFsXCIsIFwiaWZub3RlcXVhbFwiLFxuICAgICAgICAgICAgICAgICAgICBcImVuZGlmbm90ZXF1YWxcIiwgXCJleHRlbmRzXCIsIFwiaW5jbHVkZVwiLCBcImxvYWRcIiwgXCJjb21tZW50XCIsIFwiZW5kY29tbWVudFwiLFxuICAgICAgICAgICAgICAgICAgICBcImVtcHR5XCIsIFwidXJsXCIsIFwic3RhdGljXCIsIFwidHJhbnNcIiwgXCJibG9ja3RyYW5zXCIsIFwiZW5kYmxvY2t0cmFuc1wiLCBcIm5vd1wiLFxuICAgICAgICAgICAgICAgICAgICBcInJlZ3JvdXBcIiwgXCJsb3JlbVwiLCBcImlmY2hhbmdlZFwiLCBcImVuZGlmY2hhbmdlZFwiLCBcImZpcnN0b2ZcIiwgXCJkZWJ1Z1wiLCBcImN5Y2xlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY3NyZl90b2tlblwiLCBcImF1dG9lc2NhcGVcIiwgXCJlbmRhdXRvZXNjYXBlXCIsIFwic3BhY2VsZXNzXCIsIFwiZW5kc3BhY2VsZXNzXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3NpXCIsIFwidGVtcGxhdGV0YWdcIiwgXCJ2ZXJiYXRpbVwiLCBcImVuZHZlcmJhdGltXCIsIFwid2lkdGhyYXRpb1wiXSxcbiAgICAgICAgZmlsdGVycyA9IFtcImFkZFwiLCBcImFkZHNsYXNoZXNcIiwgXCJjYXBmaXJzdFwiLCBcImNlbnRlclwiLCBcImN1dFwiLCBcImRhdGVcIixcbiAgICAgICAgICAgICAgICAgICBcImRlZmF1bHRcIiwgXCJkZWZhdWx0X2lmX25vbmVcIiwgXCJkaWN0c29ydFwiLFxuICAgICAgICAgICAgICAgICAgIFwiZGljdHNvcnRyZXZlcnNlZFwiLCBcImRpdmlzaWJsZWJ5XCIsIFwiZXNjYXBlXCIsIFwiZXNjYXBlanNcIixcbiAgICAgICAgICAgICAgICAgICBcImZpbGVzaXplZm9ybWF0XCIsIFwiZmlyc3RcIiwgXCJmbG9hdGZvcm1hdFwiLCBcImZvcmNlX2VzY2FwZVwiLFxuICAgICAgICAgICAgICAgICAgIFwiZ2V0X2RpZ2l0XCIsIFwiaXJpZW5jb2RlXCIsIFwiam9pblwiLCBcImxhc3RcIiwgXCJsZW5ndGhcIixcbiAgICAgICAgICAgICAgICAgICBcImxlbmd0aF9pc1wiLCBcImxpbmVicmVha3NcIiwgXCJsaW5lYnJlYWtzYnJcIiwgXCJsaW5lbnVtYmVyc1wiLFxuICAgICAgICAgICAgICAgICAgIFwibGp1c3RcIiwgXCJsb3dlclwiLCBcIm1ha2VfbGlzdFwiLCBcInBob25lMm51bWVyaWNcIiwgXCJwbHVyYWxpemVcIixcbiAgICAgICAgICAgICAgICAgICBcInBwcmludFwiLCBcInJhbmRvbVwiLCBcInJlbW92ZXRhZ3NcIiwgXCJyanVzdFwiLCBcInNhZmVcIixcbiAgICAgICAgICAgICAgICAgICBcInNhZmVzZXFcIiwgXCJzbGljZVwiLCBcInNsdWdpZnlcIiwgXCJzdHJpbmdmb3JtYXRcIiwgXCJzdHJpcHRhZ3NcIixcbiAgICAgICAgICAgICAgICAgICBcInRpbWVcIiwgXCJ0aW1lc2luY2VcIiwgXCJ0aW1ldW50aWxcIiwgXCJ0aXRsZVwiLCBcInRydW5jYXRlY2hhcnNcIixcbiAgICAgICAgICAgICAgICAgICBcInRydW5jYXRlY2hhcnNfaHRtbFwiLCBcInRydW5jYXRld29yZHNcIiwgXCJ0cnVuY2F0ZXdvcmRzX2h0bWxcIixcbiAgICAgICAgICAgICAgICAgICBcInVub3JkZXJlZF9saXN0XCIsIFwidXBwZXJcIiwgXCJ1cmxlbmNvZGVcIiwgXCJ1cmxpemVcIixcbiAgICAgICAgICAgICAgICAgICBcInVybGl6ZXRydW5jXCIsIFwid29yZGNvdW50XCIsIFwid29yZHdyYXBcIiwgXCJ5ZXNub1wiXSxcbiAgICAgICAgb3BlcmF0b3JzID0gW1wiPT1cIiwgXCIhPVwiLCBcIjxcIiwgXCI+XCIsIFwiPD1cIiwgXCI+PVwiXSxcbiAgICAgICAgd29yZE9wZXJhdG9ycyA9IFtcImluXCIsIFwibm90XCIsIFwib3JcIiwgXCJhbmRcIl07XG5cbiAgICBrZXl3b3JkcyA9IG5ldyBSZWdFeHAoXCJeXFxcXGIoXCIgKyBrZXl3b3Jkcy5qb2luKFwifFwiKSArIFwiKVxcXFxiXCIpO1xuICAgIGZpbHRlcnMgPSBuZXcgUmVnRXhwKFwiXlxcXFxiKFwiICsgZmlsdGVycy5qb2luKFwifFwiKSArIFwiKVxcXFxiXCIpO1xuICAgIG9wZXJhdG9ycyA9IG5ldyBSZWdFeHAoXCJeXFxcXGIoXCIgKyBvcGVyYXRvcnMuam9pbihcInxcIikgKyBcIilcXFxcYlwiKTtcbiAgICB3b3JkT3BlcmF0b3JzID0gbmV3IFJlZ0V4cChcIl5cXFxcYihcIiArIHdvcmRPcGVyYXRvcnMuam9pbihcInxcIikgKyBcIilcXFxcYlwiKTtcblxuICAgIC8vIFdlIGhhdmUgdG8gcmV0dXJuIFwibnVsbFwiIGluc3RlYWQgb2YgbnVsbCwgaW4gb3JkZXIgdG8gYXZvaWQgc3RyaW5nXG4gICAgLy8gc3R5bGluZyBhcyB0aGUgZGVmYXVsdCwgd2hlbiB1c2luZyBEamFuZ28gdGVtcGxhdGVzIGluc2lkZSBIVE1MXG4gICAgLy8gZWxlbWVudCBhdHRyaWJ1dGVzXG4gICAgZnVuY3Rpb24gdG9rZW5CYXNlIChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAvLyBBdHRlbXB0IHRvIGlkZW50aWZ5IGEgdmFyaWFibGUsIHRlbXBsYXRlIG9yIGNvbW1lbnQgdGFnIHJlc3BlY3RpdmVseVxuICAgICAgaWYgKHN0cmVhbS5tYXRjaChcInt7XCIpKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gaW5WYXJpYWJsZTtcbiAgICAgICAgcmV0dXJuIFwidGFnXCI7XG4gICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaChcInslXCIpKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gaW5UYWc7XG4gICAgICAgIHJldHVybiBcInRhZ1wiO1xuICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goXCJ7I1wiKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IGluQ29tbWVudDtcbiAgICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgICAgfVxuXG4gICAgICAvLyBJZ25vcmUgY29tcGxldGVseSBhbnkgc3RyZWFtIHNlcmllcyB0aGF0IGRvIG5vdCBtYXRjaCB0aGVcbiAgICAgIC8vIERqYW5nbyB0ZW1wbGF0ZSBvcGVuaW5nIHRhZ3MuXG4gICAgICB3aGlsZSAoc3RyZWFtLm5leHQoKSAhPSBudWxsICYmICFzdHJlYW0ubWF0Y2goL1xce1t7JSNdLywgZmFsc2UpKSB7fVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gQSBzdHJpbmcgY2FuIGJlIGluY2x1ZGVkIGluIGVpdGhlciBzaW5nbGUgb3IgZG91YmxlIHF1b3RlcyAodGhpcyBpc1xuICAgIC8vIHRoZSBkZWxpbWl0ZXIpLiBNYXJrIGV2ZXJ5dGhpbmcgYXMgYSBzdHJpbmcgdW50aWwgdGhlIHN0YXJ0IGRlbGltaXRlclxuICAgIC8vIG9jY3VycyBhZ2Fpbi5cbiAgICBmdW5jdGlvbiBpblN0cmluZyAoZGVsaW1pdGVyLCBwcmV2aW91c1Rva2VuaXplcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIGlmICghc3RhdGUuZXNjYXBlTmV4dCAmJiBzdHJlYW0uZWF0KGRlbGltaXRlcikpIHtcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHByZXZpb3VzVG9rZW5pemVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzdGF0ZS5lc2NhcGVOZXh0KSB7XG4gICAgICAgICAgICBzdGF0ZS5lc2NhcGVOZXh0ID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGNoID0gc3RyZWFtLm5leHQoKTtcblxuICAgICAgICAgIC8vIFRha2UgaW50byBhY2NvdW50IHRoZSBiYWNrc2xhc2ggZm9yIGVzY2FwaW5nIGNoYXJhY3RlcnMsIHN1Y2ggYXNcbiAgICAgICAgICAvLyB0aGUgc3RyaW5nIGRlbGltaXRlci5cbiAgICAgICAgICBpZiAoY2ggPT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgIHN0YXRlLmVzY2FwZU5leHQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBBcHBseSBEamFuZ28gdGVtcGxhdGUgdmFyaWFibGUgc3ludGF4IGhpZ2hsaWdodGluZ1xuICAgIGZ1bmN0aW9uIGluVmFyaWFibGUgKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIC8vIEF0dGVtcHQgdG8gbWF0Y2ggYSBkb3QgdGhhdCBwcmVjZWRlcyBhIHByb3BlcnR5XG4gICAgICBpZiAoc3RhdGUud2FpdERvdCkge1xuICAgICAgICBzdGF0ZS53YWl0RG90ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHN0cmVhbS5wZWVrKCkgIT0gXCIuXCIpIHtcbiAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEb3QgZm9sbG93ZWQgYnkgYSBub24td29yZCBjaGFyYWN0ZXIgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYW4gZXJyb3IuXG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2goL1xcLlxcVysvKSkge1xuICAgICAgICAgIHJldHVybiBcImVycm9yXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLmVhdChcIi5cIikpIHtcbiAgICAgICAgICBzdGF0ZS53YWl0UHJvcGVydHkgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBFcnJvciAoXCJVbmV4cGVjdGVkIGVycm9yIHdoaWxlIHdhaXRpbmcgZm9yIHByb3BlcnR5LlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBdHRlbXB0IHRvIG1hdGNoIGEgcGlwZSB0aGF0IHByZWNlZGVzIGEgZmlsdGVyXG4gICAgICBpZiAoc3RhdGUud2FpdFBpcGUpIHtcbiAgICAgICAgc3RhdGUud2FpdFBpcGUgPSBmYWxzZTtcblxuICAgICAgICBpZiAoc3RyZWFtLnBlZWsoKSAhPSBcInxcIikge1xuICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBpcGUgZm9sbG93ZWQgYnkgYSBub24td29yZCBjaGFyYWN0ZXIgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYW4gZXJyb3IuXG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2goL1xcLlxcVysvKSkge1xuICAgICAgICAgIHJldHVybiBcImVycm9yXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLmVhdChcInxcIikpIHtcbiAgICAgICAgICBzdGF0ZS53YWl0RmlsdGVyID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IgKFwiVW5leHBlY3RlZCBlcnJvciB3aGlsZSB3YWl0aW5nIGZvciBmaWx0ZXIuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEhpZ2hsaWdodCBwcm9wZXJ0aWVzXG4gICAgICBpZiAoc3RhdGUud2FpdFByb3BlcnR5KSB7XG4gICAgICAgIHN0YXRlLndhaXRQcm9wZXJ0eSA9IGZhbHNlO1xuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9cXGIoXFx3KylcXGIvKSkge1xuICAgICAgICAgIHN0YXRlLndhaXREb3QgPSB0cnVlOyAgLy8gQSBwcm9wZXJ0eSBjYW4gYmUgZm9sbG93ZWQgYnkgYW5vdGhlciBwcm9wZXJ0eVxuICAgICAgICAgIHN0YXRlLndhaXRQaXBlID0gdHJ1ZTsgIC8vIEEgcHJvcGVydHkgY2FuIGJlIGZvbGxvd2VkIGJ5IGEgZmlsdGVyXG4gICAgICAgICAgcmV0dXJuIFwicHJvcGVydHlcIjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBIaWdobGlnaHQgZmlsdGVyc1xuICAgICAgaWYgKHN0YXRlLndhaXRGaWx0ZXIpIHtcbiAgICAgICAgICBzdGF0ZS53YWl0RmlsdGVyID0gZmFsc2U7XG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2goZmlsdGVycykpIHtcbiAgICAgICAgICByZXR1cm4gXCJ2YXJpYWJsZS0yXCI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWdub3JlIGFsbCB3aGl0ZSBzcGFjZXNcbiAgICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkge1xuICAgICAgICBzdGF0ZS53YWl0UHJvcGVydHkgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgfVxuXG4gICAgICAvLyBJZGVudGlmeSBudW1iZXJzXG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC9cXGJcXGQrKFxcLlxcZCspP1xcYi8pKSB7XG4gICAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgICAgfVxuXG4gICAgICAvLyBJZGVudGlmeSBzdHJpbmdzXG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKFwiJ1wiKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IGluU3RyaW5nKFwiJ1wiLCBzdGF0ZS50b2tlbml6ZSk7XG4gICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goJ1wiJykpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSBpblN0cmluZygnXCInLCBzdGF0ZS50b2tlbml6ZSk7XG4gICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgfVxuXG4gICAgICAvLyBBdHRlbXB0IHRvIGZpbmQgdGhlIHZhcmlhYmxlXG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC9cXGIoXFx3KylcXGIvKSAmJiAhc3RhdGUuZm91bmRWYXJpYWJsZSkge1xuICAgICAgICBzdGF0ZS53YWl0RG90ID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUud2FpdFBpcGUgPSB0cnVlOyAgLy8gQSBwcm9wZXJ0eSBjYW4gYmUgZm9sbG93ZWQgYnkgYSBmaWx0ZXJcbiAgICAgICAgcmV0dXJuIFwidmFyaWFibGVcIjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgZm91bmQgY2xvc2luZyB0YWcgcmVzZXRcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goXCJ9fVwiKSkge1xuICAgICAgICBzdGF0ZS53YWl0UHJvcGVydHkgPSBudWxsO1xuICAgICAgICBzdGF0ZS53YWl0RmlsdGVyID0gbnVsbDtcbiAgICAgICAgc3RhdGUud2FpdERvdCA9IG51bGw7XG4gICAgICAgIHN0YXRlLndhaXRQaXBlID0gbnVsbDtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgIHJldHVybiBcInRhZ1wiO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCwgYWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXJcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5UYWcgKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIC8vIEF0dGVtcHQgdG8gbWF0Y2ggYSBkb3QgdGhhdCBwcmVjZWRlcyBhIHByb3BlcnR5XG4gICAgICBpZiAoc3RhdGUud2FpdERvdCkge1xuICAgICAgICBzdGF0ZS53YWl0RG90ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHN0cmVhbS5wZWVrKCkgIT0gXCIuXCIpIHtcbiAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEb3QgZm9sbG93ZWQgYnkgYSBub24td29yZCBjaGFyYWN0ZXIgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYW4gZXJyb3IuXG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2goL1xcLlxcVysvKSkge1xuICAgICAgICAgIHJldHVybiBcImVycm9yXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLmVhdChcIi5cIikpIHtcbiAgICAgICAgICBzdGF0ZS53YWl0UHJvcGVydHkgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBFcnJvciAoXCJVbmV4cGVjdGVkIGVycm9yIHdoaWxlIHdhaXRpbmcgZm9yIHByb3BlcnR5LlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBdHRlbXB0IHRvIG1hdGNoIGEgcGlwZSB0aGF0IHByZWNlZGVzIGEgZmlsdGVyXG4gICAgICBpZiAoc3RhdGUud2FpdFBpcGUpIHtcbiAgICAgICAgc3RhdGUud2FpdFBpcGUgPSBmYWxzZTtcblxuICAgICAgICBpZiAoc3RyZWFtLnBlZWsoKSAhPSBcInxcIikge1xuICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBpcGUgZm9sbG93ZWQgYnkgYSBub24td29yZCBjaGFyYWN0ZXIgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYW4gZXJyb3IuXG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2goL1xcLlxcVysvKSkge1xuICAgICAgICAgIHJldHVybiBcImVycm9yXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLmVhdChcInxcIikpIHtcbiAgICAgICAgICBzdGF0ZS53YWl0RmlsdGVyID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IgKFwiVW5leHBlY3RlZCBlcnJvciB3aGlsZSB3YWl0aW5nIGZvciBmaWx0ZXIuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEhpZ2hsaWdodCBwcm9wZXJ0aWVzXG4gICAgICBpZiAoc3RhdGUud2FpdFByb3BlcnR5KSB7XG4gICAgICAgIHN0YXRlLndhaXRQcm9wZXJ0eSA9IGZhbHNlO1xuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9cXGIoXFx3KylcXGIvKSkge1xuICAgICAgICAgIHN0YXRlLndhaXREb3QgPSB0cnVlOyAgLy8gQSBwcm9wZXJ0eSBjYW4gYmUgZm9sbG93ZWQgYnkgYW5vdGhlciBwcm9wZXJ0eVxuICAgICAgICAgIHN0YXRlLndhaXRQaXBlID0gdHJ1ZTsgIC8vIEEgcHJvcGVydHkgY2FuIGJlIGZvbGxvd2VkIGJ5IGEgZmlsdGVyXG4gICAgICAgICAgcmV0dXJuIFwicHJvcGVydHlcIjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBIaWdobGlnaHQgZmlsdGVyc1xuICAgICAgaWYgKHN0YXRlLndhaXRGaWx0ZXIpIHtcbiAgICAgICAgICBzdGF0ZS53YWl0RmlsdGVyID0gZmFsc2U7XG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2goZmlsdGVycykpIHtcbiAgICAgICAgICByZXR1cm4gXCJ2YXJpYWJsZS0yXCI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWdub3JlIGFsbCB3aGl0ZSBzcGFjZXNcbiAgICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkge1xuICAgICAgICBzdGF0ZS53YWl0UHJvcGVydHkgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgfVxuXG4gICAgICAvLyBJZGVudGlmeSBudW1iZXJzXG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC9cXGJcXGQrKFxcLlxcZCspP1xcYi8pKSB7XG4gICAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgICAgfVxuXG4gICAgICAvLyBJZGVudGlmeSBzdHJpbmdzXG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKFwiJ1wiKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IGluU3RyaW5nKFwiJ1wiLCBzdGF0ZS50b2tlbml6ZSk7XG4gICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goJ1wiJykpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSBpblN0cmluZygnXCInLCBzdGF0ZS50b2tlbml6ZSk7XG4gICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgfVxuXG4gICAgICAvLyBBdHRlbXB0IHRvIG1hdGNoIGFuIG9wZXJhdG9yXG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKG9wZXJhdG9ycykpIHtcbiAgICAgICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgICAgIH1cblxuICAgICAgLy8gQXR0ZW1wdCB0byBtYXRjaCBhIHdvcmQgb3BlcmF0b3JcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2god29yZE9wZXJhdG9ycykpIHtcbiAgICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICAgICAgfVxuXG4gICAgICAvLyBBdHRlbXB0IHRvIG1hdGNoIGEga2V5d29yZFxuICAgICAgdmFyIGtleXdvcmRNYXRjaCA9IHN0cmVhbS5tYXRjaChrZXl3b3Jkcyk7XG4gICAgICBpZiAoa2V5d29yZE1hdGNoKSB7XG4gICAgICAgIGlmIChrZXl3b3JkTWF0Y2hbMF0gPT0gXCJjb21tZW50XCIpIHtcbiAgICAgICAgICBzdGF0ZS5ibG9ja0NvbW1lbnRUYWcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgICAgIH1cblxuICAgICAgLy8gQXR0ZW1wdCB0byBtYXRjaCBhIHZhcmlhYmxlXG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC9cXGIoXFx3KylcXGIvKSkge1xuICAgICAgICBzdGF0ZS53YWl0RG90ID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUud2FpdFBpcGUgPSB0cnVlOyAgLy8gQSBwcm9wZXJ0eSBjYW4gYmUgZm9sbG93ZWQgYnkgYSBmaWx0ZXJcbiAgICAgICAgcmV0dXJuIFwidmFyaWFibGVcIjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgZm91bmQgY2xvc2luZyB0YWcgcmVzZXRcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goXCIlfVwiKSkge1xuICAgICAgICBzdGF0ZS53YWl0UHJvcGVydHkgPSBudWxsO1xuICAgICAgICBzdGF0ZS53YWl0RmlsdGVyID0gbnVsbDtcbiAgICAgICAgc3RhdGUud2FpdERvdCA9IG51bGw7XG4gICAgICAgIHN0YXRlLndhaXRQaXBlID0gbnVsbDtcbiAgICAgICAgLy8gSWYgdGhlIHRhZyB0aGF0IGNsb3NlcyBpcyBhIGJsb2NrIGNvbW1lbnQgdGFnLCB3ZSB3YW50IHRvIG1hcmsgdGhlXG4gICAgICAgIC8vIGZvbGxvd2luZyBjb2RlIGFzIGNvbW1lbnQsIHVudGlsIHRoZSB0YWcgY2xvc2VzLlxuICAgICAgICBpZiAoc3RhdGUuYmxvY2tDb21tZW50VGFnKSB7XG4gICAgICAgICAgc3RhdGUuYmxvY2tDb21tZW50VGFnID0gZmFsc2U7ICAvLyBSZWxlYXNlIHRoZSBcImxvY2tcIlxuICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gaW5CbG9ja0NvbW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwidGFnXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kLCBhZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlclxuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICB9XG5cbiAgICAvLyBNYXJrIGV2ZXJ5dGhpbmcgYXMgY29tbWVudCBpbnNpZGUgdGhlIHRhZyBhbmQgdGhlIHRhZyBpdHNlbGYuXG4gICAgZnVuY3Rpb24gaW5Db21tZW50IChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eLio/I1xcfS8pKSBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZVxuICAgICAgZWxzZSBzdHJlYW0uc2tpcFRvRW5kKClcbiAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICB9XG5cbiAgICAvLyBNYXJrIGV2ZXJ5dGhpbmcgYXMgYSBjb21tZW50IHVudGlsIHRoZSBgYmxvY2tjb21tZW50YCB0YWcgY2xvc2VzLlxuICAgIGZ1bmN0aW9uIGluQmxvY2tDb21tZW50IChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC9cXHslXFxzKmVuZGNvbW1lbnRcXHMqJVxcfS8sIGZhbHNlKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IGluVGFnO1xuICAgICAgICBzdHJlYW0ubWF0Y2goXCJ7JVwiKTtcbiAgICAgICAgcmV0dXJuIFwidGFnXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHt0b2tlbml6ZTogdG9rZW5CYXNlfTtcbiAgICAgIH0sXG4gICAgICB0b2tlbjogZnVuY3Rpb24gKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgfSxcbiAgICAgIGJsb2NrQ29tbWVudFN0YXJ0OiBcInslIGNvbW1lbnQgJX1cIixcbiAgICAgIGJsb2NrQ29tbWVudEVuZDogXCJ7JSBlbmRjb21tZW50ICV9XCJcbiAgICB9O1xuICB9KTtcblxuICBDb2RlTWlycm9yLmRlZmluZU1vZGUoXCJkamFuZ29cIiwgZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdmFyIGh0bWxCYXNlID0gQ29kZU1pcnJvci5nZXRNb2RlKGNvbmZpZywgXCJ0ZXh0L2h0bWxcIik7XG4gICAgdmFyIGRqYW5nb0lubmVyID0gQ29kZU1pcnJvci5nZXRNb2RlKGNvbmZpZywgXCJkamFuZ286aW5uZXJcIik7XG4gICAgcmV0dXJuIENvZGVNaXJyb3Iub3ZlcmxheU1vZGUoaHRtbEJhc2UsIGRqYW5nb0lubmVyKTtcbiAgfSk7XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LWRqYW5nb1wiLCBcImRqYW5nb1wiKTtcbn0pO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSwgcmVxdWlyZShcIi4uLy4uL2FkZG9uL21vZGUvc2ltcGxlXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIsIFwiLi4vLi4vYWRkb24vbW9kZS9zaW1wbGVcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBmcm9tID0gXCJmcm9tXCI7XG4gIHZhciBmcm9tUmVnZXggPSBuZXcgUmVnRXhwKFwiXihcXFxccyopXFxcXGIoXCIgKyBmcm9tICsgXCIpXFxcXGJcIiwgXCJpXCIpO1xuXG4gIHZhciBzaGVsbHMgPSBbXCJydW5cIiwgXCJjbWRcIiwgXCJlbnRyeXBvaW50XCIsIFwic2hlbGxcIl07XG4gIHZhciBzaGVsbHNBc0FycmF5UmVnZXggPSBuZXcgUmVnRXhwKFwiXihcXFxccyopKFwiICsgc2hlbGxzLmpvaW4oJ3wnKSArIFwiKShcXFxccytcXFxcWylcIiwgXCJpXCIpO1xuXG4gIHZhciBleHBvc2UgPSBcImV4cG9zZVwiO1xuICB2YXIgZXhwb3NlUmVnZXggPSBuZXcgUmVnRXhwKFwiXihcXFxccyopKFwiICsgZXhwb3NlICsgXCIpKFxcXFxzKylcIiwgXCJpXCIpO1xuXG4gIHZhciBvdGhlcnMgPSBbXG4gICAgXCJhcmdcIiwgXCJmcm9tXCIsIFwibWFpbnRhaW5lclwiLCBcImxhYmVsXCIsIFwiZW52XCIsXG4gICAgXCJhZGRcIiwgXCJjb3B5XCIsIFwidm9sdW1lXCIsIFwidXNlclwiLFxuICAgIFwid29ya2RpclwiLCBcIm9uYnVpbGRcIiwgXCJzdG9wc2lnbmFsXCIsIFwiaGVhbHRoY2hlY2tcIiwgXCJzaGVsbFwiXG4gIF07XG5cbiAgLy8gQ29sbGVjdCBhbGwgRG9ja2VyZmlsZSBkaXJlY3RpdmVzXG4gIHZhciBpbnN0cnVjdGlvbnMgPSBbZnJvbSwgZXhwb3NlXS5jb25jYXQoc2hlbGxzKS5jb25jYXQob3RoZXJzKSxcbiAgICAgIGluc3RydWN0aW9uUmVnZXggPSBcIihcIiArIGluc3RydWN0aW9ucy5qb2luKCd8JykgKyBcIilcIixcbiAgICAgIGluc3RydWN0aW9uT25seUxpbmUgPSBuZXcgUmVnRXhwKFwiXihcXFxccyopXCIgKyBpbnN0cnVjdGlvblJlZ2V4ICsgXCIoXFxcXHMqKSgjLiopPyRcIiwgXCJpXCIpLFxuICAgICAgaW5zdHJ1Y3Rpb25XaXRoQXJndW1lbnRzID0gbmV3IFJlZ0V4cChcIl4oXFxcXHMqKVwiICsgaW5zdHJ1Y3Rpb25SZWdleCArIFwiKFxcXFxzKylcIiwgXCJpXCIpO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lU2ltcGxlTW9kZShcImRvY2tlcmZpbGVcIiwge1xuICAgIHN0YXJ0OiBbXG4gICAgICAvLyBCbG9jayBjb21tZW50OiBUaGlzIGlzIGEgbGluZSBzdGFydGluZyB3aXRoIGEgY29tbWVudFxuICAgICAge1xuICAgICAgICByZWdleDogL15cXHMqIy4qJC8sXG4gICAgICAgIHNvbDogdHJ1ZSxcbiAgICAgICAgdG9rZW46IFwiY29tbWVudFwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICByZWdleDogZnJvbVJlZ2V4LFxuICAgICAgICB0b2tlbjogW251bGwsIFwia2V5d29yZFwiXSxcbiAgICAgICAgc29sOiB0cnVlLFxuICAgICAgICBuZXh0OiBcImZyb21cIlxuICAgICAgfSxcbiAgICAgIC8vIEhpZ2hsaWdodCBhbiBpbnN0cnVjdGlvbiB3aXRob3V0IGFueSBhcmd1bWVudHMgKGZvciBjb252ZW5pZW5jZSlcbiAgICAgIHtcbiAgICAgICAgcmVnZXg6IGluc3RydWN0aW9uT25seUxpbmUsXG4gICAgICAgIHRva2VuOiBbbnVsbCwgXCJrZXl3b3JkXCIsIG51bGwsIFwiZXJyb3JcIl0sXG4gICAgICAgIHNvbDogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcmVnZXg6IHNoZWxsc0FzQXJyYXlSZWdleCxcbiAgICAgICAgdG9rZW46IFtudWxsLCBcImtleXdvcmRcIiwgbnVsbF0sXG4gICAgICAgIHNvbDogdHJ1ZSxcbiAgICAgICAgbmV4dDogXCJhcnJheVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICByZWdleDogZXhwb3NlUmVnZXgsXG4gICAgICAgIHRva2VuOiBbbnVsbCwgXCJrZXl3b3JkXCIsIG51bGxdLFxuICAgICAgICBzb2w6IHRydWUsXG4gICAgICAgIG5leHQ6IFwiZXhwb3NlXCJcbiAgICAgIH0sXG4gICAgICAvLyBIaWdobGlnaHQgYW4gaW5zdHJ1Y3Rpb24gZm9sbG93ZWQgYnkgYXJndW1lbnRzXG4gICAgICB7XG4gICAgICAgIHJlZ2V4OiBpbnN0cnVjdGlvbldpdGhBcmd1bWVudHMsXG4gICAgICAgIHRva2VuOiBbbnVsbCwgXCJrZXl3b3JkXCIsIG51bGxdLFxuICAgICAgICBzb2w6IHRydWUsXG4gICAgICAgIG5leHQ6IFwiYXJndW1lbnRzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHJlZ2V4OiAvLi8sXG4gICAgICAgIHRva2VuOiBudWxsXG4gICAgICB9XG4gICAgXSxcbiAgICBmcm9tOiBbXG4gICAgICB7XG4gICAgICAgIHJlZ2V4OiAvXFxzKiQvLFxuICAgICAgICB0b2tlbjogbnVsbCxcbiAgICAgICAgbmV4dDogXCJzdGFydFwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAvLyBMaW5lIGNvbW1lbnQgd2l0aG91dCBpbnN0cnVjdGlvbiBhcmd1bWVudHMgaXMgYW4gZXJyb3JcbiAgICAgICAgcmVnZXg6IC8oXFxzKikoIy4qKSQvLFxuICAgICAgICB0b2tlbjogW251bGwsIFwiZXJyb3JcIl0sXG4gICAgICAgIG5leHQ6IFwic3RhcnRcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcmVnZXg6IC8oXFxzKlxcUytcXHMrKShhcykvaSxcbiAgICAgICAgdG9rZW46IFtudWxsLCBcImtleXdvcmRcIl0sXG4gICAgICAgIG5leHQ6IFwic3RhcnRcIlxuICAgICAgfSxcbiAgICAgIC8vIEZhaWwgc2FmZSByZXR1cm4gdG8gc3RhcnRcbiAgICAgIHtcbiAgICAgICAgdG9rZW46IG51bGwsXG4gICAgICAgIG5leHQ6IFwic3RhcnRcIlxuICAgICAgfVxuICAgIF0sXG4gICAgc2luZ2xlOiBbXG4gICAgICB7XG4gICAgICAgIHJlZ2V4OiAvKD86W15cXFxcJ118XFxcXC4pLyxcbiAgICAgICAgdG9rZW46IFwic3RyaW5nXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHJlZ2V4OiAvJy8sXG4gICAgICAgIHRva2VuOiBcInN0cmluZ1wiLFxuICAgICAgICBwb3A6IHRydWVcbiAgICAgIH1cbiAgICBdLFxuICAgIGRvdWJsZTogW1xuICAgICAge1xuICAgICAgICByZWdleDogLyg/OlteXFxcXFwiXXxcXFxcLikvLFxuICAgICAgICB0b2tlbjogXCJzdHJpbmdcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcmVnZXg6IC9cIi8sXG4gICAgICAgIHRva2VuOiBcInN0cmluZ1wiLFxuICAgICAgICBwb3A6IHRydWVcbiAgICAgIH1cbiAgICBdLFxuICAgIGFycmF5OiBbXG4gICAgICB7XG4gICAgICAgIHJlZ2V4OiAvXFxdLyxcbiAgICAgICAgdG9rZW46IG51bGwsXG4gICAgICAgIG5leHQ6IFwic3RhcnRcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcmVnZXg6IC9cIig/OlteXFxcXFwiXXxcXFxcLikqXCI/LyxcbiAgICAgICAgdG9rZW46IFwic3RyaW5nXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIGV4cG9zZTogW1xuICAgICAge1xuICAgICAgICByZWdleDogL1xcZCskLyxcbiAgICAgICAgdG9rZW46IFwibnVtYmVyXCIsXG4gICAgICAgIG5leHQ6IFwic3RhcnRcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcmVnZXg6IC9bXlxcZF0rJC8sXG4gICAgICAgIHRva2VuOiBudWxsLFxuICAgICAgICBuZXh0OiBcInN0YXJ0XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHJlZ2V4OiAvXFxkKy8sXG4gICAgICAgIHRva2VuOiBcIm51bWJlclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICByZWdleDogL1teXFxkXSsvLFxuICAgICAgICB0b2tlbjogbnVsbFxuICAgICAgfSxcbiAgICAgIC8vIEZhaWwgc2FmZSByZXR1cm4gdG8gc3RhcnRcbiAgICAgIHtcbiAgICAgICAgdG9rZW46IG51bGwsXG4gICAgICAgIG5leHQ6IFwic3RhcnRcIlxuICAgICAgfVxuICAgIF0sXG4gICAgYXJndW1lbnRzOiBbXG4gICAgICB7XG4gICAgICAgIHJlZ2V4OiAvXlxccyojLiokLyxcbiAgICAgICAgc29sOiB0cnVlLFxuICAgICAgICB0b2tlbjogXCJjb21tZW50XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHJlZ2V4OiAvXCIoPzpbXlxcXFxcIl18XFxcXC4pKlwiPyQvLFxuICAgICAgICB0b2tlbjogXCJzdHJpbmdcIixcbiAgICAgICAgbmV4dDogXCJzdGFydFwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICByZWdleDogL1wiLyxcbiAgICAgICAgdG9rZW46IFwic3RyaW5nXCIsXG4gICAgICAgIHB1c2g6IFwiZG91YmxlXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHJlZ2V4OiAvJyg/OlteXFxcXCddfFxcXFwuKSonPyQvLFxuICAgICAgICB0b2tlbjogXCJzdHJpbmdcIixcbiAgICAgICAgbmV4dDogXCJzdGFydFwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICByZWdleDogLycvLFxuICAgICAgICB0b2tlbjogXCJzdHJpbmdcIixcbiAgICAgICAgcHVzaDogXCJzaW5nbGVcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcmVnZXg6IC9bXiNcIiddK1tcXFxcYF0kLyxcbiAgICAgICAgdG9rZW46IG51bGxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHJlZ2V4OiAvW14jXCInXSskLyxcbiAgICAgICAgdG9rZW46IG51bGwsXG4gICAgICAgIG5leHQ6IFwic3RhcnRcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcmVnZXg6IC9bXiNcIiddKy8sXG4gICAgICAgIHRva2VuOiBudWxsXG4gICAgICB9LFxuICAgICAgLy8gRmFpbCBzYWZlIHJldHVybiB0byBzdGFydFxuICAgICAge1xuICAgICAgICB0b2tlbjogbnVsbCxcbiAgICAgICAgbmV4dDogXCJzdGFydFwiXG4gICAgICB9XG4gICAgXSxcbiAgICBtZXRhOiB7XG4gICAgICBsaW5lQ29tbWVudDogXCIjXCJcbiAgICB9XG4gIH0pO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQveC1kb2NrZXJmaWxlXCIsIFwiZG9ja2VyZmlsZVwiKTtcbn0pO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuLypcbiAgRFREIG1vZGVcbiAgUG9ydGVkIHRvIENvZGVNaXJyb3IgYnkgUGV0ZXIgS3Jvb24gPHBsYWtyb29uQGdtYWlsLmNvbT5cbiAgUmVwb3J0IGJ1Z3MvaXNzdWVzIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9jb2RlbWlycm9yL0NvZGVNaXJyb3IvaXNzdWVzXG4gIEdpdEh1YjogQHBldGVya3Jvb25cbiovXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwiZHRkXCIsIGZ1bmN0aW9uKGNvbmZpZykge1xuICB2YXIgaW5kZW50VW5pdCA9IGNvbmZpZy5pbmRlbnRVbml0LCB0eXBlO1xuICBmdW5jdGlvbiByZXQoc3R5bGUsIHRwKSB7dHlwZSA9IHRwOyByZXR1cm4gc3R5bGU7fVxuXG4gIGZ1bmN0aW9uIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGNoID0gc3RyZWFtLm5leHQoKTtcblxuICAgIGlmIChjaCA9PSBcIjxcIiAmJiBzdHJlYW0uZWF0KFwiIVwiKSApIHtcbiAgICAgIGlmIChzdHJlYW0uZWF0V2hpbGUoL1tcXC1dLykpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlblNHTUxDb21tZW50O1xuICAgICAgICByZXR1cm4gdG9rZW5TR01MQ29tbWVudChzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLmVhdFdoaWxlKC9bXFx3XS8pKSByZXR1cm4gcmV0KFwia2V5d29yZFwiLCBcImRvaW5kZW50XCIpO1xuICAgIH0gZWxzZSBpZiAoY2ggPT0gXCI8XCIgJiYgc3RyZWFtLmVhdChcIj9cIikpIHsgLy94bWwgZGVjbGFyYXRpb25cbiAgICAgIHN0YXRlLnRva2VuaXplID0gaW5CbG9jayhcIm1ldGFcIiwgXCI/PlwiKTtcbiAgICAgIHJldHVybiByZXQoXCJtZXRhXCIsIGNoKTtcbiAgICB9IGVsc2UgaWYgKGNoID09IFwiI1wiICYmIHN0cmVhbS5lYXRXaGlsZSgvW1xcd10vKSkgcmV0dXJuIHJldChcImF0b21cIiwgXCJ0YWdcIik7XG4gICAgZWxzZSBpZiAoY2ggPT0gXCJ8XCIpIHJldHVybiByZXQoXCJrZXl3b3JkXCIsIFwic2VwYXJhdG9yXCIpO1xuICAgIGVsc2UgaWYgKGNoLm1hdGNoKC9bXFwoXFwpXFxbXFxdXFwtXFwuLFxcK1xcPz5dLykpIHJldHVybiByZXQobnVsbCwgY2gpOy8vaWYoY2ggPT09IFwiPlwiKSByZXR1cm4gcmV0KG51bGwsIFwiZW5kdGFnXCIpOyBlbHNlXG4gICAgZWxzZSBpZiAoY2gubWF0Y2goL1tcXFtcXF1dLykpIHJldHVybiByZXQoXCJydWxlXCIsIGNoKTtcbiAgICBlbHNlIGlmIChjaCA9PSBcIlxcXCJcIiB8fCBjaCA9PSBcIidcIikge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlblN0cmluZyhjaCk7XG4gICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIGlmIChzdHJlYW0uZWF0V2hpbGUoL1thLXpBLVpcXD9cXCtcXGRdLykpIHtcbiAgICAgIHZhciBzYyA9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAgICBpZiggc2Muc3Vic3RyKHNjLmxlbmd0aC0xLHNjLmxlbmd0aCkubWF0Y2goL1xcP3xcXCsvKSAhPT0gbnVsbCApc3RyZWFtLmJhY2tVcCgxKTtcbiAgICAgIHJldHVybiByZXQoXCJ0YWdcIiwgXCJ0YWdcIik7XG4gICAgfSBlbHNlIGlmIChjaCA9PSBcIiVcIiB8fCBjaCA9PSBcIipcIiApIHJldHVybiByZXQoXCJudW1iZXJcIiwgXCJudW1iZXJcIik7XG4gICAgZWxzZSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXFxcXFwtXyUueyxdLyk7XG4gICAgICByZXR1cm4gcmV0KG51bGwsIG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuU0dNTENvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBkYXNoZXMgPSAwLCBjaDtcbiAgICB3aGlsZSAoKGNoID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgaWYgKGRhc2hlcyA+PSAyICYmIGNoID09IFwiPlwiKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRhc2hlcyA9IChjaCA9PSBcIi1cIikgPyBkYXNoZXMgKyAxIDogMDtcbiAgICB9XG4gICAgcmV0dXJuIHJldChcImNvbW1lbnRcIiwgXCJjb21tZW50XCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5TdHJpbmcocXVvdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIGVzY2FwZWQgPSBmYWxzZSwgY2g7XG4gICAgICB3aGlsZSAoKGNoID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgICBpZiAoY2ggPT0gcXVvdGUgJiYgIWVzY2FwZWQpIHtcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQgJiYgY2ggPT0gXCJcXFxcXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0KFwic3RyaW5nXCIsIFwidGFnXCIpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBpbkJsb2NrKHN0eWxlLCB0ZXJtaW5hdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2godGVybWluYXRvcikpIHtcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKGJhc2UpIHtcbiAgICAgIHJldHVybiB7dG9rZW5pemU6IHRva2VuQmFzZSxcbiAgICAgICAgICAgICAgYmFzZUluZGVudDogYmFzZSB8fCAwLFxuICAgICAgICAgICAgICBzdGFjazogW119O1xuICAgIH0sXG5cbiAgICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBzdHlsZSA9IHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgICB2YXIgY29udGV4dCA9IHN0YXRlLnN0YWNrW3N0YXRlLnN0YWNrLmxlbmd0aC0xXTtcbiAgICAgIGlmIChzdHJlYW0uY3VycmVudCgpID09IFwiW1wiIHx8IHR5cGUgPT09IFwiZG9pbmRlbnRcIiB8fCB0eXBlID09IFwiW1wiKSBzdGF0ZS5zdGFjay5wdXNoKFwicnVsZVwiKTtcbiAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiZW5kdGFnXCIpIHN0YXRlLnN0YWNrW3N0YXRlLnN0YWNrLmxlbmd0aC0xXSA9IFwiZW5kdGFnXCI7XG4gICAgICBlbHNlIGlmIChzdHJlYW0uY3VycmVudCgpID09IFwiXVwiIHx8IHR5cGUgPT0gXCJdXCIgfHwgKHR5cGUgPT0gXCI+XCIgJiYgY29udGV4dCA9PSBcInJ1bGVcIikpIHN0YXRlLnN0YWNrLnBvcCgpO1xuICAgICAgZWxzZSBpZiAodHlwZSA9PSBcIltcIikgc3RhdGUuc3RhY2sucHVzaChcIltcIik7XG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfSxcblxuICAgIGluZGVudDogZnVuY3Rpb24oc3RhdGUsIHRleHRBZnRlcikge1xuICAgICAgdmFyIG4gPSBzdGF0ZS5zdGFjay5sZW5ndGg7XG5cbiAgICAgIGlmKCB0ZXh0QWZ0ZXIuY2hhckF0KDApID09PSAnXScgKW4tLTtcbiAgICAgIGVsc2UgaWYodGV4dEFmdGVyLnN1YnN0cih0ZXh0QWZ0ZXIubGVuZ3RoLTEsIHRleHRBZnRlci5sZW5ndGgpID09PSBcIj5cIil7XG4gICAgICAgIGlmKHRleHRBZnRlci5zdWJzdHIoMCwxKSA9PT0gXCI8XCIpIHt9XG4gICAgICAgIGVsc2UgaWYoIHR5cGUgPT0gXCJkb2luZGVudFwiICYmIHRleHRBZnRlci5sZW5ndGggPiAxICkge31cbiAgICAgICAgZWxzZSBpZiggdHlwZSA9PSBcImRvaW5kZW50XCIpbi0tO1xuICAgICAgICBlbHNlIGlmKCB0eXBlID09IFwiPlwiICYmIHRleHRBZnRlci5sZW5ndGggPiAxKSB7fVxuICAgICAgICBlbHNlIGlmKCB0eXBlID09IFwidGFnXCIgJiYgdGV4dEFmdGVyICE9PSBcIj5cIikge31cbiAgICAgICAgZWxzZSBpZiggdHlwZSA9PSBcInRhZ1wiICYmIHN0YXRlLnN0YWNrW3N0YXRlLnN0YWNrLmxlbmd0aC0xXSA9PSBcInJ1bGVcIiluLS07XG4gICAgICAgIGVsc2UgaWYoIHR5cGUgPT0gXCJ0YWdcIiluKys7XG4gICAgICAgIGVsc2UgaWYoIHRleHRBZnRlciA9PT0gXCI+XCIgJiYgc3RhdGUuc3RhY2tbc3RhdGUuc3RhY2subGVuZ3RoLTFdID09IFwicnVsZVwiICYmIHR5cGUgPT09IFwiPlwiKW4tLTtcbiAgICAgICAgZWxzZSBpZiggdGV4dEFmdGVyID09PSBcIj5cIiAmJiBzdGF0ZS5zdGFja1tzdGF0ZS5zdGFjay5sZW5ndGgtMV0gPT0gXCJydWxlXCIpIHt9XG4gICAgICAgIGVsc2UgaWYoIHRleHRBZnRlci5zdWJzdHIoMCwxKSAhPT0gXCI8XCIgJiYgdGV4dEFmdGVyLnN1YnN0cigwLDEpID09PSBcIj5cIiApbj1uLTE7XG4gICAgICAgIGVsc2UgaWYoIHRleHRBZnRlciA9PT0gXCI+XCIpIHt9XG4gICAgICAgIGVsc2Ugbj1uLTE7XG4gICAgICAgIC8vb3ZlciBydWxlIHRoZW0gYWxsXG4gICAgICAgIGlmKHR5cGUgPT0gbnVsbCB8fCB0eXBlID09IFwiXVwiKW4tLTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0YXRlLmJhc2VJbmRlbnQgKyBuICogaW5kZW50VW5pdDtcbiAgICB9LFxuXG4gICAgZWxlY3RyaWNDaGFyczogXCJdPlwiXG4gIH07XG59KTtcblxuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwiYXBwbGljYXRpb24veG1sLWR0ZFwiLCBcImR0ZFwiKTtcblxufSk7XG4iLCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIGZvckVhY2goYXJyLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBmKGFycltpXSwgaSlcbn1cbmZ1bmN0aW9uIHNvbWUoYXJyLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBpZiAoZihhcnJbaV0sIGkpKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gZmFsc2Vcbn1cblxuQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwiZHlsYW5cIiwgZnVuY3Rpb24oX2NvbmZpZykge1xuICAvLyBXb3Jkc1xuICB2YXIgd29yZHMgPSB7XG4gICAgLy8gV29yZHMgdGhhdCBpbnRyb2R1Y2UgdW5uYW1lZCBkZWZpbml0aW9ucyBsaWtlIFwiZGVmaW5lIGludGVyZmFjZVwiXG4gICAgdW5uYW1lZERlZmluaXRpb246IFtcImludGVyZmFjZVwiXSxcblxuICAgIC8vIFdvcmRzIHRoYXQgaW50cm9kdWNlIHNpbXBsZSBuYW1lZCBkZWZpbml0aW9ucyBsaWtlIFwiZGVmaW5lIGxpYnJhcnlcIlxuICAgIG5hbWVkRGVmaW5pdGlvbjogW1wibW9kdWxlXCIsIFwibGlicmFyeVwiLCBcIm1hY3JvXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJDLXN0cnVjdFwiLCBcIkMtdW5pb25cIixcbiAgICAgICAgICAgICAgICAgICAgICBcIkMtZnVuY3Rpb25cIiwgXCJDLWNhbGxhYmxlLXdyYXBwZXJcIlxuICAgICAgICAgICAgICAgICAgICAgXSxcblxuICAgIC8vIFdvcmRzIHRoYXQgaW50cm9kdWNlIHR5cGUgZGVmaW5pdGlvbnMgbGlrZSBcImRlZmluZSBjbGFzc1wiLlxuICAgIC8vIFRoZXNlIGFyZSBhbHNvIHBhcmFtZXRlcml6ZWQgbGlrZSBcImRlZmluZSBtZXRob2RcIiBhbmQgYXJlXG4gICAgLy8gYXBwZW5kZWQgdG8gb3RoZXJQYXJhbWV0ZXJpemVkRGVmaW5pdGlvbldvcmRzXG4gICAgdHlwZVBhcmFtZXRlcml6ZWREZWZpbml0aW9uOiBbXCJjbGFzc1wiLCBcIkMtc3VidHlwZVwiLCBcIkMtbWFwcGVkLXN1YnR5cGVcIl0sXG5cbiAgICAvLyBXb3JkcyB0aGF0IGludHJvZHVjZSB0cmlja2llciBkZWZpbml0aW9ucyBsaWtlIFwiZGVmaW5lIG1ldGhvZFwiLlxuICAgIC8vIFRoZXNlIHJlcXVpcmUgc3BlY2lhbCBkZWZpbml0aW9ucyB0byBiZSBhZGRlZCB0byBzdGFydEV4cHJlc3Npb25zXG4gICAgb3RoZXJQYXJhbWV0ZXJpemVkRGVmaW5pdGlvbjogW1wibWV0aG9kXCIsIFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDLXZhcmlhYmxlXCIsIFwiQy1hZGRyZXNzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuXG4gICAgLy8gV29yZHMgdGhhdCBpbnRyb2R1Y2UgbW9kdWxlIGNvbnN0YW50IGRlZmluaXRpb25zLlxuICAgIC8vIFRoZXNlIG11c3QgYWxzbyBiZSBzaW1wbGUgZGVmaW5pdGlvbnMgYW5kIGFyZVxuICAgIC8vIGFwcGVuZGVkIHRvIG90aGVyU2ltcGxlRGVmaW5pdGlvbldvcmRzXG4gICAgY29uc3RhbnRTaW1wbGVEZWZpbml0aW9uOiBbXCJjb25zdGFudFwiXSxcblxuICAgIC8vIFdvcmRzIHRoYXQgaW50cm9kdWNlIG1vZHVsZSB2YXJpYWJsZSBkZWZpbml0aW9ucy5cbiAgICAvLyBUaGVzZSBtdXN0IGFsc28gYmUgc2ltcGxlIGRlZmluaXRpb25zIGFuZCBhcmVcbiAgICAvLyBhcHBlbmRlZCB0byBvdGhlclNpbXBsZURlZmluaXRpb25Xb3Jkc1xuICAgIHZhcmlhYmxlU2ltcGxlRGVmaW5pdGlvbjogW1widmFyaWFibGVcIl0sXG5cbiAgICAvLyBPdGhlciB3b3JkcyB0aGF0IGludHJvZHVjZSBzaW1wbGUgZGVmaW5pdGlvbnNcbiAgICAvLyAod2l0aG91dCBpbXBsaWNpdCBib2RpZXMpLlxuICAgIG90aGVyU2ltcGxlRGVmaW5pdGlvbjogW1wiZ2VuZXJpY1wiLCBcImRvbWFpblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQy1wb2ludGVyLXR5cGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRhYmxlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG5cbiAgICAvLyBXb3JkcyB0aGF0IGJlZ2luIHN0YXRlbWVudHMgd2l0aCBpbXBsaWNpdCBib2RpZXMuXG4gICAgc3RhdGVtZW50OiBbXCJpZlwiLCBcImJsb2NrXCIsIFwiYmVnaW5cIiwgXCJtZXRob2RcIiwgXCJjYXNlXCIsXG4gICAgICAgICAgICAgICAgXCJmb3JcIiwgXCJzZWxlY3RcIiwgXCJ3aGVuXCIsIFwidW5sZXNzXCIsIFwidW50aWxcIixcbiAgICAgICAgICAgICAgICBcIndoaWxlXCIsIFwiaXRlcmF0ZVwiLCBcInByb2ZpbGluZ1wiLCBcImR5bmFtaWMtYmluZFwiXG4gICAgICAgICAgICAgICBdLFxuXG4gICAgLy8gUGF0dGVybnMgdGhhdCBhY3QgYXMgc2VwYXJhdG9ycyBpbiBjb21wb3VuZCBzdGF0ZW1lbnRzLlxuICAgIC8vIFRoaXMgbWF5IGluY2x1ZGUgYW55IGdlbmVyYWwgcGF0dGVybiB0aGF0IG11c3QgYmUgaW5kZW50ZWRcbiAgICAvLyBzcGVjaWFsbHkuXG4gICAgc2VwYXJhdG9yOiBbXCJmaW5hbGx5XCIsIFwiZXhjZXB0aW9uXCIsIFwiY2xlYW51cFwiLCBcImVsc2VcIixcbiAgICAgICAgICAgICAgICBcImVsc2VpZlwiLCBcImFmdGVyd2FyZHNcIlxuICAgICAgICAgICAgICAgXSxcblxuICAgIC8vIEtleXdvcmRzIHRoYXQgZG8gbm90IHJlcXVpcmUgc3BlY2lhbCBpbmRlbnRhdGlvbiBoYW5kbGluZyxcbiAgICAvLyBidXQgd2hpY2ggc2hvdWxkIGJlIGhpZ2hsaWdodGVkXG4gICAgb3RoZXI6IFtcImFib3ZlXCIsIFwiYmVsb3dcIiwgXCJieVwiLCBcImZyb21cIiwgXCJoYW5kbGVyXCIsIFwiaW5cIixcbiAgICAgICAgICAgIFwiaW5zdGFuY2VcIiwgXCJsZXRcIiwgXCJsb2NhbFwiLCBcIm90aGVyd2lzZVwiLCBcInNsb3RcIixcbiAgICAgICAgICAgIFwic3ViY2xhc3NcIiwgXCJ0aGVuXCIsIFwidG9cIiwgXCJrZXllZC1ieVwiLCBcInZpcnR1YWxcIlxuICAgICAgICAgICBdLFxuXG4gICAgLy8gQ29uZGl0aW9uIHNpZ25hbGluZyBmdW5jdGlvbiBjYWxsc1xuICAgIHNpZ25hbGluZ0NhbGxzOiBbXCJzaWduYWxcIiwgXCJlcnJvclwiLCBcImNlcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICAgXCJicmVha1wiLCBcImNoZWNrLXR5cGVcIiwgXCJhYm9ydFwiXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgfTtcblxuICB3b3Jkc1tcIm90aGVyRGVmaW5pdGlvblwiXSA9XG4gICAgd29yZHNbXCJ1bm5hbWVkRGVmaW5pdGlvblwiXVxuICAgIC5jb25jYXQod29yZHNbXCJuYW1lZERlZmluaXRpb25cIl0pXG4gICAgLmNvbmNhdCh3b3Jkc1tcIm90aGVyUGFyYW1ldGVyaXplZERlZmluaXRpb25cIl0pO1xuXG4gIHdvcmRzW1wiZGVmaW5pdGlvblwiXSA9XG4gICAgd29yZHNbXCJ0eXBlUGFyYW1ldGVyaXplZERlZmluaXRpb25cIl1cbiAgICAuY29uY2F0KHdvcmRzW1wib3RoZXJEZWZpbml0aW9uXCJdKTtcblxuICB3b3Jkc1tcInBhcmFtZXRlcml6ZWREZWZpbml0aW9uXCJdID1cbiAgICB3b3Jkc1tcInR5cGVQYXJhbWV0ZXJpemVkRGVmaW5pdGlvblwiXVxuICAgIC5jb25jYXQod29yZHNbXCJvdGhlclBhcmFtZXRlcml6ZWREZWZpbml0aW9uXCJdKTtcblxuICB3b3Jkc1tcInNpbXBsZURlZmluaXRpb25cIl0gPVxuICAgIHdvcmRzW1wiY29uc3RhbnRTaW1wbGVEZWZpbml0aW9uXCJdXG4gICAgLmNvbmNhdCh3b3Jkc1tcInZhcmlhYmxlU2ltcGxlRGVmaW5pdGlvblwiXSlcbiAgICAuY29uY2F0KHdvcmRzW1wib3RoZXJTaW1wbGVEZWZpbml0aW9uXCJdKTtcblxuICB3b3Jkc1tcImtleXdvcmRcIl0gPVxuICAgIHdvcmRzW1wic3RhdGVtZW50XCJdXG4gICAgLmNvbmNhdCh3b3Jkc1tcInNlcGFyYXRvclwiXSlcbiAgICAuY29uY2F0KHdvcmRzW1wib3RoZXJcIl0pO1xuXG4gIC8vIFBhdHRlcm5zXG4gIHZhciBzeW1ib2xQYXR0ZXJuID0gXCJbLV9hLXpBLVo/ISpAPD4kJV0rXCI7XG4gIHZhciBzeW1ib2wgPSBuZXcgUmVnRXhwKFwiXlwiICsgc3ltYm9sUGF0dGVybik7XG4gIHZhciBwYXR0ZXJucyA9IHtcbiAgICAvLyBTeW1ib2xzIHdpdGggc3BlY2lhbCBzeW50YXhcbiAgICBzeW1ib2xLZXl3b3JkOiBzeW1ib2xQYXR0ZXJuICsgXCI6XCIsXG4gICAgc3ltYm9sQ2xhc3M6IFwiPFwiICsgc3ltYm9sUGF0dGVybiArIFwiPlwiLFxuICAgIHN5bWJvbEdsb2JhbDogXCJcXFxcKlwiICsgc3ltYm9sUGF0dGVybiArIFwiXFxcXCpcIixcbiAgICBzeW1ib2xDb25zdGFudDogXCJcXFxcJFwiICsgc3ltYm9sUGF0dGVyblxuICB9O1xuICB2YXIgcGF0dGVyblN0eWxlcyA9IHtcbiAgICBzeW1ib2xLZXl3b3JkOiBcImF0b21cIixcbiAgICBzeW1ib2xDbGFzczogXCJ0YWdcIixcbiAgICBzeW1ib2xHbG9iYWw6IFwidmFyaWFibGUtMlwiLFxuICAgIHN5bWJvbENvbnN0YW50OiBcInZhcmlhYmxlLTNcIlxuICB9O1xuXG4gIC8vIENvbXBpbGUgYWxsIHBhdHRlcm5zIHRvIHJlZ3VsYXIgZXhwcmVzc2lvbnNcbiAgZm9yICh2YXIgcGF0dGVybk5hbWUgaW4gcGF0dGVybnMpXG4gICAgaWYgKHBhdHRlcm5zLmhhc093blByb3BlcnR5KHBhdHRlcm5OYW1lKSlcbiAgICAgIHBhdHRlcm5zW3BhdHRlcm5OYW1lXSA9IG5ldyBSZWdFeHAoXCJeXCIgKyBwYXR0ZXJuc1twYXR0ZXJuTmFtZV0pO1xuXG4gIC8vIE5hbWVzIGJlZ2lubmluZyBcIndpdGgtXCIgYW5kIFwid2l0aG91dC1cIiBhcmUgY29tbW9ubHlcbiAgLy8gdXNlZCBhcyBzdGF0ZW1lbnQgbWFjcm9cbiAgcGF0dGVybnNbXCJrZXl3b3JkXCJdID0gWy9ed2l0aCg/Om91dCk/LVstX2EtekEtWj8hKkA8PiQlXSsvXTtcblxuICB2YXIgc3R5bGVzID0ge307XG4gIHN0eWxlc1tcImtleXdvcmRcIl0gPSBcImtleXdvcmRcIjtcbiAgc3R5bGVzW1wiZGVmaW5pdGlvblwiXSA9IFwiZGVmXCI7XG4gIHN0eWxlc1tcInNpbXBsZURlZmluaXRpb25cIl0gPSBcImRlZlwiO1xuICBzdHlsZXNbXCJzaWduYWxpbmdDYWxsc1wiXSA9IFwiYnVpbHRpblwiO1xuXG4gIC8vIHByb3RlY3RlZCB3b3JkcyBsb29rdXAgdGFibGVcbiAgdmFyIHdvcmRMb29rdXAgPSB7fTtcbiAgdmFyIHN0eWxlTG9va3VwID0ge307XG5cbiAgZm9yRWFjaChbXG4gICAgXCJrZXl3b3JkXCIsXG4gICAgXCJkZWZpbml0aW9uXCIsXG4gICAgXCJzaW1wbGVEZWZpbml0aW9uXCIsXG4gICAgXCJzaWduYWxpbmdDYWxsc1wiXG4gIF0sIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBmb3JFYWNoKHdvcmRzW3R5cGVdLCBmdW5jdGlvbih3b3JkKSB7XG4gICAgICB3b3JkTG9va3VwW3dvcmRdID0gdHlwZTtcbiAgICAgIHN0eWxlTG9va3VwW3dvcmRdID0gc3R5bGVzW3R5cGVdO1xuICAgIH0pO1xuICB9KTtcblxuXG4gIGZ1bmN0aW9uIGNoYWluKHN0cmVhbSwgc3RhdGUsIGYpIHtcbiAgICBzdGF0ZS50b2tlbml6ZSA9IGY7XG4gICAgcmV0dXJuIGYoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuICAgIC8vIFN0cmluZ1xuICAgIHZhciBjaCA9IHN0cmVhbS5wZWVrKCk7XG4gICAgaWYgKGNoID09IFwiJ1wiIHx8IGNoID09ICdcIicpIHtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICByZXR1cm4gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgdG9rZW5TdHJpbmcoY2gsIFwic3RyaW5nXCIpKTtcbiAgICB9XG4gICAgLy8gQ29tbWVudFxuICAgIGVsc2UgaWYgKGNoID09IFwiL1wiKSB7XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgaWYgKHN0cmVhbS5lYXQoXCIqXCIpKSB7XG4gICAgICAgIHJldHVybiBjaGFpbihzdHJlYW0sIHN0YXRlLCB0b2tlbkNvbW1lbnQpO1xuICAgICAgfSBlbHNlIGlmIChzdHJlYW0uZWF0KFwiL1wiKSkge1xuICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICAgIH1cbiAgICAgIHN0cmVhbS5iYWNrVXAoMSk7XG4gICAgfVxuICAgIC8vIERlY2ltYWxcbiAgICBlbHNlIGlmICgvWytcXC1cXGRcXC5dLy50ZXN0KGNoKSkge1xuICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXlsrLV0/WzAtOV0qXFwuWzAtOV0qKFtlc2R4XVsrLV0/WzAtOV0rKT8vaSkgfHxcbiAgICAgICAgICBzdHJlYW0ubWF0Y2goL15bKy1dP1swLTldKyhbZXNkeF1bKy1dP1swLTldKykvaSkgfHxcbiAgICAgICAgICBzdHJlYW0ubWF0Y2goL15bKy1dP1xcZCsvKSkge1xuICAgICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gSGFzaFxuICAgIGVsc2UgaWYgKGNoID09IFwiI1wiKSB7XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgLy8gU3ltYm9sIHdpdGggc3RyaW5nIHN5bnRheFxuICAgICAgY2ggPSBzdHJlYW0ucGVlaygpO1xuICAgICAgaWYgKGNoID09ICdcIicpIHtcbiAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIHRva2VuU3RyaW5nKCdcIicsIFwic3RyaW5nXCIpKTtcbiAgICAgIH1cbiAgICAgIC8vIEJpbmFyeSBudW1iZXJcbiAgICAgIGVsc2UgaWYgKGNoID09IFwiYlwiKSB7XG4gICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvWzAxXS8pO1xuICAgICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICAgIH1cbiAgICAgIC8vIEhleCBudW1iZXJcbiAgICAgIGVsc2UgaWYgKGNoID09IFwieFwiKSB7XG4gICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcZGEtZl0vaSk7XG4gICAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgICAgfVxuICAgICAgLy8gT2N0YWwgbnVtYmVyXG4gICAgICBlbHNlIGlmIChjaCA9PSBcIm9cIikge1xuICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1swLTddLyk7XG4gICAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgICAgfVxuICAgICAgLy8gVG9rZW4gY29uY2F0ZW5hdGlvbiBpbiBtYWNyb3NcbiAgICAgIGVsc2UgaWYgKGNoID09ICcjJykge1xuICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICByZXR1cm4gXCJwdW5jdHVhdGlvblwiO1xuICAgICAgfVxuICAgICAgLy8gU2VxdWVuY2UgbGl0ZXJhbHNcbiAgICAgIGVsc2UgaWYgKChjaCA9PSAnWycpIHx8IChjaCA9PSAnKCcpKSB7XG4gICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIHJldHVybiBcImJyYWNrZXRcIjtcbiAgICAgIC8vIEhhc2ggc3ltYm9sXG4gICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaCgvZnx0fGFsbC1rZXlzfGluY2x1ZGV8a2V5fG5leHR8cmVzdC9pKSkge1xuICAgICAgICByZXR1cm4gXCJhdG9tXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1stYS16QS1aXS8pO1xuICAgICAgICByZXR1cm4gXCJlcnJvclwiO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2ggPT0gXCJ+XCIpIHtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICBjaCA9IHN0cmVhbS5wZWVrKCk7XG4gICAgICBpZiAoY2ggPT0gXCI9XCIpIHtcbiAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgY2ggPSBzdHJlYW0ucGVlaygpO1xuICAgICAgICBpZiAoY2ggPT0gXCI9XCIpIHtcbiAgICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gICAgfSBlbHNlIGlmIChjaCA9PSBcIjpcIikge1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIGNoID0gc3RyZWFtLnBlZWsoKTtcbiAgICAgIGlmIChjaCA9PSBcIj1cIikge1xuICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICAgICAgfSBlbHNlIGlmIChjaCA9PSBcIjpcIikge1xuICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICByZXR1cm4gXCJwdW5jdHVhdGlvblwiO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXCJbXSgpe31cIi5pbmRleE9mKGNoKSAhPSAtMSkge1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHJldHVybiBcImJyYWNrZXRcIjtcbiAgICB9IGVsc2UgaWYgKFwiLixcIi5pbmRleE9mKGNoKSAhPSAtMSkge1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHJldHVybiBcInB1bmN0dWF0aW9uXCI7XG4gICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goXCJlbmRcIikpIHtcbiAgICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgICB9XG4gICAgZm9yICh2YXIgbmFtZSBpbiBwYXR0ZXJucykge1xuICAgICAgaWYgKHBhdHRlcm5zLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHZhciBwYXR0ZXJuID0gcGF0dGVybnNbbmFtZV07XG4gICAgICAgIGlmICgocGF0dGVybiBpbnN0YW5jZW9mIEFycmF5ICYmIHNvbWUocGF0dGVybiwgZnVuY3Rpb24ocCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW0ubWF0Y2gocCk7XG4gICAgICAgIH0pKSB8fCBzdHJlYW0ubWF0Y2gocGF0dGVybikpXG4gICAgICAgICAgcmV0dXJuIHBhdHRlcm5TdHlsZXNbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgvWytcXC0qXFwvXj08PiZ8XS8udGVzdChjaCkpIHtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICAgIH1cbiAgICBpZiAoc3RyZWFtLm1hdGNoKFwiZGVmaW5lXCIpKSB7XG4gICAgICByZXR1cm4gXCJkZWZcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwtXS8pO1xuICAgICAgLy8gS2V5d29yZFxuICAgICAgaWYgKHdvcmRMb29rdXAuaGFzT3duUHJvcGVydHkoc3RyZWFtLmN1cnJlbnQoKSkpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxlTG9va3VwW3N0cmVhbS5jdXJyZW50KCldO1xuICAgICAgfSBlbHNlIGlmIChzdHJlYW0uY3VycmVudCgpLm1hdGNoKHN5bWJvbCkpIHtcbiAgICAgICAgcmV0dXJuIFwidmFyaWFibGVcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIHJldHVybiBcInZhcmlhYmxlLTJcIjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBtYXliZUVuZCA9IGZhbHNlLCBtYXliZU5lc3RlZCA9IGZhbHNlLCBuZXN0ZWRDb3VudCA9IDAsIGNoO1xuICAgIHdoaWxlICgoY2ggPSBzdHJlYW0ubmV4dCgpKSkge1xuICAgICAgaWYgKGNoID09IFwiL1wiICYmIG1heWJlRW5kKSB7XG4gICAgICAgIGlmIChuZXN0ZWRDb3VudCA+IDApIHtcbiAgICAgICAgICBuZXN0ZWRDb3VudC0tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoID09IFwiKlwiICYmIG1heWJlTmVzdGVkKSB7XG4gICAgICAgIG5lc3RlZENvdW50Kys7XG4gICAgICB9XG4gICAgICBtYXliZUVuZCA9IChjaCA9PSBcIipcIik7XG4gICAgICBtYXliZU5lc3RlZCA9IChjaCA9PSBcIi9cIik7XG4gICAgfVxuICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuU3RyaW5nKHF1b3RlLCBzdHlsZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgZXNjYXBlZCA9IGZhbHNlLCBuZXh0LCBlbmQgPSBmYWxzZTtcbiAgICAgIHdoaWxlICgobmV4dCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgICAgaWYgKG5leHQgPT0gcXVvdGUgJiYgIWVzY2FwZWQpIHtcbiAgICAgICAgICBlbmQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZCAmJiBuZXh0ID09IFwiXFxcXFwiO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCB8fCAhZXNjYXBlZCkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9O1xuICB9XG5cbiAgLy8gSW50ZXJmYWNlXG4gIHJldHVybiB7XG4gICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b2tlbml6ZTogdG9rZW5CYXNlLFxuICAgICAgICBjdXJyZW50SW5kZW50OiAwXG4gICAgICB9O1xuICAgIH0sXG4gICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgc3R5bGUgPSBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9LFxuICAgIGJsb2NrQ29tbWVudFN0YXJ0OiBcIi8qXCIsXG4gICAgYmxvY2tDb21tZW50RW5kOiBcIiovXCJcbiAgfTtcbn0pO1xuXG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3gtZHlsYW5cIiwgXCJkeWxhblwiKTtcblxufSk7XG4iLCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBDb2RlTWlycm9yLmRlZmluZU1vZGUoXCJlYm5mXCIsIGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICB2YXIgY29tbWVudFR5cGUgPSB7c2xhc2g6IDAsIHBhcmVudGhlc2lzOiAxfTtcbiAgICB2YXIgc3RhdGVUeXBlID0ge2NvbW1lbnQ6IDAsIF9zdHJpbmc6IDEsIGNoYXJhY3RlckNsYXNzOiAyfTtcbiAgICB2YXIgYnJhY2VzTW9kZSA9IG51bGw7XG5cbiAgICBpZiAoY29uZmlnLmJyYWNlc01vZGUpXG4gICAgICBicmFjZXNNb2RlID0gQ29kZU1pcnJvci5nZXRNb2RlKGNvbmZpZywgY29uZmlnLmJyYWNlc01vZGUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdHJpbmdUeXBlOiBudWxsLFxuICAgICAgICAgIGNvbW1lbnRUeXBlOiBudWxsLFxuICAgICAgICAgIGJyYWNlZDogMCxcbiAgICAgICAgICBsaHM6IHRydWUsXG4gICAgICAgICAgbG9jYWxTdGF0ZTogbnVsbCxcbiAgICAgICAgICBzdGFjazogW10sXG4gICAgICAgICAgaW5EZWZpbml0aW9uOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHRva2VuOiBmdW5jdGlvbiAoc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgICBpZiAoIXN0cmVhbSkgcmV0dXJuO1xuXG4gICAgICAgIC8vY2hlY2sgZm9yIHN0YXRlIGNoYW5nZXNcbiAgICAgICAgaWYgKHN0YXRlLnN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIC8vc3RyaW5nc1xuICAgICAgICAgIGlmICgoc3RyZWFtLnBlZWsoKSA9PSAnXCInKSB8fCAoc3RyZWFtLnBlZWsoKSA9PSBcIidcIikpIHtcbiAgICAgICAgICAgIHN0YXRlLnN0cmluZ1R5cGUgPSBzdHJlYW0ucGVlaygpO1xuICAgICAgICAgICAgc3RyZWFtLm5leHQoKTsgLy8gU2tpcCBxdW90ZVxuICAgICAgICAgICAgc3RhdGUuc3RhY2sudW5zaGlmdChzdGF0ZVR5cGUuX3N0cmluZyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goJy8qJykpIHsgLy9jb21tZW50cyBzdGFydGluZyB3aXRoIC8qXG4gICAgICAgICAgICBzdGF0ZS5zdGFjay51bnNoaWZ0KHN0YXRlVHlwZS5jb21tZW50KTtcbiAgICAgICAgICAgIHN0YXRlLmNvbW1lbnRUeXBlID0gY29tbWVudFR5cGUuc2xhc2g7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goJygqJykpIHsgLy9jb21tZW50cyBzdGFydGluZyB3aXRoICgqXG4gICAgICAgICAgICBzdGF0ZS5zdGFjay51bnNoaWZ0KHN0YXRlVHlwZS5jb21tZW50KTtcbiAgICAgICAgICAgIHN0YXRlLmNvbW1lbnRUeXBlID0gY29tbWVudFR5cGUucGFyZW50aGVzaXM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9yZXR1cm4gc3RhdGVcbiAgICAgICAgLy9zdGFjayBoYXNcbiAgICAgICAgc3dpdGNoIChzdGF0ZS5zdGFja1swXSkge1xuICAgICAgICBjYXNlIHN0YXRlVHlwZS5fc3RyaW5nOlxuICAgICAgICAgIHdoaWxlIChzdGF0ZS5zdGFja1swXSA9PT0gc3RhdGVUeXBlLl9zdHJpbmcgJiYgIXN0cmVhbS5lb2woKSkge1xuICAgICAgICAgICAgaWYgKHN0cmVhbS5wZWVrKCkgPT09IHN0YXRlLnN0cmluZ1R5cGUpIHtcbiAgICAgICAgICAgICAgc3RyZWFtLm5leHQoKTsgLy8gU2tpcCBxdW90ZVxuICAgICAgICAgICAgICBzdGF0ZS5zdGFjay5zaGlmdCgpOyAvLyBDbGVhciBmbGFnXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5wZWVrKCkgPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHJlYW0ubWF0Y2goL14uW15cXFxcXFxcIlxcJ10qLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzdGF0ZS5saHMgPyBcInByb3BlcnR5IHN0cmluZ1wiIDogXCJzdHJpbmdcIjsgLy8gVG9rZW4gc3R5bGVcblxuICAgICAgICBjYXNlIHN0YXRlVHlwZS5jb21tZW50OlxuICAgICAgICAgIHdoaWxlIChzdGF0ZS5zdGFja1swXSA9PT0gc3RhdGVUeXBlLmNvbW1lbnQgJiYgIXN0cmVhbS5lb2woKSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmNvbW1lbnRUeXBlID09PSBjb21tZW50VHlwZS5zbGFzaCAmJiBzdHJlYW0ubWF0Y2goJyovJykpIHtcbiAgICAgICAgICAgICAgc3RhdGUuc3RhY2suc2hpZnQoKTsgLy8gQ2xlYXIgZmxhZ1xuICAgICAgICAgICAgICBzdGF0ZS5jb21tZW50VHlwZSA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLmNvbW1lbnRUeXBlID09PSBjb21tZW50VHlwZS5wYXJlbnRoZXNpcyAmJiBzdHJlYW0ubWF0Y2goJyopJykpIHtcbiAgICAgICAgICAgICAgc3RhdGUuc3RhY2suc2hpZnQoKTsgLy8gQ2xlYXIgZmxhZ1xuICAgICAgICAgICAgICBzdGF0ZS5jb21tZW50VHlwZSA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHJlYW0ubWF0Y2goL14uW15cXCpdKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gXCJjb21tZW50XCI7XG5cbiAgICAgICAgY2FzZSBzdGF0ZVR5cGUuY2hhcmFjdGVyQ2xhc3M6XG4gICAgICAgICAgd2hpbGUgKHN0YXRlLnN0YWNrWzBdID09PSBzdGF0ZVR5cGUuY2hhcmFjdGVyQ2xhc3MgJiYgIXN0cmVhbS5lb2woKSkge1xuICAgICAgICAgICAgaWYgKCEoc3RyZWFtLm1hdGNoKC9eW15cXF1cXFxcXSsvKSB8fCBzdHJlYW0ubWF0Y2goJy4nKSkpIHtcbiAgICAgICAgICAgICAgc3RhdGUuc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwZWVrID0gc3RyZWFtLnBlZWsoKTtcblxuICAgICAgICBpZiAoYnJhY2VzTW9kZSAhPT0gbnVsbCAmJiAoc3RhdGUuYnJhY2VkIHx8IHBlZWsgPT09IFwie1wiKSkge1xuICAgICAgICAgIGlmIChzdGF0ZS5sb2NhbFN0YXRlID09PSBudWxsKVxuICAgICAgICAgICAgc3RhdGUubG9jYWxTdGF0ZSA9IENvZGVNaXJyb3Iuc3RhcnRTdGF0ZShicmFjZXNNb2RlKTtcblxuICAgICAgICAgIHZhciB0b2tlbiA9IGJyYWNlc01vZGUudG9rZW4oc3RyZWFtLCBzdGF0ZS5sb2NhbFN0YXRlKSxcbiAgICAgICAgICB0ZXh0ID0gc3RyZWFtLmN1cnJlbnQoKTtcblxuICAgICAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAodGV4dFtpXSA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuYnJhY2VkID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICB0b2tlbiA9IFwibWF0Y2hpbmdicmFja2V0XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXRlLmJyYWNlZCsrO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRleHRbaV0gPT09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuYnJhY2VkLS07XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmJyYWNlZCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgdG9rZW4gPSBcIm1hdGNoaW5nYnJhY2tldFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH1cblxuICAgICAgICAvL25vIHN0YWNrXG4gICAgICAgIHN3aXRjaCAocGVlaykge1xuICAgICAgICBjYXNlIFwiW1wiOlxuICAgICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgICAgc3RhdGUuc3RhY2sudW5zaGlmdChzdGF0ZVR5cGUuY2hhcmFjdGVyQ2xhc3MpO1xuICAgICAgICAgIHJldHVybiBcImJyYWNrZXRcIjtcbiAgICAgICAgY2FzZSBcIjpcIjpcbiAgICAgICAgY2FzZSBcInxcIjpcbiAgICAgICAgY2FzZSBcIjtcIjpcbiAgICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gICAgICAgIGNhc2UgXCIlXCI6XG4gICAgICAgICAgaWYgKHN0cmVhbS5tYXRjaChcIiUlXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJoZWFkZXJcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaCgvWyVdW0EtWmEtel0rLykpIHtcbiAgICAgICAgICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaCgvWyVdW31dLykpIHtcbiAgICAgICAgICAgIHJldHVybiBcIm1hdGNoaW5nYnJhY2tldFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIi9cIjpcbiAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9bXFwvXVtBLVphLXpdKy8pKSB7XG4gICAgICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJcXFxcXCI6XG4gICAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvW1xcXVthLXpdKy8pKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJzdHJpbmctMlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcIi5cIjpcbiAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKFwiLlwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiYXRvbVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcIipcIjpcbiAgICAgICAgY2FzZSBcIi1cIjpcbiAgICAgICAgY2FzZSBcIitcIjpcbiAgICAgICAgY2FzZSBcIl5cIjpcbiAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKHBlZWspKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJhdG9tXCI7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFwiJFwiOlxuICAgICAgICAgIGlmIChzdHJlYW0ubWF0Y2goXCIkJFwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiYnVpbHRpblwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKC9bJF1bMC05XSsvKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwidmFyaWFibGUtM1wiO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcIjxcIjpcbiAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC88PFthLXpBLVpfXSs+Pi8pKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJidWlsdGluXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgnLy8nKSkge1xuICAgICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKCdyZXR1cm4nKSkge1xuICAgICAgICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKC9eW2EtekEtWl9dW2EtekEtWjAtOV9dKi8pKSB7XG4gICAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvKD89W1xcKC5dKS8pKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKC8oPz1bXFxzXFxuXSpbOj1dKS8pKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJkZWZcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFwidmFyaWFibGUtMlwiO1xuICAgICAgICB9IGVsc2UgaWYgKFtcIltcIiwgXCJdXCIsIFwiKFwiLCBcIilcIl0uaW5kZXhPZihzdHJlYW0ucGVlaygpKSAhPSAtMSkge1xuICAgICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgICAgcmV0dXJuIFwiYnJhY2tldFwiO1xuICAgICAgICB9IGVsc2UgaWYgKCFzdHJlYW0uZWF0U3BhY2UoKSkge1xuICAgICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LWVibmZcIiwgXCJlYm5mXCIpO1xufSk7XG4iLCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTW9kZShcImVjbFwiLCBmdW5jdGlvbihjb25maWcpIHtcblxuICBmdW5jdGlvbiB3b3JkcyhzdHIpIHtcbiAgICB2YXIgb2JqID0ge30sIHdvcmRzID0gc3RyLnNwbGl0KFwiIFwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgKytpKSBvYmpbd29yZHNbaV1dID0gdHJ1ZTtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgZnVuY3Rpb24gbWV0YUhvb2soc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmICghc3RhdGUuc3RhcnRPZkxpbmUpIHJldHVybiBmYWxzZTtcbiAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgcmV0dXJuIFwibWV0YVwiO1xuICB9XG5cbiAgdmFyIGluZGVudFVuaXQgPSBjb25maWcuaW5kZW50VW5pdDtcbiAgdmFyIGtleXdvcmQgPSB3b3JkcyhcImFicyBhY29zIGFsbG5vZGVzIGFzY2lpIGFzaW4gYXNzdHJpbmcgYXRhbiBhdGFuMiBhdmUgY2FzZSBjaG9vc2UgY2hvb3NlbiBjaG9vc2VzZXRzIGNsdXN0ZXJzaXplIGNvbWJpbmUgY29ycmVsYXRpb24gY29zIGNvc2ggY291bnQgY292YXJpYW5jZSBjcm9uIGRhdGFzZXQgZGVkdXAgZGVmaW5lIGRlbm9ybWFsaXplIGRpc3RyaWJ1dGUgZGlzdHJpYnV0ZWQgZGlzdHJpYnV0aW9uIGViY2RpYyBlbnRoIGVycm9yIGV2YWx1YXRlIGV2ZW50IGV2ZW50ZXh0cmEgZXZlbnRuYW1lIGV4aXN0cyBleHAgZmFpbGNvZGUgZmFpbG1lc3NhZ2UgZmV0Y2ggZnJvbXVuaWNvZGUgZ2V0aXN2YWxpZCBnbG9iYWwgZ3JhcGggZ3JvdXAgaGFzaCBoYXNoMzIgaGFzaDY0IGhhc2hjcmMgaGFzaG1kNSBoYXZpbmcgaWYgaW5kZXggaW50Zm9ybWF0IGlzdmFsaWQgaXRlcmF0ZSBqb2luIGtleXVuaWNvZGUgbGVuZ3RoIGxpYnJhcnkgbGltaXQgbG4gbG9jYWwgbG9nIGxvb3AgbWFwIG1hdGNoZWQgbWF0Y2hsZW5ndGggbWF0Y2hwb3NpdGlvbiBtYXRjaHRleHQgbWF0Y2h1bmljb2RlIG1heCBtZXJnZSBtZXJnZWpvaW4gbWluIG5vbG9jYWwgbm9uZW1wdHkgbm9ybWFsaXplIHBhcnNlIHBpcGUgcG93ZXIgcHJlbG9hZCBwcm9jZXNzIHByb2plY3QgcHVsbCByYW5kb20gcmFuZ2UgcmFuayByYW5rZWQgcmVhbGZvcm1hdCByZWNvcmRvZiByZWdleGZpbmQgcmVnZXhyZXBsYWNlIHJlZ3JvdXAgcmVqZWN0ZWQgcm9sbHVwIHJvdW5kIHJvdW5kdXAgcm93IHJvd2RpZmYgc2FtcGxlIHNldCBzaW4gc2luaCBzaXplb2Ygc29hcGNhbGwgc29ydCBzb3J0ZWQgc3FydCBzdGVwcGVkIHN0b3JlZCBzdW0gdGFibGUgdGFuIHRhbmggdGhpc25vZGUgdG9wbiB0b3VuaWNvZGUgdHJhbnNmZXIgdHJpbSB0cnVuY2F0ZSB0eXBlb2YgdW5ncm91cCB1bmljb2Rlb3JkZXIgdmFyaWFuY2Ugd2hpY2ggd29ya3VuaXQgeG1sZGVjb2RlIHhtbGVuY29kZSB4bWx0ZXh0IHhtbHVuaWNvZGVcIik7XG4gIHZhciB2YXJpYWJsZSA9IHdvcmRzKFwiYXBwbHkgYXNzZXJ0IGJ1aWxkIGJ1aWxkaW5kZXggZXZhbHVhdGUgZmFpbCBrZXlkaWZmIGtleXBhdGNoIGxvYWR4bWwgbm90aG9yIG5vdGlmeSBvdXRwdXQgcGFyYWxsZWwgc2VxdWVudGlhbCBzb2FwY2FsbCB3YWl0XCIpO1xuICB2YXIgdmFyaWFibGVfMiA9IHdvcmRzKFwiX19jb21wcmVzc2VkX18gYWxsIGFuZCBhbnkgYXMgYXRtb3N0IGJlZm9yZSBiZWdpbmMrKyBiZXN0IGJldHdlZW4gY2FzZSBjb25zdCBjb3VudGVyIGNzdiBkZXNjZW5kIGVuY3J5cHQgZW5kIGVuZGMrKyBlbmRtYWNybyBleGNlcHQgZXhjbHVzaXZlIGV4cGlyZSBleHBvcnQgZXh0ZW5kIGZhbHNlIGZldyBmaXJzdCBmbGF0IGZyb20gZnVsbCBmdW5jdGlvbiBncm91cCBoZWFkZXIgaGVhZGluZyBob2xlIGlmYmxvY2sgaW1wb3J0IGluIGludGVyZmFjZSBqb2luZWQga2VlcCBrZXllZCBsYXN0IGxlZnQgbGltaXQgbG9hZCBsb2NhbCBsb2NhbGUgbG9va3VwIG1hY3JvIG1hbnkgbWF4Y291bnQgbWF4bGVuZ3RoIG1pbiBza2V3IG1vZHVsZSBuYW1lZCBub2Nhc2Ugbm9yb290IG5vc2NhbiBub3NvcnQgbm90IG9mIG9ubHkgb3B0IG9yIG91dGVyIG92ZXJ3cml0ZSBwYWNrZWQgcGFydGl0aW9uIHBlbmFsdHkgcGh5c2ljYWxsZW5ndGggcGlwZSBxdW90ZSByZWNvcmQgcmVsYXRpb25zaGlwIHJlcGVhdCByZXR1cm4gcmlnaHQgc2NhbiBzZWxmIHNlcGFyYXRvciBzZXJ2aWNlIHNoYXJlZCBza2V3IHNraXAgc3FsIHN0b3JlIHRlcm1pbmF0b3IgdGhvciB0aHJlc2hvbGQgdG9rZW4gdHJhbnNmb3JtIHRyaW0gdHJ1ZSB0eXBlIHVuaWNvZGVvcmRlciB1bnNvcnRlZCB2YWxpZGF0ZSB2aXJ0dWFsIHdob2xlIHdpbGQgd2l0aGluIHhtbCB4cGF0aFwiKTtcbiAgdmFyIHZhcmlhYmxlXzMgPSB3b3JkcyhcImFzY2lpIGJpZ19lbmRpYW4gYm9vbGVhbiBkYXRhIGRlY2ltYWwgZWJjZGljIGludGVnZXIgcGF0dGVybiBxc3RyaW5nIHJlYWwgcmVjb3JkIHJ1bGUgc2V0IG9mIHN0cmluZyB0b2tlbiB1ZGVjaW1hbCB1bmljb2RlIHVuc2lnbmVkIHZhcnN0cmluZyB2YXJ1bmljb2RlXCIpO1xuICB2YXIgYnVpbHRpbiA9IHdvcmRzKFwiY2hlY2twb2ludCBkZXByZWNhdGVkIGZhaWxjb2RlIGZhaWxtZXNzYWdlIGZhaWx1cmUgZ2xvYmFsIGluZGVwZW5kZW50IG9ud2FybmluZyBwZXJzaXN0IHByaW9yaXR5IHJlY292ZXJ5IHN0b3JlZCBzdWNjZXNzIHdhaXQgd2hlblwiKTtcbiAgdmFyIGJsb2NrS2V5d29yZHMgPSB3b3JkcyhcImNhdGNoIGNsYXNzIGRvIGVsc2UgZmluYWxseSBmb3IgaWYgc3dpdGNoIHRyeSB3aGlsZVwiKTtcbiAgdmFyIGF0b21zID0gd29yZHMoXCJ0cnVlIGZhbHNlIG51bGxcIik7XG4gIHZhciBob29rcyA9IHtcIiNcIjogbWV0YUhvb2t9O1xuICB2YXIgaXNPcGVyYXRvckNoYXIgPSAvWytcXC0qJiU9PD4hP3xcXC9dLztcblxuICB2YXIgY3VyUHVuYztcblxuICBmdW5jdGlvbiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG4gICAgaWYgKGhvb2tzW2NoXSkge1xuICAgICAgdmFyIHJlc3VsdCA9IGhvb2tzW2NoXShzdHJlYW0sIHN0YXRlKTtcbiAgICAgIGlmIChyZXN1bHQgIT09IGZhbHNlKSByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAoY2ggPT0gJ1wiJyB8fCBjaCA9PSBcIidcIikge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlblN0cmluZyhjaCk7XG4gICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICAgIGlmICgvW1xcW1xcXXt9XFwoXFwpLDtcXDpcXC5dLy50ZXN0KGNoKSkge1xuICAgICAgY3VyUHVuYyA9IGNoO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICgvXFxkLy50ZXN0KGNoKSkge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwuXS8pO1xuICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgfVxuICAgIGlmIChjaCA9PSBcIi9cIikge1xuICAgICAgaWYgKHN0cmVhbS5lYXQoXCIqXCIpKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5Db21tZW50O1xuICAgICAgICByZXR1cm4gdG9rZW5Db21tZW50KHN0cmVhbSwgc3RhdGUpO1xuICAgICAgfVxuICAgICAgaWYgKHN0cmVhbS5lYXQoXCIvXCIpKSB7XG4gICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNPcGVyYXRvckNoYXIudGVzdChjaCkpIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZShpc09wZXJhdG9yQ2hhcik7XG4gICAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICAgIH1cbiAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXCRfXS8pO1xuICAgIHZhciBjdXIgPSBzdHJlYW0uY3VycmVudCgpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGtleXdvcmQucHJvcGVydHlJc0VudW1lcmFibGUoY3VyKSkge1xuICAgICAgaWYgKGJsb2NrS2V5d29yZHMucHJvcGVydHlJc0VudW1lcmFibGUoY3VyKSkgY3VyUHVuYyA9IFwibmV3c3RhdGVtZW50XCI7XG4gICAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gICAgfSBlbHNlIGlmICh2YXJpYWJsZS5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSB7XG4gICAgICBpZiAoYmxvY2tLZXl3b3Jkcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSBjdXJQdW5jID0gXCJuZXdzdGF0ZW1lbnRcIjtcbiAgICAgIHJldHVybiBcInZhcmlhYmxlXCI7XG4gICAgfSBlbHNlIGlmICh2YXJpYWJsZV8yLnByb3BlcnR5SXNFbnVtZXJhYmxlKGN1cikpIHtcbiAgICAgIGlmIChibG9ja0tleXdvcmRzLnByb3BlcnR5SXNFbnVtZXJhYmxlKGN1cikpIGN1clB1bmMgPSBcIm5ld3N0YXRlbWVudFwiO1xuICAgICAgcmV0dXJuIFwidmFyaWFibGUtMlwiO1xuICAgIH0gZWxzZSBpZiAodmFyaWFibGVfMy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSB7XG4gICAgICBpZiAoYmxvY2tLZXl3b3Jkcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSBjdXJQdW5jID0gXCJuZXdzdGF0ZW1lbnRcIjtcbiAgICAgIHJldHVybiBcInZhcmlhYmxlLTNcIjtcbiAgICB9IGVsc2UgaWYgKGJ1aWx0aW4ucHJvcGVydHlJc0VudW1lcmFibGUoY3VyKSkge1xuICAgICAgaWYgKGJsb2NrS2V5d29yZHMucHJvcGVydHlJc0VudW1lcmFibGUoY3VyKSkgY3VyUHVuYyA9IFwibmV3c3RhdGVtZW50XCI7XG4gICAgICByZXR1cm4gXCJidWlsdGluXCI7XG4gICAgfSBlbHNlIHsgLy9EYXRhIHR5cGVzIGFyZSBvZiBmcm9tIEtFWVdPUkQjI1xuICAgICAgICAgICAgICAgIHZhciBpID0gY3VyLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgd2hpbGUoaSA+PSAwICYmICghaXNOYU4oY3VyW2ldKSB8fCBjdXJbaV0gPT0gJ18nKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC0taTtcblxuICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cjIgPSBjdXIuc3Vic3RyKDAsIGkgKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAodmFyaWFibGVfMy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrS2V5d29yZHMucHJvcGVydHlJc0VudW1lcmFibGUoY3VyMikpIGN1clB1bmMgPSBcIm5ld3N0YXRlbWVudFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidmFyaWFibGUtM1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGF0b21zLnByb3BlcnR5SXNFbnVtZXJhYmxlKGN1cikpIHJldHVybiBcImF0b21cIjtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuU3RyaW5nKHF1b3RlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBlc2NhcGVkID0gZmFsc2UsIG5leHQsIGVuZCA9IGZhbHNlO1xuICAgICAgd2hpbGUgKChuZXh0ID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgICBpZiAobmV4dCA9PSBxdW90ZSAmJiAhZXNjYXBlZCkge2VuZCA9IHRydWU7IGJyZWFrO31cbiAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkICYmIG5leHQgPT0gXCJcXFxcXCI7XG4gICAgICB9XG4gICAgICBpZiAoZW5kIHx8ICFlc2NhcGVkKVxuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBtYXliZUVuZCA9IGZhbHNlLCBjaDtcbiAgICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgICBpZiAoY2ggPT0gXCIvXCIgJiYgbWF5YmVFbmQpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbWF5YmVFbmQgPSAoY2ggPT0gXCIqXCIpO1xuICAgIH1cbiAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KGluZGVudGVkLCBjb2x1bW4sIHR5cGUsIGFsaWduLCBwcmV2KSB7XG4gICAgdGhpcy5pbmRlbnRlZCA9IGluZGVudGVkO1xuICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5hbGlnbiA9IGFsaWduO1xuICAgIHRoaXMucHJldiA9IHByZXY7XG4gIH1cbiAgZnVuY3Rpb24gcHVzaENvbnRleHQoc3RhdGUsIGNvbCwgdHlwZSkge1xuICAgIHJldHVybiBzdGF0ZS5jb250ZXh0ID0gbmV3IENvbnRleHQoc3RhdGUuaW5kZW50ZWQsIGNvbCwgdHlwZSwgbnVsbCwgc3RhdGUuY29udGV4dCk7XG4gIH1cbiAgZnVuY3Rpb24gcG9wQ29udGV4dChzdGF0ZSkge1xuICAgIHZhciB0ID0gc3RhdGUuY29udGV4dC50eXBlO1xuICAgIGlmICh0ID09IFwiKVwiIHx8IHQgPT0gXCJdXCIgfHwgdCA9PSBcIn1cIilcbiAgICAgIHN0YXRlLmluZGVudGVkID0gc3RhdGUuY29udGV4dC5pbmRlbnRlZDtcbiAgICByZXR1cm4gc3RhdGUuY29udGV4dCA9IHN0YXRlLmNvbnRleHQucHJldjtcbiAgfVxuXG4gIC8vIEludGVyZmFjZVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oYmFzZWNvbHVtbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9rZW5pemU6IG51bGwsXG4gICAgICAgIGNvbnRleHQ6IG5ldyBDb250ZXh0KChiYXNlY29sdW1uIHx8IDApIC0gaW5kZW50VW5pdCwgMCwgXCJ0b3BcIiwgZmFsc2UpLFxuICAgICAgICBpbmRlbnRlZDogMCxcbiAgICAgICAgc3RhcnRPZkxpbmU6IHRydWVcbiAgICAgIH07XG4gICAgfSxcblxuICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgY3R4ID0gc3RhdGUuY29udGV4dDtcbiAgICAgIGlmIChzdHJlYW0uc29sKCkpIHtcbiAgICAgICAgaWYgKGN0eC5hbGlnbiA9PSBudWxsKSBjdHguYWxpZ24gPSBmYWxzZTtcbiAgICAgICAgc3RhdGUuaW5kZW50ZWQgPSBzdHJlYW0uaW5kZW50YXRpb24oKTtcbiAgICAgICAgc3RhdGUuc3RhcnRPZkxpbmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSByZXR1cm4gbnVsbDtcbiAgICAgIGN1clB1bmMgPSBudWxsO1xuICAgICAgdmFyIHN0eWxlID0gKHN0YXRlLnRva2VuaXplIHx8IHRva2VuQmFzZSkoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBpZiAoc3R5bGUgPT0gXCJjb21tZW50XCIgfHwgc3R5bGUgPT0gXCJtZXRhXCIpIHJldHVybiBzdHlsZTtcbiAgICAgIGlmIChjdHguYWxpZ24gPT0gbnVsbCkgY3R4LmFsaWduID0gdHJ1ZTtcblxuICAgICAgaWYgKChjdXJQdW5jID09IFwiO1wiIHx8IGN1clB1bmMgPT0gXCI6XCIpICYmIGN0eC50eXBlID09IFwic3RhdGVtZW50XCIpIHBvcENvbnRleHQoc3RhdGUpO1xuICAgICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBcIntcIikgcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbS5jb2x1bW4oKSwgXCJ9XCIpO1xuICAgICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBcIltcIikgcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbS5jb2x1bW4oKSwgXCJdXCIpO1xuICAgICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBcIihcIikgcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbS5jb2x1bW4oKSwgXCIpXCIpO1xuICAgICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBcIn1cIikge1xuICAgICAgICB3aGlsZSAoY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIikgY3R4ID0gcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICAgIGlmIChjdHgudHlwZSA9PSBcIn1cIikgY3R4ID0gcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICAgIHdoaWxlIChjdHgudHlwZSA9PSBcInN0YXRlbWVudFwiKSBjdHggPSBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGN1clB1bmMgPT0gY3R4LnR5cGUpIHBvcENvbnRleHQoc3RhdGUpO1xuICAgICAgZWxzZSBpZiAoY3R4LnR5cGUgPT0gXCJ9XCIgfHwgY3R4LnR5cGUgPT0gXCJ0b3BcIiB8fCAoY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIiAmJiBjdXJQdW5jID09IFwibmV3c3RhdGVtZW50XCIpKVxuICAgICAgICBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLmNvbHVtbigpLCBcInN0YXRlbWVudFwiKTtcbiAgICAgIHN0YXRlLnN0YXJ0T2ZMaW5lID0gZmFsc2U7XG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfSxcblxuICAgIGluZGVudDogZnVuY3Rpb24oc3RhdGUsIHRleHRBZnRlcikge1xuICAgICAgaWYgKHN0YXRlLnRva2VuaXplICE9IHRva2VuQmFzZSAmJiBzdGF0ZS50b2tlbml6ZSAhPSBudWxsKSByZXR1cm4gMDtcbiAgICAgIHZhciBjdHggPSBzdGF0ZS5jb250ZXh0LCBmaXJzdENoYXIgPSB0ZXh0QWZ0ZXIgJiYgdGV4dEFmdGVyLmNoYXJBdCgwKTtcbiAgICAgIGlmIChjdHgudHlwZSA9PSBcInN0YXRlbWVudFwiICYmIGZpcnN0Q2hhciA9PSBcIn1cIikgY3R4ID0gY3R4LnByZXY7XG4gICAgICB2YXIgY2xvc2luZyA9IGZpcnN0Q2hhciA9PSBjdHgudHlwZTtcbiAgICAgIGlmIChjdHgudHlwZSA9PSBcInN0YXRlbWVudFwiKSByZXR1cm4gY3R4LmluZGVudGVkICsgKGZpcnN0Q2hhciA9PSBcIntcIiA/IDAgOiBpbmRlbnRVbml0KTtcbiAgICAgIGVsc2UgaWYgKGN0eC5hbGlnbikgcmV0dXJuIGN0eC5jb2x1bW4gKyAoY2xvc2luZyA/IDAgOiAxKTtcbiAgICAgIGVsc2UgcmV0dXJuIGN0eC5pbmRlbnRlZCArIChjbG9zaW5nID8gMCA6IGluZGVudFVuaXQpO1xuICAgIH0sXG5cbiAgICBlbGVjdHJpY0NoYXJzOiBcInt9XCJcbiAgfTtcbn0pO1xuXG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3gtZWNsXCIsIFwiZWNsXCIpO1xuXG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwiZWlmZmVsXCIsIGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiB3b3JkT2JqKHdvcmRzKSB7XG4gICAgdmFyIG8gPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMCwgZSA9IHdvcmRzLmxlbmd0aDsgaSA8IGU7ICsraSkgb1t3b3Jkc1tpXV0gPSB0cnVlO1xuICAgIHJldHVybiBvO1xuICB9XG4gIHZhciBrZXl3b3JkcyA9IHdvcmRPYmooW1xuICAgICdub3RlJyxcbiAgICAnYWNyb3NzJyxcbiAgICAnd2hlbicsXG4gICAgJ3ZhcmlhbnQnLFxuICAgICd1bnRpbCcsXG4gICAgJ3VuaXF1ZScsXG4gICAgJ3VuZGVmaW5lJyxcbiAgICAndGhlbicsXG4gICAgJ3N0cmlwJyxcbiAgICAnc2VsZWN0JyxcbiAgICAncmV0cnknLFxuICAgICdyZXNjdWUnLFxuICAgICdyZXF1aXJlJyxcbiAgICAncmVuYW1lJyxcbiAgICAncmVmZXJlbmNlJyxcbiAgICAncmVkZWZpbmUnLFxuICAgICdwcmVmaXgnLFxuICAgICdvbmNlJyxcbiAgICAnb2xkJyxcbiAgICAnb2Jzb2xldGUnLFxuICAgICdsb29wJyxcbiAgICAnbG9jYWwnLFxuICAgICdsaWtlJyxcbiAgICAnaXMnLFxuICAgICdpbnNwZWN0JyxcbiAgICAnaW5maXgnLFxuICAgICdpbmNsdWRlJyxcbiAgICAnaWYnLFxuICAgICdmcm96ZW4nLFxuICAgICdmcm9tJyxcbiAgICAnZXh0ZXJuYWwnLFxuICAgICdleHBvcnQnLFxuICAgICdlbnN1cmUnLFxuICAgICdlbmQnLFxuICAgICdlbHNlaWYnLFxuICAgICdlbHNlJyxcbiAgICAnZG8nLFxuICAgICdjcmVhdGlvbicsXG4gICAgJ2NyZWF0ZScsXG4gICAgJ2NoZWNrJyxcbiAgICAnYWxpYXMnLFxuICAgICdhZ2VudCcsXG4gICAgJ3NlcGFyYXRlJyxcbiAgICAnaW52YXJpYW50JyxcbiAgICAnaW5oZXJpdCcsXG4gICAgJ2luZGV4aW5nJyxcbiAgICAnZmVhdHVyZScsXG4gICAgJ2V4cGFuZGVkJyxcbiAgICAnZGVmZXJyZWQnLFxuICAgICdjbGFzcycsXG4gICAgJ1ZvaWQnLFxuICAgICdUcnVlJyxcbiAgICAnUmVzdWx0JyxcbiAgICAnUHJlY3Vyc29yJyxcbiAgICAnRmFsc2UnLFxuICAgICdDdXJyZW50JyxcbiAgICAnY3JlYXRlJyxcbiAgICAnYXR0YWNoZWQnLFxuICAgICdkZXRhY2hhYmxlJyxcbiAgICAnYXMnLFxuICAgICdhbmQnLFxuICAgICdpbXBsaWVzJyxcbiAgICAnbm90JyxcbiAgICAnb3InXG4gIF0pO1xuICB2YXIgb3BlcmF0b3JzID0gd29yZE9iaihbXCI6PVwiLCBcImFuZCB0aGVuXCIsXCJhbmRcIiwgXCJvclwiLFwiPDxcIixcIj4+XCJdKTtcblxuICBmdW5jdGlvbiBjaGFpbihuZXd0b2ssIHN0cmVhbSwgc3RhdGUpIHtcbiAgICBzdGF0ZS50b2tlbml6ZS5wdXNoKG5ld3Rvayk7XG4gICAgcmV0dXJuIG5ld3RvayhzdHJlYW0sIHN0YXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICAgIGlmIChjaCA9PSAnXCInfHxjaCA9PSBcIidcIikge1xuICAgICAgcmV0dXJuIGNoYWluKHJlYWRRdW90ZWQoY2gsIFwic3RyaW5nXCIpLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2UgaWYgKGNoID09IFwiLVwiJiZzdHJlYW0uZWF0KFwiLVwiKSkge1xuICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgIH0gZWxzZSBpZiAoY2ggPT0gXCI6XCImJnN0cmVhbS5lYXQoXCI9XCIpKSB7XG4gICAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICAgIH0gZWxzZSBpZiAoL1swLTldLy50ZXN0KGNoKSkge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9beFhiQkNjMC05XFwuXS8pO1xuICAgICAgc3RyZWFtLmVhdCgvW1xcP1xcIV0vKTtcbiAgICAgIHJldHVybiBcImlkZW50XCI7XG4gICAgfSBlbHNlIGlmICgvW2EtekEtWl8wLTldLy50ZXN0KGNoKSkge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bYS16QS1aXzAtOV0vKTtcbiAgICAgIHN0cmVhbS5lYXQoL1tcXD9cXCFdLyk7XG4gICAgICByZXR1cm4gXCJpZGVudFwiO1xuICAgIH0gZWxzZSBpZiAoL1s9K1xcLVxcLypeJTw+fl0vLnRlc3QoY2gpKSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1s9K1xcLVxcLypeJTw+fl0vKTtcbiAgICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRRdW90ZWQocXVvdGUsIHN0eWxlLCAgdW5lc2NhcGVkKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBlc2NhcGVkID0gZmFsc2UsIGNoO1xuICAgICAgd2hpbGUgKChjaCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGNoID09IHF1b3RlICYmICh1bmVzY2FwZWQgfHwgIWVzY2FwZWQpKSB7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemUucG9wKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkICYmIGNoID09IFwiJVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHt0b2tlbml6ZTogW3Rva2VuQmFzZV19O1xuICAgIH0sXG5cbiAgICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIHN0eWxlID0gc3RhdGUudG9rZW5pemVbc3RhdGUudG9rZW5pemUubGVuZ3RoLTFdKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgaWYgKHN0eWxlID09IFwiaWRlbnRcIikge1xuICAgICAgICB2YXIgd29yZCA9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAgICAgIHN0eWxlID0ga2V5d29yZHMucHJvcGVydHlJc0VudW1lcmFibGUoc3RyZWFtLmN1cnJlbnQoKSkgPyBcImtleXdvcmRcIlxuICAgICAgICAgIDogb3BlcmF0b3JzLnByb3BlcnR5SXNFbnVtZXJhYmxlKHN0cmVhbS5jdXJyZW50KCkpID8gXCJvcGVyYXRvclwiXG4gICAgICAgICAgOiAvXltBLVpdW0EtWl8wLTldKiQvZy50ZXN0KHdvcmQpID8gXCJ0YWdcIlxuICAgICAgICAgIDogL14wW2JCXVswLTFdKyQvZy50ZXN0KHdvcmQpID8gXCJudW1iZXJcIlxuICAgICAgICAgIDogL14wW2NDXVswLTddKyQvZy50ZXN0KHdvcmQpID8gXCJudW1iZXJcIlxuICAgICAgICAgIDogL14wW3hYXVthLWZBLUYwLTldKyQvZy50ZXN0KHdvcmQpID8gXCJudW1iZXJcIlxuICAgICAgICAgIDogL14oWzAtOV0rXFwuWzAtOV0qKXwoWzAtOV0qXFwuWzAtOV0rKSQvZy50ZXN0KHdvcmQpID8gXCJudW1iZXJcIlxuICAgICAgICAgIDogL15bMC05XSskL2cudGVzdCh3b3JkKSA/IFwibnVtYmVyXCJcbiAgICAgICAgICA6IFwidmFyaWFibGVcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9LFxuICAgIGxpbmVDb21tZW50OiBcIi0tXCJcbiAgfTtcbn0pO1xuXG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3gtZWlmZmVsXCIsIFwiZWlmZmVsXCIpO1xuXG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cDovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwiZWxtXCIsIGZ1bmN0aW9uKCkge1xuXG4gICAgZnVuY3Rpb24gc3dpdGNoU3RhdGUoc291cmNlLCBzZXRTdGF0ZSwgZilcbiAgICB7XG4gICAgICBzZXRTdGF0ZShmKTtcbiAgICAgIHJldHVybiBmKHNvdXJjZSwgc2V0U3RhdGUpO1xuICAgIH1cblxuICAgIHZhciBsb3dlclJFID0gL1thLXpdLztcbiAgICB2YXIgdXBwZXJSRSA9IC9bQS1aXS87XG4gICAgdmFyIGlubmVyUkUgPSAvW2EtekEtWjAtOV9dLztcblxuICAgIHZhciBkaWdpdFJFID0gL1swLTldLztcbiAgICB2YXIgaGV4UkUgPSAvWzAtOUEtRmEtZl0vO1xuICAgIHZhciBzeW1ib2xSRSA9IC9bLSYqKy5cXFxcLzw+PT9efDpdLztcbiAgICB2YXIgc3BlY2lhbFJFID0gL1soKSxbXFxde31dLztcbiAgICB2YXIgc3BhY2VzUkUgPSAvWyBcXHZcXGZdLzsgLy8gbmV3bGluZXMgYXJlIGhhbmRsZWQgaW4gdG9rZW5pemVyXG5cbiAgICBmdW5jdGlvbiBub3JtYWwoKVxuICAgIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzb3VyY2UsIHNldFN0YXRlKVxuICAgICAge1xuICAgICAgICBpZiAoc291cmNlLmVhdFdoaWxlKHNwYWNlc1JFKSlcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoYXIgPSBzb3VyY2UubmV4dCgpO1xuXG4gICAgICAgIGlmIChzcGVjaWFsUkUudGVzdChjaGFyKSlcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiAoY2hhciA9PT0gJ3snICYmIHNvdXJjZS5lYXQoJy0nKSlcbiAgICAgICAgICAgID8gc3dpdGNoU3RhdGUoc291cmNlLCBzZXRTdGF0ZSwgY2hvbXBNdWx0aUNvbW1lbnQoMSkpXG4gICAgICAgICAgICA6IChjaGFyID09PSAnWycgJiYgc291cmNlLm1hdGNoKCdnbHNsfCcpKVxuICAgICAgICAgICAgICAgID8gc3dpdGNoU3RhdGUoc291cmNlLCBzZXRTdGF0ZSwgY2hvbXBHbHNsKVxuICAgICAgICAgICAgICAgIDogJ2J1aWx0aW4nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYXIgPT09ICdcXCcnKVxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHN3aXRjaFN0YXRlKHNvdXJjZSwgc2V0U3RhdGUsIGNob21wQ2hhcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hhciA9PT0gJ1wiJylcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBzb3VyY2UuZWF0KCdcIicpXG4gICAgICAgICAgICA/IHNvdXJjZS5lYXQoJ1wiJylcbiAgICAgICAgICAgICAgICA/IHN3aXRjaFN0YXRlKHNvdXJjZSwgc2V0U3RhdGUsIGNob21wTXVsdGlTdHJpbmcpXG4gICAgICAgICAgICAgICAgOiAnc3RyaW5nJ1xuICAgICAgICAgICAgOiBzd2l0Y2hTdGF0ZShzb3VyY2UsIHNldFN0YXRlLCBjaG9tcFNpbmdsZVN0cmluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXBwZXJSRS50ZXN0KGNoYXIpKVxuICAgICAgICB7XG4gICAgICAgICAgc291cmNlLmVhdFdoaWxlKGlubmVyUkUpO1xuICAgICAgICAgIHJldHVybiAndmFyaWFibGUtMic7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG93ZXJSRS50ZXN0KGNoYXIpKVxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGlzRGVmID0gc291cmNlLnBvcyA9PT0gMTtcbiAgICAgICAgICBzb3VyY2UuZWF0V2hpbGUoaW5uZXJSRSk7XG4gICAgICAgICAgcmV0dXJuIGlzRGVmID8gXCJkZWZcIiA6IFwidmFyaWFibGVcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkaWdpdFJFLnRlc3QoY2hhcikpXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoY2hhciA9PT0gJzAnKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UuZWF0KC9beFhdLykpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHNvdXJjZS5lYXRXaGlsZShoZXhSRSk7IC8vIHNob3VsZCByZXF1aXJlIGF0IGxlYXN0IDFcbiAgICAgICAgICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzb3VyY2UuZWF0V2hpbGUoZGlnaXRSRSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzb3VyY2UuZWF0KCcuJykpXG4gICAgICAgICAge1xuICAgICAgICAgICAgc291cmNlLmVhdFdoaWxlKGRpZ2l0UkUpOyAvLyBzaG91bGQgcmVxdWlyZSBhdCBsZWFzdCAxXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzb3VyY2UuZWF0KC9bZUVdLykpXG4gICAgICAgICAge1xuICAgICAgICAgICAgc291cmNlLmVhdCgvWy0rXS8pO1xuICAgICAgICAgICAgc291cmNlLmVhdFdoaWxlKGRpZ2l0UkUpOyAvLyBzaG91bGQgcmVxdWlyZSBhdCBsZWFzdCAxXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN5bWJvbFJFLnRlc3QoY2hhcikpXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoY2hhciA9PT0gJy0nICYmIHNvdXJjZS5lYXQoJy0nKSlcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzb3VyY2Uuc2tpcFRvRW5kKCk7XG4gICAgICAgICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNvdXJjZS5lYXRXaGlsZShzeW1ib2xSRSk7XG4gICAgICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYXIgPT09ICdfJylcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBcImVycm9yXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hvbXBNdWx0aUNvbW1lbnQobmVzdClcbiAgICB7XG4gICAgICBpZiAobmVzdCA9PSAwKVxuICAgICAge1xuICAgICAgICByZXR1cm4gbm9ybWFsKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc291cmNlLCBzZXRTdGF0ZSlcbiAgICAgIHtcbiAgICAgICAgd2hpbGUgKCFzb3VyY2UuZW9sKCkpXG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgY2hhciA9IHNvdXJjZS5uZXh0KCk7XG4gICAgICAgICAgaWYgKGNoYXIgPT0gJ3snICYmIHNvdXJjZS5lYXQoJy0nKSlcbiAgICAgICAgICB7XG4gICAgICAgICAgICArK25lc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGNoYXIgPT0gJy0nICYmIHNvdXJjZS5lYXQoJ30nKSlcbiAgICAgICAgICB7XG4gICAgICAgICAgICAtLW5lc3Q7XG4gICAgICAgICAgICBpZiAobmVzdCA9PT0gMClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc2V0U3RhdGUobm9ybWFsKCkpO1xuICAgICAgICAgICAgICByZXR1cm4gJ2NvbW1lbnQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXRTdGF0ZShjaG9tcE11bHRpQ29tbWVudChuZXN0KSk7XG4gICAgICAgIHJldHVybiAnY29tbWVudCc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hvbXBNdWx0aVN0cmluZyhzb3VyY2UsIHNldFN0YXRlKVxuICAgIHtcbiAgICAgIHdoaWxlICghc291cmNlLmVvbCgpKVxuICAgICAge1xuICAgICAgICB2YXIgY2hhciA9IHNvdXJjZS5uZXh0KCk7XG4gICAgICAgIGlmIChjaGFyID09PSAnXCInICYmIHNvdXJjZS5lYXQoJ1wiJykgJiYgc291cmNlLmVhdCgnXCInKSlcbiAgICAgICAge1xuICAgICAgICAgIHNldFN0YXRlKG5vcm1hbCgpKTtcbiAgICAgICAgICByZXR1cm4gJ3N0cmluZyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAnc3RyaW5nJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaG9tcFNpbmdsZVN0cmluZyhzb3VyY2UsIHNldFN0YXRlKVxuICAgIHtcbiAgICAgIHdoaWxlIChzb3VyY2Uuc2tpcFRvKCdcXFxcXCInKSkgeyBzb3VyY2UubmV4dCgpOyBzb3VyY2UubmV4dCgpOyB9XG4gICAgICBpZiAoc291cmNlLnNraXBUbygnXCInKSlcbiAgICAgIHtcbiAgICAgICAgc291cmNlLm5leHQoKTtcbiAgICAgICAgc2V0U3RhdGUobm9ybWFsKCkpO1xuICAgICAgICByZXR1cm4gJ3N0cmluZyc7XG4gICAgICB9XG4gICAgICBzb3VyY2Uuc2tpcFRvRW5kKCk7XG4gICAgICBzZXRTdGF0ZShub3JtYWwoKSk7XG4gICAgICByZXR1cm4gJ2Vycm9yJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaG9tcENoYXIoc291cmNlLCBzZXRTdGF0ZSlcbiAgICB7XG4gICAgICB3aGlsZSAoc291cmNlLnNraXBUbyhcIlxcXFwnXCIpKSB7IHNvdXJjZS5uZXh0KCk7IHNvdXJjZS5uZXh0KCk7IH1cbiAgICAgIGlmIChzb3VyY2Uuc2tpcFRvKFwiJ1wiKSlcbiAgICAgIHtcbiAgICAgICAgc291cmNlLm5leHQoKTtcbiAgICAgICAgc2V0U3RhdGUobm9ybWFsKCkpO1xuICAgICAgICByZXR1cm4gJ3N0cmluZyc7XG4gICAgICB9XG4gICAgICBzb3VyY2Uuc2tpcFRvRW5kKCk7XG4gICAgICBzZXRTdGF0ZShub3JtYWwoKSk7XG4gICAgICByZXR1cm4gJ2Vycm9yJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaG9tcEdsc2woc291cmNlLCBzZXRTdGF0ZSlcbiAgICB7XG4gICAgICB3aGlsZSAoIXNvdXJjZS5lb2woKSlcbiAgICAgIHtcbiAgICAgICAgdmFyIGNoYXIgPSBzb3VyY2UubmV4dCgpO1xuICAgICAgICBpZiAoY2hhciA9PT0gJ3wnICYmIHNvdXJjZS5lYXQoJ10nKSlcbiAgICAgICAge1xuICAgICAgICAgIHNldFN0YXRlKG5vcm1hbCgpKTtcbiAgICAgICAgICByZXR1cm4gJ3N0cmluZyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAnc3RyaW5nJztcbiAgICB9XG5cbiAgICB2YXIgd2VsbEtub3duV29yZHMgPSB7XG4gICAgICBjYXNlOiAxLFxuICAgICAgb2Y6IDEsXG4gICAgICBhczogMSxcbiAgICAgIGlmOiAxLFxuICAgICAgdGhlbjogMSxcbiAgICAgIGVsc2U6IDEsXG4gICAgICBsZXQ6IDEsXG4gICAgICBpbjogMSxcbiAgICAgIHR5cGU6IDEsXG4gICAgICBhbGlhczogMSxcbiAgICAgIG1vZHVsZTogMSxcbiAgICAgIHdoZXJlOiAxLFxuICAgICAgaW1wb3J0OiAxLFxuICAgICAgZXhwb3Npbmc6IDEsXG4gICAgICBwb3J0OiAxXG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICBzdGFydFN0YXRlOiBmdW5jdGlvbiAoKSAgeyByZXR1cm4geyBmOiBub3JtYWwoKSB9OyB9LFxuICAgICAgY29weVN0YXRlOiAgZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHsgZjogcy5mIH07IH0sXG5cbiAgICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIHZhciB0eXBlID0gc3RhdGUuZihzdHJlYW0sIGZ1bmN0aW9uKHMpIHsgc3RhdGUuZiA9IHM7IH0pO1xuICAgICAgICB2YXIgd29yZCA9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAgICAgIHJldHVybiAod2VsbEtub3duV29yZHMuaGFzT3duUHJvcGVydHkod29yZCkpID8gJ2tleXdvcmQnIDogdHlwZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIH0pO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQveC1lbG1cIiwgXCJlbG1cIik7XG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbi8qanNoaW50IHVudXNlZDp0cnVlLCBlcW51bGw6dHJ1ZSwgY3VybHk6dHJ1ZSwgYml0d2lzZTp0cnVlICovXG4vKmpzaGludCB1bmRlZjp0cnVlLCBsYXRlZGVmOnRydWUsIHRyYWlsaW5nOnRydWUgKi9cbi8qZ2xvYmFsIENvZGVNaXJyb3I6dHJ1ZSAqL1xuXG4vLyBlcmxhbmcgbW9kZS5cbi8vIHRva2VuaXplciAtPiB0b2tlbiB0eXBlcyAtPiBDb2RlTWlycm9yIHN0eWxlc1xuLy8gdG9rZW5pemVyIG1haW50YWlucyBhIHBhcnNlIHN0YWNrXG4vLyBpbmRlbnRlciB1c2VzIHRoZSBwYXJzZSBzdGFja1xuXG4vLyBUT0RPIGluZGVudGVyOlxuLy8gICBiaXQgc3ludGF4XG4vLyAgIG9sZCBndWFyZC9iaWYvY29udmVyc2lvbiBjbGFzaGVzIChlLmcuIFwiZmxvYXQvMVwiKVxuLy8gICB0eXBlL3NwZWMvb3BhcXVlXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LWVybGFuZ1wiLCBcImVybGFuZ1wiKTtcblxuQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwiZXJsYW5nXCIsIGZ1bmN0aW9uKGNtQ2ZnKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gY29uc3RhbnRzXG5cbiAgdmFyIHR5cGVXb3JkcyA9IFtcbiAgICBcIi10eXBlXCIsIFwiLXNwZWNcIiwgXCItZXhwb3J0X3R5cGVcIiwgXCItb3BhcXVlXCJdO1xuXG4gIHZhciBrZXl3b3JkV29yZHMgPSBbXG4gICAgXCJhZnRlclwiLFwiYmVnaW5cIixcImNhdGNoXCIsXCJjYXNlXCIsXCJjb25kXCIsXCJlbmRcIixcImZ1blwiLFwiaWZcIixcbiAgICBcImxldFwiLFwib2ZcIixcInF1ZXJ5XCIsXCJyZWNlaXZlXCIsXCJ0cnlcIixcIndoZW5cIl07XG5cbiAgdmFyIHNlcGFyYXRvclJFICAgID0gL1tcXC0+LDtdLztcbiAgdmFyIHNlcGFyYXRvcldvcmRzID0gW1xuICAgIFwiLT5cIixcIjtcIixcIixcIl07XG5cbiAgdmFyIG9wZXJhdG9yQXRvbVdvcmRzID0gW1xuICAgIFwiYW5kXCIsXCJhbmRhbHNvXCIsXCJiYW5kXCIsXCJibm90XCIsXCJib3JcIixcImJzbFwiLFwiYnNyXCIsXCJieG9yXCIsXG4gICAgXCJkaXZcIixcIm5vdFwiLFwib3JcIixcIm9yZWxzZVwiLFwicmVtXCIsXCJ4b3JcIl07XG5cbiAgdmFyIG9wZXJhdG9yU3ltYm9sUkUgICAgPSAvW1xcK1xcLVxcKlxcLzw+PVxcfDohXS87XG4gIHZhciBvcGVyYXRvclN5bWJvbFdvcmRzID0gW1xuICAgIFwiPVwiLFwiK1wiLFwiLVwiLFwiKlwiLFwiL1wiLFwiPlwiLFwiPj1cIixcIjxcIixcIj08XCIsXCI9Oj1cIixcIj09XCIsXCI9Lz1cIixcIi89XCIsXCJ8fFwiLFwiPC1cIixcIiFcIl07XG5cbiAgdmFyIG9wZW5QYXJlblJFICAgID0gL1s8XFwoXFxbXFx7XS87XG4gIHZhciBvcGVuUGFyZW5Xb3JkcyA9IFtcbiAgICBcIjw8XCIsXCIoXCIsXCJbXCIsXCJ7XCJdO1xuXG4gIHZhciBjbG9zZVBhcmVuUkUgICAgPSAvWz5cXClcXF1cXH1dLztcbiAgdmFyIGNsb3NlUGFyZW5Xb3JkcyA9IFtcbiAgICBcIn1cIixcIl1cIixcIilcIixcIj4+XCJdO1xuXG4gIHZhciBndWFyZFdvcmRzID0gW1xuICAgIFwiaXNfYXRvbVwiLFwiaXNfYmluYXJ5XCIsXCJpc19iaXRzdHJpbmdcIixcImlzX2Jvb2xlYW5cIixcImlzX2Zsb2F0XCIsXG4gICAgXCJpc19mdW5jdGlvblwiLFwiaXNfaW50ZWdlclwiLFwiaXNfbGlzdFwiLFwiaXNfbnVtYmVyXCIsXCJpc19waWRcIixcbiAgICBcImlzX3BvcnRcIixcImlzX3JlY29yZFwiLFwiaXNfcmVmZXJlbmNlXCIsXCJpc190dXBsZVwiLFxuICAgIFwiYXRvbVwiLFwiYmluYXJ5XCIsXCJiaXRzdHJpbmdcIixcImJvb2xlYW5cIixcImZ1bmN0aW9uXCIsXCJpbnRlZ2VyXCIsXCJsaXN0XCIsXG4gICAgXCJudW1iZXJcIixcInBpZFwiLFwicG9ydFwiLFwicmVjb3JkXCIsXCJyZWZlcmVuY2VcIixcInR1cGxlXCJdO1xuXG4gIHZhciBiaWZXb3JkcyA9IFtcbiAgICBcImFic1wiLFwiYWRsZXIzMlwiLFwiYWRsZXIzMl9jb21iaW5lXCIsXCJhbGl2ZVwiLFwiYXBwbHlcIixcImF0b21fdG9fYmluYXJ5XCIsXG4gICAgXCJhdG9tX3RvX2xpc3RcIixcImJpbmFyeV90b19hdG9tXCIsXCJiaW5hcnlfdG9fZXhpc3RpbmdfYXRvbVwiLFxuICAgIFwiYmluYXJ5X3RvX2xpc3RcIixcImJpbmFyeV90b190ZXJtXCIsXCJiaXRfc2l6ZVwiLFwiYml0c3RyaW5nX3RvX2xpc3RcIixcbiAgICBcImJ5dGVfc2l6ZVwiLFwiY2hlY2tfcHJvY2Vzc19jb2RlXCIsXCJjb250YWN0X2JpbmFyeVwiLFwiY3JjMzJcIixcbiAgICBcImNyYzMyX2NvbWJpbmVcIixcImRhdGVcIixcImRlY29kZV9wYWNrZXRcIixcImRlbGV0ZV9tb2R1bGVcIixcbiAgICBcImRpc2Nvbm5lY3Rfbm9kZVwiLFwiZWxlbWVudFwiLFwiZXJhc2VcIixcImV4aXRcIixcImZsb2F0XCIsXCJmbG9hdF90b19saXN0XCIsXG4gICAgXCJnYXJiYWdlX2NvbGxlY3RcIixcImdldFwiLFwiZ2V0X2tleXNcIixcImdyb3VwX2xlYWRlclwiLFwiaGFsdFwiLFwiaGRcIixcbiAgICBcImludGVnZXJfdG9fbGlzdFwiLFwiaW50ZXJuYWxfYmlmXCIsXCJpb2xpc3Rfc2l6ZVwiLFwiaW9saXN0X3RvX2JpbmFyeVwiLFxuICAgIFwiaXNfYWxpdmVcIixcImlzX2F0b21cIixcImlzX2JpbmFyeVwiLFwiaXNfYml0c3RyaW5nXCIsXCJpc19ib29sZWFuXCIsXG4gICAgXCJpc19mbG9hdFwiLFwiaXNfZnVuY3Rpb25cIixcImlzX2ludGVnZXJcIixcImlzX2xpc3RcIixcImlzX251bWJlclwiLFwiaXNfcGlkXCIsXG4gICAgXCJpc19wb3J0XCIsXCJpc19wcm9jZXNzX2FsaXZlXCIsXCJpc19yZWNvcmRcIixcImlzX3JlZmVyZW5jZVwiLFwiaXNfdHVwbGVcIixcbiAgICBcImxlbmd0aFwiLFwibGlua1wiLFwibGlzdF90b19hdG9tXCIsXCJsaXN0X3RvX2JpbmFyeVwiLFwibGlzdF90b19iaXRzdHJpbmdcIixcbiAgICBcImxpc3RfdG9fZXhpc3RpbmdfYXRvbVwiLFwibGlzdF90b19mbG9hdFwiLFwibGlzdF90b19pbnRlZ2VyXCIsXG4gICAgXCJsaXN0X3RvX3BpZFwiLFwibGlzdF90b190dXBsZVwiLFwibG9hZF9tb2R1bGVcIixcIm1ha2VfcmVmXCIsXCJtb2R1bGVfbG9hZGVkXCIsXG4gICAgXCJtb25pdG9yX25vZGVcIixcIm5vZGVcIixcIm5vZGVfbGlua1wiLFwibm9kZV91bmxpbmtcIixcIm5vZGVzXCIsXCJub3RhbGl2ZVwiLFxuICAgIFwibm93XCIsXCJvcGVuX3BvcnRcIixcInBpZF90b19saXN0XCIsXCJwb3J0X2Nsb3NlXCIsXCJwb3J0X2NvbW1hbmRcIixcbiAgICBcInBvcnRfY29ubmVjdFwiLFwicG9ydF9jb250cm9sXCIsXCJwcmVfbG9hZGVkXCIsXCJwcm9jZXNzX2ZsYWdcIixcbiAgICBcInByb2Nlc3NfaW5mb1wiLFwicHJvY2Vzc2VzXCIsXCJwdXJnZV9tb2R1bGVcIixcInB1dFwiLFwicmVnaXN0ZXJcIixcbiAgICBcInJlZ2lzdGVyZWRcIixcInJvdW5kXCIsXCJzZWxmXCIsXCJzZXRlbGVtZW50XCIsXCJzaXplXCIsXCJzcGF3blwiLFwic3Bhd25fbGlua1wiLFxuICAgIFwic3Bhd25fbW9uaXRvclwiLFwic3Bhd25fb3B0XCIsXCJzcGxpdF9iaW5hcnlcIixcInN0YXRpc3RpY3NcIixcbiAgICBcInRlcm1fdG9fYmluYXJ5XCIsXCJ0aW1lXCIsXCJ0aHJvd1wiLFwidGxcIixcInRydW5jXCIsXCJ0dXBsZV9zaXplXCIsXG4gICAgXCJ0dXBsZV90b19saXN0XCIsXCJ1bmxpbmtcIixcInVucmVnaXN0ZXJcIixcIndoZXJlaXNcIl07XG5cbi8vIHVwcGVyIGNhc2U6IFtBLVpdIFvDmC3Dnl0gW8OALcOWXVxuLy8gbG93ZXIgY2FzZTogW2Etel0gW8OfLcO2XSBbw7gtw79dXG4gIHZhciBhbnVtUkUgICAgICAgPSAvW1xcd0DDmC3DnsOALcOWw58tw7bDuC3Dv10vO1xuICB2YXIgZXNjYXBlc1JFICAgID1cbiAgICAvWzAtN117MSwzfXxbYmRlZm5yc3R2XFxcXFwiJ118XFxeW2EtekEtWl18eFswLTlhLXpBLVpdezJ9fHh7WzAtOWEtekEtWl0rfS87XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyB0b2tlbml6ZXJcblxuICBmdW5jdGlvbiB0b2tlbml6ZXIoc3RyZWFtLHN0YXRlKSB7XG4gICAgLy8gaW4gbXVsdGktbGluZSBzdHJpbmdcbiAgICBpZiAoc3RhdGUuaW5fc3RyaW5nKSB7XG4gICAgICBzdGF0ZS5pbl9zdHJpbmcgPSAoIWRvdWJsZVF1b3RlKHN0cmVhbSkpO1xuICAgICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwic3RyaW5nXCIpO1xuICAgIH1cblxuICAgIC8vIGluIG11bHRpLWxpbmUgYXRvbVxuICAgIGlmIChzdGF0ZS5pbl9hdG9tKSB7XG4gICAgICBzdGF0ZS5pbl9hdG9tID0gKCFzaW5nbGVRdW90ZShzdHJlYW0pKTtcbiAgICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcImF0b21cIik7XG4gICAgfVxuXG4gICAgLy8gd2hpdGVzcGFjZVxuICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkge1xuICAgICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwid2hpdGVzcGFjZVwiKTtcbiAgICB9XG5cbiAgICAvLyBhdHRyaWJ1dGVzIGFuZCB0eXBlIHNwZWNzXG4gICAgaWYgKCFwZWVrVG9rZW4oc3RhdGUpICYmXG4gICAgICAgIHN0cmVhbS5tYXRjaCgvLVxccypbYS16w58tw7bDuC3Dv11bXFx3w5gtw57DgC3DlsOfLcO2w7gtw79dKi8pKSB7XG4gICAgICBpZiAoaXNfbWVtYmVyKHN0cmVhbS5jdXJyZW50KCksdHlwZVdvcmRzKSkge1xuICAgICAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJ0eXBlXCIpO1xuICAgICAgfWVsc2V7XG4gICAgICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcImF0dHJpYnV0ZVwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuXG4gICAgLy8gY29tbWVudFxuICAgIGlmIChjaCA9PSAnJScpIHtcbiAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcImNvbW1lbnRcIik7XG4gICAgfVxuXG4gICAgLy8gY29sb25cbiAgICBpZiAoY2ggPT0gXCI6XCIpIHtcbiAgICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcImNvbG9uXCIpO1xuICAgIH1cblxuICAgIC8vIG1hY3JvXG4gICAgaWYgKGNoID09ICc/Jykge1xuICAgICAgc3RyZWFtLmVhdFNwYWNlKCk7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoYW51bVJFKTtcbiAgICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcIm1hY3JvXCIpO1xuICAgIH1cblxuICAgIC8vIHJlY29yZFxuICAgIGlmIChjaCA9PSBcIiNcIikge1xuICAgICAgc3RyZWFtLmVhdFNwYWNlKCk7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoYW51bVJFKTtcbiAgICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcInJlY29yZFwiKTtcbiAgICB9XG5cbiAgICAvLyBkb2xsYXIgZXNjYXBlXG4gICAgaWYgKGNoID09IFwiJFwiKSB7XG4gICAgICBpZiAoc3RyZWFtLm5leHQoKSA9PSBcIlxcXFxcIiAmJiAhc3RyZWFtLm1hdGNoKGVzY2FwZXNSRSkpIHtcbiAgICAgICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwiZXJyb3JcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJudW1iZXJcIik7XG4gICAgfVxuXG4gICAgLy8gZG90XG4gICAgaWYgKGNoID09IFwiLlwiKSB7XG4gICAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJkb3RcIik7XG4gICAgfVxuXG4gICAgLy8gcXVvdGVkIGF0b21cbiAgICBpZiAoY2ggPT0gJ1xcJycpIHtcbiAgICAgIGlmICghKHN0YXRlLmluX2F0b20gPSAoIXNpbmdsZVF1b3RlKHN0cmVhbSkpKSkge1xuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9cXHMqXFwvXFxzKlswLTldLyxmYWxzZSkpIHtcbiAgICAgICAgICBzdHJlYW0ubWF0Y2goL1xccypcXC9cXHMqWzAtOV0vLHRydWUpO1xuICAgICAgICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcImZ1blwiKTsgICAgICAvLyAnZicvMCBzdHlsZSBmdW5cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9cXHMqXFwoLyxmYWxzZSkgfHwgc3RyZWFtLm1hdGNoKC9cXHMqOi8sZmFsc2UpKSB7XG4gICAgICAgICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwiZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcImF0b21cIik7XG4gICAgfVxuXG4gICAgLy8gc3RyaW5nXG4gICAgaWYgKGNoID09ICdcIicpIHtcbiAgICAgIHN0YXRlLmluX3N0cmluZyA9ICghZG91YmxlUXVvdGUoc3RyZWFtKSk7XG4gICAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJzdHJpbmdcIik7XG4gICAgfVxuXG4gICAgLy8gdmFyaWFibGVcbiAgICBpZiAoL1tBLVpfw5gtw57DgC3Dll0vLnRlc3QoY2gpKSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoYW51bVJFKTtcbiAgICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcInZhcmlhYmxlXCIpO1xuICAgIH1cblxuICAgIC8vIGF0b20va2V5d29yZC9CSUYvZnVuY3Rpb25cbiAgICBpZiAoL1thLXpfw58tw7bDuC3Dv10vLnRlc3QoY2gpKSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoYW51bVJFKTtcblxuICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXFxzKlxcL1xccypbMC05XS8sZmFsc2UpKSB7XG4gICAgICAgIHN0cmVhbS5tYXRjaCgvXFxzKlxcL1xccypbMC05XS8sdHJ1ZSk7XG4gICAgICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcImZ1blwiKTsgICAgICAvLyBmLzAgc3R5bGUgZnVuXG4gICAgICB9XG5cbiAgICAgIHZhciB3ID0gc3RyZWFtLmN1cnJlbnQoKTtcblxuICAgICAgaWYgKGlzX21lbWJlcih3LGtleXdvcmRXb3JkcykpIHtcbiAgICAgICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwia2V5d29yZFwiKTtcbiAgICAgIH1lbHNlIGlmIChpc19tZW1iZXIodyxvcGVyYXRvckF0b21Xb3JkcykpIHtcbiAgICAgICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwib3BlcmF0b3JcIik7XG4gICAgICB9ZWxzZSBpZiAoc3RyZWFtLm1hdGNoKC9cXHMqXFwoLyxmYWxzZSkpIHtcbiAgICAgICAgLy8gJ3B1dCcgYW5kICdlcmxhbmc6cHV0JyBhcmUgYmlmcywgJ2ZvbzpwdXQnIGlzIG5vdFxuICAgICAgICBpZiAoaXNfbWVtYmVyKHcsYmlmV29yZHMpICYmXG4gICAgICAgICAgICAoKHBlZWtUb2tlbihzdGF0ZSkudG9rZW4gIT0gXCI6XCIpIHx8XG4gICAgICAgICAgICAgKHBlZWtUb2tlbihzdGF0ZSwyKS50b2tlbiA9PSBcImVybGFuZ1wiKSkpIHtcbiAgICAgICAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJidWlsdGluXCIpO1xuICAgICAgICB9ZWxzZSBpZiAoaXNfbWVtYmVyKHcsZ3VhcmRXb3JkcykpIHtcbiAgICAgICAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJndWFyZFwiKTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwiZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgIH1lbHNlIGlmIChsb29rYWhlYWQoc3RyZWFtKSA9PSBcIjpcIikge1xuICAgICAgICBpZiAodyA9PSBcImVybGFuZ1wiKSB7XG4gICAgICAgICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwiYnVpbHRpblwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgfWVsc2UgaWYgKGlzX21lbWJlcih3LFtcInRydWVcIixcImZhbHNlXCJdKSkge1xuICAgICAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJib29sZWFuXCIpO1xuICAgICAgfWVsc2V7XG4gICAgICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcImF0b21cIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gbnVtYmVyXG4gICAgdmFyIGRpZ2l0UkUgICAgICA9IC9bMC05XS87XG4gICAgdmFyIHJhZGl4UkUgICAgICA9IC9bMC05YS16QS1aXS87ICAgICAgICAgLy8gMzYjelogc3R5bGUgaW50XG4gICAgaWYgKGRpZ2l0UkUudGVzdChjaCkpIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZShkaWdpdFJFKTtcbiAgICAgIGlmIChzdHJlYW0uZWF0KCcjJykpIHsgICAgICAgICAgICAgICAgLy8gMzYjYVogIHN0eWxlIGludGVnZXJcbiAgICAgICAgaWYgKCFzdHJlYW0uZWF0V2hpbGUocmFkaXhSRSkpIHtcbiAgICAgICAgICBzdHJlYW0uYmFja1VwKDEpOyAgICAgICAgICAgICAgICAgLy9cIjM2I1wiIC0gc3ludGF4IGVycm9yXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLmVhdCgnLicpKSB7ICAgICAgIC8vIGZsb2F0XG4gICAgICAgIGlmICghc3RyZWFtLmVhdFdoaWxlKGRpZ2l0UkUpKSB7XG4gICAgICAgICAgc3RyZWFtLmJhY2tVcCgxKTsgICAgICAgIC8vIFwiMy5cIiAtIHByb2JhYmx5IGVuZCBvZiBmdW5jdGlvblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzdHJlYW0uZWF0KC9bZUVdLykpIHsgICAgICAgIC8vIGZsb2F0IHdpdGggZXhwb25lbnRcbiAgICAgICAgICAgIGlmIChzdHJlYW0uZWF0KC9bLStdLykpIHtcbiAgICAgICAgICAgICAgaWYgKCFzdHJlYW0uZWF0V2hpbGUoZGlnaXRSRSkpIHtcbiAgICAgICAgICAgICAgICBzdHJlYW0uYmFja1VwKDIpOyAgICAgICAgICAgIC8vIFwiMmUtXCIgLSBzeW50YXggZXJyb3JcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKCFzdHJlYW0uZWF0V2hpbGUoZGlnaXRSRSkpIHtcbiAgICAgICAgICAgICAgICBzdHJlYW0uYmFja1VwKDEpOyAgICAgICAgICAgIC8vIFwiMmVcIiAtIHN5bnRheCBlcnJvclxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJudW1iZXJcIik7ICAgLy8gbm9ybWFsIGludGVnZXJcbiAgICB9XG5cbiAgICAvLyBvcGVuIHBhcmVuc1xuICAgIGlmIChub25ncmVlZHkoc3RyZWFtLG9wZW5QYXJlblJFLG9wZW5QYXJlbldvcmRzKSkge1xuICAgICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwib3Blbl9wYXJlblwiKTtcbiAgICB9XG5cbiAgICAvLyBjbG9zZSBwYXJlbnNcbiAgICBpZiAobm9uZ3JlZWR5KHN0cmVhbSxjbG9zZVBhcmVuUkUsY2xvc2VQYXJlbldvcmRzKSkge1xuICAgICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwiY2xvc2VfcGFyZW5cIik7XG4gICAgfVxuXG4gICAgLy8gc2VwYXJhdG9yc1xuICAgIGlmIChncmVlZHkoc3RyZWFtLHNlcGFyYXRvclJFLHNlcGFyYXRvcldvcmRzKSkge1xuICAgICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwic2VwYXJhdG9yXCIpO1xuICAgIH1cblxuICAgIC8vIG9wZXJhdG9yc1xuICAgIGlmIChncmVlZHkoc3RyZWFtLG9wZXJhdG9yU3ltYm9sUkUsb3BlcmF0b3JTeW1ib2xXb3JkcykpIHtcbiAgICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcIm9wZXJhdG9yXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxudWxsKTtcbiAgfVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gdXRpbGl0aWVzXG4gIGZ1bmN0aW9uIG5vbmdyZWVkeShzdHJlYW0scmUsd29yZHMpIHtcbiAgICBpZiAoc3RyZWFtLmN1cnJlbnQoKS5sZW5ndGggPT0gMSAmJiByZS50ZXN0KHN0cmVhbS5jdXJyZW50KCkpKSB7XG4gICAgICBzdHJlYW0uYmFja1VwKDEpO1xuICAgICAgd2hpbGUgKHJlLnRlc3Qoc3RyZWFtLnBlZWsoKSkpIHtcbiAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgaWYgKGlzX21lbWJlcihzdHJlYW0uY3VycmVudCgpLHdvcmRzKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdHJlYW0uYmFja1VwKHN0cmVhbS5jdXJyZW50KCkubGVuZ3RoLTEpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBncmVlZHkoc3RyZWFtLHJlLHdvcmRzKSB7XG4gICAgaWYgKHN0cmVhbS5jdXJyZW50KCkubGVuZ3RoID09IDEgJiYgcmUudGVzdChzdHJlYW0uY3VycmVudCgpKSkge1xuICAgICAgd2hpbGUgKHJlLnRlc3Qoc3RyZWFtLnBlZWsoKSkpIHtcbiAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgwIDwgc3RyZWFtLmN1cnJlbnQoKS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGlzX21lbWJlcihzdHJlYW0uY3VycmVudCgpLHdvcmRzKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBzdHJlYW0uYmFja1VwKDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBkb3VibGVRdW90ZShzdHJlYW0pIHtcbiAgICByZXR1cm4gcXVvdGUoc3RyZWFtLCAnXCInLCAnXFxcXCcpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2luZ2xlUXVvdGUoc3RyZWFtKSB7XG4gICAgcmV0dXJuIHF1b3RlKHN0cmVhbSwnXFwnJywnXFxcXCcpO1xuICB9XG5cbiAgZnVuY3Rpb24gcXVvdGUoc3RyZWFtLHF1b3RlQ2hhcixlc2NhcGVDaGFyKSB7XG4gICAgd2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcbiAgICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG4gICAgICBpZiAoY2ggPT0gcXVvdGVDaGFyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfWVsc2UgaWYgKGNoID09IGVzY2FwZUNoYXIpIHtcbiAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gbG9va2FoZWFkKHN0cmVhbSkge1xuICAgIHZhciBtID0gc3RyZWFtLm1hdGNoKC9eXFxzKihbXlxccyVdKS8sIGZhbHNlKVxuICAgIHJldHVybiBtID8gbVsxXSA6IFwiXCI7XG4gIH1cblxuICBmdW5jdGlvbiBpc19tZW1iZXIoZWxlbWVudCxsaXN0KSB7XG4gICAgcmV0dXJuICgtMSA8IGxpc3QuaW5kZXhPZihlbGVtZW50KSk7XG4gIH1cblxuICBmdW5jdGlvbiBydmFsKHN0YXRlLHN0cmVhbSx0eXBlKSB7XG5cbiAgICAvLyBwYXJzZSBzdGFja1xuICAgIHB1c2hUb2tlbihzdGF0ZSxyZWFsVG9rZW4odHlwZSxzdHJlYW0pKTtcblxuICAgIC8vIG1hcCBlcmxhbmcgdG9rZW4gdHlwZSB0byBDb2RlTWlycm9yIHN0eWxlIGNsYXNzXG4gICAgLy8gICAgIGVybGFuZyAgICAgICAgICAgICAtPiBDb2RlTWlycm9yIHRhZ1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcImF0b21cIjogICAgICAgIHJldHVybiBcImF0b21cIjtcbiAgICAgIGNhc2UgXCJhdHRyaWJ1dGVcIjogICByZXR1cm4gXCJhdHRyaWJ1dGVcIjtcbiAgICAgIGNhc2UgXCJib29sZWFuXCI6ICAgICByZXR1cm4gXCJhdG9tXCI7XG4gICAgICBjYXNlIFwiYnVpbHRpblwiOiAgICAgcmV0dXJuIFwiYnVpbHRpblwiO1xuICAgICAgY2FzZSBcImNsb3NlX3BhcmVuXCI6IHJldHVybiBudWxsO1xuICAgICAgY2FzZSBcImNvbG9uXCI6ICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBcImNvbW1lbnRcIjogICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICAgIGNhc2UgXCJkb3RcIjogICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgXCJlcnJvclwiOiAgICAgICByZXR1cm4gXCJlcnJvclwiO1xuICAgICAgY2FzZSBcImZ1blwiOiAgICAgICAgIHJldHVybiBcIm1ldGFcIjtcbiAgICAgIGNhc2UgXCJmdW5jdGlvblwiOiAgICByZXR1cm4gXCJ0YWdcIjtcbiAgICAgIGNhc2UgXCJndWFyZFwiOiAgICAgICByZXR1cm4gXCJwcm9wZXJ0eVwiO1xuICAgICAgY2FzZSBcImtleXdvcmRcIjogICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgICAgIGNhc2UgXCJtYWNyb1wiOiAgICAgICByZXR1cm4gXCJ2YXJpYWJsZS0yXCI7XG4gICAgICBjYXNlIFwibnVtYmVyXCI6ICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgICBjYXNlIFwib3Blbl9wYXJlblwiOiAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlIFwib3BlcmF0b3JcIjogICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgICAgIGNhc2UgXCJyZWNvcmRcIjogICAgICByZXR1cm4gXCJicmFja2V0XCI7XG4gICAgICBjYXNlIFwic2VwYXJhdG9yXCI6ICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlIFwic3RyaW5nXCI6ICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgICBjYXNlIFwidHlwZVwiOiAgICAgICAgcmV0dXJuIFwiZGVmXCI7XG4gICAgICBjYXNlIFwidmFyaWFibGVcIjogICAgcmV0dXJuIFwidmFyaWFibGVcIjtcbiAgICAgIGRlZmF1bHQ6ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYVRva2VuKHRvayxjb2wsaW5kLHR5cCkge1xuICAgIHJldHVybiB7dG9rZW46ICB0b2ssXG4gICAgICAgICAgICBjb2x1bW46IGNvbCxcbiAgICAgICAgICAgIGluZGVudDogaW5kLFxuICAgICAgICAgICAgdHlwZTogICB0eXB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhbFRva2VuKHR5cGUsc3RyZWFtKSB7XG4gICAgcmV0dXJuIGFUb2tlbihzdHJlYW0uY3VycmVudCgpLFxuICAgICAgICAgICAgICAgICBzdHJlYW0uY29sdW1uKCksXG4gICAgICAgICAgICAgICAgIHN0cmVhbS5pbmRlbnRhdGlvbigpLFxuICAgICAgICAgICAgICAgICB0eXBlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZha2VUb2tlbih0eXBlKSB7XG4gICAgcmV0dXJuIGFUb2tlbih0eXBlLDAsMCx0eXBlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZWtUb2tlbihzdGF0ZSxkZXB0aCkge1xuICAgIHZhciBsZW4gPSBzdGF0ZS50b2tlblN0YWNrLmxlbmd0aDtcbiAgICB2YXIgZGVwID0gKGRlcHRoID8gZGVwdGggOiAxKTtcblxuICAgIGlmIChsZW4gPCBkZXApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9ZWxzZXtcbiAgICAgIHJldHVybiBzdGF0ZS50b2tlblN0YWNrW2xlbi1kZXBdO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hUb2tlbihzdGF0ZSx0b2tlbikge1xuXG4gICAgaWYgKCEodG9rZW4udHlwZSA9PSBcImNvbW1lbnRcIiB8fCB0b2tlbi50eXBlID09IFwid2hpdGVzcGFjZVwiKSkge1xuICAgICAgc3RhdGUudG9rZW5TdGFjayA9IG1heWJlX2Ryb3BfcHJlKHN0YXRlLnRva2VuU3RhY2ssdG9rZW4pO1xuICAgICAgc3RhdGUudG9rZW5TdGFjayA9IG1heWJlX2Ryb3BfcG9zdChzdGF0ZS50b2tlblN0YWNrKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXliZV9kcm9wX3ByZShzLHRva2VuKSB7XG4gICAgdmFyIGxhc3QgPSBzLmxlbmd0aC0xO1xuXG4gICAgaWYgKDAgPCBsYXN0ICYmIHNbbGFzdF0udHlwZSA9PT0gXCJyZWNvcmRcIiAmJiB0b2tlbi50eXBlID09PSBcImRvdFwiKSB7XG4gICAgICBzLnBvcCgpO1xuICAgIH1lbHNlIGlmICgwIDwgbGFzdCAmJiBzW2xhc3RdLnR5cGUgPT09IFwiZ3JvdXBcIikge1xuICAgICAgcy5wb3AoKTtcbiAgICAgIHMucHVzaCh0b2tlbik7XG4gICAgfWVsc2V7XG4gICAgICBzLnB1c2godG9rZW4pO1xuICAgIH1cbiAgICByZXR1cm4gcztcbiAgfVxuXG4gIGZ1bmN0aW9uIG1heWJlX2Ryb3BfcG9zdChzKSB7XG4gICAgaWYgKCFzLmxlbmd0aCkgcmV0dXJuIHNcbiAgICB2YXIgbGFzdCA9IHMubGVuZ3RoLTE7XG5cbiAgICBpZiAoc1tsYXN0XS50eXBlID09PSBcImRvdFwiKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmIChsYXN0ID4gMSAmJiBzW2xhc3RdLnR5cGUgPT09IFwiZnVuXCIgJiYgc1tsYXN0LTFdLnRva2VuID09PSBcImZ1blwiKSB7XG4gICAgICByZXR1cm4gcy5zbGljZSgwLGxhc3QtMSk7XG4gICAgfVxuICAgIHN3aXRjaCAoc1tsYXN0XS50b2tlbikge1xuICAgICAgY2FzZSBcIn1cIjogICAgcmV0dXJuIGQocyx7ZzpbXCJ7XCJdfSk7XG4gICAgICBjYXNlIFwiXVwiOiAgICByZXR1cm4gZChzLHtpOltcIltcIl19KTtcbiAgICAgIGNhc2UgXCIpXCI6ICAgIHJldHVybiBkKHMse2k6W1wiKFwiXX0pO1xuICAgICAgY2FzZSBcIj4+XCI6ICAgcmV0dXJuIGQocyx7aTpbXCI8PFwiXX0pO1xuICAgICAgY2FzZSBcImVuZFwiOiAgcmV0dXJuIGQocyx7aTpbXCJiZWdpblwiLFwiY2FzZVwiLFwiZnVuXCIsXCJpZlwiLFwicmVjZWl2ZVwiLFwidHJ5XCJdfSk7XG4gICAgICBjYXNlIFwiLFwiOiAgICByZXR1cm4gZChzLHtlOltcImJlZ2luXCIsXCJ0cnlcIixcIndoZW5cIixcIi0+XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXCIsXCIoXCIsXCJbXCIsXCJ7XCIsXCI8PFwiXX0pO1xuICAgICAgY2FzZSBcIi0+XCI6ICAgcmV0dXJuIGQocyx7cjpbXCJ3aGVuXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG06W1widHJ5XCIsXCJpZlwiLFwiY2FzZVwiLFwicmVjZWl2ZVwiXX0pO1xuICAgICAgY2FzZSBcIjtcIjogICAgcmV0dXJuIGQocyx7RTpbXCJjYXNlXCIsXCJmdW5cIixcImlmXCIsXCJyZWNlaXZlXCIsXCJ0cnlcIixcIndoZW5cIl19KTtcbiAgICAgIGNhc2UgXCJjYXRjaFwiOnJldHVybiBkKHMse2U6W1widHJ5XCJdfSk7XG4gICAgICBjYXNlIFwib2ZcIjogICByZXR1cm4gZChzLHtlOltcImNhc2VcIl19KTtcbiAgICAgIGNhc2UgXCJhZnRlclwiOnJldHVybiBkKHMse2U6W1wicmVjZWl2ZVwiLFwidHJ5XCJdfSk7XG4gICAgICBkZWZhdWx0OiAgICAgcmV0dXJuIHM7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZChzdGFjayx0dCkge1xuICAgIC8vIHN0YWNrIGlzIGEgc3RhY2sgb2YgVG9rZW4gb2JqZWN0cy5cbiAgICAvLyB0dCBpcyBhbiBvYmplY3Q7IHt0eXBlOnRva2Vuc31cbiAgICAvLyB0eXBlIGlzIGEgY2hhciwgdG9rZW5zIGlzIGEgbGlzdCBvZiB0b2tlbiBzdHJpbmdzLlxuICAgIC8vIFRoZSBmdW5jdGlvbiByZXR1cm5zIChwb3NzaWJseSB0cnVuY2F0ZWQpIHN0YWNrLlxuICAgIC8vIEl0IHdpbGwgZGVzY2VuZCB0aGUgc3RhY2ssIGxvb2tpbmcgZm9yIGEgVG9rZW4gc3VjaCB0aGF0IFRva2VuLnRva2VuXG4gICAgLy8gIGlzIGEgbWVtYmVyIG9mIHRva2Vucy4gSWYgaXQgZG9lcyBub3QgZmluZCB0aGF0LCBpdCB3aWxsIG5vcm1hbGx5IChidXRcbiAgICAvLyAgc2VlIFwiRVwiIGJlbG93KSByZXR1cm4gc3RhY2suIElmIGl0IGRvZXMgZmluZCBhIG1hdGNoLCBpdCB3aWxsIHJlbW92ZVxuICAgIC8vICBhbGwgdGhlIFRva2VucyBiZXR3ZWVuIHRoZSB0b3AgYW5kIHRoZSBtYXRjaGVkIFRva2VuLlxuICAgIC8vIElmIHR5cGUgaXMgXCJtXCIsIHRoYXQgaXMgYWxsIGl0IGRvZXMuXG4gICAgLy8gSWYgdHlwZSBpcyBcImlcIiwgaXQgd2lsbCBhbHNvIHJlbW92ZSB0aGUgbWF0Y2hlZCBUb2tlbiBhbmQgdGhlIHRvcCBUb2tlbi5cbiAgICAvLyBJZiB0eXBlIGlzIFwiZ1wiLCBsaWtlIFwiaVwiLCBidXQgYWRkIGEgZmFrZSBcImdyb3VwXCIgdG9rZW4gYXQgdGhlIHRvcC5cbiAgICAvLyBJZiB0eXBlIGlzIFwiclwiLCBpdCB3aWxsIHJlbW92ZSB0aGUgbWF0Y2hlZCBUb2tlbiwgYnV0IG5vdCB0aGUgdG9wIFRva2VuLlxuICAgIC8vIElmIHR5cGUgaXMgXCJlXCIsIGl0IHdpbGwga2VlcCB0aGUgbWF0Y2hlZCBUb2tlbiBidXQgbm90IHRoZSB0b3AgVG9rZW4uXG4gICAgLy8gSWYgdHlwZSBpcyBcIkVcIiwgaXQgYmVoYXZlcyBhcyBmb3IgdHlwZSBcImVcIiwgZXhjZXB0IGlmIHRoZXJlIGlzIG5vIG1hdGNoLFxuICAgIC8vICBpbiB3aGljaCBjYXNlIGl0IHdpbGwgcmV0dXJuIGFuIGVtcHR5IHN0YWNrLlxuXG4gICAgZm9yICh2YXIgdHlwZSBpbiB0dCkge1xuICAgICAgdmFyIGxlbiA9IHN0YWNrLmxlbmd0aC0xO1xuICAgICAgdmFyIHRva2VucyA9IHR0W3R5cGVdO1xuICAgICAgZm9yICh2YXIgaSA9IGxlbi0xOyAtMSA8IGkgOyBpLS0pIHtcbiAgICAgICAgaWYgKGlzX21lbWJlcihzdGFja1tpXS50b2tlbix0b2tlbnMpKSB7XG4gICAgICAgICAgdmFyIHNzID0gc3RhY2suc2xpY2UoMCxpKTtcbiAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcIm1cIjogcmV0dXJuIHNzLmNvbmNhdChzdGFja1tpXSkuY29uY2F0KHN0YWNrW2xlbl0pO1xuICAgICAgICAgICAgICBjYXNlIFwiclwiOiByZXR1cm4gc3MuY29uY2F0KHN0YWNrW2xlbl0pO1xuICAgICAgICAgICAgICBjYXNlIFwiaVwiOiByZXR1cm4gc3M7XG4gICAgICAgICAgICAgIGNhc2UgXCJnXCI6IHJldHVybiBzcy5jb25jYXQoZmFrZVRva2VuKFwiZ3JvdXBcIikpO1xuICAgICAgICAgICAgICBjYXNlIFwiRVwiOiByZXR1cm4gc3MuY29uY2F0KHN0YWNrW2ldKTtcbiAgICAgICAgICAgICAgY2FzZSBcImVcIjogcmV0dXJuIHNzLmNvbmNhdChzdGFja1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAodHlwZSA9PSBcIkVcIiA/IFtdIDogc3RhY2spO1xuICB9XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBpbmRlbnRlclxuXG4gIGZ1bmN0aW9uIGluZGVudGVyKHN0YXRlLHRleHRBZnRlcikge1xuICAgIHZhciB0O1xuICAgIHZhciB1bml0ID0gY21DZmcuaW5kZW50VW5pdDtcbiAgICB2YXIgd29yZEFmdGVyID0gd29yZGFmdGVyKHRleHRBZnRlcik7XG4gICAgdmFyIGN1cnJUID0gcGVla1Rva2VuKHN0YXRlLDEpO1xuICAgIHZhciBwcmV2VCA9IHBlZWtUb2tlbihzdGF0ZSwyKTtcblxuICAgIGlmIChzdGF0ZS5pbl9zdHJpbmcgfHwgc3RhdGUuaW5fYXRvbSkge1xuICAgICAgcmV0dXJuIENvZGVNaXJyb3IuUGFzcztcbiAgICB9ZWxzZSBpZiAoIXByZXZUKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9ZWxzZSBpZiAoY3VyclQudG9rZW4gPT0gXCJ3aGVuXCIpIHtcbiAgICAgIHJldHVybiBjdXJyVC5jb2x1bW4rdW5pdDtcbiAgICB9ZWxzZSBpZiAod29yZEFmdGVyID09PSBcIndoZW5cIiAmJiBwcmV2VC50eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBwcmV2VC5pbmRlbnQrdW5pdDtcbiAgICB9ZWxzZSBpZiAod29yZEFmdGVyID09PSBcIihcIiAmJiBjdXJyVC50b2tlbiA9PT0gXCJmdW5cIikge1xuICAgICAgcmV0dXJuICBjdXJyVC5jb2x1bW4rMztcbiAgICB9ZWxzZSBpZiAod29yZEFmdGVyID09PSBcImNhdGNoXCIgJiYgKHQgPSBnZXRUb2tlbihzdGF0ZSxbXCJ0cnlcIl0pKSkge1xuICAgICAgcmV0dXJuIHQuY29sdW1uO1xuICAgIH1lbHNlIGlmIChpc19tZW1iZXIod29yZEFmdGVyLFtcImVuZFwiLFwiYWZ0ZXJcIixcIm9mXCJdKSkge1xuICAgICAgdCA9IGdldFRva2VuKHN0YXRlLFtcImJlZ2luXCIsXCJjYXNlXCIsXCJmdW5cIixcImlmXCIsXCJyZWNlaXZlXCIsXCJ0cnlcIl0pO1xuICAgICAgcmV0dXJuIHQgPyB0LmNvbHVtbiA6IENvZGVNaXJyb3IuUGFzcztcbiAgICB9ZWxzZSBpZiAoaXNfbWVtYmVyKHdvcmRBZnRlcixjbG9zZVBhcmVuV29yZHMpKSB7XG4gICAgICB0ID0gZ2V0VG9rZW4oc3RhdGUsb3BlblBhcmVuV29yZHMpO1xuICAgICAgcmV0dXJuIHQgPyB0LmNvbHVtbiA6IENvZGVNaXJyb3IuUGFzcztcbiAgICB9ZWxzZSBpZiAoaXNfbWVtYmVyKGN1cnJULnRva2VuLFtcIixcIixcInxcIixcInx8XCJdKSB8fFxuICAgICAgICAgICAgICBpc19tZW1iZXIod29yZEFmdGVyLFtcIixcIixcInxcIixcInx8XCJdKSkge1xuICAgICAgdCA9IHBvc3Rjb21tYVRva2VuKHN0YXRlKTtcbiAgICAgIHJldHVybiB0ID8gdC5jb2x1bW4rdC50b2tlbi5sZW5ndGggOiB1bml0O1xuICAgIH1lbHNlIGlmIChjdXJyVC50b2tlbiA9PSBcIi0+XCIpIHtcbiAgICAgIGlmIChpc19tZW1iZXIocHJldlQudG9rZW4sIFtcInJlY2VpdmVcIixcImNhc2VcIixcImlmXCIsXCJ0cnlcIl0pKSB7XG4gICAgICAgIHJldHVybiBwcmV2VC5jb2x1bW4rdW5pdCt1bml0O1xuICAgICAgfWVsc2V7XG4gICAgICAgIHJldHVybiBwcmV2VC5jb2x1bW4rdW5pdDtcbiAgICAgIH1cbiAgICB9ZWxzZSBpZiAoaXNfbWVtYmVyKGN1cnJULnRva2VuLG9wZW5QYXJlbldvcmRzKSkge1xuICAgICAgcmV0dXJuIGN1cnJULmNvbHVtbitjdXJyVC50b2tlbi5sZW5ndGg7XG4gICAgfWVsc2V7XG4gICAgICB0ID0gZGVmYXVsdFRva2VuKHN0YXRlKTtcbiAgICAgIHJldHVybiB0cnV0aHkodCkgPyB0LmNvbHVtbit1bml0IDogMDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB3b3JkYWZ0ZXIoc3RyKSB7XG4gICAgdmFyIG0gPSBzdHIubWF0Y2goLyx8W2Etel0rfFxcfXxcXF18XFwpfD4+fFxcfCt8XFwoLyk7XG5cbiAgICByZXR1cm4gdHJ1dGh5KG0pICYmIChtLmluZGV4ID09PSAwKSA/IG1bMF0gOiBcIlwiO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9zdGNvbW1hVG9rZW4oc3RhdGUpIHtcbiAgICB2YXIgb2JqcyA9IHN0YXRlLnRva2VuU3RhY2suc2xpY2UoMCwtMSk7XG4gICAgdmFyIGkgPSBnZXRUb2tlbkluZGV4KG9ianMsXCJ0eXBlXCIsW1wib3Blbl9wYXJlblwiXSk7XG5cbiAgICByZXR1cm4gdHJ1dGh5KG9ianNbaV0pID8gb2Jqc1tpXSA6IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVmYXVsdFRva2VuKHN0YXRlKSB7XG4gICAgdmFyIG9ianMgPSBzdGF0ZS50b2tlblN0YWNrO1xuICAgIHZhciBzdG9wID0gZ2V0VG9rZW5JbmRleChvYmpzLFwidHlwZVwiLFtcIm9wZW5fcGFyZW5cIixcInNlcGFyYXRvclwiLFwia2V5d29yZFwiXSk7XG4gICAgdmFyIG9wZXIgPSBnZXRUb2tlbkluZGV4KG9ianMsXCJ0eXBlXCIsW1wib3BlcmF0b3JcIl0pO1xuXG4gICAgaWYgKHRydXRoeShzdG9wKSAmJiB0cnV0aHkob3BlcikgJiYgc3RvcCA8IG9wZXIpIHtcbiAgICAgIHJldHVybiBvYmpzW3N0b3ArMV07XG4gICAgfSBlbHNlIGlmICh0cnV0aHkoc3RvcCkpIHtcbiAgICAgIHJldHVybiBvYmpzW3N0b3BdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VG9rZW4oc3RhdGUsdG9rZW5zKSB7XG4gICAgdmFyIG9ianMgPSBzdGF0ZS50b2tlblN0YWNrO1xuICAgIHZhciBpID0gZ2V0VG9rZW5JbmRleChvYmpzLFwidG9rZW5cIix0b2tlbnMpO1xuXG4gICAgcmV0dXJuIHRydXRoeShvYmpzW2ldKSA/IG9ianNbaV0gOiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFRva2VuSW5kZXgob2Jqcyxwcm9wbmFtZSxwcm9wdmFscykge1xuXG4gICAgZm9yICh2YXIgaSA9IG9ianMubGVuZ3RoLTE7IC0xIDwgaSA7IGktLSkge1xuICAgICAgaWYgKGlzX21lbWJlcihvYmpzW2ldW3Byb3BuYW1lXSxwcm9wdmFscykpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRydXRoeSh4KSB7XG4gICAgcmV0dXJuICh4ICE9PSBmYWxzZSkgJiYgKHggIT0gbnVsbCk7XG4gIH1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIHRoaXMgb2JqZWN0IGRlZmluZXMgdGhlIG1vZGVcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0U3RhdGU6XG4gICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHt0b2tlblN0YWNrOiBbXSxcbiAgICAgICAgICAgICAgICBpbl9zdHJpbmc6ICBmYWxzZSxcbiAgICAgICAgICAgICAgICBpbl9hdG9tOiAgICBmYWxzZX07XG4gICAgICB9LFxuXG4gICAgdG9rZW46XG4gICAgICBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIHJldHVybiB0b2tlbml6ZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICB9LFxuXG4gICAgaW5kZW50OlxuICAgICAgZnVuY3Rpb24oc3RhdGUsIHRleHRBZnRlcikge1xuICAgICAgICByZXR1cm4gaW5kZW50ZXIoc3RhdGUsdGV4dEFmdGVyKTtcbiAgICAgIH0sXG5cbiAgICBsaW5lQ29tbWVudDogXCIlXCJcbiAgfTtcbn0pO1xuXG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbi8vIEZhY3RvciBzeW50YXggaGlnaGxpZ2h0IC0gc2ltcGxlIG1vZGVcbi8vXG4vLyBieSBEaW1hZ2UgU2FwZWxraW4gKGh0dHBzOi8vZ2l0aHViLmNvbS9rZXJhYnJvbXNtdSlcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSwgcmVxdWlyZShcIi4uLy4uL2FkZG9uL21vZGUvc2ltcGxlXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIsIFwiLi4vLi4vYWRkb24vbW9kZS9zaW1wbGVcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lU2ltcGxlTW9kZShcImZhY3RvclwiLCB7XG4gICAgLy8gVGhlIHN0YXJ0IHN0YXRlIGNvbnRhaW5zIHRoZSBydWxlcyB0aGF0IGFyZSBpbml0aWFsbHkgdXNlZFxuICAgIHN0YXJ0OiBbXG4gICAgICAvLyBjb21tZW50c1xuICAgICAge3JlZ2V4OiAvIz8hLiovLCB0b2tlbjogXCJjb21tZW50XCJ9LFxuICAgICAgLy8gc3RyaW5ncyBcIlwiXCIsIG11bHRpbGluZSAtLT4gc3RhdGVcbiAgICAgIHtyZWdleDogL1wiXCJcIi8sIHRva2VuOiBcInN0cmluZ1wiLCBuZXh0OiBcInN0cmluZzNcIn0sXG4gICAgICB7cmVnZXg6IC8oU1RSSU5HOikoXFxzKS8sIHRva2VuOiBbXCJrZXl3b3JkXCIsIG51bGxdLCBuZXh0OiBcInN0cmluZzJcIn0sXG4gICAgICB7cmVnZXg6IC9cXFMqP1wiLywgdG9rZW46IFwic3RyaW5nXCIsIG5leHQ6IFwic3RyaW5nXCJ9LFxuICAgICAgLy8gbnVtYmVyczogZGVjLCBoZXgsIHVuaWNvZGUsIGJpbiwgZnJhY3Rpb25hbCwgY29tcGxleFxuICAgICAge3JlZ2V4OiAvKD86MHhbXFxkLGEtZl0rKXwoPzowb1swLTddKyl8KD86MGJbMCwxXSspfCg/OlxcLT9cXGQrLj9cXGQqKSg/PVxccykvLCB0b2tlbjogXCJudW1iZXJcIn0sXG4gICAgICAvL3tyZWdleDogL1srLV0/L30gLy9mcmFjdGlvbmFsXG4gICAgICAvLyBkZWZpbml0aW9uOiBkZWZpbmluZyB3b3JkLCBkZWZpbmVkIHdvcmQsIGV0Y1xuICAgICAge3JlZ2V4OiAvKCg/OkdFTkVSSUMpfFxcOj9cXDopKFxccyspKFxcUyspKFxccyspKFxcKCkvLCB0b2tlbjogW1wia2V5d29yZFwiLCBudWxsLCBcImRlZlwiLCBudWxsLCBcImJyYWNrZXRcIl0sIG5leHQ6IFwic3RhY2tcIn0sXG4gICAgICAvLyBtZXRob2QgZGVmaW5pdGlvbjogZGVmaW5pbmcgd29yZCwgdHlwZSwgZGVmaW5lZCB3b3JkLCBldGNcbiAgICAgIHtyZWdleDogLyhNXFw6KShcXHMrKShcXFMrKShcXHMrKShcXFMrKS8sIHRva2VuOiBbXCJrZXl3b3JkXCIsIG51bGwsIFwiZGVmXCIsIG51bGwsIFwidGFnXCJdfSxcbiAgICAgIC8vIHZvY2FidWxhcnkgdXNpbmcgLS0+IHN0YXRlXG4gICAgICB7cmVnZXg6IC9VU0lOR1xcOi8sIHRva2VuOiBcImtleXdvcmRcIiwgbmV4dDogXCJ2b2NhYnVsYXJ5XCJ9LFxuICAgICAgLy8gdm9jYWJ1bGFyeSBkZWZpbml0aW9uL3VzZVxuICAgICAge3JlZ2V4OiAvKFVTRVxcOnxJTlxcOikoXFxzKykoXFxTKykoPz1cXHN8JCkvLCB0b2tlbjogW1wia2V5d29yZFwiLCBudWxsLCBcInRhZ1wiXX0sXG4gICAgICAvLyBkZWZpbml0aW9uOiBhIGRlZmluaW5nIHdvcmQsIGRlZmluZWQgd29yZFxuICAgICAge3JlZ2V4OiAvKFxcUytcXDopKFxccyspKFxcUyspKD89XFxzfCQpLywgdG9rZW46IFtcImtleXdvcmRcIiwgbnVsbCwgXCJkZWZcIl19LFxuICAgICAgLy8gXCJrZXl3b3Jkc1wiLCBpbmNsLiA7IHQgZiAuIFsgXSB7IH0gZGVmaW5pbmcgd29yZHNcbiAgICAgIHtyZWdleDogLyg/Ojt8XFxcXHx0fGZ8aWZ8bG9vcHx3aGlsZXx1bnRpbHxkb3xQUklWQVRFPnw8UFJJVkFURXxcXC58XFxTKlxcW3xcXF18XFxTKlxce3xcXH0pKD89XFxzfCQpLywgdG9rZW46IFwia2V5d29yZFwifSxcbiAgICAgIC8vIDxjb25zdHJ1Y3RvcnM+IGFuZCB0aGUgbGlrZVxuICAgICAge3JlZ2V4OiAvXFxTK1tcXCk+XFwuXFwqXFw/XSsoPz1cXHN8JCkvLCB0b2tlbjogXCJidWlsdGluXCJ9LFxuICAgICAge3JlZ2V4OiAvW1xcKT48XStcXFMrKD89XFxzfCQpLywgdG9rZW46IFwiYnVpbHRpblwifSxcbiAgICAgIC8vIG9wZXJhdG9yc1xuICAgICAge3JlZ2V4OiAvKD86W1xcK1xcLVxcPVxcL1xcKjw+XSkoPz1cXHN8JCkvLCB0b2tlbjogXCJrZXl3b3JkXCJ9LFxuICAgICAgLy8gYW55IGlkICg/KVxuICAgICAge3JlZ2V4OiAvXFxTKy8sIHRva2VuOiBcInZhcmlhYmxlXCJ9LFxuICAgICAge3JlZ2V4OiAvXFxzK3wuLywgdG9rZW46IG51bGx9XG4gICAgXSxcbiAgICB2b2NhYnVsYXJ5OiBbXG4gICAgICB7cmVnZXg6IC87LywgdG9rZW46IFwia2V5d29yZFwiLCBuZXh0OiBcInN0YXJ0XCJ9LFxuICAgICAge3JlZ2V4OiAvXFxTKy8sIHRva2VuOiBcInRhZ1wifSxcbiAgICAgIHtyZWdleDogL1xccyt8Li8sIHRva2VuOiBudWxsfVxuICAgIF0sXG4gICAgc3RyaW5nOiBbXG4gICAgICB7cmVnZXg6IC8oPzpbXlxcXFxdfFxcXFwuKSo/XCIvLCB0b2tlbjogXCJzdHJpbmdcIiwgbmV4dDogXCJzdGFydFwifSxcbiAgICAgIHtyZWdleDogLy4qLywgdG9rZW46IFwic3RyaW5nXCJ9XG4gICAgXSxcbiAgICBzdHJpbmcyOiBbXG4gICAgICB7cmVnZXg6IC9eOy8sIHRva2VuOiBcImtleXdvcmRcIiwgbmV4dDogXCJzdGFydFwifSxcbiAgICAgIHtyZWdleDogLy4qLywgdG9rZW46IFwic3RyaW5nXCJ9XG4gICAgXSxcbiAgICBzdHJpbmczOiBbXG4gICAgICB7cmVnZXg6IC8oPzpbXlxcXFxdfFxcXFwuKSo/XCJcIlwiLywgdG9rZW46IFwic3RyaW5nXCIsIG5leHQ6IFwic3RhcnRcIn0sXG4gICAgICB7cmVnZXg6IC8uKi8sIHRva2VuOiBcInN0cmluZ1wifVxuICAgIF0sXG4gICAgc3RhY2s6IFtcbiAgICAgIHtyZWdleDogL1xcKS8sIHRva2VuOiBcImJyYWNrZXRcIiwgbmV4dDogXCJzdGFydFwifSxcbiAgICAgIHtyZWdleDogLy0tLywgdG9rZW46IFwiYnJhY2tldFwifSxcbiAgICAgIHtyZWdleDogL1xcUysvLCB0b2tlbjogXCJtZXRhXCJ9LFxuICAgICAge3JlZ2V4OiAvXFxzK3wuLywgdG9rZW46IG51bGx9XG4gICAgXSxcbiAgICAvLyBUaGUgbWV0YSBwcm9wZXJ0eSBjb250YWlucyBnbG9iYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG1vZGUuIEl0XG4gICAgLy8gY2FuIGNvbnRhaW4gcHJvcGVydGllcyBsaWtlIGxpbmVDb21tZW50LCB3aGljaCBhcmUgc3VwcG9ydGVkIGJ5XG4gICAgLy8gYWxsIG1vZGVzLCBhbmQgYWxzbyBkaXJlY3RpdmVzIGxpa2UgZG9udEluZGVudFN0YXRlcywgd2hpY2ggYXJlXG4gICAgLy8gc3BlY2lmaWMgdG8gc2ltcGxlIG1vZGVzLlxuICAgIG1ldGE6IHtcbiAgICAgIGRvbnRJbmRlbnRTdGF0ZXM6IFtcInN0YXJ0XCIsIFwidm9jYWJ1bGFyeVwiLCBcInN0cmluZ1wiLCBcInN0cmluZzNcIiwgXCJzdGFja1wiXSxcbiAgICAgIGxpbmVDb21tZW50OiBbIFwiIVwiLCBcIiMhXCIgXVxuICAgIH1cbiAgfSk7XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LWZhY3RvclwiLCBcImZhY3RvclwiKTtcbn0pO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcblwidXNlIHN0cmljdFwiO1xuXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoXCJmY2xcIiwgZnVuY3Rpb24oY29uZmlnKSB7XG4gIHZhciBpbmRlbnRVbml0ID0gY29uZmlnLmluZGVudFVuaXQ7XG5cbiAgdmFyIGtleXdvcmRzID0ge1xuICAgICAgXCJ0ZXJtXCI6IHRydWUsXG4gICAgICBcIm1ldGhvZFwiOiB0cnVlLCBcImFjY3VcIjogdHJ1ZSxcbiAgICAgIFwicnVsZVwiOiB0cnVlLCBcInRoZW5cIjogdHJ1ZSwgXCJpc1wiOiB0cnVlLCBcImFuZFwiOiB0cnVlLCBcIm9yXCI6IHRydWUsXG4gICAgICBcImlmXCI6IHRydWUsIFwiZGVmYXVsdFwiOiB0cnVlXG4gIH07XG5cbiAgdmFyIHN0YXJ0X2Jsb2NrcyA9IHtcbiAgICAgIFwidmFyX2lucHV0XCI6IHRydWUsXG4gICAgICBcInZhcl9vdXRwdXRcIjogdHJ1ZSxcbiAgICAgIFwiZnV6emlmeVwiOiB0cnVlLFxuICAgICAgXCJkZWZ1enppZnlcIjogdHJ1ZSxcbiAgICAgIFwiZnVuY3Rpb25fYmxvY2tcIjogdHJ1ZSxcbiAgICAgIFwicnVsZWJsb2NrXCI6IHRydWVcbiAgfTtcblxuICB2YXIgZW5kX2Jsb2NrcyA9IHtcbiAgICAgIFwiZW5kX3J1bGVibG9ja1wiOiB0cnVlLFxuICAgICAgXCJlbmRfZGVmdXp6aWZ5XCI6IHRydWUsXG4gICAgICBcImVuZF9mdW5jdGlvbl9ibG9ja1wiOiB0cnVlLFxuICAgICAgXCJlbmRfZnV6emlmeVwiOiB0cnVlLFxuICAgICAgXCJlbmRfdmFyXCI6IHRydWVcbiAgfTtcblxuICB2YXIgYXRvbXMgPSB7XG4gICAgICBcInRydWVcIjogdHJ1ZSwgXCJmYWxzZVwiOiB0cnVlLCBcIm5hblwiOiB0cnVlLFxuICAgICAgXCJyZWFsXCI6IHRydWUsIFwibWluXCI6IHRydWUsIFwibWF4XCI6IHRydWUsIFwiY29nXCI6IHRydWUsIFwiY29nc1wiOiB0cnVlXG4gIH07XG5cbiAgdmFyIGlzT3BlcmF0b3JDaGFyID0gL1srXFwtKiZeJTo9PD4hfFxcL10vO1xuXG4gIGZ1bmN0aW9uIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGNoID0gc3RyZWFtLm5leHQoKTtcblxuICAgIGlmICgvW1xcZFxcLl0vLnRlc3QoY2gpKSB7XG4gICAgICBpZiAoY2ggPT0gXCIuXCIpIHtcbiAgICAgICAgc3RyZWFtLm1hdGNoKC9eWzAtOV0rKFtlRV1bXFwtK10/WzAtOV0rKT8vKTtcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCIwXCIpIHtcbiAgICAgICAgc3RyZWFtLm1hdGNoKC9eW3hYXVswLTlhLWZBLUZdKy8pIHx8IHN0cmVhbS5tYXRjaCgvXjBbMC03XSsvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmVhbS5tYXRjaCgvXlswLTldKlxcLj9bMC05XSooW2VFXVtcXC0rXT9bMC05XSspPy8pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgfVxuXG4gICAgaWYgKGNoID09IFwiL1wiIHx8IGNoID09IFwiKFwiKSB7XG4gICAgICBpZiAoc3RyZWFtLmVhdChcIipcIikpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkNvbW1lbnQ7XG4gICAgICAgIHJldHVybiB0b2tlbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyZWFtLmVhdChcIi9cIikpIHtcbiAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc09wZXJhdG9yQ2hhci50ZXN0KGNoKSkge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKGlzT3BlcmF0b3JDaGFyKTtcbiAgICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gICAgfVxuICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcJF9cXHhhMS1cXHVmZmZmXS8pO1xuXG4gICAgdmFyIGN1ciA9IHN0cmVhbS5jdXJyZW50KCkudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoa2V5d29yZHMucHJvcGVydHlJc0VudW1lcmFibGUoY3VyKSB8fFxuICAgICAgICBzdGFydF9ibG9ja3MucHJvcGVydHlJc0VudW1lcmFibGUoY3VyKSB8fFxuICAgICAgICBlbmRfYmxvY2tzLnByb3BlcnR5SXNFbnVtZXJhYmxlKGN1cikpIHtcbiAgICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgICB9XG4gICAgaWYgKGF0b21zLnByb3BlcnR5SXNFbnVtZXJhYmxlKGN1cikpIHJldHVybiBcImF0b21cIjtcbiAgICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xuICB9XG5cblxuICBmdW5jdGlvbiB0b2tlbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBtYXliZUVuZCA9IGZhbHNlLCBjaDtcbiAgICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgICBpZiAoKGNoID09IFwiL1wiIHx8IGNoID09IFwiKVwiKSAmJiBtYXliZUVuZCkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBtYXliZUVuZCA9IChjaCA9PSBcIipcIik7XG4gICAgfVxuICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQoaW5kZW50ZWQsIGNvbHVtbiwgdHlwZSwgYWxpZ24sIHByZXYpIHtcbiAgICB0aGlzLmluZGVudGVkID0gaW5kZW50ZWQ7XG4gICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmFsaWduID0gYWxpZ247XG4gICAgdGhpcy5wcmV2ID0gcHJldjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hDb250ZXh0KHN0YXRlLCBjb2wsIHR5cGUpIHtcbiAgICByZXR1cm4gc3RhdGUuY29udGV4dCA9IG5ldyBDb250ZXh0KHN0YXRlLmluZGVudGVkLCBjb2wsIHR5cGUsIG51bGwsIHN0YXRlLmNvbnRleHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wQ29udGV4dChzdGF0ZSkge1xuICAgIGlmICghc3RhdGUuY29udGV4dC5wcmV2KSByZXR1cm47XG4gICAgdmFyIHQgPSBzdGF0ZS5jb250ZXh0LnR5cGU7XG4gICAgaWYgKHQgPT0gXCJlbmRfYmxvY2tcIilcbiAgICAgIHN0YXRlLmluZGVudGVkID0gc3RhdGUuY29udGV4dC5pbmRlbnRlZDtcbiAgICByZXR1cm4gc3RhdGUuY29udGV4dCA9IHN0YXRlLmNvbnRleHQucHJldjtcbiAgfVxuXG4gIC8vIEludGVyZmFjZVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oYmFzZWNvbHVtbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9rZW5pemU6IG51bGwsXG4gICAgICAgIGNvbnRleHQ6IG5ldyBDb250ZXh0KChiYXNlY29sdW1uIHx8IDApIC0gaW5kZW50VW5pdCwgMCwgXCJ0b3BcIiwgZmFsc2UpLFxuICAgICAgICBpbmRlbnRlZDogMCxcbiAgICAgICAgc3RhcnRPZkxpbmU6IHRydWVcbiAgICAgIH07XG4gICAgfSxcblxuICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIHZhciBjdHggPSBzdGF0ZS5jb250ZXh0O1xuICAgICAgICBpZiAoc3RyZWFtLnNvbCgpKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmFsaWduID09IG51bGwpIGN0eC5hbGlnbiA9IGZhbHNlO1xuICAgICAgICAgICAgc3RhdGUuaW5kZW50ZWQgPSBzdHJlYW0uaW5kZW50YXRpb24oKTtcbiAgICAgICAgICAgIHN0YXRlLnN0YXJ0T2ZMaW5lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xuXG4gICAgICAgIHZhciBzdHlsZSA9IChzdGF0ZS50b2tlbml6ZSB8fCB0b2tlbkJhc2UpKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICBpZiAoc3R5bGUgPT0gXCJjb21tZW50XCIpIHJldHVybiBzdHlsZTtcbiAgICAgICAgaWYgKGN0eC5hbGlnbiA9PSBudWxsKSBjdHguYWxpZ24gPSB0cnVlO1xuXG4gICAgICAgIHZhciBjdXIgPSBzdHJlYW0uY3VycmVudCgpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgaWYgKHN0YXJ0X2Jsb2Nrcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLmNvbHVtbigpLCBcImVuZF9ibG9ja1wiKTtcbiAgICAgICAgZWxzZSBpZiAoZW5kX2Jsb2Nrcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSAgcG9wQ29udGV4dChzdGF0ZSk7XG5cbiAgICAgICAgc3RhdGUuc3RhcnRPZkxpbmUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH0sXG5cbiAgICBpbmRlbnQ6IGZ1bmN0aW9uKHN0YXRlLCB0ZXh0QWZ0ZXIpIHtcbiAgICAgIGlmIChzdGF0ZS50b2tlbml6ZSAhPSB0b2tlbkJhc2UgJiYgc3RhdGUudG9rZW5pemUgIT0gbnVsbCkgcmV0dXJuIDA7XG4gICAgICB2YXIgY3R4ID0gc3RhdGUuY29udGV4dDtcblxuICAgICAgdmFyIGNsb3NpbmcgPSBlbmRfYmxvY2tzLnByb3BlcnR5SXNFbnVtZXJhYmxlKHRleHRBZnRlcik7XG4gICAgICBpZiAoY3R4LmFsaWduKSByZXR1cm4gY3R4LmNvbHVtbiArIChjbG9zaW5nID8gMCA6IDEpO1xuICAgICAgZWxzZSByZXR1cm4gY3R4LmluZGVudGVkICsgKGNsb3NpbmcgPyAwIDogaW5kZW50VW5pdCk7XG4gICAgfSxcblxuICAgIGVsZWN0cmljQ2hhcnM6IFwicnlrXCIsXG4gICAgZm9sZDogXCJicmFjZVwiLFxuICAgIGJsb2NrQ29tbWVudFN0YXJ0OiBcIigqXCIsXG4gICAgYmxvY2tDb21tZW50RW5kOiBcIiopXCIsXG4gICAgbGluZUNvbW1lbnQ6IFwiLy9cIlxuICB9O1xufSk7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQveC1mY2xcIiwgXCJmY2xcIik7XG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbi8vIEF1dGhvcjogQWxpYWtzZWkgQ2hhcHl6aGVua2FcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgZnVuY3Rpb24gdG9Xb3JkTGlzdCh3b3Jkcykge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICB3b3Jkcy5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24oZSl7XG4gICAgICByZXQucHVzaCh7bmFtZTogZX0pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICB2YXIgY29yZVdvcmRMaXN0ID0gdG9Xb3JkTGlzdChcbidJTlZFUlQgQU5EIE9SIFhPUlxcXG4gMiogMi8gTFNISUZUIFJTSElGVFxcXG4gMD0gPSAwPCA8ID4gVTwgTUlOIE1BWFxcXG4gMkRST1AgMkRVUCAyT1ZFUiAyU1dBUCA/RFVQIERFUFRIIERST1AgRFVQIE9WRVIgUk9UIFNXQVBcXFxuID5SIFI+IFJAXFxcbiArIC0gMSsgMS0gQUJTIE5FR0FURVxcXG4gUz5EICogTSogVU0qXFxcbiBGTS9NT0QgU00vUkVNIFVNL01PRCAqLyAqL01PRCAvIC9NT0QgTU9EXFxcbiBIRVJFICwgQCAhIENFTEwrIENFTExTIEMsIENAIEMhIENIQVJTIDJAIDIhXFxcbiBBTElHTiBBTElHTkVEICshIEFMTE9UXFxcbiBDSEFSIFtDSEFSXSBbIF0gQkxcXFxuIEZJTkQgRVhFQ1VURSBJTU1FRElBVEUgQ09VTlQgTElURVJBTCBTVEFURVxcXG4gOyBET0VTPiA+Qk9EWVxcXG4gRVZBTFVBVEVcXFxuIFNPVVJDRSA+SU5cXFxuIDwjICMgI1MgIz4gSE9MRCBTSUdOIEJBU0UgPk5VTUJFUiBIRVggREVDSU1BTFxcXG4gRklMTCBNT1ZFXFxcbiAuIENSIEVNSVQgU1BBQ0UgU1BBQ0VTIFRZUEUgVS4gLlIgVS5SXFxcbiBBQ0NFUFRcXFxuIFRSVUUgRkFMU0VcXFxuIDw+IFU+IDA8PiAwPlxcXG4gTklQIFRVQ0sgUk9MTCBQSUNLXFxcbiAyPlIgMlJAIDJSPlxcXG4gV0lUSElOIFVOVVNFRCBNQVJLRVJcXFxuIEkgSlxcXG4gVE9cXFxuIENPTVBJTEUsIFtDT01QSUxFXVxcXG4gU0FWRS1JTlBVVCBSRVNUT1JFLUlOUFVUXFxcbiBQQUQgRVJBU0VcXFxuIDJMSVRFUkFMIERORUdBVEVcXFxuIEQtIEQrIEQwPCBEMD0gRDIqIEQyLyBEPCBEPSBETUFYIERNSU4gRD5TIERBQlNcXFxuIE0rIE0qLyBELiBELlIgMlJPVCBEVTxcXFxuIENBVENIIFRIUk9XXFxcbiBGUkVFIFJFU0laRSBBTExPQ0FURVxcXG4gQ1MtUElDSyBDUy1ST0xMXFxcbiBHRVQtQ1VSUkVOVCBTRVQtQ1VSUkVOVCBGT1JUSC1XT1JETElTVCBHRVQtT1JERVIgU0VULU9SREVSXFxcbiBQUkVWSU9VUyBTRUFSQ0gtV09SRExJU1QgV09SRExJU1QgRklORCBBTFNPIE9OTFkgRk9SVEggREVGSU5JVElPTlMgT1JERVJcXFxuIC1UUkFJTElORyAvU1RSSU5HIFNFQVJDSCBDT01QQVJFIENNT1ZFIENNT1ZFPiBCTEFOSyBTTElURVJBTCcpO1xuXG4gIHZhciBpbW1lZGlhdGVXb3JkTGlzdCA9IHRvV29yZExpc3QoJ0lGIEVMU0UgVEhFTiBCRUdJTiBXSElMRSBSRVBFQVQgVU5USUwgUkVDVVJTRSBbSUZdIFtFTFNFXSBbVEhFTl0gP0RPIERPIExPT1AgK0xPT1AgVU5MT09QIExFQVZFIEVYSVQgQUdBSU4gQ0FTRSBPRiBFTkRPRiBFTkRDQVNFJyk7XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNb2RlKCdmb3J0aCcsIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIHNlYXJjaFdvcmRMaXN0ICh3b3JkTGlzdCwgd29yZCkge1xuICAgICAgdmFyIGk7XG4gICAgICBmb3IgKGkgPSB3b3JkTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAod29yZExpc3RbaV0ubmFtZSA9PT0gd29yZC50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgcmV0dXJuIHdvcmRMaXN0W2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgcmV0dXJuIHtcbiAgICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXRlOiAnJyxcbiAgICAgICAgYmFzZTogMTAsXG4gICAgICAgIGNvcmVXb3JkTGlzdDogY29yZVdvcmRMaXN0LFxuICAgICAgICBpbW1lZGlhdGVXb3JkTGlzdDogaW1tZWRpYXRlV29yZExpc3QsXG4gICAgICAgIHdvcmRMaXN0OiBbXVxuICAgICAgfTtcbiAgICB9LFxuICAgIHRva2VuOiBmdW5jdGlvbiAoc3RyZWFtLCBzdHQpIHtcbiAgICAgIHZhciBtYXQ7XG4gICAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoc3R0LnN0YXRlID09PSAnJykgeyAvLyBpbnRlcnByZXRhdGlvblxuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eKFxcXXw6Tk9OQU1FKShcXHN8JCkvaSkpIHtcbiAgICAgICAgICBzdHQuc3RhdGUgPSAnIGNvbXBpbGF0aW9uJztcbiAgICAgICAgICByZXR1cm4gJ2J1aWx0aW4gY29tcGlsYXRpb24nO1xuICAgICAgICB9XG4gICAgICAgIG1hdCA9IHN0cmVhbS5tYXRjaCgvXihcXDopXFxzKyhcXFMrKShcXHN8JCkrLyk7XG4gICAgICAgIGlmIChtYXQpIHtcbiAgICAgICAgICBzdHQud29yZExpc3QucHVzaCh7bmFtZTogbWF0WzJdLnRvVXBwZXJDYXNlKCl9KTtcbiAgICAgICAgICBzdHQuc3RhdGUgPSAnIGNvbXBpbGF0aW9uJztcbiAgICAgICAgICByZXR1cm4gJ2RlZicgKyBzdHQuc3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgbWF0ID0gc3RyZWFtLm1hdGNoKC9eKFZBUklBQkxFfDJWQVJJQUJMRXxDT05TVEFOVHwyQ09OU1RBTlR8Q1JFQVRFfFBPU1RQT05FfFZBTFVFfFdPUkQpXFxzKyhcXFMrKShcXHN8JCkrL2kpO1xuICAgICAgICBpZiAobWF0KSB7XG4gICAgICAgICAgc3R0LndvcmRMaXN0LnB1c2goe25hbWU6IG1hdFsyXS50b1VwcGVyQ2FzZSgpfSk7XG4gICAgICAgICAgcmV0dXJuICdkZWYnICsgc3R0LnN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIG1hdCA9IHN0cmVhbS5tYXRjaCgvXihcXCd8XFxbXFwnXFxdKVxccysoXFxTKykoXFxzfCQpKy8pO1xuICAgICAgICBpZiAobWF0KSB7XG4gICAgICAgICAgcmV0dXJuICdidWlsdGluJyArIHN0dC5zdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICB9IGVsc2UgeyAvLyBjb21waWxhdGlvblxuICAgICAgICAvLyA7IFtcbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXihcXDt8XFxbKShcXHMpLykpIHtcbiAgICAgICAgICBzdHQuc3RhdGUgPSAnJztcbiAgICAgICAgICBzdHJlYW0uYmFja1VwKDEpO1xuICAgICAgICAgIHJldHVybiAnYnVpbHRpbiBjb21waWxhdGlvbic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXihcXDt8XFxbKSgkKS8pKSB7XG4gICAgICAgICAgc3R0LnN0YXRlID0gJyc7XG4gICAgICAgICAgcmV0dXJuICdidWlsdGluIGNvbXBpbGF0aW9uJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eKFBPU1RQT05FKVxccytcXFMrKFxcc3wkKSsvKSkge1xuICAgICAgICAgIHJldHVybiAnYnVpbHRpbic7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZHluYW1pYyB3b3JkbGlzdFxuICAgICAgbWF0ID0gc3RyZWFtLm1hdGNoKC9eKFxcUyspKFxccyt8JCkvKTtcbiAgICAgIGlmIChtYXQpIHtcbiAgICAgICAgaWYgKHNlYXJjaFdvcmRMaXN0KHN0dC53b3JkTGlzdCwgbWF0WzFdKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuICd2YXJpYWJsZScgKyBzdHQuc3RhdGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb21tZW50c1xuICAgICAgICBpZiAobWF0WzFdID09PSAnXFxcXCcpIHtcbiAgICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgICAgICByZXR1cm4gJ2NvbW1lbnQnICsgc3R0LnN0YXRlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGNvcmUgd29yZHNcbiAgICAgICAgICBpZiAoc2VhcmNoV29yZExpc3Qoc3R0LmNvcmVXb3JkTGlzdCwgbWF0WzFdKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2J1aWx0aW4nICsgc3R0LnN0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2VhcmNoV29yZExpc3Qoc3R0LmltbWVkaWF0ZVdvcmRMaXN0LCBtYXRbMV0pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAna2V5d29yZCcgKyBzdHQuc3RhdGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG1hdFsxXSA9PT0gJygnKSB7XG4gICAgICAgICAgICBzdHJlYW0uZWF0V2hpbGUoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMgIT09ICcpJzsgfSk7XG4gICAgICAgICAgICBzdHJlYW0uZWF0KCcpJyk7XG4gICAgICAgICAgICByZXR1cm4gJ2NvbW1lbnQnICsgc3R0LnN0YXRlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIC8vIHN0cmluZ3NcbiAgICAgICAgICBpZiAobWF0WzFdID09PSAnLignKSB7XG4gICAgICAgICAgICBzdHJlYW0uZWF0V2hpbGUoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMgIT09ICcpJzsgfSk7XG4gICAgICAgICAgICBzdHJlYW0uZWF0KCcpJyk7XG4gICAgICAgICAgICByZXR1cm4gJ3N0cmluZycgKyBzdHQuc3RhdGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtYXRbMV0gPT09ICdTXCInIHx8IG1hdFsxXSA9PT0gJy5cIicgfHwgbWF0WzFdID09PSAnQ1wiJykge1xuICAgICAgICAgICAgc3RyZWFtLmVhdFdoaWxlKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzICE9PSAnXCInOyB9KTtcbiAgICAgICAgICAgIHN0cmVhbS5lYXQoJ1wiJyk7XG4gICAgICAgICAgICByZXR1cm4gJ3N0cmluZycgKyBzdHQuc3RhdGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gbnVtYmVyc1xuICAgICAgICAgIGlmIChtYXRbMV0gLSAweGZmZmZmZmZmZikge1xuICAgICAgICAgICAgcmV0dXJuICdudW1iZXInICsgc3R0LnN0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBpZiAobWF0WzFdLm1hdGNoKC9eWy0rXT9bMC05XStcXC5bMC05XSovKSkge1xuICAgICAgICAgIC8vICAgICByZXR1cm4gJ251bWJlcicgKyBzdHQuc3RhdGU7XG4gICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgcmV0dXJuICdhdG9tJyArIHN0dC5zdGF0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0pO1xuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3gtZm9ydGhcIiwgXCJmb3J0aFwiKTtcbn0pO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcblwidXNlIHN0cmljdFwiO1xuXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoXCJmb3J0cmFuXCIsIGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiB3b3JkcyhhcnJheSkge1xuICAgIHZhciBrZXlzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAga2V5c1thcnJheVtpXV0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbiAgfVxuXG4gIHZhciBrZXl3b3JkcyA9IHdvcmRzKFtcbiAgICAgICAgICAgICAgICAgIFwiYWJzdHJhY3RcIiwgXCJhY2NlcHRcIiwgXCJhbGxvY2F0YWJsZVwiLCBcImFsbG9jYXRlXCIsXG4gICAgICAgICAgICAgICAgICBcImFycmF5XCIsIFwiYXNzaWduXCIsIFwiYXN5bmNocm9ub3VzXCIsIFwiYmFja3NwYWNlXCIsXG4gICAgICAgICAgICAgICAgICBcImJpbmRcIiwgXCJibG9ja1wiLCBcImJ5dGVcIiwgXCJjYWxsXCIsIFwiY2FzZVwiLFxuICAgICAgICAgICAgICAgICAgXCJjbGFzc1wiLCBcImNsb3NlXCIsIFwiY29tbW9uXCIsIFwiY29udGFpbnNcIixcbiAgICAgICAgICAgICAgICAgIFwiY29udGludWVcIiwgXCJjeWNsZVwiLCBcImRhdGFcIiwgXCJkZWFsbG9jYXRlXCIsXG4gICAgICAgICAgICAgICAgICBcImRlY29kZVwiLCBcImRlZmVycmVkXCIsIFwiZGltZW5zaW9uXCIsIFwiZG9cIixcbiAgICAgICAgICAgICAgICAgIFwiZWxlbWVudGFsXCIsIFwiZWxzZVwiLCBcImVuY29kZVwiLCBcImVuZFwiLFxuICAgICAgICAgICAgICAgICAgXCJlbmRpZlwiLCBcImVudHJ5XCIsIFwiZW51bWVyYXRvclwiLCBcImVxdWl2YWxlbmNlXCIsXG4gICAgICAgICAgICAgICAgICBcImV4aXRcIiwgXCJleHRlcm5hbFwiLCBcImV4dHJpbnNpY1wiLCBcImZpbmFsXCIsXG4gICAgICAgICAgICAgICAgICBcImZvcmFsbFwiLCBcImZvcm1hdFwiLCBcImZ1bmN0aW9uXCIsIFwiZ2VuZXJpY1wiLFxuICAgICAgICAgICAgICAgICAgXCJnb1wiLCBcImdvdG9cIiwgXCJpZlwiLCBcImltcGxpY2l0XCIsIFwiaW1wb3J0XCIsIFwiaW5jbHVkZVwiLFxuICAgICAgICAgICAgICAgICAgXCJpbnF1aXJlXCIsIFwiaW50ZW50XCIsIFwiaW50ZXJmYWNlXCIsIFwiaW50cmluc2ljXCIsXG4gICAgICAgICAgICAgICAgICBcIm1vZHVsZVwiLCBcIm5hbWVsaXN0XCIsIFwibm9uX2ludHJpbnNpY1wiLFxuICAgICAgICAgICAgICAgICAgXCJub25fb3ZlcnJpZGFibGVcIiwgXCJub25lXCIsIFwibm9wYXNzXCIsXG4gICAgICAgICAgICAgICAgICBcIm51bGxpZnlcIiwgXCJvcGVuXCIsIFwib3B0aW9uYWxcIiwgXCJvcHRpb25zXCIsXG4gICAgICAgICAgICAgICAgICBcInBhcmFtZXRlclwiLCBcInBhc3NcIiwgXCJwYXVzZVwiLCBcInBvaW50ZXJcIixcbiAgICAgICAgICAgICAgICAgIFwicHJpbnRcIiwgXCJwcml2YXRlXCIsIFwicHJvZ3JhbVwiLCBcInByb3RlY3RlZFwiLFxuICAgICAgICAgICAgICAgICAgXCJwdWJsaWNcIiwgXCJwdXJlXCIsIFwicmVhZFwiLCBcInJlY3Vyc2l2ZVwiLCBcInJlc3VsdFwiLFxuICAgICAgICAgICAgICAgICAgXCJyZXR1cm5cIiwgXCJyZXdpbmRcIiwgXCJzYXZlXCIsIFwic2VsZWN0XCIsIFwic2VxdWVuY2VcIixcbiAgICAgICAgICAgICAgICAgIFwic3RvcFwiLCBcInN1YnJvdXRpbmVcIiwgXCJ0YXJnZXRcIiwgXCJ0aGVuXCIsIFwidG9cIiwgXCJ0eXBlXCIsXG4gICAgICAgICAgICAgICAgICBcInVzZVwiLCBcInZhbHVlXCIsIFwidm9sYXRpbGVcIiwgXCJ3aGVyZVwiLCBcIndoaWxlXCIsXG4gICAgICAgICAgICAgICAgICBcIndyaXRlXCJdKTtcbiAgdmFyIGJ1aWx0aW5zID0gd29yZHMoW1wiYWJvcnRcIiwgXCJhYnNcIiwgXCJhY2Nlc3NcIiwgXCJhY2hhclwiLCBcImFjb3NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhZGp1c3RsXCIsIFwiYWRqdXN0clwiLCBcImFpbWFnXCIsIFwiYWludFwiLCBcImFsYXJtXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWxsXCIsIFwiYWxsb2NhdGVkXCIsIFwiYWxvZ1wiLCBcImFtYXhcIiwgXCJhbWluXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYW1vZFwiLCBcImFuZFwiLCBcImFuaW50XCIsIFwiYW55XCIsIFwiYXNpblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFzc29jaWF0ZWRcIiwgXCJhdGFuXCIsIFwiYmVzalwiLCBcImJlc2puXCIsIFwiYmVzeVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImJlc3luXCIsIFwiYml0X3NpemVcIiwgXCJidGVzdFwiLCBcImNhYnNcIiwgXCJjY29zXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiY2VpbGluZ1wiLCBcImNleHBcIiwgXCJjaGFyXCIsIFwiY2hkaXJcIiwgXCJjaG1vZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImNsb2dcIiwgXCJjbXBseFwiLCBcImNvbW1hbmRfYXJndW1lbnRfY291bnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjb21wbGV4XCIsIFwiY29uamdcIiwgXCJjb3NcIiwgXCJjb3NoXCIsIFwiY291bnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjcHVfdGltZVwiLCBcImNzaGlmdFwiLCBcImNzaW5cIiwgXCJjc3FydFwiLCBcImN0aW1lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiY19mdW5sb2NcIiwgXCJjX2xvY1wiLCBcImNfYXNzb2NpYXRlZFwiLCBcImNfbnVsbF9wdHJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjX251bGxfZnVucHRyXCIsIFwiY19mX3BvaW50ZXJcIiwgXCJjX251bGxfY2hhclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImNfYWxlcnRcIiwgXCJjX2JhY2tzcGFjZVwiLCBcImNfZm9ybV9mZWVkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiY19uZXdfbGluZVwiLCBcImNfY2FycmlhZ2VfcmV0dXJuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiY19ob3Jpem9udGFsX3RhYlwiLCBcImNfdmVydGljYWxfdGFiXCIsIFwiZGFic1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImRhY29zXCIsIFwiZGFzaW5cIiwgXCJkYXRhblwiLCBcImRhdGVfYW5kX3RpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkYmVzalwiLCBcImRiZXNqXCIsIFwiZGJlc2puXCIsIFwiZGJlc3lcIiwgXCJkYmVzeVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImRiZXN5blwiLCBcImRibGVcIiwgXCJkY29zXCIsIFwiZGNvc2hcIiwgXCJkZGltXCIsIFwiZGVyZlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImRlcmZjXCIsIFwiZGV4cFwiLCBcImRpZ2l0c1wiLCBcImRpbVwiLCBcImRpbnRcIiwgXCJkbG9nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiZGxvZ1wiLCBcImRtYXhcIiwgXCJkbWluXCIsIFwiZG1vZFwiLCBcImRuaW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiZG90X3Byb2R1Y3RcIiwgXCJkcHJvZFwiLCBcImRzaWduXCIsIFwiZHNpbmhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkc2luXCIsIFwiZHNxcnRcIiwgXCJkdGFuaFwiLCBcImR0YW5cIiwgXCJkdGltZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImVvc2hpZnRcIiwgXCJlcHNpbG9uXCIsIFwiZXJmXCIsIFwiZXJmY1wiLCBcImV0aW1lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiZXhpdFwiLCBcImV4cFwiLCBcImV4cG9uZW50XCIsIFwiZXh0ZW5kc190eXBlX29mXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiZmRhdGVcIiwgXCJmZ2V0XCIsIFwiZmdldGNcIiwgXCJmbG9hdFwiLCBcImZsb29yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiZmx1c2hcIiwgXCJmbnVtXCIsIFwiZnB1dGNcIiwgXCJmcHV0XCIsIFwiZnJhY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmc2Vla1wiLCBcImZzdGF0XCIsIFwiZnRlbGxcIiwgXCJnZXJyb3JcIiwgXCJnZXRhcmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJnZXRfY29tbWFuZFwiLCBcImdldF9jb21tYW5kX2FyZ3VtZW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2V0X2Vudmlyb25tZW50X3ZhcmlhYmxlXCIsIFwiZ2V0Y3dkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2V0ZW52XCIsIFwiZ2V0Z2lkXCIsIFwiZ2V0bG9nXCIsIFwiZ2V0cGlkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2V0dWlkXCIsIFwiZ210aW1lXCIsIFwiaG9zdG5tXCIsIFwiaHVnZVwiLCBcImlhYnNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpYWNoYXJcIiwgXCJpYW5kXCIsIFwiaWFyZ2NcIiwgXCJpYmNsclwiLCBcImliaXRzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiaWJzZXRcIiwgXCJpY2hhclwiLCBcImlkYXRlXCIsIFwiaWRpbVwiLCBcImlkaW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiaWRuaW50XCIsIFwiaWVvclwiLCBcImllcnJub1wiLCBcImlmaXhcIiwgXCJpbWFnXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiaW1hZ3BhcnRcIiwgXCJpbmRleFwiLCBcImludFwiLCBcImlvclwiLCBcImlyYW5kXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiaXNhdHR5XCIsIFwiaXNoZnRcIiwgXCJpc2hmdGNcIiwgXCJpc2lnblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImlzb19jX2JpbmRpbmdcIiwgXCJpc19pb3N0YXRfZW5kXCIsIFwiaXNfaW9zdGF0X2VvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcIml0aW1lXCIsIFwia2lsbFwiLCBcImtpbmRcIiwgXCJsYm91bmRcIiwgXCJsZW5cIiwgXCJsZW5fdHJpbVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImxnZVwiLCBcImxndFwiLCBcImxpbmtcIiwgXCJsbGVcIiwgXCJsbHRcIiwgXCJsbmJsbmtcIiwgXCJsb2NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJsb2dcIiwgXCJsb2dpY2FsXCIsIFwibG9uZ1wiLCBcImxzaGlmdFwiLCBcImxzdGF0XCIsIFwibHRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXRtdWxcIiwgXCJtYXhcIiwgXCJtYXhleHBvbmVudFwiLCBcIm1heGxvY1wiLCBcIm1heHZhbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1jbG9ja1wiLCBcIm1lcmdlXCIsIFwibW92ZV9hbGxvY1wiLCBcIm1pblwiLCBcIm1pbmV4cG9uZW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwibWlubG9jXCIsIFwibWludmFsXCIsIFwibW9kXCIsIFwibW9kdWxvXCIsIFwibXZiaXRzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwibmVhcmVzdFwiLCBcIm5ld19saW5lXCIsIFwibmludFwiLCBcIm5vdFwiLCBcIm9yXCIsIFwicGFja1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcInBlcnJvclwiLCBcInByZWNpc2lvblwiLCBcInByZXNlbnRcIiwgXCJwcm9kdWN0XCIsIFwicmFkaXhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJyYW5kXCIsIFwicmFuZG9tX251bWJlclwiLCBcInJhbmRvbV9zZWVkXCIsIFwicmFuZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJyZWFsXCIsIFwicmVhbHBhcnRcIiwgXCJyZW5hbWVcIiwgXCJyZXBlYXRcIiwgXCJyZXNoYXBlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwicnJzcGFjaW5nXCIsIFwicnNoaWZ0XCIsIFwic2FtZV90eXBlX2FzXCIsIFwic2NhbGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzY2FuXCIsIFwic2Vjb25kXCIsIFwic2VsZWN0ZWRfaW50X2tpbmRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzZWxlY3RlZF9yZWFsX2tpbmRcIiwgXCJzZXRfZXhwb25lbnRcIiwgXCJzaGFwZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcInNob3J0XCIsIFwic2lnblwiLCBcInNpZ25hbFwiLCBcInNpbmhcIiwgXCJzaW5cIiwgXCJzbGVlcFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcInNuZ2xcIiwgXCJzcGFjaW5nXCIsIFwic3ByZWFkXCIsIFwic3FydFwiLCBcInNyYW5kXCIsIFwic3RhdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcInN1bVwiLCBcInN5bWxua1wiLCBcInN5c3RlbVwiLCBcInN5c3RlbV9jbG9ja1wiLCBcInRhblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcInRhbmhcIiwgXCJ0aW1lXCIsIFwidGlueVwiLCBcInRyYW5zZmVyXCIsIFwidHJhbnNwb3NlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwidHJpbVwiLCBcInR0eW5hbVwiLCBcInVib3VuZFwiLCBcInVtYXNrXCIsIFwidW5saW5rXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwidW5wYWNrXCIsIFwidmVyaWZ5XCIsIFwieG9yXCIsIFwiemFic1wiLCBcInpjb3NcIiwgXCJ6ZXhwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiemxvZ1wiLCBcInpzaW5cIiwgXCJ6c3FydFwiXSk7XG5cbiAgICB2YXIgZGF0YVR5cGVzID0gIHdvcmRzKFtcImNfYm9vbFwiLCBcImNfY2hhclwiLCBcImNfZG91YmxlXCIsIFwiY19kb3VibGVfY29tcGxleFwiLFxuICAgICAgICAgICAgICAgICAgICAgXCJjX2Zsb2F0XCIsIFwiY19mbG9hdF9jb21wbGV4XCIsIFwiY19mdW5wdHJcIiwgXCJjX2ludFwiLFxuICAgICAgICAgICAgICAgICAgICAgXCJjX2ludDE2X3RcIiwgXCJjX2ludDMyX3RcIiwgXCJjX2ludDY0X3RcIiwgXCJjX2ludDhfdFwiLFxuICAgICAgICAgICAgICAgICAgICAgXCJjX2ludF9mYXN0MTZfdFwiLCBcImNfaW50X2Zhc3QzMl90XCIsIFwiY19pbnRfZmFzdDY0X3RcIixcbiAgICAgICAgICAgICAgICAgICAgIFwiY19pbnRfZmFzdDhfdFwiLCBcImNfaW50X2xlYXN0MTZfdFwiLCBcImNfaW50X2xlYXN0MzJfdFwiLFxuICAgICAgICAgICAgICAgICAgICAgXCJjX2ludF9sZWFzdDY0X3RcIiwgXCJjX2ludF9sZWFzdDhfdFwiLCBcImNfaW50bWF4X3RcIixcbiAgICAgICAgICAgICAgICAgICAgIFwiY19pbnRwdHJfdFwiLCBcImNfbG9uZ1wiLCBcImNfbG9uZ19kb3VibGVcIixcbiAgICAgICAgICAgICAgICAgICAgIFwiY19sb25nX2RvdWJsZV9jb21wbGV4XCIsIFwiY19sb25nX2xvbmdcIiwgXCJjX3B0clwiLFxuICAgICAgICAgICAgICAgICAgICAgXCJjX3Nob3J0XCIsIFwiY19zaWduZWRfY2hhclwiLCBcImNfc2l6ZV90XCIsIFwiY2hhcmFjdGVyXCIsXG4gICAgICAgICAgICAgICAgICAgICBcImNvbXBsZXhcIiwgXCJkb3VibGVcIiwgXCJpbnRlZ2VyXCIsIFwibG9naWNhbFwiLCBcInJlYWxcIl0pO1xuICB2YXIgaXNPcGVyYXRvckNoYXIgPSAvWytcXC0qJj08PlxcL1xcOl0vO1xuICB2YXIgbGl0T3BlcmF0b3IgPSBuZXcgUmVnRXhwKFwiKFxcLmFuZFxcLnxcXC5vclxcLnxcXC5lcVxcLnxcXC5sdFxcLnxcXC5sZVxcLnxcXC5ndFxcLnxcXC5nZVxcLnxcXC5uZVxcLnxcXC5ub3RcXC58XFwuZXF2XFwufFxcLm5lcXZcXC4pXCIsIFwiaVwiKTtcblxuICBmdW5jdGlvbiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuXG4gICAgaWYgKHN0cmVhbS5tYXRjaChsaXRPcGVyYXRvcikpe1xuICAgICAgICByZXR1cm4gJ29wZXJhdG9yJztcbiAgICB9XG5cbiAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICAgIGlmIChjaCA9PSBcIiFcIikge1xuICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgIH1cbiAgICBpZiAoY2ggPT0gJ1wiJyB8fCBjaCA9PSBcIidcIikge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlblN0cmluZyhjaCk7XG4gICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICAgIGlmICgvW1xcW1xcXVxcKFxcKSxdLy50ZXN0KGNoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICgvXFxkLy50ZXN0KGNoKSkge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwuXS8pO1xuICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgfVxuICAgIGlmIChpc09wZXJhdG9yQ2hhci50ZXN0KGNoKSkge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKGlzT3BlcmF0b3JDaGFyKTtcbiAgICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gICAgfVxuICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcJF9dLyk7XG4gICAgdmFyIHdvcmQgPSBzdHJlYW0uY3VycmVudCgpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBpZiAoa2V5d29yZHMuaGFzT3duUHJvcGVydHkod29yZCkpe1xuICAgICAgICAgICAgcmV0dXJuICdrZXl3b3JkJztcbiAgICB9XG4gICAgaWYgKGJ1aWx0aW5zLmhhc093blByb3BlcnR5KHdvcmQpIHx8IGRhdGFUeXBlcy5oYXNPd25Qcm9wZXJ0eSh3b3JkKSkge1xuICAgICAgICAgICAgcmV0dXJuICdidWlsdGluJztcbiAgICB9XG4gICAgcmV0dXJuIFwidmFyaWFibGVcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuU3RyaW5nKHF1b3RlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBlc2NhcGVkID0gZmFsc2UsIG5leHQsIGVuZCA9IGZhbHNlO1xuICAgICAgd2hpbGUgKChuZXh0ID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgICBpZiAobmV4dCA9PSBxdW90ZSAmJiAhZXNjYXBlZCkge1xuICAgICAgICAgICAgZW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZCAmJiBuZXh0ID09IFwiXFxcXFwiO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCB8fCAhZXNjYXBlZCkgc3RhdGUudG9rZW5pemUgPSBudWxsO1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfTtcbiAgfVxuXG4gIC8vIEludGVyZmFjZVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge3Rva2VuaXplOiBudWxsfTtcbiAgICB9LFxuXG4gICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgc3R5bGUgPSAoc3RhdGUudG9rZW5pemUgfHwgdG9rZW5CYXNlKShzdHJlYW0sIHN0YXRlKTtcbiAgICAgIGlmIChzdHlsZSA9PSBcImNvbW1lbnRcIiB8fCBzdHlsZSA9PSBcIm1ldGFcIikgcmV0dXJuIHN0eWxlO1xuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH1cbiAgfTtcbn0pO1xuXG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3gtZm9ydHJhblwiLCBcImZvcnRyYW5cIik7XG5cbn0pO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcblwidXNlIHN0cmljdFwiO1xuXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoXCJnYXNcIiwgZnVuY3Rpb24oX2NvbmZpZywgcGFyc2VyQ29uZmlnKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBJZiBhbiBhcmNoaXRlY3R1cmUgaXMgc3BlY2lmaWVkLCBpdHMgaW5pdGlhbGl6YXRpb24gZnVuY3Rpb24gbWF5XG4gIC8vIHBvcHVsYXRlIHRoaXMgYXJyYXkgd2l0aCBjdXN0b20gcGFyc2luZyBmdW5jdGlvbnMgd2hpY2ggd2lsbCBiZVxuICAvLyB0cmllZCBpbiB0aGUgZXZlbnQgdGhhdCB0aGUgc3RhbmRhcmQgZnVuY3Rpb25zIGRvIG5vdCBmaW5kIGEgbWF0Y2guXG4gIHZhciBjdXN0b20gPSBbXTtcblxuICAvLyBUaGUgc3ltYm9sIHVzZWQgdG8gc3RhcnQgYSBsaW5lIGNvbW1lbnQgY2hhbmdlcyBiYXNlZCBvbiB0aGUgdGFyZ2V0XG4gIC8vIGFyY2hpdGVjdHVyZS5cbiAgLy8gSWYgbm8gYXJjaGl0ZWN0dXJlIGlzIHBhc2VkIGluIFwicGFyc2VyQ29uZmlnXCIgdGhlbiBvbmx5IG11bHRpbGluZVxuICAvLyBjb21tZW50cyB3aWxsIGhhdmUgc3ludGF4IHN1cHBvcnQuXG4gIHZhciBsaW5lQ29tbWVudFN0YXJ0U3ltYm9sID0gXCJcIjtcblxuICAvLyBUaGVzZSBkaXJlY3RpdmVzIGFyZSBhcmNoaXRlY3R1cmUgaW5kZXBlbmRlbnQuXG4gIC8vIE1hY2hpbmUgc3BlY2lmaWMgZGlyZWN0aXZlcyBzaG91bGQgZ28gaW4gdGhlaXIgcmVzcGVjdGl2ZVxuICAvLyBhcmNoaXRlY3R1cmUgaW5pdGlhbGl6YXRpb24gZnVuY3Rpb24uXG4gIC8vIFJlZmVyZW5jZTpcbiAgLy8gaHR0cDovL3NvdXJjZXdhcmUub3JnL2JpbnV0aWxzL2RvY3MvYXMvUHNldWRvLU9wcy5odG1sI1BzZXVkby1PcHNcbiAgdmFyIGRpcmVjdGl2ZXMgPSB7XG4gICAgXCIuYWJvcnRcIiA6IFwiYnVpbHRpblwiLFxuICAgIFwiLmFsaWduXCIgOiBcImJ1aWx0aW5cIixcbiAgICBcIi5hbHRtYWNyb1wiIDogXCJidWlsdGluXCIsXG4gICAgXCIuYXNjaWlcIiA6IFwiYnVpbHRpblwiLFxuICAgIFwiLmFzY2l6XCIgOiBcImJ1aWx0aW5cIixcbiAgICBcIi5iYWxpZ25cIiA6IFwiYnVpbHRpblwiLFxuICAgIFwiLmJhbGlnbndcIiA6IFwiYnVpbHRpblwiLFxuICAgIFwiLmJhbGlnbmxcIiA6IFwiYnVpbHRpblwiLFxuICAgIFwiLmJ1bmRsZV9hbGlnbl9tb2RlXCIgOiBcImJ1aWx0aW5cIixcbiAgICBcIi5idW5kbGVfbG9ja1wiIDogXCJidWlsdGluXCIsXG4gICAgXCIuYnVuZGxlX3VubG9ja1wiIDogXCJidWlsdGluXCIsXG4gICAgXCIuYnl0ZVwiIDogXCJidWlsdGluXCIsXG4gICAgXCIuY2ZpX3N0YXJ0cHJvY1wiIDogXCJidWlsdGluXCIsXG4gICAgXCIuY29tbVwiIDogXCJidWlsdGluXCIsXG4gICAgXCIuZGF0YVwiIDogXCJidWlsdGluXCIsXG4gICAgXCIuZGVmXCIgOiBcImJ1aWx0aW5cIixcbiAgICBcIi5kZXNjXCIgOiBcImJ1aWx0aW5cIixcbiAgICBcIi5kaW1cIiA6IFwiYnVpbHRpblwiLFxuICAgIFwiLmRvdWJsZVwiIDogXCJidWlsdGluXCIsXG4gICAgXCIuZWplY3RcIiA6IFwiYnVpbHRpblwiLFxuICAgIFwiLmVsc2VcIiA6IFwiYnVpbHRpblwiLFxuICAgIFwiLmVsc2VpZlwiIDogXCJidWlsdGluXCIsXG4gICAgXCIuZW5kXCIgOiBcImJ1aWx0aW5cIixcbiAgICBcIi5lbmRlZlwiIDogXCJidWlsdGluXCIsXG4gICAgXCIuZW5kZnVuY1wiIDogXCJidWlsdGluXCIsXG4gICAgXCIuZW5kaWZcIiA6IFwiYnVpbHRpblwiLFxuICAgIFwiLmVxdVwiIDogXCJidWlsdGluXCIsXG4gICAgXCIuZXF1aXZcIiA6IFwiYnVpbHRpblwiLFxuICAgIFwiLmVxdlwiIDogXCJidWlsdGluXCIsXG4gICAgXCIuZXJyXCIgOiBcImJ1aWx0aW5cIixcbiAgICBcIi5lcnJvclwiIDogXCJidWlsdGluXCIsXG4gICAgXCIuZXhpdG1cIiA6IFwiYnVpbHRpblwiLFxuICAgIFwiLmV4dGVyblwiIDogXCJidWlsdGluXCIsXG4gICAgXCIuZmFpbFwiIDogXCJidWlsdGluXCIsXG4gICAgXCIuZmlsZVwiIDogXCJidWlsdGluXCIsXG4gICAgXCIuZmlsbFwiIDogXCJidWlsdGluXCIsXG4gICAgXCIuZmxvYXRcIiA6IFwiYnVpbHRpblwiLFxuICAgIFwiLmZ1bmNcIiA6IFwiYnVpbHRpblwiLFxuICAgIFwiLmdsb2JhbFwiIDogXCJidWlsdGluXCIsXG4gICAgXCIuZ251X2F0dHJpYnV0ZVwiIDogXCJidWlsdGluXCIsXG4gICAgXCIuaGlkZGVuXCIgOiBcImJ1aWx0aW5cIixcbiAgICBcIi5od29yZFwiIDogXCJidWlsdGluXCIsXG4gICAgXCIuaWRlbnRcIiA6IFwiYnVpbHRpblwiLFxuICAgIFwiLmlmXCIgOiBcImJ1aWx0aW5cIixcbiAgICBcIi5pbmNiaW5cIiA6IFwiYnVpbHRpblwiLFxuICAgIFwiLmluY2x1ZGVcIiA6IFwiYnVpbHRpblwiLFxuICAgIFwiLmludFwiIDogXCJidWlsdGluXCIsXG4gICAgXCIuaW50ZXJuYWxcIiA6IFwiYnVpbHRpblwiLFxuICAgIFwiLmlycFwiIDogXCJidWlsdGluXCIsXG4gICAgXCIuaXJwY1wiIDogXCJidWlsdGluXCIsXG4gICAgXCIubGNvbW1cIiA6IFwiYnVpbHRpblwiLFxuICAgIFwiLmxmbGFnc1wiIDogXCJidWlsdGluXCIsXG4gICAgXCIubGluZVwiIDogXCJidWlsdGluXCIsXG4gICAgXCIubGlua29uY2VcIiA6IFwiYnVpbHRpblwiLFxuICAgIFwiLmxpc3RcIiA6IFwiYnVpbHRpblwiLFxuICAgIFwiLmxuXCIgOiBcImJ1aWx0aW5cIixcbiAgICBcIi5sb2NcIiA6IFwiYnVpbHRpblwiLFxuICAgIFwiLmxvY19tYXJrX2xhYmVsc1wiIDogXCJidWlsdGluXCIsXG4gICAgXCIubG9jYWxcIiA6IFwiYnVpbHRpblwiLFxuICAgIFwiLmxvbmdcIiA6IFwiYnVpbHRpblwiLFxuICAgIFwiLm1hY3JvXCIgOiBcImJ1aWx0aW5cIixcbiAgICBcIi5tcmlcIiA6IFwiYnVpbHRpblwiLFxuICAgIFwiLm5vYWx0bWFjcm9cIiA6IFwiYnVpbHRpblwiLFxuICAgIFwiLm5vbGlzdFwiIDogXCJidWlsdGluXCIsXG4gICAgXCIub2N0YVwiIDogXCJidWlsdGluXCIsXG4gICAgXCIub2Zmc2V0XCIgOiBcImJ1aWx0aW5cIixcbiAgICBcIi5vcmdcIiA6IFwiYnVpbHRpblwiLFxuICAgIFwiLnAyYWxpZ25cIiA6IFwiYnVpbHRpblwiLFxuICAgIFwiLnBvcHNlY3Rpb25cIiA6IFwiYnVpbHRpblwiLFxuICAgIFwiLnByZXZpb3VzXCIgOiBcImJ1aWx0aW5cIixcbiAgICBcIi5wcmludFwiIDogXCJidWlsdGluXCIsXG4gICAgXCIucHJvdGVjdGVkXCIgOiBcImJ1aWx0aW5cIixcbiAgICBcIi5wc2l6ZVwiIDogXCJidWlsdGluXCIsXG4gICAgXCIucHVyZ2VtXCIgOiBcImJ1aWx0aW5cIixcbiAgICBcIi5wdXNoc2VjdGlvblwiIDogXCJidWlsdGluXCIsXG4gICAgXCIucXVhZFwiIDogXCJidWlsdGluXCIsXG4gICAgXCIucmVsb2NcIiA6IFwiYnVpbHRpblwiLFxuICAgIFwiLnJlcHRcIiA6IFwiYnVpbHRpblwiLFxuICAgIFwiLnNidHRsXCIgOiBcImJ1aWx0aW5cIixcbiAgICBcIi5zY2xcIiA6IFwiYnVpbHRpblwiLFxuICAgIFwiLnNlY3Rpb25cIiA6IFwiYnVpbHRpblwiLFxuICAgIFwiLnNldFwiIDogXCJidWlsdGluXCIsXG4gICAgXCIuc2hvcnRcIiA6IFwiYnVpbHRpblwiLFxuICAgIFwiLnNpbmdsZVwiIDogXCJidWlsdGluXCIsXG4gICAgXCIuc2l6ZVwiIDogXCJidWlsdGluXCIsXG4gICAgXCIuc2tpcFwiIDogXCJidWlsdGluXCIsXG4gICAgXCIuc2xlYjEyOFwiIDogXCJidWlsdGluXCIsXG4gICAgXCIuc3BhY2VcIiA6IFwiYnVpbHRpblwiLFxuICAgIFwiLnN0YWJcIiA6IFwiYnVpbHRpblwiLFxuICAgIFwiLnN0cmluZ1wiIDogXCJidWlsdGluXCIsXG4gICAgXCIuc3RydWN0XCIgOiBcImJ1aWx0aW5cIixcbiAgICBcIi5zdWJzZWN0aW9uXCIgOiBcImJ1aWx0aW5cIixcbiAgICBcIi5zeW12ZXJcIiA6IFwiYnVpbHRpblwiLFxuICAgIFwiLnRhZ1wiIDogXCJidWlsdGluXCIsXG4gICAgXCIudGV4dFwiIDogXCJidWlsdGluXCIsXG4gICAgXCIudGl0bGVcIiA6IFwiYnVpbHRpblwiLFxuICAgIFwiLnR5cGVcIiA6IFwiYnVpbHRpblwiLFxuICAgIFwiLnVsZWIxMjhcIiA6IFwiYnVpbHRpblwiLFxuICAgIFwiLnZhbFwiIDogXCJidWlsdGluXCIsXG4gICAgXCIudmVyc2lvblwiIDogXCJidWlsdGluXCIsXG4gICAgXCIudnRhYmxlX2VudHJ5XCIgOiBcImJ1aWx0aW5cIixcbiAgICBcIi52dGFibGVfaW5oZXJpdFwiIDogXCJidWlsdGluXCIsXG4gICAgXCIud2FybmluZ1wiIDogXCJidWlsdGluXCIsXG4gICAgXCIud2Vha1wiIDogXCJidWlsdGluXCIsXG4gICAgXCIud2Vha3JlZlwiIDogXCJidWlsdGluXCIsXG4gICAgXCIud29yZFwiIDogXCJidWlsdGluXCJcbiAgfTtcblxuICB2YXIgcmVnaXN0ZXJzID0ge307XG5cbiAgZnVuY3Rpb24geDg2KF9wYXJzZXJDb25maWcpIHtcbiAgICBsaW5lQ29tbWVudFN0YXJ0U3ltYm9sID0gXCIjXCI7XG5cbiAgICByZWdpc3RlcnMuYXggID0gXCJ2YXJpYWJsZVwiO1xuICAgIHJlZ2lzdGVycy5lYXggPSBcInZhcmlhYmxlLTJcIjtcbiAgICByZWdpc3RlcnMucmF4ID0gXCJ2YXJpYWJsZS0zXCI7XG5cbiAgICByZWdpc3RlcnMuYnggID0gXCJ2YXJpYWJsZVwiO1xuICAgIHJlZ2lzdGVycy5lYnggPSBcInZhcmlhYmxlLTJcIjtcbiAgICByZWdpc3RlcnMucmJ4ID0gXCJ2YXJpYWJsZS0zXCI7XG5cbiAgICByZWdpc3RlcnMuY3ggID0gXCJ2YXJpYWJsZVwiO1xuICAgIHJlZ2lzdGVycy5lY3ggPSBcInZhcmlhYmxlLTJcIjtcbiAgICByZWdpc3RlcnMucmN4ID0gXCJ2YXJpYWJsZS0zXCI7XG5cbiAgICByZWdpc3RlcnMuZHggID0gXCJ2YXJpYWJsZVwiO1xuICAgIHJlZ2lzdGVycy5lZHggPSBcInZhcmlhYmxlLTJcIjtcbiAgICByZWdpc3RlcnMucmR4ID0gXCJ2YXJpYWJsZS0zXCI7XG5cbiAgICByZWdpc3RlcnMuc2kgID0gXCJ2YXJpYWJsZVwiO1xuICAgIHJlZ2lzdGVycy5lc2kgPSBcInZhcmlhYmxlLTJcIjtcbiAgICByZWdpc3RlcnMucnNpID0gXCJ2YXJpYWJsZS0zXCI7XG5cbiAgICByZWdpc3RlcnMuZGkgID0gXCJ2YXJpYWJsZVwiO1xuICAgIHJlZ2lzdGVycy5lZGkgPSBcInZhcmlhYmxlLTJcIjtcbiAgICByZWdpc3RlcnMucmRpID0gXCJ2YXJpYWJsZS0zXCI7XG5cbiAgICByZWdpc3RlcnMuc3AgID0gXCJ2YXJpYWJsZVwiO1xuICAgIHJlZ2lzdGVycy5lc3AgPSBcInZhcmlhYmxlLTJcIjtcbiAgICByZWdpc3RlcnMucnNwID0gXCJ2YXJpYWJsZS0zXCI7XG5cbiAgICByZWdpc3RlcnMuYnAgID0gXCJ2YXJpYWJsZVwiO1xuICAgIHJlZ2lzdGVycy5lYnAgPSBcInZhcmlhYmxlLTJcIjtcbiAgICByZWdpc3RlcnMucmJwID0gXCJ2YXJpYWJsZS0zXCI7XG5cbiAgICByZWdpc3RlcnMuaXAgID0gXCJ2YXJpYWJsZVwiO1xuICAgIHJlZ2lzdGVycy5laXAgPSBcInZhcmlhYmxlLTJcIjtcbiAgICByZWdpc3RlcnMucmlwID0gXCJ2YXJpYWJsZS0zXCI7XG5cbiAgICByZWdpc3RlcnMuY3MgID0gXCJrZXl3b3JkXCI7XG4gICAgcmVnaXN0ZXJzLmRzICA9IFwia2V5d29yZFwiO1xuICAgIHJlZ2lzdGVycy5zcyAgPSBcImtleXdvcmRcIjtcbiAgICByZWdpc3RlcnMuZXMgID0gXCJrZXl3b3JkXCI7XG4gICAgcmVnaXN0ZXJzLmZzICA9IFwia2V5d29yZFwiO1xuICAgIHJlZ2lzdGVycy5ncyAgPSBcImtleXdvcmRcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFybXY2KF9wYXJzZXJDb25maWcpIHtcbiAgICAvLyBSZWZlcmVuY2U6XG4gICAgLy8gaHR0cDovL2luZm9jZW50ZXIuYXJtLmNvbS9oZWxwL3RvcGljL2NvbS5hcm0uZG9jLnFyYzAwMDFsL1FSQzAwMDFfVUFMLnBkZlxuICAgIC8vIGh0dHA6Ly9pbmZvY2VudGVyLmFybS5jb20vaGVscC90b3BpYy9jb20uYXJtLmRvYy5kZGkwMzAxaC9EREkwMzAxSF9hcm0xMTc2anpmc19yMHA3X3RybS5wZGZcbiAgICBsaW5lQ29tbWVudFN0YXJ0U3ltYm9sID0gXCJAXCI7XG4gICAgZGlyZWN0aXZlcy5zeW50YXggPSBcImJ1aWx0aW5cIjtcblxuICAgIHJlZ2lzdGVycy5yMCAgPSBcInZhcmlhYmxlXCI7XG4gICAgcmVnaXN0ZXJzLnIxICA9IFwidmFyaWFibGVcIjtcbiAgICByZWdpc3RlcnMucjIgID0gXCJ2YXJpYWJsZVwiO1xuICAgIHJlZ2lzdGVycy5yMyAgPSBcInZhcmlhYmxlXCI7XG4gICAgcmVnaXN0ZXJzLnI0ICA9IFwidmFyaWFibGVcIjtcbiAgICByZWdpc3RlcnMucjUgID0gXCJ2YXJpYWJsZVwiO1xuICAgIHJlZ2lzdGVycy5yNiAgPSBcInZhcmlhYmxlXCI7XG4gICAgcmVnaXN0ZXJzLnI3ICA9IFwidmFyaWFibGVcIjtcbiAgICByZWdpc3RlcnMucjggID0gXCJ2YXJpYWJsZVwiO1xuICAgIHJlZ2lzdGVycy5yOSAgPSBcInZhcmlhYmxlXCI7XG4gICAgcmVnaXN0ZXJzLnIxMCA9IFwidmFyaWFibGVcIjtcbiAgICByZWdpc3RlcnMucjExID0gXCJ2YXJpYWJsZVwiO1xuICAgIHJlZ2lzdGVycy5yMTIgPSBcInZhcmlhYmxlXCI7XG5cbiAgICByZWdpc3RlcnMuc3AgID0gXCJ2YXJpYWJsZS0yXCI7XG4gICAgcmVnaXN0ZXJzLmxyICA9IFwidmFyaWFibGUtMlwiO1xuICAgIHJlZ2lzdGVycy5wYyAgPSBcInZhcmlhYmxlLTJcIjtcbiAgICByZWdpc3RlcnMucjEzID0gcmVnaXN0ZXJzLnNwO1xuICAgIHJlZ2lzdGVycy5yMTQgPSByZWdpc3RlcnMubHI7XG4gICAgcmVnaXN0ZXJzLnIxNSA9IHJlZ2lzdGVycy5wYztcblxuICAgIGN1c3RvbS5wdXNoKGZ1bmN0aW9uKGNoLCBzdHJlYW0pIHtcbiAgICAgIGlmIChjaCA9PT0gJyMnKSB7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvXFx3Lyk7XG4gICAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIGFyY2ggPSAocGFyc2VyQ29uZmlnLmFyY2hpdGVjdHVyZSB8fCBcIng4NlwiKS50b0xvd2VyQ2FzZSgpO1xuICBpZiAoYXJjaCA9PT0gXCJ4ODZcIikge1xuICAgIHg4NihwYXJzZXJDb25maWcpO1xuICB9IGVsc2UgaWYgKGFyY2ggPT09IFwiYXJtXCIgfHwgYXJjaCA9PT0gXCJhcm12NlwiKSB7XG4gICAgYXJtdjYocGFyc2VyQ29uZmlnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5leHRVbnRpbFVuZXNjYXBlZChzdHJlYW0sIGVuZCkge1xuICAgIHZhciBlc2NhcGVkID0gZmFsc2UsIG5leHQ7XG4gICAgd2hpbGUgKChuZXh0ID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgaWYgKG5leHQgPT09IGVuZCAmJiAhZXNjYXBlZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBlc2NhcGVkID0gIWVzY2FwZWQgJiYgbmV4dCA9PT0gXCJcXFxcXCI7XG4gICAgfVxuICAgIHJldHVybiBlc2NhcGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xpa2VDb21tZW50KHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgbWF5YmVFbmQgPSBmYWxzZSwgY2g7XG4gICAgd2hpbGUgKChjaCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgIGlmIChjaCA9PT0gXCIvXCIgJiYgbWF5YmVFbmQpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG1heWJlRW5kID0gKGNoID09PSBcIipcIik7XG4gICAgfVxuICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b2tlbml6ZTogbnVsbFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmIChzdGF0ZS50b2tlbml6ZSkge1xuICAgICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0eWxlLCBjdXIsIGNoID0gc3RyZWFtLm5leHQoKTtcblxuICAgICAgaWYgKGNoID09PSBcIi9cIikge1xuICAgICAgICBpZiAoc3RyZWFtLmVhdChcIipcIikpIHtcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IGNsaWtlQ29tbWVudDtcbiAgICAgICAgICByZXR1cm4gY2xpa2VDb21tZW50KHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjaCA9PT0gbGluZUNvbW1lbnRTdGFydFN5bWJvbCkge1xuICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoID09PSAnXCInKSB7XG4gICAgICAgIG5leHRVbnRpbFVuZXNjYXBlZChzdHJlYW0sICdcIicpO1xuICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoID09PSAnLicpIHtcbiAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9cXHcvKTtcbiAgICAgICAgY3VyID0gc3RyZWFtLmN1cnJlbnQoKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBzdHlsZSA9IGRpcmVjdGl2ZXNbY3VyXTtcbiAgICAgICAgcmV0dXJuIHN0eWxlIHx8IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaCA9PT0gJz0nKSB7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvXFx3Lyk7XG4gICAgICAgIHJldHVybiBcInRhZ1wiO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2ggPT09ICd7Jykge1xuICAgICAgICByZXR1cm4gXCJicmFja2V0XCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaCA9PT0gJ30nKSB7XG4gICAgICAgIHJldHVybiBcImJyYWNrZXRcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKC9cXGQvLnRlc3QoY2gpKSB7XG4gICAgICAgIGlmIChjaCA9PT0gXCIwXCIgJiYgc3RyZWFtLmVhdChcInhcIikpIHtcbiAgICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1swLTlhLWZBLUZdLyk7XG4gICAgICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9cXGQvKTtcbiAgICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgICB9XG5cbiAgICAgIGlmICgvXFx3Ly50ZXN0KGNoKSkge1xuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1xcdy8pO1xuICAgICAgICBpZiAoc3RyZWFtLmVhdChcIjpcIikpIHtcbiAgICAgICAgICByZXR1cm4gJ3RhZyc7XG4gICAgICAgIH1cbiAgICAgICAgY3VyID0gc3RyZWFtLmN1cnJlbnQoKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBzdHlsZSA9IHJlZ2lzdGVyc1tjdXJdO1xuICAgICAgICByZXR1cm4gc3R5bGUgfHwgbnVsbDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdXN0b20ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3R5bGUgPSBjdXN0b21baV0oY2gsIHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbGluZUNvbW1lbnQ6IGxpbmVDb21tZW50U3RhcnRTeW1ib2wsXG4gICAgYmxvY2tDb21tZW50U3RhcnQ6IFwiLypcIixcbiAgICBibG9ja0NvbW1lbnRFbmQ6IFwiKi9cIlxuICB9O1xufSk7XG5cbn0pO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuLypcbkdoZXJraW4gbW9kZSAtIGh0dHA6Ly93d3cuY3VrZXMuaW5mby9cblJlcG9ydCBidWdzL2lzc3VlcyBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vY29kZW1pcnJvci9Db2RlTWlycm9yL2lzc3Vlc1xuKi9cblxuLy8gRm9sbG93aW5nIE9ianMgZnJvbSBCcmFja2V0cyBpbXBsZW1lbnRhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL3RyZWd1c3RpL2JyYWNrZXRzLWdoZXJraW4vYmxvYi9tYXN0ZXIvbWFpbi5qc1xuLy92YXIgUXVvdGVzID0ge1xuLy8gIFNJTkdMRTogMSxcbi8vICBET1VCTEU6IDJcbi8vfTtcblxuLy92YXIgcmVnZXggPSB7XG4vLyAga2V5d29yZHM6IC8oRmVhdHVyZXwgezJ9KFNjZW5hcmlvfEluIG9yZGVyIHRvfEFzfEkpfCB7NH0oR2l2ZW58V2hlbnxUaGVufEFuZCkpL1xuLy99O1xuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTW9kZShcImdoZXJraW5cIiwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmVOdW1iZXI6IDAsXG4gICAgICAgIHRhYmxlSGVhZGVyTGluZTogZmFsc2UsXG4gICAgICAgIGFsbG93RmVhdHVyZTogdHJ1ZSxcbiAgICAgICAgYWxsb3dCYWNrZ3JvdW5kOiBmYWxzZSxcbiAgICAgICAgYWxsb3dTY2VuYXJpbzogZmFsc2UsXG4gICAgICAgIGFsbG93U3RlcHM6IGZhbHNlLFxuICAgICAgICBhbGxvd1BsYWNlaG9sZGVyczogZmFsc2UsXG4gICAgICAgIGFsbG93TXVsdGlsaW5lQXJndW1lbnQ6IGZhbHNlLFxuICAgICAgICBpbk11bHRpbGluZVN0cmluZzogZmFsc2UsXG4gICAgICAgIGluTXVsdGlsaW5lVGFibGU6IGZhbHNlLFxuICAgICAgICBpbktleXdvcmRMaW5lOiBmYWxzZVxuICAgICAgfTtcbiAgICB9LFxuICAgIHRva2VuOiBmdW5jdGlvbiAoc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKHN0cmVhbS5zb2woKSkge1xuICAgICAgICBzdGF0ZS5saW5lTnVtYmVyKys7XG4gICAgICAgIHN0YXRlLmluS2V5d29yZExpbmUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHN0YXRlLmluTXVsdGlsaW5lVGFibGUpIHtcbiAgICAgICAgICAgIHN0YXRlLnRhYmxlSGVhZGVyTGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFzdHJlYW0ubWF0Y2goL1xccypcXHwvLCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgc3RhdGUuYWxsb3dNdWx0aWxpbmVBcmd1bWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICBzdGF0ZS5pbk11bHRpbGluZVRhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RyZWFtLmVhdFNwYWNlKCk7XG5cbiAgICAgIGlmIChzdGF0ZS5hbGxvd011bHRpbGluZUFyZ3VtZW50KSB7XG5cbiAgICAgICAgLy8gU1RSSU5HXG4gICAgICAgIGlmIChzdGF0ZS5pbk11bHRpbGluZVN0cmluZykge1xuICAgICAgICAgIGlmIChzdHJlYW0ubWF0Y2goJ1wiXCJcIicpKSB7XG4gICAgICAgICAgICBzdGF0ZS5pbk11bHRpbGluZVN0cmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgc3RhdGUuYWxsb3dNdWx0aWxpbmVBcmd1bWVudCA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJlYW0ubWF0Y2goLy4qLyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVEFCTEVcbiAgICAgICAgaWYgKHN0YXRlLmluTXVsdGlsaW5lVGFibGUpIHtcbiAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9cXHxcXHMqLykpIHtcbiAgICAgICAgICAgIHJldHVybiBcImJyYWNrZXRcIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyZWFtLm1hdGNoKC9bXlxcfF0qLyk7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUudGFibGVIZWFkZXJMaW5lID8gXCJoZWFkZXJcIiA6IFwic3RyaW5nXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gREVURUNUIFNUQVJUXG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2goJ1wiXCJcIicpKSB7XG4gICAgICAgICAgLy8gU3RyaW5nXG4gICAgICAgICAgc3RhdGUuaW5NdWx0aWxpbmVTdHJpbmcgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaChcInxcIikpIHtcbiAgICAgICAgICAvLyBUYWJsZVxuICAgICAgICAgIHN0YXRlLmluTXVsdGlsaW5lVGFibGUgPSB0cnVlO1xuICAgICAgICAgIHN0YXRlLnRhYmxlSGVhZGVyTGluZSA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIFwiYnJhY2tldFwiO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgLy8gTElORSBDT01NRU5UXG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC8jLiovKSkge1xuICAgICAgICByZXR1cm4gXCJjb21tZW50XCI7XG5cbiAgICAgIC8vIFRBR1xuICAgICAgfSBlbHNlIGlmICghc3RhdGUuaW5LZXl3b3JkTGluZSAmJiBzdHJlYW0ubWF0Y2goL0BcXFMrLykpIHtcbiAgICAgICAgcmV0dXJuIFwidGFnXCI7XG5cbiAgICAgIC8vIEZFQVRVUkVcbiAgICAgIH0gZWxzZSBpZiAoIXN0YXRlLmluS2V5d29yZExpbmUgJiYgc3RhdGUuYWxsb3dGZWF0dXJlICYmIHN0cmVhbS5tYXRjaCgvKOapn+iDvXzlip/og71844OV44Kj44O844OB44OjfOq4sOuKpXzguYLguITguKPguIfguKvguKXguLHguIF84LiE4Lin4Liy4Lih4Liq4Liy4Lih4Liy4Lij4LiWfOC4hOC4p+C4suC4oeC4leC5ieC4reC4h+C4geC4suC4o+C4l+C4suC4h+C4mOC4uOC4o+C4geC4tOC4iHzgsrngs4bgsprgs43gsprgsrN84LCX4LGB4LCj4LCu4LGBfOCoruCpgeCoueCovuCoguCopuCosOCovnzgqKjgqJXgqLYg4Kio4KmB4Ki54Ki+4KiwfOColuCovuCouOCpgOCoheCopHzgpLDgpYLgpKog4KSy4KWH4KSWfNmI2ZDbjNqY2q/bjHzYrtin2LXZitipfNeq15vXldeg15R80KTRg9C90LrRhtGW0L7QvdCw0Lt80KTRg9C90LrRhtC40Y980KTRg9C90LrRhtC40L7QvdCw0LvQvdC+0YHRgnzQpNGD0L3QutGG0LjQvtC90LDQu3zSrtC30LXQvdGH05nQu9C10LrQu9C10LvQtdC6fNCh0LLQvtC50YHRgtCy0L580J7RgdC+0LHQuNC90LB80JzTqdC80LrQuNC90LvQtdC6fNCc0L7Qs9GD0ZvQvdC+0YHRgnzOm861zrnPhM6/z4XPgc6zzq/OsXzOlM+Fzr3Osc+Ez4zPhM63z4TOsXxXxYJhxZtjaXdvxZvEh3xWbGFzdG5vc8WlfFRyYWp0b3xUw61uaCBuxINuZ3xTYXZ5YsSXfFByZXR0eSBtdWNofFBvxb5pYWRhdmthfFBvxb5hZGF2ZWt8UG90cnplYmEgYml6bmVzb3dhfMOWemVsbGlrfE9zb2JpbmF8T21pbmFpc3V1c3xPbWFkdXN8T0ggSEFJfE1vZ3XEh25vc3R8TW9ndWNub3N0fEplbGxlbXrFkXxId8OmdHxId2FldHxGdW56aW9uYWxpdMOgfEZ1bmt0aW9uYWxpdMOpaXR8RnVua3Rpb25hbGl0w6R0fEZ1bmtjamF8RnVua2Npb25hbG5vc3R8RnVua2Npb25hbGl0xIF0ZXxGdW5rY2lhfEZ1bmdzaXxGdW5jdGlvbmFsaXRlaXR8RnVuY8ibaW9uYWxpdGF0ZXxGdW5jxaNpb25hbGl0YXRlfEZ1bmN0aW9uYWxpdGF0ZXxGdW5jaW9uYWxpdGF0fEZ1bmNpb25hbGlkYWRlfEZvbmN0aW9ubmFsaXTDqXxGaXR1cnxGxKvEjWF8RmVhdHVyZXxFaWdpbmxlaWtpfEVnZW5za2FwfEVnZW5za2FifENhcmFjdGVyw61zdGljYXxDYXJhY3RlcmlzdGljYXxCdXNpbmVzcyBOZWVkfEFzcGVrdHxBcndlZGR8QWhveSBtYXRleSF8QWJpbGl0eSk6LykpIHtcbiAgICAgICAgc3RhdGUuYWxsb3dTY2VuYXJpbyA9IHRydWU7XG4gICAgICAgIHN0YXRlLmFsbG93QmFja2dyb3VuZCA9IHRydWU7XG4gICAgICAgIHN0YXRlLmFsbG93UGxhY2Vob2xkZXJzID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmFsbG93U3RlcHMgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUuYWxsb3dNdWx0aWxpbmVBcmd1bWVudCA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5pbktleXdvcmRMaW5lID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuXG4gICAgICAvLyBCQUNLR1JPVU5EXG4gICAgICB9IGVsc2UgaWYgKCFzdGF0ZS5pbktleXdvcmRMaW5lICYmIHN0YXRlLmFsbG93QmFja2dyb3VuZCAmJiBzdHJlYW0ubWF0Y2goLyjog4zmma9867Cw6rK9fOC5geC4meC4p+C4hOC4tOC4lHzgsrngsr/gsqjgs43gsqjgs4bgsrLgs4Z84LCo4LGH4LCq4LCl4LGN4LCv4LCCfOCoquCov+Com+Cpi+ColeCpnHzgpKrgpYPgpLfgpY3gpKDgpK3gpYLgpK7gpL982LLZhduM2YbZh3zYp9mE2K7ZhNmB2YrYqXzXqNen16J80KLQsNGA0LjRhXzQn9GA0LXQtNGL0YHRgtC+0YDQuNGPfNCf0YDQtdC00LjRgdGC0L7RgNC40Y980J/QvtC30LDQtNC40L3QsHzQn9C10YDQtdC00YPQvNC+0LLQsHzQntGB0L3QvtCy0LB80JrQvtC90YLQtdC60YHRgnzQmtC10YDQtdGIfM6lz4DPjM6yzrHOuM+Bzr98WmHFgm/FvGVuaWF8WW9cXC1ob1xcLWhvfFRhdXN0YXxUYXVzdHxTaXR1xIFjaWphfFJlcmVmb25zfFBvemFkaW5hfFBvemFkaWV8UG96YWTDrXxPc25vdmF8TGF0YXIgQmVsYWthbmd8S29udGV4dHxLb250ZWtzdHN8S29udGVrc3Rhc3xLb250ZWtzdHxIw6F0dMOpcnxIYW5uZXJncm9uZHxHcnVuZGxhZ2V8R2XDp21pxZ98RnVuZG98Rm9ub3xGaXJzdCBvZmZ8RGlzIGlzIHdoYXQgd2VudCBkb3dufERhc2FyfENvbnRleHRvfENvbnRleHRlfENvbnRleHR8Q29udGVzdG98Q2Vuw6FyaW8gZGUgRnVuZG98Q2VuYXJpbyBkZSBGdW5kb3xDZWZuZGlyfELhu5FpIGPhuqNuaHxCYWtncnVubnVyfEJha2dydW5ufEJha2dydW5kfEJhZ2dydW5kfEJhY2tncm91bmR8QjR8QW50ZWNlZGVudHN8QW50ZWNlZGVudGVzfMOGcnxBZXJ8QWNodGVyZ3JvbmQpOi8pKSB7XG4gICAgICAgIHN0YXRlLmFsbG93UGxhY2Vob2xkZXJzID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmFsbG93U3RlcHMgPSB0cnVlO1xuICAgICAgICBzdGF0ZS5hbGxvd0JhY2tncm91bmQgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUuYWxsb3dNdWx0aWxpbmVBcmd1bWVudCA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5pbktleXdvcmRMaW5lID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuXG4gICAgICAvLyBTQ0VOQVJJTyBPVVRMSU5FXG4gICAgICB9IGVsc2UgaWYgKCFzdGF0ZS5pbktleXdvcmRMaW5lICYmIHN0YXRlLmFsbG93U2NlbmFyaW8gJiYgc3RyZWFtLm1hdGNoKC8o5aC05pmv5aSn57axfOWcuuaZr+Wkp+e6snzliofmnKzlpKfntrF85Ymn5pys5aSn57qyfOODhuODs+ODl+ODrHzjgrfjg4rjg6rjgqrjg4bjg7Pjg5fjg6zjg7zjg4h844K344OK44Oq44Kq44OG44Oz44OX44OsfOOCt+ODiuODquOCquOCouOCpuODiOODqeOCpOODs3zsi5zrgpjrpqzsmKQg6rCc7JqUfOC4quC4o+C4uOC4m+C5gOC4q+C4leC4uOC4geC4suC4o+C4k+C5jHzguYLguITguKPguIfguKrguKPguYnguLLguIfguILguK3guIfguYDguKvguJXguLjguIHguLLguKPguJPguYx84LK14LK/4LK14LKw4LKj4LOGfOCwleCwpeCwqOCwgnzgqKrgqJ/gqJXgqKXgqL4g4Kiw4KmC4KiqIOCosOCph+ColuCovnzgqKrgqJ/gqJXgqKXgqL4g4Kii4Ki+4KiC4Kia4Ki+fOCkquCksOCkv+CkpuClg+CktuCljeCkryDgpLDgpYLgpKrgpLDgpYfgpJbgpL582LPZitmG2KfYsdmK2Ygg2YXYrti32Ld82KfZhNqv2YjbjCDYs9mG2KfYsduM2Yh816rXkdeg15nXqiDXqteo15fXmdepfNCh0YbQtdC90LDRgNC40LnQvdGL0qMg0YLTqdC30LXQu9C10YjQtXzQodGG0LXQvdCw0YDQuNC5INGB0YLRgNGD0LrRgtGD0YDQsNGB0Lh80KHRgtGA0YPQutGC0YPRgNCwINGB0YbQtdC90LDRgNGW0Y580KHRgtGA0YPQutGC0YPRgNCwINGB0YbQtdC90LDRgNC40Y980KHRgtGA0YPQutGC0YPRgNCwINGB0YbQtdC90LDRgNC40ZjQsHzQodC60LjRhtCwfNCg0LDQvNC60LAg0L3QsCDRgdGG0LXQvdCw0YDQuNC5fNCa0L7QvdGG0LXQv9GCfM6gzrXPgc65zrPPgc6xz4bOriDOo861zr3Osc+Bzq/Ov8+FfFdoYXJyaW1lYW4gaXN8VGVtcGxhdGUgU2l0dWFpfFRlbXBsYXRlIFNlbmFyaW98VGVtcGxhdGUgS2VhZGFhbnxUYXBhdXNhaWhpb3xTemVuYXJpb2dydW5kcmlzc3xTemFibG9uIHNjZW5hcml1c3phfFN3YSBod8OmciBzd2F8U3dhIGh3YWVyIHN3YXxTdHJ1a3R1cmEgc2NlbmFyaWphfFN0cnVjdHVyxIMgc2NlbmFyaXV8U3RydWN0dXJhIHNjZW5hcml1fFNraWNhfFNrZW5hcmlvIGtvbnNlcHxTaGl2ZXIgbWUgdGltYmVyc3xTZW5hcnlvIHRhc2xhxJ/EsXxTY2hlbWEgZGVsbG8gc2NlbmFyaW98U2NlbmFyaW9tYWxsfFNjZW5hcmlvbWFsfFNjZW5hcmlvIFRlbXBsYXRlfFNjZW5hcmlvIE91dGxpbmV8U2NlbmFyaW8gQW1saW5lbGxvbHxTY2VuxIFyaWpzIHDEk2MgcGFyYXVnYXxTY2VuYXJpamF1cyDFoWFibG9uYXN8UmVja29uIGl0J3MgbGlrZXxSYWFtc3RzZW5hYXJpdW18UGxhbmcgdnVtIFN6ZW5hcmlvfFBsYW4gZHUgU2PDqW5hcmlvfFBsYW4gZHUgc2PDqW5hcmlvfE9zbm92YSBzY8OpbsOhxZllfE9zbm92YSBTY2Vuw6FyYXxOw6HEjXJ0IFNjZW7DoXJ1fE7DocSNcnQgU2PDqW7DocWZZXxOw6HEjXJ0IFNjZW7DoXJhfE1JU0hVTiBTUlNMWXxNZW5nZ2FyaXNrYW4gU2VuYXJpb3xMw71zaW5nIETDpm1hfEzDvXNpbmcgQXRidXLDsGFyw6FzYXJ8S29udHVybyBkZSBsYSBzY2VuYXJvfEtvbmNlcHR8S2h1bmcgdMOsbmggaHXhu5FuZ3xLaHVuZyBr4buLY2ggYuG6o258Rm9yZ2F0w7Nrw7ZueXYgdsOhemxhdHxFc3F1ZW1hIGRvIENlbsOhcmlvfEVzcXVlbWEgZG8gQ2VuYXJpb3xFc3F1ZW1hIGRlbCBlc2NlbmFyaW98RXNxdWVtYSBkZSBsJ2VzY2VuYXJpfEVzYm96byBkbyBlc2NlbmFyaW98RGVsaW5lYcOnw6NvIGRvIENlbsOhcmlvfERlbGluZWFjYW8gZG8gQ2VuYXJpb3xBbGwgeSdhbGx8QWJzdHJha3QgU2NlbmFyaW98QWJzdHJhY3QgU2NlbmFyaW8pOi8pKSB7XG4gICAgICAgIHN0YXRlLmFsbG93UGxhY2Vob2xkZXJzID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUuYWxsb3dTdGVwcyA9IHRydWU7XG4gICAgICAgIHN0YXRlLmFsbG93TXVsdGlsaW5lQXJndW1lbnQgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUuaW5LZXl3b3JkTGluZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBcImtleXdvcmRcIjtcblxuICAgICAgLy8gRVhBTVBMRVNcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuYWxsb3dTY2VuYXJpbyAmJiBzdHJlYW0ubWF0Y2goLyjkvovlrZB85L6LfOOCteODs+ODl+ODq3zsmIh84LiK4Li44LiU4LiC4Lit4LiH4LmA4Lir4LiV4Li44LiB4Liy4Lij4LiT4LmMfOC4iuC4uOC4lOC4guC4reC4h+C4leC4seC4p+C4reC4ouC5iOC4suC4h3zgsongsqbgsr7gsrngsrDgsqPgs4bgspfgsrPgs4F84LCJ4LCm4LC+4LC54LCw4LCj4LCy4LGBfOCoieCopuCovuCoueCosOCoqOCovuCognzgpIngpKbgpL7gpLngpLDgpKN82YbZhdmI2YbZhyDZh9infNin2YXYq9mE2Kl815PXldeS157XkNeV16p80q7RgNC905nQutC705nRgHzQodGG0LXQvdCw0YDQuNGY0Lh80J/RgNC40LzQtdGA0Yt80J/RgNC40LzQtdGA0Lh80J/RgNC40LrQu9Cw0LTQuHzQnNC40YHQvtC70LvQsNGAfNCc0LjRgdCw0LvQu9Cw0YB8zqPOtc69zqzPgc65zrF8zqDOsc+BzrHOtM61zq/Os868zrHPhM6xfFlvdSdsbCB3YW5uYXxWb29yYmVlbGRlbnxWYXJpYW50YWl8VGFwYXVrc2V0fFNlIMO+ZXxTZSB0aGV8U2Ugw7BlfFNjZW5hcmlvc3xTY2VuYXJpaml8U2NlbmFyaWphaXxQcnp5a8WCYWR5fFByaW1qZXJpfFByaW1lcml8UMWZw61rbGFkeXxQcsOta2xhZHl8UGllbcSTcml8UMOpbGTDoWt8UGF2eXpkxb5pYWl8UGFyYXVnc3zDlnJuZWtsZXJ8SnVodHVtaWR8RXhlbXBsb3N8RXhlbXBsZXN8RXhlbXBsZXxFeGVtcGVsfEVYQU1QTFp8RXhhbXBsZXN8RXNlbXBpfEVuZ2hyZWlmZnRpYXV8RWt6ZW1wbG9qfEVrc2VtcGxlcnxFamVtcGxvc3xE4buvIGxp4buHdXxEZWFkIG1lbiB0ZWxsIG5vIHRhbGVzfETDpm1pfENvbnRvaHxDZW7DoXJpb3N8Q2VuYXJpb3N8QmVpc3BpbGxlcnxCZWlzcGllbGV8QXRidXLDsGFyw6FzaXIpOi8pKSB7XG4gICAgICAgIHN0YXRlLmFsbG93UGxhY2Vob2xkZXJzID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmFsbG93U3RlcHMgPSB0cnVlO1xuICAgICAgICBzdGF0ZS5hbGxvd0JhY2tncm91bmQgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUuYWxsb3dNdWx0aWxpbmVBcmd1bWVudCA9IHRydWU7XG4gICAgICAgIHJldHVybiBcImtleXdvcmRcIjtcblxuICAgICAgLy8gU0NFTkFSSU9cbiAgICAgIH0gZWxzZSBpZiAoIXN0YXRlLmluS2V5d29yZExpbmUgJiYgc3RhdGUuYWxsb3dTY2VuYXJpbyAmJiBzdHJlYW0ubWF0Y2goLyjloLTmma985Zy65pmvfOWKh+acrHzliafmnKx844K344OK44Oq44KqfOyLnOuCmOumrOyYpHzguYDguKvguJXguLjguIHguLLguKPguJPguYx84LKV4LKl4LK+4LK44LK+4LKw4LK+4LKC4LK2fOCwuOCwqOCxjeCwqOCwv+CwteCxh+CwtuCwgnzgqKrgqJ/gqJXgqKXgqL584KSq4KSw4KS/4KSm4KWD4KS24KWN4KSvfNiz2YrZhtin2LHZitmIfNiz2YbYp9ix24zZiHzXqteo15fXmdepfNCh0YbQtdC90LDRgNGW0Ll80KHRhtC10L3QsNGA0LjQvnzQodGG0LXQvdCw0YDQuNC5fNCf0YDQuNC80LXRgHzOo861zr3OrM+BzrnOv3xUw6xuaCBodeG7kW5nfFRoZSB0aGluZyBvZiBpdCBpc3xUYXBhdXN8U3plbmFyaW98U3dhfFN0c2VuYWFyaXVtfFNrZW5hcmlvfFNpdHVhaXxTZW5hcnlvfFNlbmFyaW98U2NlbmFyb3xTY2VuYXJpdXN6fFNjZW5hcml1fFNjw6luYXJpb3xTY2VuYXJpb3xTY2VuYXJpanVzfFNjZW7EgXJpanN8U2NlbmFyaWp8U2NlbmFyaWV8U2PDqW7DocWZfFNjZW7DoXJ8UHJpbWVyfE1JU0hVTnxL4buLY2ggYuG6o258S2VhZGFhbnxIZWF2ZSB0b3xGb3JnYXTDs2vDtm55dnxFc2NlbmFyaW98RXNjZW5hcml8Q2Vuw6FyaW98Q2VuYXJpb3xBd3d3LCBsb29rIG1hdGV8QXRidXLDsGFyw6FzKTovKSkge1xuICAgICAgICBzdGF0ZS5hbGxvd1BsYWNlaG9sZGVycyA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5hbGxvd1N0ZXBzID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUuYWxsb3dCYWNrZ3JvdW5kID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmFsbG93TXVsdGlsaW5lQXJndW1lbnQgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUuaW5LZXl3b3JkTGluZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBcImtleXdvcmRcIjtcblxuICAgICAgLy8gU1RFUFNcbiAgICAgIH0gZWxzZSBpZiAoIXN0YXRlLmluS2V5d29yZExpbmUgJiYgc3RhdGUuYWxsb3dTdGVwcyAmJiBzdHJlYW0ubWF0Y2goLyjpgqPpurx86YKj5LmIfOiAjOS4lHznlbZ85b2TfOW5tuS4lHzlkIzmmYJ85ZCM5pe2fOWJjeaPkHzlgYforr585YGH6KitfOWBh+WumnzlgYflpoJ85L2G5pivfOS9huOBl3zkuKbkuJR844KC44GXfOOBquOCieOBsHzjgZ/jgaDjgZd844GX44GL44GXfOOBi+OBpHztlZjsp4Drp4x87KGw6rG0fOuovOyggHzrp4zsnbx866eM7JW9fOuLqHzqt7jrpqzqs6B86re465+s66m0fOC5geC4peC4sCB84LmA4Lih4Li34LmI4LitIHzguYHguJXguYggfOC4lOC4seC4h+C4meC4seC5ieC4mSB84LiB4Liz4Lir4LiZ4LiU4LmD4Lir4LmJIHzgsrjgs43gsqXgsr/gsqTgsr/gsq/gsqjgs43gsqjgs4EgfOCyruCypOCzjeCypOCzgSB84LKo4LK/4LOV4LKh4LK/4LKmIHzgsqjgsoLgsqTgsrAgfOCyhuCypuCysOCzhiB84LCu4LCw4LC/4LCv4LGBIHzgsJrgsYbgsKrgsY3gsKrgsKzgsKHgsL/gsKjgsKbgsL8gfOCwleCwvuCwqOCwvyB84LCIIOCwquCwsOCwv+CwuOCxjeCwpeCwv+CwpOCwv+CwsuCxiyB84LCF4LCq4LGN4LCq4LGB4LCh4LGBIHzgqKrgqLAgfOCopOCopiB84Kic4KmH4KiV4KiwIHzgqJzgqL/gqLXgqYfgqIIg4KiV4Ki/IHzgqJzgqKbgqYvgqIIgfOCoheCopOCphyB84KSv4KSm4KS/IHzgpKrgpLDgpKjgpY3gpKTgpYEgfOCkquCksCB84KSk4KSsIHzgpKTgpKbgpL4gfOCkpOCkpeCkviB84KSc4KSsIHzgpJrgpYLgpILgpJXgpL8gfOCkleCkv+CkqOCljeCkpOClgSB84KSV4KSm4KS+IHzgpJTgpLAgfOCkheCkl+CksCB82YggfNmH2Ybar9in2YXbjCB82YXYqtmJIHzZhNmD2YYgfNi52YbYr9mF2KcgfNir2YUgfNio2YHYsdi2IHzYqNinINmB2LHYtiB82KfZhdinIHzYp9iw2KfZiyB82KLZhtqv2KfZhyB815vXkNep16ggfNeV15LXnSB815HXlNeZ16DXqtefIHzXkNeW15kgfNeQ15YgfNeQ15HXnCB80K/QutGJ0L4gfNK605nQvCB80KPQvdC00LAgfNCi0L7QtNGWIHzQotC+0LPQtNCwIHzQotC+IHzQotCw0LrQttC1IHzQotCwIHzQn9GD0YHRgtGMIHzQn9GA0LjQv9GD0YHRgtC40LzQviwg0YnQviB80J/RgNC40L/Rg9GB0YLQuNC80L4gfNCe0L3QtNCwIHzQndC+IHzQndC10YXQsNC5IHzQndOZ0YLQuNKX05nQtNOZIHzQm9C10LrQuNC9IHzQm9OZ0LrQuNC9IHzQmtC+0LvQuCB80JrQvtCz0LTQsCB80JrQvtCz0LDRgtC+IHzQmtCw0LTQsCB80JrQsNC0IHzQmiDRgtC+0LzRgyDQttC1IHzQhiB80JggfNCX0LDQtNCw0YLQviB80JfQsNC00LDRgtC4IHzQl9Cw0LTQsNGC0LUgfNCV0YHQu9C4IHzQlNC+0L/Rg9GB0YLQuNC8IHzQlNCw0L3QviB80JTQsNC00LXQvdC+IHzQktOZIHzQktCwIHzQkdC40YDQvtC6IHzTmNC80LzQsCB805jQudGC0LjQuiB805jQs9OZ0YAgfNCQ0LzQvNC+IHzQkNC70LggfNCQ0LvQtSB80JDQs9Cw0YAgfNCQINGC0LDQutC+0LYgfNCQIHzOpM+Mz4TOtSB8zozPhM6xzr0gfM6azrHOuSB8zpTOtc60zr/OvM6tzr3Ov8+FIHzOkc67zrvOrCB8w551cmggfMOeZWdhciB8w55hIMO+ZSB8w57DoSB8w55hIHxaYXRhdGkgfFpha8WCYWRhasSFYyB8WmFkYXRvIHxaYWRhdGUgfFphZGFubyB8WmFkYW5pIHxaYWRhbiB8WmEgcMWZZWRwb2tsYWR1IHxaYSBwcmVkcG9rbGFkdSB8WW91c2Uga25vdyB3aGVuIHlvdXNlIGdvdCB8WW91c2Uga25vdyBsaWtlIHdoZW4gfFluYSB8WWVhaCBuYWggfFkna25vdyB8WSB8V3VuIHxXdGVkeSB8V2hlbiB5J2FsbCB8V2hlbiB8V2VubiB8V0VOIHx3YW5uIHxWZSB8VsOgIHxVbmQgfFVuIHx1Z2Vob2xsIHxUb28gcmlnaHQgfFRodXJoIHxUaMOsIHxUaGVuIHknYWxsIHxUaGVuIHxUaGEgdGhlIHxUaGEgfFRldGFwaSB8VGFwaSB8VGFrIHxUYWRhIHxUYWQgfFN0ZWwgfFNvaXQgfFNpaXMgfMiYaSB8xZ5pIHxTaSB8U2VkIHxTZSB8U8OlIHxRdWFuZG8gfFF1YW5kIHxRdWFuIHxQcnlkIHxQb3RvbSB8UG9rdWQgfFBva2lhxL4gfFBlcsOyIHxQZXJvIHxQYWsgfE9yYXogfE9uZGEgfE9uZCB8T2xldGV0YWFuIHxPZyB8T2NoIHxPIHphbWFuIHxOaWluIHxOaMawbmcgfE7DpHIgfE7DpXIgfE11dHRhIHxNZW4gfE1hcyB8TWFrYSB8TWFqZCB8TWFqxIVjIHxNYWlzIHxNYWFyIHxtw6QgfE1hIHxMb3JzcXVlIHxMb3JzcXUnfExvZ28gfExldCBnbyBhbmQgaGF1bCB8S3VuIHxLdWlkIHxLdWkgfEtpZWR5IHxLaGkgfEtldGlrYSB8S2VtdWRpYW4gfEtlxI8gfEtkecW+IHxLYWogfEthaSB8S2FkYSB8S2FkIHxKZcW8ZWxpIHxKZcWbbGkgfEphIHxJdCdzIGp1c3QgdW5iZWxpZXZhYmxlIHxJciB8SSBDQU4gSEFaIHxJIHxIYSB8R2l2dW4gfEdpdmV0IHxHaXZlbiB5J2FsbCB8R2l2ZW4gfEdpdHQgfEdlZ2V2ZW4gfEdlZ2ViZW4gc2VpZW4gfEdlZ2ViZW4gc2VpIHxHZHkgfEdhbmd3YXkhIHxGYWthdCB8w4l0YW50IGRvbm7DqXMgfEV0YW50IGRvbm7DqXMgfMOJdGFudCBkb25uw6llcyB8RXRhbnQgZG9ubsOpZXMgfMOJdGFudCBkb25uw6llIHxFdGFudCBkb25uw6llIHzDiXRhbnQgZG9ubsOpIHxFdGFudCBkb25uw6kgfEV0IHzDiXMgfEVudG9uY2VzIHxFbnTDs24gfEVudMOjbyB8RW50YW8gfEVuIHxFxJ9lciBraSB8RWYgfEVlbGRhZGVzIHxFIHzDkHVyaCB8RHVvdGEgfER1biB8RG9uaXRhxLVvIHxEb25hdCB8RG9uYWRhIHxEbyB8RGl5ZWxpbSBraSB8RGliZXJpIHxEZW5nYW4gfERlbiB5b3VzZSBnb3R0YSB8REVOIHxEZSB8RGF0byB8RGHIm2kgZmlpbmQgfERhxaNpIGZpaW5kIHxEYXRpIGZpaW5kIHxEYXRpIHxEYXRlIGZpaW5kIHxEYXRlIHxEYXRhIHxEYXQgZmlpbmQgfERhciB8RGFubiB8ZGFubiB8RGFuIHxEYWRvcyB8RGFkbyB8RGFkYXMgfERhZGEgfMOQYSDDsGUgfMOQYSB8Q3VhbmRvIHxDaG8gfENhbmRvIHxDw6JuZCB8Q2FuZCB8Q2FsIHxCdXQgeSdhbGwgfEJ1dCBhdCB0aGUgZW5kIG9mIHRoZSBkYXkgSSByZWNrb24gfEJVVCB8QnV0IHxCdWggfEJsaW1leSEgfEJp4bq/dCB8QmV0IHxCYWdpIHxBeWUgfGF3ZXIgfEF2YXN0ISB8QXR1bmNpIHxBdGVzYSB8QXTDqHMgfEFwYWJpbGEgfEFucmhlZ2VkaWcgYSB8QW5nZW5vbW1lbiB8QW5kIHknYWxsIHxBbmQgfEFOIHxBbiB8YW4gfEFtaWtvciB8QW1lbm55aWJlbiB8QW1hIHxBbHMgfEFsb3JzIHxBbGxvcmEgfEFsaSB8QWxlc2hvcmVzIHxBbGUgfEFra29yIHxBayB8QWRvdHQgfEFjIHxBYmVyIHxBIHrDoXJvdmXFiCB8QSB0aWXFviB8QSB0YWt0aWXFviB8QSB0YWvDqSB8QSB8YSB8NyB8XFwqICkvKSkge1xuICAgICAgICBzdGF0ZS5pblN0ZXAgPSB0cnVlO1xuICAgICAgICBzdGF0ZS5hbGxvd1BsYWNlaG9sZGVycyA9IHRydWU7XG4gICAgICAgIHN0YXRlLmFsbG93TXVsdGlsaW5lQXJndW1lbnQgPSB0cnVlO1xuICAgICAgICBzdGF0ZS5pbktleXdvcmRMaW5lID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuXG4gICAgICAvLyBJTkxJTkUgU1RSSU5HXG4gICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaCgvXCJbXlwiXSpcIj8vKSkge1xuICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcblxuICAgICAgLy8gUExBQ0VIT0xERVJcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuYWxsb3dQbGFjZWhvbGRlcnMgJiYgc3RyZWFtLm1hdGNoKC88W14+XSo+Py8pKSB7XG4gICAgICAgIHJldHVybiBcInZhcmlhYmxlXCI7XG5cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXkBcIjwjXS8pO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59KTtcblxuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LWZlYXR1cmVcIiwgXCJnaGVya2luXCIpO1xuXG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwiZ29cIiwgZnVuY3Rpb24oY29uZmlnKSB7XG4gIHZhciBpbmRlbnRVbml0ID0gY29uZmlnLmluZGVudFVuaXQ7XG5cbiAgdmFyIGtleXdvcmRzID0ge1xuICAgIFwiYnJlYWtcIjp0cnVlLCBcImNhc2VcIjp0cnVlLCBcImNoYW5cIjp0cnVlLCBcImNvbnN0XCI6dHJ1ZSwgXCJjb250aW51ZVwiOnRydWUsXG4gICAgXCJkZWZhdWx0XCI6dHJ1ZSwgXCJkZWZlclwiOnRydWUsIFwiZWxzZVwiOnRydWUsIFwiZmFsbHRocm91Z2hcIjp0cnVlLCBcImZvclwiOnRydWUsXG4gICAgXCJmdW5jXCI6dHJ1ZSwgXCJnb1wiOnRydWUsIFwiZ290b1wiOnRydWUsIFwiaWZcIjp0cnVlLCBcImltcG9ydFwiOnRydWUsXG4gICAgXCJpbnRlcmZhY2VcIjp0cnVlLCBcIm1hcFwiOnRydWUsIFwicGFja2FnZVwiOnRydWUsIFwicmFuZ2VcIjp0cnVlLCBcInJldHVyblwiOnRydWUsXG4gICAgXCJzZWxlY3RcIjp0cnVlLCBcInN0cnVjdFwiOnRydWUsIFwic3dpdGNoXCI6dHJ1ZSwgXCJ0eXBlXCI6dHJ1ZSwgXCJ2YXJcIjp0cnVlLFxuICAgIFwiYm9vbFwiOnRydWUsIFwiYnl0ZVwiOnRydWUsIFwiY29tcGxleDY0XCI6dHJ1ZSwgXCJjb21wbGV4MTI4XCI6dHJ1ZSxcbiAgICBcImZsb2F0MzJcIjp0cnVlLCBcImZsb2F0NjRcIjp0cnVlLCBcImludDhcIjp0cnVlLCBcImludDE2XCI6dHJ1ZSwgXCJpbnQzMlwiOnRydWUsXG4gICAgXCJpbnQ2NFwiOnRydWUsIFwic3RyaW5nXCI6dHJ1ZSwgXCJ1aW50OFwiOnRydWUsIFwidWludDE2XCI6dHJ1ZSwgXCJ1aW50MzJcIjp0cnVlLFxuICAgIFwidWludDY0XCI6dHJ1ZSwgXCJpbnRcIjp0cnVlLCBcInVpbnRcIjp0cnVlLCBcInVpbnRwdHJcIjp0cnVlLCBcImVycm9yXCI6IHRydWUsXG4gICAgXCJydW5lXCI6dHJ1ZVxuICB9O1xuXG4gIHZhciBhdG9tcyA9IHtcbiAgICBcInRydWVcIjp0cnVlLCBcImZhbHNlXCI6dHJ1ZSwgXCJpb3RhXCI6dHJ1ZSwgXCJuaWxcIjp0cnVlLCBcImFwcGVuZFwiOnRydWUsXG4gICAgXCJjYXBcIjp0cnVlLCBcImNsb3NlXCI6dHJ1ZSwgXCJjb21wbGV4XCI6dHJ1ZSwgXCJjb3B5XCI6dHJ1ZSwgXCJkZWxldGVcIjp0cnVlLCBcImltYWdcIjp0cnVlLFxuICAgIFwibGVuXCI6dHJ1ZSwgXCJtYWtlXCI6dHJ1ZSwgXCJuZXdcIjp0cnVlLCBcInBhbmljXCI6dHJ1ZSwgXCJwcmludFwiOnRydWUsXG4gICAgXCJwcmludGxuXCI6dHJ1ZSwgXCJyZWFsXCI6dHJ1ZSwgXCJyZWNvdmVyXCI6dHJ1ZVxuICB9O1xuXG4gIHZhciBpc09wZXJhdG9yQ2hhciA9IC9bK1xcLSomXiU6PTw+IXxcXC9dLztcblxuICB2YXIgY3VyUHVuYztcblxuICBmdW5jdGlvbiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG4gICAgaWYgKGNoID09ICdcIicgfHwgY2ggPT0gXCInXCIgfHwgY2ggPT0gXCJgXCIpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5TdHJpbmcoY2gpO1xuICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgICBpZiAoL1tcXGRcXC5dLy50ZXN0KGNoKSkge1xuICAgICAgaWYgKGNoID09IFwiLlwiKSB7XG4gICAgICAgIHN0cmVhbS5tYXRjaCgvXlswLTldKyhbZUVdW1xcLStdP1swLTldKyk/Lyk7XG4gICAgICB9IGVsc2UgaWYgKGNoID09IFwiMFwiKSB7XG4gICAgICAgIHN0cmVhbS5tYXRjaCgvXlt4WF1bMC05YS1mQS1GXSsvKSB8fCBzdHJlYW0ubWF0Y2goL14wWzAtN10rLyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJlYW0ubWF0Y2goL15bMC05XSpcXC4/WzAtOV0qKFtlRV1bXFwtK10/WzAtOV0rKT8vKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgIH1cbiAgICBpZiAoL1tcXFtcXF17fVxcKFxcKSw7XFw6XFwuXS8udGVzdChjaCkpIHtcbiAgICAgIGN1clB1bmMgPSBjaDtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoY2ggPT0gXCIvXCIpIHtcbiAgICAgIGlmIChzdHJlYW0uZWF0KFwiKlwiKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQ29tbWVudDtcbiAgICAgICAgcmV0dXJuIHRva2VuQ29tbWVudChzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHJlYW0uZWF0KFwiL1wiKSkge1xuICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzT3BlcmF0b3JDaGFyLnRlc3QoY2gpKSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoaXNPcGVyYXRvckNoYXIpO1xuICAgICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgICB9XG4gICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwkX1xceGExLVxcdWZmZmZdLyk7XG4gICAgdmFyIGN1ciA9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAgaWYgKGtleXdvcmRzLnByb3BlcnR5SXNFbnVtZXJhYmxlKGN1cikpIHtcbiAgICAgIGlmIChjdXIgPT0gXCJjYXNlXCIgfHwgY3VyID09IFwiZGVmYXVsdFwiKSBjdXJQdW5jID0gXCJjYXNlXCI7XG4gICAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gICAgfVxuICAgIGlmIChhdG9tcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSByZXR1cm4gXCJhdG9tXCI7XG4gICAgcmV0dXJuIFwidmFyaWFibGVcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuU3RyaW5nKHF1b3RlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBlc2NhcGVkID0gZmFsc2UsIG5leHQsIGVuZCA9IGZhbHNlO1xuICAgICAgd2hpbGUgKChuZXh0ID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgICBpZiAobmV4dCA9PSBxdW90ZSAmJiAhZXNjYXBlZCkge2VuZCA9IHRydWU7IGJyZWFrO31cbiAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkICYmIHF1b3RlICE9IFwiYFwiICYmIG5leHQgPT0gXCJcXFxcXCI7XG4gICAgICB9XG4gICAgICBpZiAoZW5kIHx8ICEoZXNjYXBlZCB8fCBxdW90ZSA9PSBcImBcIikpXG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIG1heWJlRW5kID0gZmFsc2UsIGNoO1xuICAgIHdoaWxlIChjaCA9IHN0cmVhbS5uZXh0KCkpIHtcbiAgICAgIGlmIChjaCA9PSBcIi9cIiAmJiBtYXliZUVuZCkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBtYXliZUVuZCA9IChjaCA9PSBcIipcIik7XG4gICAgfVxuICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQoaW5kZW50ZWQsIGNvbHVtbiwgdHlwZSwgYWxpZ24sIHByZXYpIHtcbiAgICB0aGlzLmluZGVudGVkID0gaW5kZW50ZWQ7XG4gICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmFsaWduID0gYWxpZ247XG4gICAgdGhpcy5wcmV2ID0gcHJldjtcbiAgfVxuICBmdW5jdGlvbiBwdXNoQ29udGV4dChzdGF0ZSwgY29sLCB0eXBlKSB7XG4gICAgcmV0dXJuIHN0YXRlLmNvbnRleHQgPSBuZXcgQ29udGV4dChzdGF0ZS5pbmRlbnRlZCwgY29sLCB0eXBlLCBudWxsLCBzdGF0ZS5jb250ZXh0KTtcbiAgfVxuICBmdW5jdGlvbiBwb3BDb250ZXh0KHN0YXRlKSB7XG4gICAgaWYgKCFzdGF0ZS5jb250ZXh0LnByZXYpIHJldHVybjtcbiAgICB2YXIgdCA9IHN0YXRlLmNvbnRleHQudHlwZTtcbiAgICBpZiAodCA9PSBcIilcIiB8fCB0ID09IFwiXVwiIHx8IHQgPT0gXCJ9XCIpXG4gICAgICBzdGF0ZS5pbmRlbnRlZCA9IHN0YXRlLmNvbnRleHQuaW5kZW50ZWQ7XG4gICAgcmV0dXJuIHN0YXRlLmNvbnRleHQgPSBzdGF0ZS5jb250ZXh0LnByZXY7XG4gIH1cblxuICAvLyBJbnRlcmZhY2VcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKGJhc2Vjb2x1bW4pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRva2VuaXplOiBudWxsLFxuICAgICAgICBjb250ZXh0OiBuZXcgQ29udGV4dCgoYmFzZWNvbHVtbiB8fCAwKSAtIGluZGVudFVuaXQsIDAsIFwidG9wXCIsIGZhbHNlKSxcbiAgICAgICAgaW5kZW50ZWQ6IDAsXG4gICAgICAgIHN0YXJ0T2ZMaW5lOiB0cnVlXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIGN0eCA9IHN0YXRlLmNvbnRleHQ7XG4gICAgICBpZiAoc3RyZWFtLnNvbCgpKSB7XG4gICAgICAgIGlmIChjdHguYWxpZ24gPT0gbnVsbCkgY3R4LmFsaWduID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmluZGVudGVkID0gc3RyZWFtLmluZGVudGF0aW9uKCk7XG4gICAgICAgIHN0YXRlLnN0YXJ0T2ZMaW5lID0gdHJ1ZTtcbiAgICAgICAgaWYgKGN0eC50eXBlID09IFwiY2FzZVwiKSBjdHgudHlwZSA9IFwifVwiO1xuICAgICAgfVxuICAgICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSByZXR1cm4gbnVsbDtcbiAgICAgIGN1clB1bmMgPSBudWxsO1xuICAgICAgdmFyIHN0eWxlID0gKHN0YXRlLnRva2VuaXplIHx8IHRva2VuQmFzZSkoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBpZiAoc3R5bGUgPT0gXCJjb21tZW50XCIpIHJldHVybiBzdHlsZTtcbiAgICAgIGlmIChjdHguYWxpZ24gPT0gbnVsbCkgY3R4LmFsaWduID0gdHJ1ZTtcblxuICAgICAgaWYgKGN1clB1bmMgPT0gXCJ7XCIpIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0uY29sdW1uKCksIFwifVwiKTtcbiAgICAgIGVsc2UgaWYgKGN1clB1bmMgPT0gXCJbXCIpIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0uY29sdW1uKCksIFwiXVwiKTtcbiAgICAgIGVsc2UgaWYgKGN1clB1bmMgPT0gXCIoXCIpIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0uY29sdW1uKCksIFwiKVwiKTtcbiAgICAgIGVsc2UgaWYgKGN1clB1bmMgPT0gXCJjYXNlXCIpIGN0eC50eXBlID0gXCJjYXNlXCI7XG4gICAgICBlbHNlIGlmIChjdXJQdW5jID09IFwifVwiICYmIGN0eC50eXBlID09IFwifVwiKSBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgIGVsc2UgaWYgKGN1clB1bmMgPT0gY3R4LnR5cGUpIHBvcENvbnRleHQoc3RhdGUpO1xuICAgICAgc3RhdGUuc3RhcnRPZkxpbmUgPSBmYWxzZTtcbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9LFxuXG4gICAgaW5kZW50OiBmdW5jdGlvbihzdGF0ZSwgdGV4dEFmdGVyKSB7XG4gICAgICBpZiAoc3RhdGUudG9rZW5pemUgIT0gdG9rZW5CYXNlICYmIHN0YXRlLnRva2VuaXplICE9IG51bGwpIHJldHVybiBDb2RlTWlycm9yLlBhc3M7XG4gICAgICB2YXIgY3R4ID0gc3RhdGUuY29udGV4dCwgZmlyc3RDaGFyID0gdGV4dEFmdGVyICYmIHRleHRBZnRlci5jaGFyQXQoMCk7XG4gICAgICBpZiAoY3R4LnR5cGUgPT0gXCJjYXNlXCIgJiYgL14oPzpjYXNlfGRlZmF1bHQpXFxiLy50ZXN0KHRleHRBZnRlcikpIHtcbiAgICAgICAgc3RhdGUuY29udGV4dC50eXBlID0gXCJ9XCI7XG4gICAgICAgIHJldHVybiBjdHguaW5kZW50ZWQ7XG4gICAgICB9XG4gICAgICB2YXIgY2xvc2luZyA9IGZpcnN0Q2hhciA9PSBjdHgudHlwZTtcbiAgICAgIGlmIChjdHguYWxpZ24pIHJldHVybiBjdHguY29sdW1uICsgKGNsb3NpbmcgPyAwIDogMSk7XG4gICAgICBlbHNlIHJldHVybiBjdHguaW5kZW50ZWQgKyAoY2xvc2luZyA/IDAgOiBpbmRlbnRVbml0KTtcbiAgICB9LFxuXG4gICAgZWxlY3RyaWNDaGFyczogXCJ7fSk6XCIsXG4gICAgY2xvc2VCcmFja2V0czogXCIoKVtde30nJ1xcXCJcXFwiYGBcIixcbiAgICBmb2xkOiBcImJyYWNlXCIsXG4gICAgYmxvY2tDb21tZW50U3RhcnQ6IFwiLypcIixcbiAgICBibG9ja0NvbW1lbnRFbmQ6IFwiKi9cIixcbiAgICBsaW5lQ29tbWVudDogXCIvL1wiXG4gIH07XG59KTtcblxuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LWdvXCIsIFwiZ29cIik7XG5cbn0pO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcblwidXNlIHN0cmljdFwiO1xuXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoXCJncm9vdnlcIiwgZnVuY3Rpb24oY29uZmlnKSB7XG4gIGZ1bmN0aW9uIHdvcmRzKHN0cikge1xuICAgIHZhciBvYmogPSB7fSwgd29yZHMgPSBzdHIuc3BsaXQoXCIgXCIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyArK2kpIG9ialt3b3Jkc1tpXV0gPSB0cnVlO1xuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgdmFyIGtleXdvcmRzID0gd29yZHMoXG4gICAgXCJhYnN0cmFjdCBhcyBhc3NlcnQgYm9vbGVhbiBicmVhayBieXRlIGNhc2UgY2F0Y2ggY2hhciBjbGFzcyBjb25zdCBjb250aW51ZSBkZWYgZGVmYXVsdCBcIiArXG4gICAgXCJkbyBkb3VibGUgZWxzZSBlbnVtIGV4dGVuZHMgZmluYWwgZmluYWxseSBmbG9hdCBmb3IgZ290byBpZiBpbXBsZW1lbnRzIGltcG9ydCBpbiBcIiArXG4gICAgXCJpbnN0YW5jZW9mIGludCBpbnRlcmZhY2UgbG9uZyBuYXRpdmUgbmV3IHBhY2thZ2UgcHJpdmF0ZSBwcm90ZWN0ZWQgcHVibGljIHJldHVybiBcIiArXG4gICAgXCJzaG9ydCBzdGF0aWMgc3RyaWN0ZnAgc3VwZXIgc3dpdGNoIHN5bmNocm9uaXplZCB0aHJlYWRzYWZlIHRocm93IHRocm93cyB0cmFpdCB0cmFuc2llbnQgXCIgK1xuICAgIFwidHJ5IHZvaWQgdm9sYXRpbGUgd2hpbGVcIik7XG4gIHZhciBibG9ja0tleXdvcmRzID0gd29yZHMoXCJjYXRjaCBjbGFzcyBkZWYgZG8gZWxzZSBlbnVtIGZpbmFsbHkgZm9yIGlmIGludGVyZmFjZSBzd2l0Y2ggdHJhaXQgdHJ5IHdoaWxlXCIpO1xuICB2YXIgc3RhbmRhbG9uZUtleXdvcmRzID0gd29yZHMoXCJyZXR1cm4gYnJlYWsgY29udGludWVcIik7XG4gIHZhciBhdG9tcyA9IHdvcmRzKFwibnVsbCB0cnVlIGZhbHNlIHRoaXNcIik7XG5cbiAgdmFyIGN1clB1bmM7XG4gIGZ1bmN0aW9uIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGNoID0gc3RyZWFtLm5leHQoKTtcbiAgICBpZiAoY2ggPT0gJ1wiJyB8fCBjaCA9PSBcIidcIikge1xuICAgICAgcmV0dXJuIHN0YXJ0U3RyaW5nKGNoLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gICAgaWYgKC9bXFxbXFxde31cXChcXCksO1xcOlxcLl0vLnRlc3QoY2gpKSB7XG4gICAgICBjdXJQdW5jID0gY2g7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKC9cXGQvLnRlc3QoY2gpKSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXC5dLyk7XG4gICAgICBpZiAoc3RyZWFtLmVhdCgvZUUvKSkgeyBzdHJlYW0uZWF0KC9cXCtcXC0vKTsgc3RyZWFtLmVhdFdoaWxlKC9cXGQvKTsgfVxuICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgfVxuICAgIGlmIChjaCA9PSBcIi9cIikge1xuICAgICAgaWYgKHN0cmVhbS5lYXQoXCIqXCIpKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplLnB1c2godG9rZW5Db21tZW50KTtcbiAgICAgICAgcmV0dXJuIHRva2VuQ29tbWVudChzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHJlYW0uZWF0KFwiL1wiKSkge1xuICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICAgIH1cbiAgICAgIGlmIChleHBlY3RFeHByZXNzaW9uKHN0YXRlLmxhc3RUb2tlbiwgZmFsc2UpKSB7XG4gICAgICAgIHJldHVybiBzdGFydFN0cmluZyhjaCwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjaCA9PSBcIi1cIiAmJiBzdHJlYW0uZWF0KFwiPlwiKSkge1xuICAgICAgY3VyUHVuYyA9IFwiLT5cIjtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoL1srXFwtKiYlPTw+IT98XFwvfl0vLnRlc3QoY2gpKSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1srXFwtKiYlPTw+fH5dLyk7XG4gICAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICAgIH1cbiAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXCRfXS8pO1xuICAgIGlmIChjaCA9PSBcIkBcIikgeyBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXCRfXFwuXS8pOyByZXR1cm4gXCJtZXRhXCI7IH1cbiAgICBpZiAoc3RhdGUubGFzdFRva2VuID09IFwiLlwiKSByZXR1cm4gXCJwcm9wZXJ0eVwiO1xuICAgIGlmIChzdHJlYW0uZWF0KFwiOlwiKSkgeyBjdXJQdW5jID0gXCJwcm9wbGFiZWxcIjsgcmV0dXJuIFwicHJvcGVydHlcIjsgfVxuICAgIHZhciBjdXIgPSBzdHJlYW0uY3VycmVudCgpO1xuICAgIGlmIChhdG9tcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSB7IHJldHVybiBcImF0b21cIjsgfVxuICAgIGlmIChrZXl3b3Jkcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSB7XG4gICAgICBpZiAoYmxvY2tLZXl3b3Jkcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSBjdXJQdW5jID0gXCJuZXdzdGF0ZW1lbnRcIjtcbiAgICAgIGVsc2UgaWYgKHN0YW5kYWxvbmVLZXl3b3Jkcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSBjdXJQdW5jID0gXCJzdGFuZGFsb25lXCI7XG4gICAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gICAgfVxuICAgIHJldHVybiBcInZhcmlhYmxlXCI7XG4gIH1cbiAgdG9rZW5CYXNlLmlzQmFzZSA9IHRydWU7XG5cbiAgZnVuY3Rpb24gc3RhcnRTdHJpbmcocXVvdGUsIHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgdHJpcGxlUXVvdGVkID0gZmFsc2U7XG4gICAgaWYgKHF1b3RlICE9IFwiL1wiICYmIHN0cmVhbS5lYXQocXVvdGUpKSB7XG4gICAgICBpZiAoc3RyZWFtLmVhdChxdW90ZSkpIHRyaXBsZVF1b3RlZCA9IHRydWU7XG4gICAgICBlbHNlIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0KHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBlc2NhcGVkID0gZmFsc2UsIG5leHQsIGVuZCA9ICF0cmlwbGVRdW90ZWQ7XG4gICAgICB3aGlsZSAoKG5leHQgPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChuZXh0ID09IHF1b3RlICYmICFlc2NhcGVkKSB7XG4gICAgICAgICAgaWYgKCF0cmlwbGVRdW90ZWQpIHsgYnJlYWs7IH1cbiAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKHF1b3RlICsgcXVvdGUpKSB7IGVuZCA9IHRydWU7IGJyZWFrOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHF1b3RlID09ICdcIicgJiYgbmV4dCA9PSBcIiRcIiAmJiAhZXNjYXBlZCAmJiBzdHJlYW0uZWF0KFwie1wiKSkge1xuICAgICAgICAgIHN0YXRlLnRva2VuaXplLnB1c2godG9rZW5CYXNlVW50aWxCcmFjZSgpKTtcbiAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICAgICAgfVxuICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQgJiYgbmV4dCA9PSBcIlxcXFxcIjtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQpIHN0YXRlLnRva2VuaXplLnBvcCgpO1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfVxuICAgIHN0YXRlLnRva2VuaXplLnB1c2godCk7XG4gICAgcmV0dXJuIHQoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlbkJhc2VVbnRpbEJyYWNlKCkge1xuICAgIHZhciBkZXB0aCA9IDE7XG4gICAgZnVuY3Rpb24gdChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAoc3RyZWFtLnBlZWsoKSA9PSBcIn1cIikge1xuICAgICAgICBkZXB0aC0tO1xuICAgICAgICBpZiAoZGVwdGggPT0gMCkge1xuICAgICAgICAgIHN0YXRlLnRva2VuaXplLnBvcCgpO1xuICAgICAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZVtzdGF0ZS50b2tlbml6ZS5sZW5ndGgtMV0oc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLnBlZWsoKSA9PSBcIntcIikge1xuICAgICAgICBkZXB0aCsrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gICAgdC5pc0Jhc2UgPSB0cnVlO1xuICAgIHJldHVybiB0O1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5Db21tZW50KHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgbWF5YmVFbmQgPSBmYWxzZSwgY2g7XG4gICAgd2hpbGUgKGNoID0gc3RyZWFtLm5leHQoKSkge1xuICAgICAgaWYgKGNoID09IFwiL1wiICYmIG1heWJlRW5kKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplLnBvcCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG1heWJlRW5kID0gKGNoID09IFwiKlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICB9XG5cbiAgZnVuY3Rpb24gZXhwZWN0RXhwcmVzc2lvbihsYXN0LCBuZXdsaW5lKSB7XG4gICAgcmV0dXJuICFsYXN0IHx8IGxhc3QgPT0gXCJvcGVyYXRvclwiIHx8IGxhc3QgPT0gXCItPlwiIHx8IC9bXFwuXFxbXFx7XFwoLDs6XS8udGVzdChsYXN0KSB8fFxuICAgICAgbGFzdCA9PSBcIm5ld3N0YXRlbWVudFwiIHx8IGxhc3QgPT0gXCJrZXl3b3JkXCIgfHwgbGFzdCA9PSBcInByb3BsYWJlbFwiIHx8XG4gICAgICAobGFzdCA9PSBcInN0YW5kYWxvbmVcIiAmJiAhbmV3bGluZSk7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KGluZGVudGVkLCBjb2x1bW4sIHR5cGUsIGFsaWduLCBwcmV2KSB7XG4gICAgdGhpcy5pbmRlbnRlZCA9IGluZGVudGVkO1xuICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5hbGlnbiA9IGFsaWduO1xuICAgIHRoaXMucHJldiA9IHByZXY7XG4gIH1cbiAgZnVuY3Rpb24gcHVzaENvbnRleHQoc3RhdGUsIGNvbCwgdHlwZSkge1xuICAgIHJldHVybiBzdGF0ZS5jb250ZXh0ID0gbmV3IENvbnRleHQoc3RhdGUuaW5kZW50ZWQsIGNvbCwgdHlwZSwgbnVsbCwgc3RhdGUuY29udGV4dCk7XG4gIH1cbiAgZnVuY3Rpb24gcG9wQ29udGV4dChzdGF0ZSkge1xuICAgIHZhciB0ID0gc3RhdGUuY29udGV4dC50eXBlO1xuICAgIGlmICh0ID09IFwiKVwiIHx8IHQgPT0gXCJdXCIgfHwgdCA9PSBcIn1cIilcbiAgICAgIHN0YXRlLmluZGVudGVkID0gc3RhdGUuY29udGV4dC5pbmRlbnRlZDtcbiAgICByZXR1cm4gc3RhdGUuY29udGV4dCA9IHN0YXRlLmNvbnRleHQucHJldjtcbiAgfVxuXG4gIC8vIEludGVyZmFjZVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oYmFzZWNvbHVtbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9rZW5pemU6IFt0b2tlbkJhc2VdLFxuICAgICAgICBjb250ZXh0OiBuZXcgQ29udGV4dCgoYmFzZWNvbHVtbiB8fCAwKSAtIGNvbmZpZy5pbmRlbnRVbml0LCAwLCBcInRvcFwiLCBmYWxzZSksXG4gICAgICAgIGluZGVudGVkOiAwLFxuICAgICAgICBzdGFydE9mTGluZTogdHJ1ZSxcbiAgICAgICAgbGFzdFRva2VuOiBudWxsXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIGN0eCA9IHN0YXRlLmNvbnRleHQ7XG4gICAgICBpZiAoc3RyZWFtLnNvbCgpKSB7XG4gICAgICAgIGlmIChjdHguYWxpZ24gPT0gbnVsbCkgY3R4LmFsaWduID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmluZGVudGVkID0gc3RyZWFtLmluZGVudGF0aW9uKCk7XG4gICAgICAgIHN0YXRlLnN0YXJ0T2ZMaW5lID0gdHJ1ZTtcbiAgICAgICAgLy8gQXV0b21hdGljIHNlbWljb2xvbiBpbnNlcnRpb25cbiAgICAgICAgaWYgKGN0eC50eXBlID09IFwic3RhdGVtZW50XCIgJiYgIWV4cGVjdEV4cHJlc3Npb24oc3RhdGUubGFzdFRva2VuLCB0cnVlKSkge1xuICAgICAgICAgIHBvcENvbnRleHQoc3RhdGUpOyBjdHggPSBzdGF0ZS5jb250ZXh0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xuICAgICAgY3VyUHVuYyA9IG51bGw7XG4gICAgICB2YXIgc3R5bGUgPSBzdGF0ZS50b2tlbml6ZVtzdGF0ZS50b2tlbml6ZS5sZW5ndGgtMV0oc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBpZiAoc3R5bGUgPT0gXCJjb21tZW50XCIpIHJldHVybiBzdHlsZTtcbiAgICAgIGlmIChjdHguYWxpZ24gPT0gbnVsbCkgY3R4LmFsaWduID0gdHJ1ZTtcblxuICAgICAgaWYgKChjdXJQdW5jID09IFwiO1wiIHx8IGN1clB1bmMgPT0gXCI6XCIpICYmIGN0eC50eXBlID09IFwic3RhdGVtZW50XCIpIHBvcENvbnRleHQoc3RhdGUpO1xuICAgICAgLy8gSGFuZGxlIGluZGVudGF0aW9uIGZvciB7eCAtPiBcXG4gLi4uIH1cbiAgICAgIGVsc2UgaWYgKGN1clB1bmMgPT0gXCItPlwiICYmIGN0eC50eXBlID09IFwic3RhdGVtZW50XCIgJiYgY3R4LnByZXYudHlwZSA9PSBcIn1cIikge1xuICAgICAgICBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgICAgc3RhdGUuY29udGV4dC5hbGlnbiA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBcIntcIikgcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbS5jb2x1bW4oKSwgXCJ9XCIpO1xuICAgICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBcIltcIikgcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbS5jb2x1bW4oKSwgXCJdXCIpO1xuICAgICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBcIihcIikgcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbS5jb2x1bW4oKSwgXCIpXCIpO1xuICAgICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBcIn1cIikge1xuICAgICAgICB3aGlsZSAoY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIikgY3R4ID0gcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICAgIGlmIChjdHgudHlwZSA9PSBcIn1cIikgY3R4ID0gcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICAgIHdoaWxlIChjdHgudHlwZSA9PSBcInN0YXRlbWVudFwiKSBjdHggPSBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGN1clB1bmMgPT0gY3R4LnR5cGUpIHBvcENvbnRleHQoc3RhdGUpO1xuICAgICAgZWxzZSBpZiAoY3R4LnR5cGUgPT0gXCJ9XCIgfHwgY3R4LnR5cGUgPT0gXCJ0b3BcIiB8fCAoY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIiAmJiBjdXJQdW5jID09IFwibmV3c3RhdGVtZW50XCIpKVxuICAgICAgICBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLmNvbHVtbigpLCBcInN0YXRlbWVudFwiKTtcbiAgICAgIHN0YXRlLnN0YXJ0T2ZMaW5lID0gZmFsc2U7XG4gICAgICBzdGF0ZS5sYXN0VG9rZW4gPSBjdXJQdW5jIHx8IHN0eWxlO1xuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH0sXG5cbiAgICBpbmRlbnQ6IGZ1bmN0aW9uKHN0YXRlLCB0ZXh0QWZ0ZXIpIHtcbiAgICAgIGlmICghc3RhdGUudG9rZW5pemVbc3RhdGUudG9rZW5pemUubGVuZ3RoLTFdLmlzQmFzZSkgcmV0dXJuIENvZGVNaXJyb3IuUGFzcztcbiAgICAgIHZhciBmaXJzdENoYXIgPSB0ZXh0QWZ0ZXIgJiYgdGV4dEFmdGVyLmNoYXJBdCgwKSwgY3R4ID0gc3RhdGUuY29udGV4dDtcbiAgICAgIGlmIChjdHgudHlwZSA9PSBcInN0YXRlbWVudFwiICYmICFleHBlY3RFeHByZXNzaW9uKHN0YXRlLmxhc3RUb2tlbiwgdHJ1ZSkpIGN0eCA9IGN0eC5wcmV2O1xuICAgICAgdmFyIGNsb3NpbmcgPSBmaXJzdENoYXIgPT0gY3R4LnR5cGU7XG4gICAgICBpZiAoY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIikgcmV0dXJuIGN0eC5pbmRlbnRlZCArIChmaXJzdENoYXIgPT0gXCJ7XCIgPyAwIDogY29uZmlnLmluZGVudFVuaXQpO1xuICAgICAgZWxzZSBpZiAoY3R4LmFsaWduKSByZXR1cm4gY3R4LmNvbHVtbiArIChjbG9zaW5nID8gMCA6IDEpO1xuICAgICAgZWxzZSByZXR1cm4gY3R4LmluZGVudGVkICsgKGNsb3NpbmcgPyAwIDogY29uZmlnLmluZGVudFVuaXQpO1xuICAgIH0sXG5cbiAgICBlbGVjdHJpY0NoYXJzOiBcInt9XCIsXG4gICAgY2xvc2VCcmFja2V0czoge3RyaXBsZXM6IFwiJ1xcXCJcIn0sXG4gICAgZm9sZDogXCJicmFjZVwiLFxuICAgIGJsb2NrQ29tbWVudFN0YXJ0OiBcIi8qXCIsXG4gICAgYmxvY2tDb21tZW50RW5kOiBcIiovXCIsXG4gICAgbGluZUNvbW1lbnQ6IFwiLy9cIlxuICB9O1xufSk7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQveC1ncm9vdnlcIiwgXCJncm9vdnlcIik7XG5cbn0pO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSwgcmVxdWlyZShcIi4uL2h0bWxtaXhlZC9odG1sbWl4ZWRcIiksIHJlcXVpcmUoXCIuLi9ydWJ5L3J1YnlcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIiwgXCIuLi9odG1sbWl4ZWQvaHRtbG1peGVkXCIsIFwiLi4vcnVieS9ydWJ5XCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgLy8gZnVsbCBoYW1sIG1vZGUuIFRoaXMgaGFuZGxlZCBlbWJlZGRlZCBydWJ5IGFuZCBodG1sIGZyYWdtZW50cyB0b29cbiAgQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwiaGFtbFwiLCBmdW5jdGlvbihjb25maWcpIHtcbiAgICB2YXIgaHRtbE1vZGUgPSBDb2RlTWlycm9yLmdldE1vZGUoY29uZmlnLCB7bmFtZTogXCJodG1sbWl4ZWRcIn0pO1xuICAgIHZhciBydWJ5TW9kZSA9IENvZGVNaXJyb3IuZ2V0TW9kZShjb25maWcsIFwicnVieVwiKTtcblxuICAgIGZ1bmN0aW9uIHJ1YnlJblF1b3RlKGVuZFF1b3RlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgICB2YXIgY2ggPSBzdHJlYW0ucGVlaygpO1xuICAgICAgICBpZiAoY2ggPT0gZW5kUXVvdGUgJiYgc3RhdGUucnVieVN0YXRlLnRva2VuaXplLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgLy8gc3RlcCBvdXQgb2YgcnVieSBjb250ZXh0IGFzIGl0IHNlZW1zIHRvIGNvbXBsZXRlIHByb2Nlc3NpbmcgYWxsIHRoZSBicmFjZXNcbiAgICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gaHRtbDtcbiAgICAgICAgICByZXR1cm4gXCJjbG9zZUF0dHJpYnV0ZVRhZ1wiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBydWJ5KHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1Ynkoc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKHN0cmVhbS5tYXRjaChcIi0jXCIpKSB7XG4gICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJ1YnlNb2RlLnRva2VuKHN0cmVhbSwgc3RhdGUucnVieVN0YXRlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBodG1sKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBjaCA9IHN0cmVhbS5wZWVrKCk7XG5cbiAgICAgIC8vIGhhbmRsZSBoYW1sIGRlY2xhcmF0aW9ucy4gQWxsIGRlY2xhcmF0aW9ucyB0aGF0IGNhbnQgYmUgaGFuZGxlZCBoZXJlXG4gICAgICAvLyB3aWxsIGJlIHBhc3NlZCB0byBodG1sIG1vZGVcbiAgICAgIGlmIChzdGF0ZS5wcmV2aW91c1Rva2VuLnN0eWxlID09IFwiY29tbWVudFwiICkge1xuICAgICAgICBpZiAoc3RhdGUuaW5kZW50ZWQgPiBzdGF0ZS5wcmV2aW91c1Rva2VuLmluZGVudGVkKSB7XG4gICAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICAgIHJldHVybiBcImNvbW1lbnRMaW5lXCI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlLnN0YXJ0T2ZMaW5lKSB7XG4gICAgICAgIGlmIChjaCA9PSBcIiFcIiAmJiBzdHJlYW0ubWF0Y2goXCIhIVwiKSkge1xuICAgICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgICByZXR1cm4gXCJ0YWdcIjtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goL14lW1xcdzojXFwuXSs9LykpIHtcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHJ1Ynk7XG4gICAgICAgICAgcmV0dXJuIFwiaGFtbFRhZ1wiO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaCgvXiVbXFx3Ol0rLykpIHtcbiAgICAgICAgICByZXR1cm4gXCJoYW1sVGFnXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCIvXCIgKSB7XG4gICAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUuc3RhcnRPZkxpbmUgfHwgc3RhdGUucHJldmlvdXNUb2tlbi5zdHlsZSA9PSBcImhhbWxUYWdcIikge1xuICAgICAgICBpZiAoIGNoID09IFwiI1wiIHx8IGNoID09IFwiLlwiKSB7XG4gICAgICAgICAgc3RyZWFtLm1hdGNoKC9bXFx3LSNcXC5dKi8pO1xuICAgICAgICAgIHJldHVybiBcImhhbWxBdHRyaWJ1dGVcIjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBkbyBub3QgaGFuZGxlIC0tPiBhcyB2YWxpZCBydWJ5LCBtYWtlIGl0IEhUTUwgY2xvc2UgY29tbWVudCBpbnN0ZWFkXG4gICAgICBpZiAoc3RhdGUuc3RhcnRPZkxpbmUgJiYgIXN0cmVhbS5tYXRjaChcIi0tPlwiLCBmYWxzZSkgJiYgKGNoID09IFwiPVwiIHx8IGNoID09IFwiLVwiICkpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSBydWJ5O1xuICAgICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZS5wcmV2aW91c1Rva2VuLnN0eWxlID09IFwiaGFtbFRhZ1wiIHx8XG4gICAgICAgICAgc3RhdGUucHJldmlvdXNUb2tlbi5zdHlsZSA9PSBcImNsb3NlQXR0cmlidXRlVGFnXCIgfHxcbiAgICAgICAgICBzdGF0ZS5wcmV2aW91c1Rva2VuLnN0eWxlID09IFwiaGFtbEF0dHJpYnV0ZVwiKSB7XG4gICAgICAgIGlmIChjaCA9PSBcIihcIikge1xuICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gcnVieUluUXVvdGUoXCIpXCIpO1xuICAgICAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PSBcIntcIikge1xuICAgICAgICAgIGlmICghc3RyZWFtLm1hdGNoKC9eXFx7JS4qLykpIHtcbiAgICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gcnVieUluUXVvdGUoXCJ9XCIpO1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaHRtbE1vZGUudG9rZW4oc3RyZWFtLCBzdGF0ZS5odG1sU3RhdGUpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAvLyBkZWZhdWx0IHRvIGh0bWwgbW9kZVxuICAgICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBodG1sU3RhdGUgPSBDb2RlTWlycm9yLnN0YXJ0U3RhdGUoaHRtbE1vZGUpO1xuICAgICAgICB2YXIgcnVieVN0YXRlID0gQ29kZU1pcnJvci5zdGFydFN0YXRlKHJ1YnlNb2RlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBodG1sU3RhdGU6IGh0bWxTdGF0ZSxcbiAgICAgICAgICBydWJ5U3RhdGU6IHJ1YnlTdGF0ZSxcbiAgICAgICAgICBpbmRlbnRlZDogMCxcbiAgICAgICAgICBwcmV2aW91c1Rva2VuOiB7IHN0eWxlOiBudWxsLCBpbmRlbnRlZDogMH0sXG4gICAgICAgICAgdG9rZW5pemU6IGh0bWxcbiAgICAgICAgfTtcbiAgICAgIH0sXG5cbiAgICAgIGNvcHlTdGF0ZTogZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBodG1sU3RhdGUgOiBDb2RlTWlycm9yLmNvcHlTdGF0ZShodG1sTW9kZSwgc3RhdGUuaHRtbFN0YXRlKSxcbiAgICAgICAgICBydWJ5U3RhdGU6IENvZGVNaXJyb3IuY29weVN0YXRlKHJ1YnlNb2RlLCBzdGF0ZS5ydWJ5U3RhdGUpLFxuICAgICAgICAgIGluZGVudGVkOiBzdGF0ZS5pbmRlbnRlZCxcbiAgICAgICAgICBwcmV2aW91c1Rva2VuOiBzdGF0ZS5wcmV2aW91c1Rva2VuLFxuICAgICAgICAgIHRva2VuaXplOiBzdGF0ZS50b2tlbml6ZVxuICAgICAgICB9O1xuICAgICAgfSxcblxuICAgICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgaWYgKHN0cmVhbS5zb2woKSkge1xuICAgICAgICAgIHN0YXRlLmluZGVudGVkID0gc3RyZWFtLmluZGVudGF0aW9uKCk7XG4gICAgICAgICAgc3RhdGUuc3RhcnRPZkxpbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBzdHlsZSA9IHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICBzdGF0ZS5zdGFydE9mTGluZSA9IGZhbHNlO1xuICAgICAgICAvLyBkb250IHJlY29yZCBjb21tZW50IGxpbmUgYXMgd2Ugb25seSB3YW50IHRvIG1lYXN1cmUgY29tbWVudCBsaW5lIHdpdGhcbiAgICAgICAgLy8gdGhlIG9wZW5pbmcgY29tbWVudCBibG9ja1xuICAgICAgICBpZiAoc3R5bGUgJiYgc3R5bGUgIT0gXCJjb21tZW50TGluZVwiKSB7XG4gICAgICAgICAgc3RhdGUucHJldmlvdXNUb2tlbiA9IHsgc3R5bGU6IHN0eWxlLCBpbmRlbnRlZDogc3RhdGUuaW5kZW50ZWQgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBjdXJyZW50IHN0YXRlIGlzIHJ1YnkgYW5kIHRoZSBwcmV2aW91cyB0b2tlbiBpcyBub3QgYCxgIHJlc2V0IHRoZVxuICAgICAgICAvLyB0b2tlbml6ZSB0byBodG1sXG4gICAgICAgIGlmIChzdHJlYW0uZW9sKCkgJiYgc3RhdGUudG9rZW5pemUgPT0gcnVieSkge1xuICAgICAgICAgIHN0cmVhbS5iYWNrVXAoMSk7XG4gICAgICAgICAgdmFyIGNoID0gc3RyZWFtLnBlZWsoKTtcbiAgICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAgIGlmIChjaCAmJiBjaCAhPSBcIixcIikge1xuICAgICAgICAgICAgc3RhdGUudG9rZW5pemUgPSBodG1sO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyByZXByb2Nlc3Mgc29tZSBvZiB0aGUgc3BlY2lmaWMgc3R5bGUgdGFnIHdoZW4gZmluaXNoIHNldHRpbmcgcHJldmlvdXNUb2tlblxuICAgICAgICBpZiAoc3R5bGUgPT0gXCJoYW1sVGFnXCIpIHtcbiAgICAgICAgICBzdHlsZSA9IFwidGFnXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoc3R5bGUgPT0gXCJjb21tZW50TGluZVwiKSB7XG4gICAgICAgICAgc3R5bGUgPSBcImNvbW1lbnRcIjtcbiAgICAgICAgfSBlbHNlIGlmIChzdHlsZSA9PSBcImhhbWxBdHRyaWJ1dGVcIikge1xuICAgICAgICAgIHN0eWxlID0gXCJhdHRyaWJ1dGVcIjtcbiAgICAgICAgfSBlbHNlIGlmIChzdHlsZSA9PSBcImNsb3NlQXR0cmlidXRlVGFnXCIpIHtcbiAgICAgICAgICBzdHlsZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFwiaHRtbG1peGVkXCIsIFwicnVieVwiKTtcblxuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3gtaGFtbFwiLCBcImhhbWxcIik7XG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIiksIHJlcXVpcmUoXCIuLi8uLi9hZGRvbi9tb2RlL3NpbXBsZVwiKSwgcmVxdWlyZShcIi4uLy4uL2FkZG9uL21vZGUvbXVsdGlwbGV4XCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIsIFwiLi4vLi4vYWRkb24vbW9kZS9zaW1wbGVcIiwgXCIuLi8uLi9hZGRvbi9tb2RlL211bHRpcGxleFwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVTaW1wbGVNb2RlKFwiaGFuZGxlYmFycy10YWdzXCIsIHtcbiAgICBzdGFydDogW1xuICAgICAgeyByZWdleDogL1xce1xce1xcey8sIHB1c2g6IFwiaGFuZGxlYmFyc19yYXdcIiwgdG9rZW46IFwidGFnXCIgfSxcbiAgICAgIHsgcmVnZXg6IC9cXHtcXHshLS0vLCBwdXNoOiBcImRhc2hfY29tbWVudFwiLCB0b2tlbjogXCJjb21tZW50XCIgfSxcbiAgICAgIHsgcmVnZXg6IC9cXHtcXHshLywgICBwdXNoOiBcImNvbW1lbnRcIiwgdG9rZW46IFwiY29tbWVudFwiIH0sXG4gICAgICB7IHJlZ2V4OiAvXFx7XFx7LywgICAgcHVzaDogXCJoYW5kbGViYXJzXCIsIHRva2VuOiBcInRhZ1wiIH1cbiAgICBdLFxuICAgIGhhbmRsZWJhcnNfcmF3OiBbXG4gICAgICB7IHJlZ2V4OiAvXFx9XFx9XFx9LywgcG9wOiB0cnVlLCB0b2tlbjogXCJ0YWdcIiB9LFxuICAgIF0sXG4gICAgaGFuZGxlYmFyczogW1xuICAgICAgeyByZWdleDogL1xcfVxcfS8sIHBvcDogdHJ1ZSwgdG9rZW46IFwidGFnXCIgfSxcblxuICAgICAgLy8gRG91YmxlIGFuZCBzaW5nbGUgcXVvdGVzXG4gICAgICB7IHJlZ2V4OiAvXCIoPzpbXlxcXFxcIl18XFxcXC4pKlwiPy8sIHRva2VuOiBcInN0cmluZ1wiIH0sXG4gICAgICB7IHJlZ2V4OiAvJyg/OlteXFxcXCddfFxcXFwuKSonPy8sIHRva2VuOiBcInN0cmluZ1wiIH0sXG5cbiAgICAgIC8vIEhhbmRsZWJhcnMga2V5d29yZHNcbiAgICAgIHsgcmVnZXg6IC8+fFsjXFwvXShbQS1aYS16X11cXHcqKS8sIHRva2VuOiBcImtleXdvcmRcIiB9LFxuICAgICAgeyByZWdleDogLyg/OmVsc2V8dGhpcylcXGIvLCB0b2tlbjogXCJrZXl3b3JkXCIgfSxcblxuICAgICAgLy8gTnVtZXJhbFxuICAgICAgeyByZWdleDogL1xcZCsvaSwgdG9rZW46IFwibnVtYmVyXCIgfSxcblxuICAgICAgLy8gQXRvbXMgbGlrZSA9IGFuZCAuXG4gICAgICB7IHJlZ2V4OiAvPXx+fEB8dHJ1ZXxmYWxzZS8sIHRva2VuOiBcImF0b21cIiB9LFxuXG4gICAgICAvLyBQYXRoc1xuICAgICAgeyByZWdleDogLyg/OlxcLlxcLlxcLykqKD86W0EtWmEtel9dW1xcd1xcLl0qKSsvLCB0b2tlbjogXCJ2YXJpYWJsZS0yXCIgfVxuICAgIF0sXG4gICAgZGFzaF9jb21tZW50OiBbXG4gICAgICB7IHJlZ2V4OiAvLS1cXH1cXH0vLCBwb3A6IHRydWUsIHRva2VuOiBcImNvbW1lbnRcIiB9LFxuXG4gICAgICAvLyBDb21tZW50ZWQgY29kZVxuICAgICAgeyByZWdleDogLy4vLCB0b2tlbjogXCJjb21tZW50XCJ9XG4gICAgXSxcbiAgICBjb21tZW50OiBbXG4gICAgICB7IHJlZ2V4OiAvXFx9XFx9LywgcG9wOiB0cnVlLCB0b2tlbjogXCJjb21tZW50XCIgfSxcbiAgICAgIHsgcmVnZXg6IC8uLywgdG9rZW46IFwiY29tbWVudFwiIH1cbiAgICBdLFxuICAgIG1ldGE6IHtcbiAgICAgIGJsb2NrQ29tbWVudFN0YXJ0OiBcInt7LS1cIixcbiAgICAgIGJsb2NrQ29tbWVudEVuZDogXCItLX19XCJcbiAgICB9XG4gIH0pO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lTW9kZShcImhhbmRsZWJhcnNcIiwgZnVuY3Rpb24oY29uZmlnLCBwYXJzZXJDb25maWcpIHtcbiAgICB2YXIgaGFuZGxlYmFycyA9IENvZGVNaXJyb3IuZ2V0TW9kZShjb25maWcsIFwiaGFuZGxlYmFycy10YWdzXCIpO1xuICAgIGlmICghcGFyc2VyQ29uZmlnIHx8ICFwYXJzZXJDb25maWcuYmFzZSkgcmV0dXJuIGhhbmRsZWJhcnM7XG4gICAgcmV0dXJuIENvZGVNaXJyb3IubXVsdGlwbGV4aW5nTW9kZShcbiAgICAgIENvZGVNaXJyb3IuZ2V0TW9kZShjb25maWcsIHBhcnNlckNvbmZpZy5iYXNlKSxcbiAgICAgIHtvcGVuOiBcInt7XCIsIGNsb3NlOiAvXFx9XFx9XFx9Py8sIG1vZGU6IGhhbmRsZWJhcnMsIHBhcnNlRGVsaW1pdGVyczogdHJ1ZX1cbiAgICApO1xuICB9KTtcblxuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3gtaGFuZGxlYmFycy10ZW1wbGF0ZVwiLCBcImhhbmRsZWJhcnNcIik7XG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbiAobW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpLCByZXF1aXJlKFwiLi4vaGFza2VsbC9oYXNrZWxsXCIpKVxuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIiwgXCIuLi9oYXNrZWxsL2hhc2tlbGxcIl0sIG1vZClcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKVxufSkoZnVuY3Rpb24gKENvZGVNaXJyb3IpIHtcbiAgXCJ1c2Ugc3RyaWN0XCJcblxuICBDb2RlTWlycm9yLmRlZmluZU1vZGUoXCJoYXNrZWxsLWxpdGVyYXRlXCIsIGZ1bmN0aW9uIChjb25maWcsIHBhcnNlckNvbmZpZykge1xuICAgIHZhciBiYXNlTW9kZSA9IENvZGVNaXJyb3IuZ2V0TW9kZShjb25maWcsIChwYXJzZXJDb25maWcgJiYgcGFyc2VyQ29uZmlnLmJhc2UpIHx8IFwiaGFza2VsbFwiKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpbkNvZGU6IGZhbHNlLFxuICAgICAgICAgIGJhc2VTdGF0ZTogQ29kZU1pcnJvci5zdGFydFN0YXRlKGJhc2VNb2RlKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdG9rZW46IGZ1bmN0aW9uIChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIGlmIChzdHJlYW0uc29sKCkpIHtcbiAgICAgICAgICBpZiAoc3RhdGUuaW5Db2RlID0gc3RyZWFtLmVhdChcIj5cIikpXG4gICAgICAgICAgICByZXR1cm4gXCJtZXRhXCJcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuaW5Db2RlKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VNb2RlLnRva2VuKHN0cmVhbSwgc3RhdGUuYmFzZVN0YXRlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKVxuICAgICAgICAgIHJldHVybiBcImNvbW1lbnRcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaW5uZXJNb2RlOiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmluQ29kZSA/IHtzdGF0ZTogc3RhdGUuYmFzZVN0YXRlLCBtb2RlOiBiYXNlTW9kZX0gOiBudWxsXG4gICAgICB9XG4gICAgfVxuICB9LCBcImhhc2tlbGxcIilcblxuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3gtbGl0ZXJhdGUtaGFza2VsbFwiLCBcImhhc2tlbGwtbGl0ZXJhdGVcIilcbn0pO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcblwidXNlIHN0cmljdFwiO1xuXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoXCJoYXNrZWxsXCIsIGZ1bmN0aW9uKF9jb25maWcsIG1vZGVDb25maWcpIHtcblxuICBmdW5jdGlvbiBzd2l0Y2hTdGF0ZShzb3VyY2UsIHNldFN0YXRlLCBmKSB7XG4gICAgc2V0U3RhdGUoZik7XG4gICAgcmV0dXJuIGYoc291cmNlLCBzZXRTdGF0ZSk7XG4gIH1cblxuICAvLyBUaGVzZSBzaG91bGQgYWxsIGJlIFVuaWNvZGUgZXh0ZW5kZWQsIGFzIHBlciB0aGUgSGFza2VsbCAyMDEwIHJlcG9ydFxuICB2YXIgc21hbGxSRSA9IC9bYS16X10vO1xuICB2YXIgbGFyZ2VSRSA9IC9bQS1aXS87XG4gIHZhciBkaWdpdFJFID0gL1xcZC87XG4gIHZhciBoZXhpdFJFID0gL1swLTlBLUZhLWZdLztcbiAgdmFyIG9jdGl0UkUgPSAvWzAtN10vO1xuICB2YXIgaWRSRSA9IC9bYS16X0EtWjAtOSdcXHhhMS1cXHVmZmZmXS87XG4gIHZhciBzeW1ib2xSRSA9IC9bLSEjJCUmKisuXFwvPD0+P0BcXFxcXnx+Ol0vO1xuICB2YXIgc3BlY2lhbFJFID0gL1soKSw7W1xcXWB7fV0vO1xuICB2YXIgd2hpdGVDaGFyUkUgPSAvWyBcXHRcXHZcXGZdLzsgLy8gbmV3bGluZXMgYXJlIGhhbmRsZWQgaW4gdG9rZW5pemVyXG5cbiAgZnVuY3Rpb24gbm9ybWFsKHNvdXJjZSwgc2V0U3RhdGUpIHtcbiAgICBpZiAoc291cmNlLmVhdFdoaWxlKHdoaXRlQ2hhclJFKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGNoID0gc291cmNlLm5leHQoKTtcbiAgICBpZiAoc3BlY2lhbFJFLnRlc3QoY2gpKSB7XG4gICAgICBpZiAoY2ggPT0gJ3snICYmIHNvdXJjZS5lYXQoJy0nKSkge1xuICAgICAgICB2YXIgdCA9IFwiY29tbWVudFwiO1xuICAgICAgICBpZiAoc291cmNlLmVhdCgnIycpKSB7XG4gICAgICAgICAgdCA9IFwibWV0YVwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzd2l0Y2hTdGF0ZShzb3VyY2UsIHNldFN0YXRlLCBuY29tbWVudCh0LCAxKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoY2ggPT0gJ1xcJycpIHtcbiAgICAgIGlmIChzb3VyY2UuZWF0KCdcXFxcJykpIHtcbiAgICAgICAgc291cmNlLm5leHQoKTsgIC8vIHNob3VsZCBoYW5kbGUgb3RoZXIgZXNjYXBlcyBoZXJlXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc291cmNlLm5leHQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzb3VyY2UuZWF0KCdcXCcnKSkge1xuICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcInN0cmluZyBlcnJvclwiO1xuICAgIH1cblxuICAgIGlmIChjaCA9PSAnXCInKSB7XG4gICAgICByZXR1cm4gc3dpdGNoU3RhdGUoc291cmNlLCBzZXRTdGF0ZSwgc3RyaW5nTGl0ZXJhbCk7XG4gICAgfVxuXG4gICAgaWYgKGxhcmdlUkUudGVzdChjaCkpIHtcbiAgICAgIHNvdXJjZS5lYXRXaGlsZShpZFJFKTtcbiAgICAgIGlmIChzb3VyY2UuZWF0KCcuJykpIHtcbiAgICAgICAgcmV0dXJuIFwicXVhbGlmaWVyXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJ2YXJpYWJsZS0yXCI7XG4gICAgfVxuXG4gICAgaWYgKHNtYWxsUkUudGVzdChjaCkpIHtcbiAgICAgIHNvdXJjZS5lYXRXaGlsZShpZFJFKTtcbiAgICAgIHJldHVybiBcInZhcmlhYmxlXCI7XG4gICAgfVxuXG4gICAgaWYgKGRpZ2l0UkUudGVzdChjaCkpIHtcbiAgICAgIGlmIChjaCA9PSAnMCcpIHtcbiAgICAgICAgaWYgKHNvdXJjZS5lYXQoL1t4WF0vKSkge1xuICAgICAgICAgIHNvdXJjZS5lYXRXaGlsZShoZXhpdFJFKTsgLy8gc2hvdWxkIHJlcXVpcmUgYXQgbGVhc3QgMVxuICAgICAgICAgIHJldHVybiBcImludGVnZXJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlLmVhdCgvW29PXS8pKSB7XG4gICAgICAgICAgc291cmNlLmVhdFdoaWxlKG9jdGl0UkUpOyAvLyBzaG91bGQgcmVxdWlyZSBhdCBsZWFzdCAxXG4gICAgICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNvdXJjZS5lYXRXaGlsZShkaWdpdFJFKTtcbiAgICAgIHZhciB0ID0gXCJudW1iZXJcIjtcbiAgICAgIGlmIChzb3VyY2UubWF0Y2goL15cXC5cXGQrLykpIHtcbiAgICAgICAgdCA9IFwibnVtYmVyXCI7XG4gICAgICB9XG4gICAgICBpZiAoc291cmNlLmVhdCgvW2VFXS8pKSB7XG4gICAgICAgIHQgPSBcIm51bWJlclwiO1xuICAgICAgICBzb3VyY2UuZWF0KC9bLStdLyk7XG4gICAgICAgIHNvdXJjZS5lYXRXaGlsZShkaWdpdFJFKTsgLy8gc2hvdWxkIHJlcXVpcmUgYXQgbGVhc3QgMVxuICAgICAgfVxuICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuXG4gICAgaWYgKGNoID09IFwiLlwiICYmIHNvdXJjZS5lYXQoXCIuXCIpKVxuICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuXG4gICAgaWYgKHN5bWJvbFJFLnRlc3QoY2gpKSB7XG4gICAgICBpZiAoY2ggPT0gJy0nICYmIHNvdXJjZS5lYXQoLy0vKSkge1xuICAgICAgICBzb3VyY2UuZWF0V2hpbGUoLy0vKTtcbiAgICAgICAgaWYgKCFzb3VyY2UuZWF0KHN5bWJvbFJFKSkge1xuICAgICAgICAgIHNvdXJjZS5za2lwVG9FbmQoKTtcbiAgICAgICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciB0ID0gXCJ2YXJpYWJsZVwiO1xuICAgICAgaWYgKGNoID09ICc6Jykge1xuICAgICAgICB0ID0gXCJ2YXJpYWJsZS0yXCI7XG4gICAgICB9XG4gICAgICBzb3VyY2UuZWF0V2hpbGUoc3ltYm9sUkUpO1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIFwiZXJyb3JcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5jb21tZW50KHR5cGUsIG5lc3QpIHtcbiAgICBpZiAobmVzdCA9PSAwKSB7XG4gICAgICByZXR1cm4gbm9ybWFsO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oc291cmNlLCBzZXRTdGF0ZSkge1xuICAgICAgdmFyIGN1cnJOZXN0ID0gbmVzdDtcbiAgICAgIHdoaWxlICghc291cmNlLmVvbCgpKSB7XG4gICAgICAgIHZhciBjaCA9IHNvdXJjZS5uZXh0KCk7XG4gICAgICAgIGlmIChjaCA9PSAneycgJiYgc291cmNlLmVhdCgnLScpKSB7XG4gICAgICAgICAgKytjdXJyTmVzdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaCA9PSAnLScgJiYgc291cmNlLmVhdCgnfScpKSB7XG4gICAgICAgICAgLS1jdXJyTmVzdDtcbiAgICAgICAgICBpZiAoY3Vyck5lc3QgPT0gMCkge1xuICAgICAgICAgICAgc2V0U3RhdGUobm9ybWFsKTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2V0U3RhdGUobmNvbW1lbnQodHlwZSwgY3Vyck5lc3QpKTtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzdHJpbmdMaXRlcmFsKHNvdXJjZSwgc2V0U3RhdGUpIHtcbiAgICB3aGlsZSAoIXNvdXJjZS5lb2woKSkge1xuICAgICAgdmFyIGNoID0gc291cmNlLm5leHQoKTtcbiAgICAgIGlmIChjaCA9PSAnXCInKSB7XG4gICAgICAgIHNldFN0YXRlKG5vcm1hbCk7XG4gICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgfVxuICAgICAgaWYgKGNoID09ICdcXFxcJykge1xuICAgICAgICBpZiAoc291cmNlLmVvbCgpIHx8IHNvdXJjZS5lYXQod2hpdGVDaGFyUkUpKSB7XG4gICAgICAgICAgc2V0U3RhdGUoc3RyaW5nR2FwKTtcbiAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlLmVhdCgnJicpKSB7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc291cmNlLm5leHQoKTsgLy8gc2hvdWxkIGhhbmRsZSBvdGhlciBlc2NhcGVzIGhlcmVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzZXRTdGF0ZShub3JtYWwpO1xuICAgIHJldHVybiBcInN0cmluZyBlcnJvclwiO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RyaW5nR2FwKHNvdXJjZSwgc2V0U3RhdGUpIHtcbiAgICBpZiAoc291cmNlLmVhdCgnXFxcXCcpKSB7XG4gICAgICByZXR1cm4gc3dpdGNoU3RhdGUoc291cmNlLCBzZXRTdGF0ZSwgc3RyaW5nTGl0ZXJhbCk7XG4gICAgfVxuICAgIHNvdXJjZS5uZXh0KCk7XG4gICAgc2V0U3RhdGUobm9ybWFsKTtcbiAgICByZXR1cm4gXCJlcnJvclwiO1xuICB9XG5cblxuICB2YXIgd2VsbEtub3duV29yZHMgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHdrdyA9IHt9O1xuICAgIGZ1bmN0aW9uIHNldFR5cGUodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgd2t3W2FyZ3VtZW50c1tpXV0gPSB0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBzZXRUeXBlKFwia2V5d29yZFwiKShcbiAgICAgIFwiY2FzZVwiLCBcImNsYXNzXCIsIFwiZGF0YVwiLCBcImRlZmF1bHRcIiwgXCJkZXJpdmluZ1wiLCBcImRvXCIsIFwiZWxzZVwiLCBcImZvcmVpZ25cIixcbiAgICAgIFwiaWZcIiwgXCJpbXBvcnRcIiwgXCJpblwiLCBcImluZml4XCIsIFwiaW5maXhsXCIsIFwiaW5maXhyXCIsIFwiaW5zdGFuY2VcIiwgXCJsZXRcIixcbiAgICAgIFwibW9kdWxlXCIsIFwibmV3dHlwZVwiLCBcIm9mXCIsIFwidGhlblwiLCBcInR5cGVcIiwgXCJ3aGVyZVwiLCBcIl9cIik7XG5cbiAgICBzZXRUeXBlKFwia2V5d29yZFwiKShcbiAgICAgIFwiXFwuXFwuXCIsIFwiOlwiLCBcIjo6XCIsIFwiPVwiLCBcIlxcXFxcIiwgXCI8LVwiLCBcIi0+XCIsIFwiQFwiLCBcIn5cIiwgXCI9PlwiKTtcblxuICAgIHNldFR5cGUoXCJidWlsdGluXCIpKFxuICAgICAgXCIhIVwiLCBcIiQhXCIsIFwiJFwiLCBcIiYmXCIsIFwiK1wiLCBcIisrXCIsIFwiLVwiLCBcIi5cIiwgXCIvXCIsIFwiLz1cIiwgXCI8XCIsIFwiPCpcIiwgXCI8PVwiLFxuICAgICAgXCI8JD5cIiwgXCI8Kj5cIiwgXCI9PDxcIiwgXCI9PVwiLCBcIj5cIiwgXCI+PVwiLCBcIj4+XCIsIFwiPj49XCIsIFwiXlwiLCBcIl5eXCIsIFwifHxcIiwgXCIqXCIsXG4gICAgICBcIio+XCIsIFwiKipcIik7XG5cbiAgICBzZXRUeXBlKFwiYnVpbHRpblwiKShcbiAgICAgIFwiQXBwbGljYXRpdmVcIiwgXCJCb29sXCIsIFwiQm91bmRlZFwiLCBcIkNoYXJcIiwgXCJEb3VibGVcIiwgXCJFUVwiLCBcIkVpdGhlclwiLCBcIkVudW1cIixcbiAgICAgIFwiRXFcIiwgXCJGYWxzZVwiLCBcIkZpbGVQYXRoXCIsIFwiRmxvYXRcIiwgXCJGbG9hdGluZ1wiLCBcIkZyYWN0aW9uYWxcIiwgXCJGdW5jdG9yXCIsXG4gICAgICBcIkdUXCIsIFwiSU9cIiwgXCJJT0Vycm9yXCIsIFwiSW50XCIsIFwiSW50ZWdlclwiLCBcIkludGVncmFsXCIsIFwiSnVzdFwiLCBcIkxUXCIsIFwiTGVmdFwiLFxuICAgICAgXCJNYXliZVwiLCBcIk1vbmFkXCIsIFwiTm90aGluZ1wiLCBcIk51bVwiLCBcIk9yZFwiLCBcIk9yZGVyaW5nXCIsIFwiUmF0aW9uYWxcIiwgXCJSZWFkXCIsXG4gICAgICBcIlJlYWRTXCIsIFwiUmVhbFwiLCBcIlJlYWxGbG9hdFwiLCBcIlJlYWxGcmFjXCIsIFwiUmlnaHRcIiwgXCJTaG93XCIsIFwiU2hvd1NcIixcbiAgICAgIFwiU3RyaW5nXCIsIFwiVHJ1ZVwiKTtcblxuICAgIHNldFR5cGUoXCJidWlsdGluXCIpKFxuICAgICAgXCJhYnNcIiwgXCJhY29zXCIsIFwiYWNvc2hcIiwgXCJhbGxcIiwgXCJhbmRcIiwgXCJhbnlcIiwgXCJhcHBlbmRGaWxlXCIsIFwiYXNUeXBlT2ZcIixcbiAgICAgIFwiYXNpblwiLCBcImFzaW5oXCIsIFwiYXRhblwiLCBcImF0YW4yXCIsIFwiYXRhbmhcIiwgXCJicmVha1wiLCBcImNhdGNoXCIsIFwiY2VpbGluZ1wiLFxuICAgICAgXCJjb21wYXJlXCIsIFwiY29uY2F0XCIsIFwiY29uY2F0TWFwXCIsIFwiY29uc3RcIiwgXCJjb3NcIiwgXCJjb3NoXCIsIFwiY3VycnlcIixcbiAgICAgIFwiY3ljbGVcIiwgXCJkZWNvZGVGbG9hdFwiLCBcImRpdlwiLCBcImRpdk1vZFwiLCBcImRyb3BcIiwgXCJkcm9wV2hpbGVcIiwgXCJlaXRoZXJcIixcbiAgICAgIFwiZWxlbVwiLCBcImVuY29kZUZsb2F0XCIsIFwiZW51bUZyb21cIiwgXCJlbnVtRnJvbVRoZW5cIiwgXCJlbnVtRnJvbVRoZW5Ub1wiLFxuICAgICAgXCJlbnVtRnJvbVRvXCIsIFwiZXJyb3JcIiwgXCJldmVuXCIsIFwiZXhwXCIsIFwiZXhwb25lbnRcIiwgXCJmYWlsXCIsIFwiZmlsdGVyXCIsXG4gICAgICBcImZsaXBcIiwgXCJmbG9hdERpZ2l0c1wiLCBcImZsb2F0UmFkaXhcIiwgXCJmbG9hdFJhbmdlXCIsIFwiZmxvb3JcIiwgXCJmbWFwXCIsXG4gICAgICBcImZvbGRsXCIsIFwiZm9sZGwxXCIsIFwiZm9sZHJcIiwgXCJmb2xkcjFcIiwgXCJmcm9tRW51bVwiLCBcImZyb21JbnRlZ2VyXCIsXG4gICAgICBcImZyb21JbnRlZ3JhbFwiLCBcImZyb21SYXRpb25hbFwiLCBcImZzdFwiLCBcImdjZFwiLCBcImdldENoYXJcIiwgXCJnZXRDb250ZW50c1wiLFxuICAgICAgXCJnZXRMaW5lXCIsIFwiaGVhZFwiLCBcImlkXCIsIFwiaW5pdFwiLCBcImludGVyYWN0XCIsIFwiaW9FcnJvclwiLCBcImlzRGVub3JtYWxpemVkXCIsXG4gICAgICBcImlzSUVFRVwiLCBcImlzSW5maW5pdGVcIiwgXCJpc05hTlwiLCBcImlzTmVnYXRpdmVaZXJvXCIsIFwiaXRlcmF0ZVwiLCBcImxhc3RcIixcbiAgICAgIFwibGNtXCIsIFwibGVuZ3RoXCIsIFwibGV4XCIsIFwibGluZXNcIiwgXCJsb2dcIiwgXCJsb2dCYXNlXCIsIFwibG9va3VwXCIsIFwibWFwXCIsXG4gICAgICBcIm1hcE1cIiwgXCJtYXBNX1wiLCBcIm1heFwiLCBcIm1heEJvdW5kXCIsIFwibWF4aW11bVwiLCBcIm1heWJlXCIsIFwibWluXCIsIFwibWluQm91bmRcIixcbiAgICAgIFwibWluaW11bVwiLCBcIm1vZFwiLCBcIm5lZ2F0ZVwiLCBcIm5vdFwiLCBcIm5vdEVsZW1cIiwgXCJudWxsXCIsIFwib2RkXCIsIFwib3JcIixcbiAgICAgIFwib3RoZXJ3aXNlXCIsIFwicGlcIiwgXCJwcmVkXCIsIFwicHJpbnRcIiwgXCJwcm9kdWN0XCIsIFwicHJvcGVyRnJhY3Rpb25cIiwgXCJwdXJlXCIsXG4gICAgICBcInB1dENoYXJcIiwgXCJwdXRTdHJcIiwgXCJwdXRTdHJMblwiLCBcInF1b3RcIiwgXCJxdW90UmVtXCIsIFwicmVhZFwiLCBcInJlYWRGaWxlXCIsXG4gICAgICBcInJlYWRJT1wiLCBcInJlYWRMaXN0XCIsIFwicmVhZExuXCIsIFwicmVhZFBhcmVuXCIsIFwicmVhZHNcIiwgXCJyZWFkc1ByZWNcIixcbiAgICAgIFwicmVhbFRvRnJhY1wiLCBcInJlY2lwXCIsIFwicmVtXCIsIFwicmVwZWF0XCIsIFwicmVwbGljYXRlXCIsIFwicmV0dXJuXCIsIFwicmV2ZXJzZVwiLFxuICAgICAgXCJyb3VuZFwiLCBcInNjYWxlRmxvYXRcIiwgXCJzY2FubFwiLCBcInNjYW5sMVwiLCBcInNjYW5yXCIsIFwic2NhbnIxXCIsIFwic2VxXCIsXG4gICAgICBcInNlcXVlbmNlXCIsIFwic2VxdWVuY2VfXCIsIFwic2hvd1wiLCBcInNob3dDaGFyXCIsIFwic2hvd0xpc3RcIiwgXCJzaG93UGFyZW5cIixcbiAgICAgIFwic2hvd1N0cmluZ1wiLCBcInNob3dzXCIsIFwic2hvd3NQcmVjXCIsIFwic2lnbmlmaWNhbmRcIiwgXCJzaWdudW1cIiwgXCJzaW5cIixcbiAgICAgIFwic2luaFwiLCBcInNuZFwiLCBcInNwYW5cIiwgXCJzcGxpdEF0XCIsIFwic3FydFwiLCBcInN1YnRyYWN0XCIsIFwic3VjY1wiLCBcInN1bVwiLFxuICAgICAgXCJ0YWlsXCIsIFwidGFrZVwiLCBcInRha2VXaGlsZVwiLCBcInRhblwiLCBcInRhbmhcIiwgXCJ0b0VudW1cIiwgXCJ0b0ludGVnZXJcIixcbiAgICAgIFwidG9SYXRpb25hbFwiLCBcInRydW5jYXRlXCIsIFwidW5jdXJyeVwiLCBcInVuZGVmaW5lZFwiLCBcInVubGluZXNcIiwgXCJ1bnRpbFwiLFxuICAgICAgXCJ1bndvcmRzXCIsIFwidW56aXBcIiwgXCJ1bnppcDNcIiwgXCJ1c2VyRXJyb3JcIiwgXCJ3b3Jkc1wiLCBcIndyaXRlRmlsZVwiLCBcInppcFwiLFxuICAgICAgXCJ6aXAzXCIsIFwiemlwV2l0aFwiLCBcInppcFdpdGgzXCIpO1xuXG4gICAgdmFyIG92ZXJyaWRlID0gbW9kZUNvbmZpZy5vdmVycmlkZUtleXdvcmRzO1xuICAgIGlmIChvdmVycmlkZSkgZm9yICh2YXIgd29yZCBpbiBvdmVycmlkZSkgaWYgKG92ZXJyaWRlLmhhc093blByb3BlcnR5KHdvcmQpKVxuICAgICAgd2t3W3dvcmRdID0gb3ZlcnJpZGVbd29yZF07XG5cbiAgICByZXR1cm4gd2t3O1xuICB9KSgpO1xuXG5cblxuICByZXR1cm4ge1xuICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uICgpICB7IHJldHVybiB7IGY6IG5vcm1hbCB9OyB9LFxuICAgIGNvcHlTdGF0ZTogIGZ1bmN0aW9uIChzKSB7IHJldHVybiB7IGY6IHMuZiB9OyB9LFxuXG4gICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciB0ID0gc3RhdGUuZihzdHJlYW0sIGZ1bmN0aW9uKHMpIHsgc3RhdGUuZiA9IHM7IH0pO1xuICAgICAgdmFyIHcgPSBzdHJlYW0uY3VycmVudCgpO1xuICAgICAgcmV0dXJuIHdlbGxLbm93bldvcmRzLmhhc093blByb3BlcnR5KHcpID8gd2VsbEtub3duV29yZHNbd10gOiB0O1xuICAgIH0sXG5cbiAgICBibG9ja0NvbW1lbnRTdGFydDogXCJ7LVwiLFxuICAgIGJsb2NrQ29tbWVudEVuZDogXCItfVwiLFxuICAgIGxpbmVDb21tZW50OiBcIi0tXCJcbiAgfTtcblxufSk7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQveC1oYXNrZWxsXCIsIFwiaGFza2VsbFwiKTtcblxufSk7XG4iLCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTW9kZShcImhheGVcIiwgZnVuY3Rpb24oY29uZmlnLCBwYXJzZXJDb25maWcpIHtcbiAgdmFyIGluZGVudFVuaXQgPSBjb25maWcuaW5kZW50VW5pdDtcblxuICAvLyBUb2tlbml6ZXJcblxuICBmdW5jdGlvbiBrdyh0eXBlKSB7cmV0dXJuIHt0eXBlOiB0eXBlLCBzdHlsZTogXCJrZXl3b3JkXCJ9O31cbiAgdmFyIEEgPSBrdyhcImtleXdvcmQgYVwiKSwgQiA9IGt3KFwia2V5d29yZCBiXCIpLCBDID0ga3coXCJrZXl3b3JkIGNcIik7XG4gIHZhciBvcGVyYXRvciA9IGt3KFwib3BlcmF0b3JcIiksIGF0b20gPSB7dHlwZTogXCJhdG9tXCIsIHN0eWxlOiBcImF0b21cIn0sIGF0dHJpYnV0ZSA9IHt0eXBlOlwiYXR0cmlidXRlXCIsIHN0eWxlOiBcImF0dHJpYnV0ZVwifTtcbiAgdmFyIHR5cGUgPSBrdyhcInR5cGVkZWZcIik7XG4gIHZhciBrZXl3b3JkcyA9IHtcbiAgICBcImlmXCI6IEEsIFwid2hpbGVcIjogQSwgXCJlbHNlXCI6IEIsIFwiZG9cIjogQiwgXCJ0cnlcIjogQixcbiAgICBcInJldHVyblwiOiBDLCBcImJyZWFrXCI6IEMsIFwiY29udGludWVcIjogQywgXCJuZXdcIjogQywgXCJ0aHJvd1wiOiBDLFxuICAgIFwidmFyXCI6IGt3KFwidmFyXCIpLCBcImlubGluZVwiOmF0dHJpYnV0ZSwgXCJzdGF0aWNcIjogYXR0cmlidXRlLCBcInVzaW5nXCI6a3coXCJpbXBvcnRcIiksXG4gICAgXCJwdWJsaWNcIjogYXR0cmlidXRlLCBcInByaXZhdGVcIjogYXR0cmlidXRlLCBcImNhc3RcIjoga3coXCJjYXN0XCIpLCBcImltcG9ydFwiOiBrdyhcImltcG9ydFwiKSwgXCJtYWNyb1wiOiBrdyhcIm1hY3JvXCIpLFxuICAgIFwiZnVuY3Rpb25cIjoga3coXCJmdW5jdGlvblwiKSwgXCJjYXRjaFwiOiBrdyhcImNhdGNoXCIpLCBcInVudHlwZWRcIjoga3coXCJ1bnR5cGVkXCIpLCBcImNhbGxiYWNrXCI6IGt3KFwiY2JcIiksXG4gICAgXCJmb3JcIjoga3coXCJmb3JcIiksIFwic3dpdGNoXCI6IGt3KFwic3dpdGNoXCIpLCBcImNhc2VcIjoga3coXCJjYXNlXCIpLCBcImRlZmF1bHRcIjoga3coXCJkZWZhdWx0XCIpLFxuICAgIFwiaW5cIjogb3BlcmF0b3IsIFwibmV2ZXJcIjoga3coXCJwcm9wZXJ0eV9hY2Nlc3NcIiksIFwidHJhY2VcIjprdyhcInRyYWNlXCIpLFxuICAgIFwiY2xhc3NcIjogdHlwZSwgXCJhYnN0cmFjdFwiOnR5cGUsIFwiZW51bVwiOnR5cGUsIFwiaW50ZXJmYWNlXCI6dHlwZSwgXCJ0eXBlZGVmXCI6dHlwZSwgXCJleHRlbmRzXCI6dHlwZSwgXCJpbXBsZW1lbnRzXCI6dHlwZSwgXCJkeW5hbWljXCI6dHlwZSxcbiAgICBcInRydWVcIjogYXRvbSwgXCJmYWxzZVwiOiBhdG9tLCBcIm51bGxcIjogYXRvbVxuICB9O1xuXG4gIHZhciBpc09wZXJhdG9yQ2hhciA9IC9bK1xcLSomJT08PiE/fF0vO1xuXG4gIGZ1bmN0aW9uIGNoYWluKHN0cmVhbSwgc3RhdGUsIGYpIHtcbiAgICBzdGF0ZS50b2tlbml6ZSA9IGY7XG4gICAgcmV0dXJuIGYoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiB0b1VuZXNjYXBlZChzdHJlYW0sIGVuZCkge1xuICAgIHZhciBlc2NhcGVkID0gZmFsc2UsIG5leHQ7XG4gICAgd2hpbGUgKChuZXh0ID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgaWYgKG5leHQgPT0gZW5kICYmICFlc2NhcGVkKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZCAmJiBuZXh0ID09IFwiXFxcXFwiO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVzZWQgYXMgc2NyYXRjaCB2YXJpYWJsZXMgdG8gY29tbXVuaWNhdGUgbXVsdGlwbGUgdmFsdWVzIHdpdGhvdXRcbiAgLy8gY29uc2luZyB1cCB0b25zIG9mIG9iamVjdHMuXG4gIHZhciB0eXBlLCBjb250ZW50O1xuICBmdW5jdGlvbiByZXQodHAsIHN0eWxlLCBjb250KSB7XG4gICAgdHlwZSA9IHRwOyBjb250ZW50ID0gY29udDtcbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cblxuICBmdW5jdGlvbiBoYXhlVG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICAgIGlmIChjaCA9PSAnXCInIHx8IGNoID09IFwiJ1wiKSB7XG4gICAgICByZXR1cm4gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgaGF4ZVRva2VuU3RyaW5nKGNoKSk7XG4gICAgfSBlbHNlIGlmICgvW1xcW1xcXXt9XFwoXFwpLDtcXDpcXC5dLy50ZXN0KGNoKSkge1xuICAgICAgcmV0dXJuIHJldChjaCk7XG4gICAgfSBlbHNlIGlmIChjaCA9PSBcIjBcIiAmJiBzdHJlYW0uZWF0KC94L2kpKSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXGRhLWZdL2kpO1xuICAgICAgcmV0dXJuIHJldChcIm51bWJlclwiLCBcIm51bWJlclwiKTtcbiAgICB9IGVsc2UgaWYgKC9cXGQvLnRlc3QoY2gpIHx8IGNoID09IFwiLVwiICYmIHN0cmVhbS5lYXQoL1xcZC8pKSB7XG4gICAgICBzdHJlYW0ubWF0Y2goL15cXGQqKD86XFwuXFxkKig/IVxcLikpPyg/OltlRV1bK1xcLV0/XFxkKyk/Lyk7XG4gICAgICByZXR1cm4gcmV0KFwibnVtYmVyXCIsIFwibnVtYmVyXCIpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUucmVBbGxvd2VkICYmIChjaCA9PSBcIn5cIiAmJiBzdHJlYW0uZWF0KC9cXC8vKSkpIHtcbiAgICAgIHRvVW5lc2NhcGVkKHN0cmVhbSwgXCIvXCIpO1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bZ2ltc3VdLyk7XG4gICAgICByZXR1cm4gcmV0KFwicmVnZXhwXCIsIFwic3RyaW5nLTJcIik7XG4gICAgfSBlbHNlIGlmIChjaCA9PSBcIi9cIikge1xuICAgICAgaWYgKHN0cmVhbS5lYXQoXCIqXCIpKSB7XG4gICAgICAgIHJldHVybiBjaGFpbihzdHJlYW0sIHN0YXRlLCBoYXhlVG9rZW5Db21tZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLmVhdChcIi9cIikpIHtcbiAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICByZXR1cm4gcmV0KFwiY29tbWVudFwiLCBcImNvbW1lbnRcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoaXNPcGVyYXRvckNoYXIpO1xuICAgICAgICByZXR1cm4gcmV0KFwib3BlcmF0b3JcIiwgbnVsbCwgc3RyZWFtLmN1cnJlbnQoKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjaCA9PSBcIiNcIikge1xuICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgIHJldHVybiByZXQoXCJjb25kaXRpb25hbFwiLCBcIm1ldGFcIik7XG4gICAgfSBlbHNlIGlmIChjaCA9PSBcIkBcIikge1xuICAgICAgc3RyZWFtLmVhdCgvOi8pO1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3X10vKTtcbiAgICAgIHJldHVybiByZXQgKFwibWV0YWRhdGFcIiwgXCJtZXRhXCIpO1xuICAgIH0gZWxzZSBpZiAoaXNPcGVyYXRvckNoYXIudGVzdChjaCkpIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZShpc09wZXJhdG9yQ2hhcik7XG4gICAgICByZXR1cm4gcmV0KFwib3BlcmF0b3JcIiwgbnVsbCwgc3RyZWFtLmN1cnJlbnQoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB3b3JkO1xuICAgICAgaWYoL1tBLVpdLy50ZXN0KGNoKSkge1xuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdfPD5dLyk7XG4gICAgICAgIHdvcmQgPSBzdHJlYW0uY3VycmVudCgpO1xuICAgICAgICByZXR1cm4gcmV0KFwidHlwZVwiLCBcInZhcmlhYmxlLTNcIiwgd29yZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdfXS8pO1xuICAgICAgICB2YXIgd29yZCA9IHN0cmVhbS5jdXJyZW50KCksIGtub3duID0ga2V5d29yZHMucHJvcGVydHlJc0VudW1lcmFibGUod29yZCkgJiYga2V5d29yZHNbd29yZF07XG4gICAgICAgIHJldHVybiAoa25vd24gJiYgc3RhdGUua3dBbGxvd2VkKSA/IHJldChrbm93bi50eXBlLCBrbm93bi5zdHlsZSwgd29yZCkgOlxuICAgICAgICAgICAgICAgICAgICAgICByZXQoXCJ2YXJpYWJsZVwiLCBcInZhcmlhYmxlXCIsIHdvcmQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhheGVUb2tlblN0cmluZyhxdW90ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAodG9VbmVzY2FwZWQoc3RyZWFtLCBxdW90ZSkpXG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gaGF4ZVRva2VuQmFzZTtcbiAgICAgIHJldHVybiByZXQoXCJzdHJpbmdcIiwgXCJzdHJpbmdcIik7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhheGVUb2tlbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBtYXliZUVuZCA9IGZhbHNlLCBjaDtcbiAgICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgICBpZiAoY2ggPT0gXCIvXCIgJiYgbWF5YmVFbmQpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSBoYXhlVG9rZW5CYXNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG1heWJlRW5kID0gKGNoID09IFwiKlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldChcImNvbW1lbnRcIiwgXCJjb21tZW50XCIpO1xuICB9XG5cbiAgLy8gUGFyc2VyXG5cbiAgdmFyIGF0b21pY1R5cGVzID0ge1wiYXRvbVwiOiB0cnVlLCBcIm51bWJlclwiOiB0cnVlLCBcInZhcmlhYmxlXCI6IHRydWUsIFwic3RyaW5nXCI6IHRydWUsIFwicmVnZXhwXCI6IHRydWV9O1xuXG4gIGZ1bmN0aW9uIEhheGVMZXhpY2FsKGluZGVudGVkLCBjb2x1bW4sIHR5cGUsIGFsaWduLCBwcmV2LCBpbmZvKSB7XG4gICAgdGhpcy5pbmRlbnRlZCA9IGluZGVudGVkO1xuICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5wcmV2ID0gcHJldjtcbiAgICB0aGlzLmluZm8gPSBpbmZvO1xuICAgIGlmIChhbGlnbiAhPSBudWxsKSB0aGlzLmFsaWduID0gYWxpZ247XG4gIH1cblxuICBmdW5jdGlvbiBpblNjb3BlKHN0YXRlLCB2YXJuYW1lKSB7XG4gICAgZm9yICh2YXIgdiA9IHN0YXRlLmxvY2FsVmFyczsgdjsgdiA9IHYubmV4dClcbiAgICAgIGlmICh2Lm5hbWUgPT0gdmFybmFtZSkgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUhheGUoc3RhdGUsIHN0eWxlLCB0eXBlLCBjb250ZW50LCBzdHJlYW0pIHtcbiAgICB2YXIgY2MgPSBzdGF0ZS5jYztcbiAgICAvLyBDb21tdW5pY2F0ZSBvdXIgY29udGV4dCB0byB0aGUgY29tYmluYXRvcnMuXG4gICAgLy8gKExlc3Mgd2FzdGVmdWwgdGhhbiBjb25zaW5nIHVwIGEgaHVuZHJlZCBjbG9zdXJlcyBvbiBldmVyeSBjYWxsLilcbiAgICBjeC5zdGF0ZSA9IHN0YXRlOyBjeC5zdHJlYW0gPSBzdHJlYW07IGN4Lm1hcmtlZCA9IG51bGwsIGN4LmNjID0gY2M7XG5cbiAgICBpZiAoIXN0YXRlLmxleGljYWwuaGFzT3duUHJvcGVydHkoXCJhbGlnblwiKSlcbiAgICAgIHN0YXRlLmxleGljYWwuYWxpZ24gPSB0cnVlO1xuXG4gICAgd2hpbGUodHJ1ZSkge1xuICAgICAgdmFyIGNvbWJpbmF0b3IgPSBjYy5sZW5ndGggPyBjYy5wb3AoKSA6IHN0YXRlbWVudDtcbiAgICAgIGlmIChjb21iaW5hdG9yKHR5cGUsIGNvbnRlbnQpKSB7XG4gICAgICAgIHdoaWxlKGNjLmxlbmd0aCAmJiBjY1tjYy5sZW5ndGggLSAxXS5sZXgpXG4gICAgICAgICAgY2MucG9wKCkoKTtcbiAgICAgICAgaWYgKGN4Lm1hcmtlZCkgcmV0dXJuIGN4Lm1hcmtlZDtcbiAgICAgICAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiICYmIGluU2NvcGUoc3RhdGUsIGNvbnRlbnQpKSByZXR1cm4gXCJ2YXJpYWJsZS0yXCI7XG4gICAgICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIiAmJiBpbXBvcnRlZChzdGF0ZSwgY29udGVudCkpIHJldHVybiBcInZhcmlhYmxlLTNcIjtcbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGltcG9ydGVkKHN0YXRlLCB0eXBlbmFtZSkge1xuICAgIGlmICgvW2Etel0vLnRlc3QodHlwZW5hbWUuY2hhckF0KDApKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2YXIgbGVuID0gc3RhdGUuaW1wb3J0ZWR0eXBlcy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGk8bGVuOyBpKyspXG4gICAgICBpZihzdGF0ZS5pbXBvcnRlZHR5cGVzW2ldPT10eXBlbmFtZSkgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiByZWdpc3RlcmltcG9ydChpbXBvcnRuYW1lKSB7XG4gICAgdmFyIHN0YXRlID0gY3guc3RhdGU7XG4gICAgZm9yICh2YXIgdCA9IHN0YXRlLmltcG9ydGVkdHlwZXM7IHQ7IHQgPSB0Lm5leHQpXG4gICAgICBpZih0Lm5hbWUgPT0gaW1wb3J0bmFtZSkgcmV0dXJuO1xuICAgIHN0YXRlLmltcG9ydGVkdHlwZXMgPSB7IG5hbWU6IGltcG9ydG5hbWUsIG5leHQ6IHN0YXRlLmltcG9ydGVkdHlwZXMgfTtcbiAgfVxuICAvLyBDb21iaW5hdG9yIHV0aWxzXG5cbiAgdmFyIGN4ID0ge3N0YXRlOiBudWxsLCBjb2x1bW46IG51bGwsIG1hcmtlZDogbnVsbCwgY2M6IG51bGx9O1xuICBmdW5jdGlvbiBwYXNzKCkge1xuICAgIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGN4LmNjLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgfVxuICBmdW5jdGlvbiBjb250KCkge1xuICAgIHBhc3MuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBpbkxpc3QobmFtZSwgbGlzdCkge1xuICAgIGZvciAodmFyIHYgPSBsaXN0OyB2OyB2ID0gdi5uZXh0KVxuICAgICAgaWYgKHYubmFtZSA9PSBuYW1lKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gcmVnaXN0ZXIodmFybmFtZSkge1xuICAgIHZhciBzdGF0ZSA9IGN4LnN0YXRlO1xuICAgIGlmIChzdGF0ZS5jb250ZXh0KSB7XG4gICAgICBjeC5tYXJrZWQgPSBcImRlZlwiO1xuICAgICAgaWYgKGluTGlzdCh2YXJuYW1lLCBzdGF0ZS5sb2NhbFZhcnMpKSByZXR1cm47XG4gICAgICBzdGF0ZS5sb2NhbFZhcnMgPSB7bmFtZTogdmFybmFtZSwgbmV4dDogc3RhdGUubG9jYWxWYXJzfTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmdsb2JhbFZhcnMpIHtcbiAgICAgIGlmIChpbkxpc3QodmFybmFtZSwgc3RhdGUuZ2xvYmFsVmFycykpIHJldHVybjtcbiAgICAgIHN0YXRlLmdsb2JhbFZhcnMgPSB7bmFtZTogdmFybmFtZSwgbmV4dDogc3RhdGUuZ2xvYmFsVmFyc307XG4gICAgfVxuICB9XG5cbiAgLy8gQ29tYmluYXRvcnNcblxuICB2YXIgZGVmYXVsdFZhcnMgPSB7bmFtZTogXCJ0aGlzXCIsIG5leHQ6IG51bGx9O1xuICBmdW5jdGlvbiBwdXNoY29udGV4dCgpIHtcbiAgICBpZiAoIWN4LnN0YXRlLmNvbnRleHQpIGN4LnN0YXRlLmxvY2FsVmFycyA9IGRlZmF1bHRWYXJzO1xuICAgIGN4LnN0YXRlLmNvbnRleHQgPSB7cHJldjogY3guc3RhdGUuY29udGV4dCwgdmFyczogY3guc3RhdGUubG9jYWxWYXJzfTtcbiAgfVxuICBmdW5jdGlvbiBwb3Bjb250ZXh0KCkge1xuICAgIGN4LnN0YXRlLmxvY2FsVmFycyA9IGN4LnN0YXRlLmNvbnRleHQudmFycztcbiAgICBjeC5zdGF0ZS5jb250ZXh0ID0gY3guc3RhdGUuY29udGV4dC5wcmV2O1xuICB9XG4gIHBvcGNvbnRleHQubGV4ID0gdHJ1ZTtcbiAgZnVuY3Rpb24gcHVzaGxleCh0eXBlLCBpbmZvKSB7XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHN0YXRlID0gY3guc3RhdGU7XG4gICAgICBzdGF0ZS5sZXhpY2FsID0gbmV3IEhheGVMZXhpY2FsKHN0YXRlLmluZGVudGVkLCBjeC5zdHJlYW0uY29sdW1uKCksIHR5cGUsIG51bGwsIHN0YXRlLmxleGljYWwsIGluZm8pO1xuICAgIH07XG4gICAgcmVzdWx0LmxleCA9IHRydWU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBmdW5jdGlvbiBwb3BsZXgoKSB7XG4gICAgdmFyIHN0YXRlID0gY3guc3RhdGU7XG4gICAgaWYgKHN0YXRlLmxleGljYWwucHJldikge1xuICAgICAgaWYgKHN0YXRlLmxleGljYWwudHlwZSA9PSBcIilcIilcbiAgICAgICAgc3RhdGUuaW5kZW50ZWQgPSBzdGF0ZS5sZXhpY2FsLmluZGVudGVkO1xuICAgICAgc3RhdGUubGV4aWNhbCA9IHN0YXRlLmxleGljYWwucHJldjtcbiAgICB9XG4gIH1cbiAgcG9wbGV4LmxleCA9IHRydWU7XG5cbiAgZnVuY3Rpb24gZXhwZWN0KHdhbnRlZCkge1xuICAgIGZ1bmN0aW9uIGYodHlwZSkge1xuICAgICAgaWYgKHR5cGUgPT0gd2FudGVkKSByZXR1cm4gY29udCgpO1xuICAgICAgZWxzZSBpZiAod2FudGVkID09IFwiO1wiKSByZXR1cm4gcGFzcygpO1xuICAgICAgZWxzZSByZXR1cm4gY29udChmKTtcbiAgICB9XG4gICAgcmV0dXJuIGY7XG4gIH1cblxuICBmdW5jdGlvbiBzdGF0ZW1lbnQodHlwZSkge1xuICAgIGlmICh0eXBlID09IFwiQFwiKSByZXR1cm4gY29udChtZXRhZGVmKTtcbiAgICBpZiAodHlwZSA9PSBcInZhclwiKSByZXR1cm4gY29udChwdXNobGV4KFwidmFyZGVmXCIpLCB2YXJkZWYxLCBleHBlY3QoXCI7XCIpLCBwb3BsZXgpO1xuICAgIGlmICh0eXBlID09IFwia2V5d29yZCBhXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJmb3JtXCIpLCBleHByZXNzaW9uLCBzdGF0ZW1lbnQsIHBvcGxleCk7XG4gICAgaWYgKHR5cGUgPT0gXCJrZXl3b3JkIGJcIikgcmV0dXJuIGNvbnQocHVzaGxleChcImZvcm1cIiksIHN0YXRlbWVudCwgcG9wbGV4KTtcbiAgICBpZiAodHlwZSA9PSBcIntcIikgcmV0dXJuIGNvbnQocHVzaGxleChcIn1cIiksIHB1c2hjb250ZXh0LCBibG9jaywgcG9wbGV4LCBwb3Bjb250ZXh0KTtcbiAgICBpZiAodHlwZSA9PSBcIjtcIikgcmV0dXJuIGNvbnQoKTtcbiAgICBpZiAodHlwZSA9PSBcImF0dHJpYnV0ZVwiKSByZXR1cm4gY29udChtYXliZWF0dHJpYnV0ZSk7XG4gICAgaWYgKHR5cGUgPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gY29udChmdW5jdGlvbmRlZik7XG4gICAgaWYgKHR5cGUgPT0gXCJmb3JcIikgcmV0dXJuIGNvbnQocHVzaGxleChcImZvcm1cIiksIGV4cGVjdChcIihcIiksIHB1c2hsZXgoXCIpXCIpLCBmb3JzcGVjMSwgZXhwZWN0KFwiKVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9wbGV4LCBzdGF0ZW1lbnQsIHBvcGxleCk7XG4gICAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKSByZXR1cm4gY29udChwdXNobGV4KFwic3RhdFwiKSwgbWF5YmVsYWJlbCk7XG4gICAgaWYgKHR5cGUgPT0gXCJzd2l0Y2hcIikgcmV0dXJuIGNvbnQocHVzaGxleChcImZvcm1cIiksIGV4cHJlc3Npb24sIHB1c2hsZXgoXCJ9XCIsIFwic3dpdGNoXCIpLCBleHBlY3QoXCJ7XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9jaywgcG9wbGV4LCBwb3BsZXgpO1xuICAgIGlmICh0eXBlID09IFwiY2FzZVwiKSByZXR1cm4gY29udChleHByZXNzaW9uLCBleHBlY3QoXCI6XCIpKTtcbiAgICBpZiAodHlwZSA9PSBcImRlZmF1bHRcIikgcmV0dXJuIGNvbnQoZXhwZWN0KFwiOlwiKSk7XG4gICAgaWYgKHR5cGUgPT0gXCJjYXRjaFwiKSByZXR1cm4gY29udChwdXNobGV4KFwiZm9ybVwiKSwgcHVzaGNvbnRleHQsIGV4cGVjdChcIihcIiksIGZ1bmFyZywgZXhwZWN0KFwiKVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQsIHBvcGxleCwgcG9wY29udGV4dCk7XG4gICAgaWYgKHR5cGUgPT0gXCJpbXBvcnRcIikgcmV0dXJuIGNvbnQoaW1wb3J0ZGVmLCBleHBlY3QoXCI7XCIpKTtcbiAgICBpZiAodHlwZSA9PSBcInR5cGVkZWZcIikgcmV0dXJuIGNvbnQodHlwZWRlZik7XG4gICAgcmV0dXJuIHBhc3MocHVzaGxleChcInN0YXRcIiksIGV4cHJlc3Npb24sIGV4cGVjdChcIjtcIiksIHBvcGxleCk7XG4gIH1cbiAgZnVuY3Rpb24gZXhwcmVzc2lvbih0eXBlKSB7XG4gICAgaWYgKGF0b21pY1R5cGVzLmhhc093blByb3BlcnR5KHR5cGUpKSByZXR1cm4gY29udChtYXliZW9wZXJhdG9yKTtcbiAgICBpZiAodHlwZSA9PSBcInR5cGVcIiApIHJldHVybiBjb250KG1heWJlb3BlcmF0b3IpO1xuICAgIGlmICh0eXBlID09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGNvbnQoZnVuY3Rpb25kZWYpO1xuICAgIGlmICh0eXBlID09IFwia2V5d29yZCBjXCIpIHJldHVybiBjb250KG1heWJlZXhwcmVzc2lvbik7XG4gICAgaWYgKHR5cGUgPT0gXCIoXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCIpXCIpLCBtYXliZWV4cHJlc3Npb24sIGV4cGVjdChcIilcIiksIHBvcGxleCwgbWF5YmVvcGVyYXRvcik7XG4gICAgaWYgKHR5cGUgPT0gXCJvcGVyYXRvclwiKSByZXR1cm4gY29udChleHByZXNzaW9uKTtcbiAgICBpZiAodHlwZSA9PSBcIltcIikgcmV0dXJuIGNvbnQocHVzaGxleChcIl1cIiksIGNvbW1hc2VwKG1heWJlZXhwcmVzc2lvbiwgXCJdXCIpLCBwb3BsZXgsIG1heWJlb3BlcmF0b3IpO1xuICAgIGlmICh0eXBlID09IFwie1wiKSByZXR1cm4gY29udChwdXNobGV4KFwifVwiKSwgY29tbWFzZXAob2JqcHJvcCwgXCJ9XCIpLCBwb3BsZXgsIG1heWJlb3BlcmF0b3IpO1xuICAgIHJldHVybiBjb250KCk7XG4gIH1cbiAgZnVuY3Rpb24gbWF5YmVleHByZXNzaW9uKHR5cGUpIHtcbiAgICBpZiAodHlwZS5tYXRjaCgvWztcXH1cXClcXF0sXS8pKSByZXR1cm4gcGFzcygpO1xuICAgIHJldHVybiBwYXNzKGV4cHJlc3Npb24pO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF5YmVvcGVyYXRvcih0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlID09IFwib3BlcmF0b3JcIiAmJiAvXFwrXFwrfC0tLy50ZXN0KHZhbHVlKSkgcmV0dXJuIGNvbnQobWF5YmVvcGVyYXRvcik7XG4gICAgaWYgKHR5cGUgPT0gXCJvcGVyYXRvclwiIHx8IHR5cGUgPT0gXCI6XCIpIHJldHVybiBjb250KGV4cHJlc3Npb24pO1xuICAgIGlmICh0eXBlID09IFwiO1wiKSByZXR1cm47XG4gICAgaWYgKHR5cGUgPT0gXCIoXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCIpXCIpLCBjb21tYXNlcChleHByZXNzaW9uLCBcIilcIiksIHBvcGxleCwgbWF5YmVvcGVyYXRvcik7XG4gICAgaWYgKHR5cGUgPT0gXCIuXCIpIHJldHVybiBjb250KHByb3BlcnR5LCBtYXliZW9wZXJhdG9yKTtcbiAgICBpZiAodHlwZSA9PSBcIltcIikgcmV0dXJuIGNvbnQocHVzaGxleChcIl1cIiksIGV4cHJlc3Npb24sIGV4cGVjdChcIl1cIiksIHBvcGxleCwgbWF5YmVvcGVyYXRvcik7XG4gIH1cblxuICBmdW5jdGlvbiBtYXliZWF0dHJpYnV0ZSh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJhdHRyaWJ1dGVcIikgcmV0dXJuIGNvbnQobWF5YmVhdHRyaWJ1dGUpO1xuICAgIGlmICh0eXBlID09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGNvbnQoZnVuY3Rpb25kZWYpO1xuICAgIGlmICh0eXBlID09IFwidmFyXCIpIHJldHVybiBjb250KHZhcmRlZjEpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWV0YWRlZih0eXBlKSB7XG4gICAgaWYodHlwZSA9PSBcIjpcIikgcmV0dXJuIGNvbnQobWV0YWRlZik7XG4gICAgaWYodHlwZSA9PSBcInZhcmlhYmxlXCIpIHJldHVybiBjb250KG1ldGFkZWYpO1xuICAgIGlmKHR5cGUgPT0gXCIoXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCIpXCIpLCBjb21tYXNlcChtZXRhYXJncywgXCIpXCIpLCBwb3BsZXgsIHN0YXRlbWVudCk7XG4gIH1cbiAgZnVuY3Rpb24gbWV0YWFyZ3ModHlwZSkge1xuICAgIGlmKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKSByZXR1cm4gY29udCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW1wb3J0ZGVmICh0eXBlLCB2YWx1ZSkge1xuICAgIGlmKHR5cGUgPT0gXCJ2YXJpYWJsZVwiICYmIC9bQS1aXS8udGVzdCh2YWx1ZS5jaGFyQXQoMCkpKSB7IHJlZ2lzdGVyaW1wb3J0KHZhbHVlKTsgcmV0dXJuIGNvbnQoKTsgfVxuICAgIGVsc2UgaWYodHlwZSA9PSBcInZhcmlhYmxlXCIgfHwgdHlwZSA9PSBcInByb3BlcnR5XCIgfHwgdHlwZSA9PSBcIi5cIiB8fCB2YWx1ZSA9PSBcIipcIikgcmV0dXJuIGNvbnQoaW1wb3J0ZGVmKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHR5cGVkZWYgKHR5cGUsIHZhbHVlKVxuICB7XG4gICAgaWYodHlwZSA9PSBcInZhcmlhYmxlXCIgJiYgL1tBLVpdLy50ZXN0KHZhbHVlLmNoYXJBdCgwKSkpIHsgcmVnaXN0ZXJpbXBvcnQodmFsdWUpOyByZXR1cm4gY29udCgpOyB9XG4gICAgZWxzZSBpZiAodHlwZSA9PSBcInR5cGVcIiAmJiAvW0EtWl0vLnRlc3QodmFsdWUuY2hhckF0KDApKSkgeyByZXR1cm4gY29udCgpOyB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXliZWxhYmVsKHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PSBcIjpcIikgcmV0dXJuIGNvbnQocG9wbGV4LCBzdGF0ZW1lbnQpO1xuICAgIHJldHVybiBwYXNzKG1heWJlb3BlcmF0b3IsIGV4cGVjdChcIjtcIiksIHBvcGxleCk7XG4gIH1cbiAgZnVuY3Rpb24gcHJvcGVydHkodHlwZSkge1xuICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIikge2N4Lm1hcmtlZCA9IFwicHJvcGVydHlcIjsgcmV0dXJuIGNvbnQoKTt9XG4gIH1cbiAgZnVuY3Rpb24gb2JqcHJvcCh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKSBjeC5tYXJrZWQgPSBcInByb3BlcnR5XCI7XG4gICAgaWYgKGF0b21pY1R5cGVzLmhhc093blByb3BlcnR5KHR5cGUpKSByZXR1cm4gY29udChleHBlY3QoXCI6XCIpLCBleHByZXNzaW9uKTtcbiAgfVxuICBmdW5jdGlvbiBjb21tYXNlcCh3aGF0LCBlbmQpIHtcbiAgICBmdW5jdGlvbiBwcm9jZWVkKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09IFwiLFwiKSByZXR1cm4gY29udCh3aGF0LCBwcm9jZWVkKTtcbiAgICAgIGlmICh0eXBlID09IGVuZCkgcmV0dXJuIGNvbnQoKTtcbiAgICAgIHJldHVybiBjb250KGV4cGVjdChlbmQpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09IGVuZCkgcmV0dXJuIGNvbnQoKTtcbiAgICAgIGVsc2UgcmV0dXJuIHBhc3Mod2hhdCwgcHJvY2VlZCk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBibG9jayh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJ9XCIpIHJldHVybiBjb250KCk7XG4gICAgcmV0dXJuIHBhc3Moc3RhdGVtZW50LCBibG9jayk7XG4gIH1cbiAgZnVuY3Rpb24gdmFyZGVmMSh0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIil7cmVnaXN0ZXIodmFsdWUpOyByZXR1cm4gY29udCh0eXBldXNlLCB2YXJkZWYyKTt9XG4gICAgcmV0dXJuIGNvbnQoKTtcbiAgfVxuICBmdW5jdGlvbiB2YXJkZWYyKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IFwiPVwiKSByZXR1cm4gY29udChleHByZXNzaW9uLCB2YXJkZWYyKTtcbiAgICBpZiAodHlwZSA9PSBcIixcIikgcmV0dXJuIGNvbnQodmFyZGVmMSk7XG4gIH1cbiAgZnVuY3Rpb24gZm9yc3BlYzEodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIpIHtcbiAgICAgIHJlZ2lzdGVyKHZhbHVlKTtcbiAgICAgIHJldHVybiBjb250KGZvcmluLCBleHByZXNzaW9uKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGFzcygpXG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGZvcmluKF90eXBlLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBcImluXCIpIHJldHVybiBjb250KCk7XG4gIH1cbiAgZnVuY3Rpb24gZnVuY3Rpb25kZWYodHlwZSwgdmFsdWUpIHtcbiAgICAvL2Z1bmN0aW9uIG5hbWVzIHN0YXJ0aW5nIHdpdGggdXBwZXItY2FzZSBsZXR0ZXJzIGFyZSByZWNvZ25pc2VkIGFzIHR5cGVzLCBzbyBjbHVkZ2luZyB0aGVtIHRvZ2V0aGVyIGhlcmUuXG4gICAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiIHx8IHR5cGUgPT0gXCJ0eXBlXCIpIHtyZWdpc3Rlcih2YWx1ZSk7IHJldHVybiBjb250KGZ1bmN0aW9uZGVmKTt9XG4gICAgaWYgKHZhbHVlID09IFwibmV3XCIpIHJldHVybiBjb250KGZ1bmN0aW9uZGVmKTtcbiAgICBpZiAodHlwZSA9PSBcIihcIikgcmV0dXJuIGNvbnQocHVzaGxleChcIilcIiksIHB1c2hjb250ZXh0LCBjb21tYXNlcChmdW5hcmcsIFwiKVwiKSwgcG9wbGV4LCB0eXBldXNlLCBzdGF0ZW1lbnQsIHBvcGNvbnRleHQpO1xuICB9XG4gIGZ1bmN0aW9uIHR5cGV1c2UodHlwZSkge1xuICAgIGlmKHR5cGUgPT0gXCI6XCIpIHJldHVybiBjb250KHR5cGVzdHJpbmcpO1xuICB9XG4gIGZ1bmN0aW9uIHR5cGVzdHJpbmcodHlwZSkge1xuICAgIGlmKHR5cGUgPT0gXCJ0eXBlXCIpIHJldHVybiBjb250KCk7XG4gICAgaWYodHlwZSA9PSBcInZhcmlhYmxlXCIpIHJldHVybiBjb250KCk7XG4gICAgaWYodHlwZSA9PSBcIntcIikgcmV0dXJuIGNvbnQocHVzaGxleChcIn1cIiksIGNvbW1hc2VwKHR5cGVwcm9wLCBcIn1cIiksIHBvcGxleCk7XG4gIH1cbiAgZnVuY3Rpb24gdHlwZXByb3AodHlwZSkge1xuICAgIGlmKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKSByZXR1cm4gY29udCh0eXBldXNlKTtcbiAgfVxuICBmdW5jdGlvbiBmdW5hcmcodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIpIHtyZWdpc3Rlcih2YWx1ZSk7IHJldHVybiBjb250KHR5cGV1c2UpO31cbiAgfVxuXG4gIC8vIEludGVyZmFjZVxuICByZXR1cm4ge1xuICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKGJhc2Vjb2x1bW4pIHtcbiAgICAgIHZhciBkZWZhdWx0dHlwZXMgPSBbXCJJbnRcIiwgXCJGbG9hdFwiLCBcIlN0cmluZ1wiLCBcIlZvaWRcIiwgXCJTdGRcIiwgXCJCb29sXCIsIFwiRHluYW1pY1wiLCBcIkFycmF5XCJdO1xuICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICB0b2tlbml6ZTogaGF4ZVRva2VuQmFzZSxcbiAgICAgICAgcmVBbGxvd2VkOiB0cnVlLFxuICAgICAgICBrd0FsbG93ZWQ6IHRydWUsXG4gICAgICAgIGNjOiBbXSxcbiAgICAgICAgbGV4aWNhbDogbmV3IEhheGVMZXhpY2FsKChiYXNlY29sdW1uIHx8IDApIC0gaW5kZW50VW5pdCwgMCwgXCJibG9ja1wiLCBmYWxzZSksXG4gICAgICAgIGxvY2FsVmFyczogcGFyc2VyQ29uZmlnLmxvY2FsVmFycyxcbiAgICAgICAgaW1wb3J0ZWR0eXBlczogZGVmYXVsdHR5cGVzLFxuICAgICAgICBjb250ZXh0OiBwYXJzZXJDb25maWcubG9jYWxWYXJzICYmIHt2YXJzOiBwYXJzZXJDb25maWcubG9jYWxWYXJzfSxcbiAgICAgICAgaW5kZW50ZWQ6IDBcbiAgICAgIH07XG4gICAgICBpZiAocGFyc2VyQ29uZmlnLmdsb2JhbFZhcnMgJiYgdHlwZW9mIHBhcnNlckNvbmZpZy5nbG9iYWxWYXJzID09IFwib2JqZWN0XCIpXG4gICAgICAgIHN0YXRlLmdsb2JhbFZhcnMgPSBwYXJzZXJDb25maWcuZ2xvYmFsVmFycztcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9LFxuXG4gICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmIChzdHJlYW0uc29sKCkpIHtcbiAgICAgICAgaWYgKCFzdGF0ZS5sZXhpY2FsLmhhc093blByb3BlcnR5KFwiYWxpZ25cIikpXG4gICAgICAgICAgc3RhdGUubGV4aWNhbC5hbGlnbiA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5pbmRlbnRlZCA9IHN0cmVhbS5pbmRlbnRhdGlvbigpO1xuICAgICAgfVxuICAgICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBzdHlsZSA9IHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgaWYgKHR5cGUgPT0gXCJjb21tZW50XCIpIHJldHVybiBzdHlsZTtcbiAgICAgIHN0YXRlLnJlQWxsb3dlZCA9ICEhKHR5cGUgPT0gXCJvcGVyYXRvclwiIHx8IHR5cGUgPT0gXCJrZXl3b3JkIGNcIiB8fCB0eXBlLm1hdGNoKC9eW1xcW3t9XFwoLDs6XSQvKSk7XG4gICAgICBzdGF0ZS5rd0FsbG93ZWQgPSB0eXBlICE9ICcuJztcbiAgICAgIHJldHVybiBwYXJzZUhheGUoc3RhdGUsIHN0eWxlLCB0eXBlLCBjb250ZW50LCBzdHJlYW0pO1xuICAgIH0sXG5cbiAgICBpbmRlbnQ6IGZ1bmN0aW9uKHN0YXRlLCB0ZXh0QWZ0ZXIpIHtcbiAgICAgIGlmIChzdGF0ZS50b2tlbml6ZSAhPSBoYXhlVG9rZW5CYXNlKSByZXR1cm4gMDtcbiAgICAgIHZhciBmaXJzdENoYXIgPSB0ZXh0QWZ0ZXIgJiYgdGV4dEFmdGVyLmNoYXJBdCgwKSwgbGV4aWNhbCA9IHN0YXRlLmxleGljYWw7XG4gICAgICBpZiAobGV4aWNhbC50eXBlID09IFwic3RhdFwiICYmIGZpcnN0Q2hhciA9PSBcIn1cIikgbGV4aWNhbCA9IGxleGljYWwucHJldjtcbiAgICAgIHZhciB0eXBlID0gbGV4aWNhbC50eXBlLCBjbG9zaW5nID0gZmlyc3RDaGFyID09IHR5cGU7XG4gICAgICBpZiAodHlwZSA9PSBcInZhcmRlZlwiKSByZXR1cm4gbGV4aWNhbC5pbmRlbnRlZCArIDQ7XG4gICAgICBlbHNlIGlmICh0eXBlID09IFwiZm9ybVwiICYmIGZpcnN0Q2hhciA9PSBcIntcIikgcmV0dXJuIGxleGljYWwuaW5kZW50ZWQ7XG4gICAgICBlbHNlIGlmICh0eXBlID09IFwic3RhdFwiIHx8IHR5cGUgPT0gXCJmb3JtXCIpIHJldHVybiBsZXhpY2FsLmluZGVudGVkICsgaW5kZW50VW5pdDtcbiAgICAgIGVsc2UgaWYgKGxleGljYWwuaW5mbyA9PSBcInN3aXRjaFwiICYmICFjbG9zaW5nKVxuICAgICAgICByZXR1cm4gbGV4aWNhbC5pbmRlbnRlZCArICgvXig/OmNhc2V8ZGVmYXVsdClcXGIvLnRlc3QodGV4dEFmdGVyKSA/IGluZGVudFVuaXQgOiAyICogaW5kZW50VW5pdCk7XG4gICAgICBlbHNlIGlmIChsZXhpY2FsLmFsaWduKSByZXR1cm4gbGV4aWNhbC5jb2x1bW4gKyAoY2xvc2luZyA/IDAgOiAxKTtcbiAgICAgIGVsc2UgcmV0dXJuIGxleGljYWwuaW5kZW50ZWQgKyAoY2xvc2luZyA/IDAgOiBpbmRlbnRVbml0KTtcbiAgICB9LFxuXG4gICAgZWxlY3RyaWNDaGFyczogXCJ7fVwiLFxuICAgIGJsb2NrQ29tbWVudFN0YXJ0OiBcIi8qXCIsXG4gICAgYmxvY2tDb21tZW50RW5kOiBcIiovXCIsXG4gICAgbGluZUNvbW1lbnQ6IFwiLy9cIlxuICB9O1xufSk7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQveC1oYXhlXCIsIFwiaGF4ZVwiKTtcblxuQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwiaHhtbFwiLCBmdW5jdGlvbiAoKSB7XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkZWZpbmU6IGZhbHNlLFxuICAgICAgICBpblN0cmluZzogZmFsc2VcbiAgICAgIH07XG4gICAgfSxcbiAgICB0b2tlbjogZnVuY3Rpb24gKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBjaCA9IHN0cmVhbS5wZWVrKCk7XG4gICAgICB2YXIgc29sID0gc3RyZWFtLnNvbCgpO1xuXG4gICAgICAvLy8qIGNvbW1lbnRzICovXG4gICAgICBpZiAoY2ggPT0gXCIjXCIpIHtcbiAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgICB9XG4gICAgICBpZiAoc29sICYmIGNoID09IFwiLVwiKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IFwidmFyaWFibGUtMlwiO1xuXG4gICAgICAgIHN0cmVhbS5lYXQoLy0vKTtcblxuICAgICAgICBpZiAoc3RyZWFtLnBlZWsoKSA9PSBcIi1cIikge1xuICAgICAgICAgIHN0cmVhbS5lYXQoLy0vKTtcbiAgICAgICAgICBzdHlsZSA9IFwia2V5d29yZCBhXCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyZWFtLnBlZWsoKSA9PSBcIkRcIikge1xuICAgICAgICAgIHN0cmVhbS5lYXQoL1tEXS8pO1xuICAgICAgICAgIHN0eWxlID0gXCJrZXl3b3JkIGNcIjtcbiAgICAgICAgICBzdGF0ZS5kZWZpbmUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bQS1aXS9pKTtcbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2ggPSBzdHJlYW0ucGVlaygpO1xuXG4gICAgICBpZiAoc3RhdGUuaW5TdHJpbmcgPT0gZmFsc2UgJiYgY2ggPT0gXCInXCIpIHtcbiAgICAgICAgc3RhdGUuaW5TdHJpbmcgPSB0cnVlO1xuICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUuaW5TdHJpbmcgPT0gdHJ1ZSkge1xuICAgICAgICBpZiAoc3RyZWFtLnNraXBUbyhcIidcIikpIHtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHJlYW0ucGVlaygpID09IFwiJ1wiKSB7XG4gICAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgICBzdGF0ZS5pblN0cmluZyA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgICB9XG5cbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGxpbmVDb21tZW50OiBcIiNcIlxuICB9O1xufSk7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQveC1oeG1sXCIsIFwiaHhtbFwiKTtcblxufSk7XG4iLCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpLCByZXF1aXJlKFwiLi4vaHRtbG1peGVkL2h0bWxtaXhlZFwiKSxcbiAgICAgICAgcmVxdWlyZShcIi4uLy4uL2FkZG9uL21vZGUvbXVsdGlwbGV4XCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIsIFwiLi4vaHRtbG1peGVkL2h0bWxtaXhlZFwiLFxuICAgICAgICAgICAgXCIuLi8uLi9hZGRvbi9tb2RlL211bHRpcGxleFwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwiaHRtbGVtYmVkZGVkXCIsIGZ1bmN0aW9uKGNvbmZpZywgcGFyc2VyQ29uZmlnKSB7XG4gICAgdmFyIGNsb3NlQ29tbWVudCA9IHBhcnNlckNvbmZpZy5jbG9zZUNvbW1lbnQgfHwgXCItLSU+XCJcbiAgICByZXR1cm4gQ29kZU1pcnJvci5tdWx0aXBsZXhpbmdNb2RlKENvZGVNaXJyb3IuZ2V0TW9kZShjb25maWcsIFwiaHRtbG1peGVkXCIpLCB7XG4gICAgICBvcGVuOiBwYXJzZXJDb25maWcub3BlbkNvbW1lbnQgfHwgXCI8JS0tXCIsXG4gICAgICBjbG9zZTogY2xvc2VDb21tZW50LFxuICAgICAgZGVsaW1TdHlsZTogXCJjb21tZW50XCIsXG4gICAgICBtb2RlOiB7dG9rZW46IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICBzdHJlYW0uc2tpcFRvKGNsb3NlQ29tbWVudCkgfHwgc3RyZWFtLnNraXBUb0VuZCgpXG4gICAgICAgIHJldHVybiBcImNvbW1lbnRcIlxuICAgICAgfX1cbiAgICB9LCB7XG4gICAgICBvcGVuOiBwYXJzZXJDb25maWcub3BlbiB8fCBwYXJzZXJDb25maWcuc2NyaXB0U3RhcnRSZWdleCB8fCBcIjwlXCIsXG4gICAgICBjbG9zZTogcGFyc2VyQ29uZmlnLmNsb3NlIHx8IHBhcnNlckNvbmZpZy5zY3JpcHRFbmRSZWdleCB8fCBcIiU+XCIsXG4gICAgICBtb2RlOiBDb2RlTWlycm9yLmdldE1vZGUoY29uZmlnLCBwYXJzZXJDb25maWcuc2NyaXB0aW5nTW9kZVNwZWMpXG4gICAgfSk7XG4gIH0sIFwiaHRtbG1peGVkXCIpO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcImFwcGxpY2F0aW9uL3gtZWpzXCIsIHtuYW1lOiBcImh0bWxlbWJlZGRlZFwiLCBzY3JpcHRpbmdNb2RlU3BlYzpcImphdmFzY3JpcHRcIn0pO1xuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJhcHBsaWNhdGlvbi94LWFzcHhcIiwge25hbWU6IFwiaHRtbGVtYmVkZGVkXCIsIHNjcmlwdGluZ01vZGVTcGVjOlwidGV4dC94LWNzaGFycFwifSk7XG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcImFwcGxpY2F0aW9uL3gtanNwXCIsIHtuYW1lOiBcImh0bWxlbWJlZGRlZFwiLCBzY3JpcHRpbmdNb2RlU3BlYzpcInRleHQveC1qYXZhXCJ9KTtcbiAgQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwiYXBwbGljYXRpb24veC1lcmJcIiwge25hbWU6IFwiaHRtbGVtYmVkZGVkXCIsIHNjcmlwdGluZ01vZGVTcGVjOlwicnVieVwifSk7XG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIiksIHJlcXVpcmUoXCIuLi94bWwveG1sXCIpLCByZXF1aXJlKFwiLi4vamF2YXNjcmlwdC9qYXZhc2NyaXB0XCIpLCByZXF1aXJlKFwiLi4vY3NzL2Nzc1wiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiLCBcIi4uL3htbC94bWxcIiwgXCIuLi9qYXZhc2NyaXB0L2phdmFzY3JpcHRcIiwgXCIuLi9jc3MvY3NzXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgZGVmYXVsdFRhZ3MgPSB7XG4gICAgc2NyaXB0OiBbXG4gICAgICBbXCJsYW5nXCIsIC8oamF2YXNjcmlwdHxiYWJlbCkvaSwgXCJqYXZhc2NyaXB0XCJdLFxuICAgICAgW1widHlwZVwiLCAvXig/OnRleHR8YXBwbGljYXRpb24pXFwvKD86eC0pPyg/OmphdmF8ZWNtYSlzY3JpcHQkfF5tb2R1bGUkfF4kL2ksIFwiamF2YXNjcmlwdFwiXSxcbiAgICAgIFtcInR5cGVcIiwgLy4vLCBcInRleHQvcGxhaW5cIl0sXG4gICAgICBbbnVsbCwgbnVsbCwgXCJqYXZhc2NyaXB0XCJdXG4gICAgXSxcbiAgICBzdHlsZTogIFtcbiAgICAgIFtcImxhbmdcIiwgL15jc3MkL2ksIFwiY3NzXCJdLFxuICAgICAgW1widHlwZVwiLCAvXih0ZXh0XFwvKT8oeC0pPyhzdHlsZXNoZWV0fGNzcykkL2ksIFwiY3NzXCJdLFxuICAgICAgW1widHlwZVwiLCAvLi8sIFwidGV4dC9wbGFpblwiXSxcbiAgICAgIFtudWxsLCBudWxsLCBcImNzc1wiXVxuICAgIF1cbiAgfTtcblxuICBmdW5jdGlvbiBtYXliZUJhY2t1cChzdHJlYW0sIHBhdCwgc3R5bGUpIHtcbiAgICB2YXIgY3VyID0gc3RyZWFtLmN1cnJlbnQoKSwgY2xvc2UgPSBjdXIuc2VhcmNoKHBhdCk7XG4gICAgaWYgKGNsb3NlID4gLTEpIHtcbiAgICAgIHN0cmVhbS5iYWNrVXAoY3VyLmxlbmd0aCAtIGNsb3NlKTtcbiAgICB9IGVsc2UgaWYgKGN1ci5tYXRjaCgvPFxcLz8kLykpIHtcbiAgICAgIHN0cmVhbS5iYWNrVXAoY3VyLmxlbmd0aCk7XG4gICAgICBpZiAoIXN0cmVhbS5tYXRjaChwYXQsIGZhbHNlKSkgc3RyZWFtLm1hdGNoKGN1cik7XG4gICAgfVxuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuXG4gIHZhciBhdHRyUmVnZXhwQ2FjaGUgPSB7fTtcbiAgZnVuY3Rpb24gZ2V0QXR0clJlZ2V4cChhdHRyKSB7XG4gICAgdmFyIHJlZ2V4cCA9IGF0dHJSZWdleHBDYWNoZVthdHRyXTtcbiAgICBpZiAocmVnZXhwKSByZXR1cm4gcmVnZXhwO1xuICAgIHJldHVybiBhdHRyUmVnZXhwQ2FjaGVbYXR0cl0gPSBuZXcgUmVnRXhwKFwiXFxcXHMrXCIgKyBhdHRyICsgXCJcXFxccyo9XFxcXHMqKCd8XFxcIik/KFteJ1xcXCJdKykoJ3xcXFwiKT9cXFxccypcIik7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRBdHRyVmFsdWUodGV4dCwgYXR0cikge1xuICAgIHZhciBtYXRjaCA9IHRleHQubWF0Y2goZ2V0QXR0clJlZ2V4cChhdHRyKSlcbiAgICByZXR1cm4gbWF0Y2ggPyAvXlxccyooLio/KVxccyokLy5leGVjKG1hdGNoWzJdKVsxXSA6IFwiXCJcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFRhZ1JlZ2V4cCh0YWdOYW1lLCBhbmNob3JlZCkge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKChhbmNob3JlZCA/IFwiXlwiIDogXCJcIikgKyBcIjxcXC9cXHMqXCIgKyB0YWdOYW1lICsgXCJcXHMqPlwiLCBcImlcIik7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRUYWdzKGZyb20sIHRvKSB7XG4gICAgZm9yICh2YXIgdGFnIGluIGZyb20pIHtcbiAgICAgIHZhciBkZXN0ID0gdG9bdGFnXSB8fCAodG9bdGFnXSA9IFtdKTtcbiAgICAgIHZhciBzb3VyY2UgPSBmcm9tW3RhZ107XG4gICAgICBmb3IgKHZhciBpID0gc291cmNlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBkZXN0LnVuc2hpZnQoc291cmNlW2ldKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRNYXRjaGluZ01vZGUodGFnSW5mbywgdGFnVGV4dCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFnSW5mby5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNwZWMgPSB0YWdJbmZvW2ldO1xuICAgICAgaWYgKCFzcGVjWzBdIHx8IHNwZWNbMV0udGVzdChnZXRBdHRyVmFsdWUodGFnVGV4dCwgc3BlY1swXSkpKSByZXR1cm4gc3BlY1syXTtcbiAgICB9XG4gIH1cblxuICBDb2RlTWlycm9yLmRlZmluZU1vZGUoXCJodG1sbWl4ZWRcIiwgZnVuY3Rpb24gKGNvbmZpZywgcGFyc2VyQ29uZmlnKSB7XG4gICAgdmFyIGh0bWxNb2RlID0gQ29kZU1pcnJvci5nZXRNb2RlKGNvbmZpZywge1xuICAgICAgbmFtZTogXCJ4bWxcIixcbiAgICAgIGh0bWxNb2RlOiB0cnVlLFxuICAgICAgbXVsdGlsaW5lVGFnSW5kZW50RmFjdG9yOiBwYXJzZXJDb25maWcubXVsdGlsaW5lVGFnSW5kZW50RmFjdG9yLFxuICAgICAgbXVsdGlsaW5lVGFnSW5kZW50UGFzdFRhZzogcGFyc2VyQ29uZmlnLm11bHRpbGluZVRhZ0luZGVudFBhc3RUYWcsXG4gICAgICBhbGxvd01pc3NpbmdUYWdOYW1lOiBwYXJzZXJDb25maWcuYWxsb3dNaXNzaW5nVGFnTmFtZSxcbiAgICB9KTtcblxuICAgIHZhciB0YWdzID0ge307XG4gICAgdmFyIGNvbmZpZ1RhZ3MgPSBwYXJzZXJDb25maWcgJiYgcGFyc2VyQ29uZmlnLnRhZ3MsIGNvbmZpZ1NjcmlwdCA9IHBhcnNlckNvbmZpZyAmJiBwYXJzZXJDb25maWcuc2NyaXB0VHlwZXM7XG4gICAgYWRkVGFncyhkZWZhdWx0VGFncywgdGFncyk7XG4gICAgaWYgKGNvbmZpZ1RhZ3MpIGFkZFRhZ3MoY29uZmlnVGFncywgdGFncyk7XG4gICAgaWYgKGNvbmZpZ1NjcmlwdCkgZm9yICh2YXIgaSA9IGNvbmZpZ1NjcmlwdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgIHRhZ3Muc2NyaXB0LnVuc2hpZnQoW1widHlwZVwiLCBjb25maWdTY3JpcHRbaV0ubWF0Y2hlcywgY29uZmlnU2NyaXB0W2ldLm1vZGVdKVxuXG4gICAgZnVuY3Rpb24gaHRtbChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgc3R5bGUgPSBodG1sTW9kZS50b2tlbihzdHJlYW0sIHN0YXRlLmh0bWxTdGF0ZSksIHRhZyA9IC9cXGJ0YWdcXGIvLnRlc3Qoc3R5bGUpLCB0YWdOYW1lXG4gICAgICBpZiAodGFnICYmICEvWzw+XFxzXFwvXS8udGVzdChzdHJlYW0uY3VycmVudCgpKSAmJlxuICAgICAgICAgICh0YWdOYW1lID0gc3RhdGUuaHRtbFN0YXRlLnRhZ05hbWUgJiYgc3RhdGUuaHRtbFN0YXRlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSkgJiZcbiAgICAgICAgICB0YWdzLmhhc093blByb3BlcnR5KHRhZ05hbWUpKSB7XG4gICAgICAgIHN0YXRlLmluVGFnID0gdGFnTmFtZSArIFwiIFwiXG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmluVGFnICYmIHRhZyAmJiAvPiQvLnRlc3Qoc3RyZWFtLmN1cnJlbnQoKSkpIHtcbiAgICAgICAgdmFyIGluVGFnID0gL14oW1xcU10rKSAoLiopLy5leGVjKHN0YXRlLmluVGFnKVxuICAgICAgICBzdGF0ZS5pblRhZyA9IG51bGxcbiAgICAgICAgdmFyIG1vZGVTcGVjID0gc3RyZWFtLmN1cnJlbnQoKSA9PSBcIj5cIiAmJiBmaW5kTWF0Y2hpbmdNb2RlKHRhZ3NbaW5UYWdbMV1dLCBpblRhZ1syXSlcbiAgICAgICAgdmFyIG1vZGUgPSBDb2RlTWlycm9yLmdldE1vZGUoY29uZmlnLCBtb2RlU3BlYylcbiAgICAgICAgdmFyIGVuZFRhZ0EgPSBnZXRUYWdSZWdleHAoaW5UYWdbMV0sIHRydWUpLCBlbmRUYWcgPSBnZXRUYWdSZWdleHAoaW5UYWdbMV0sIGZhbHNlKTtcbiAgICAgICAgc3RhdGUudG9rZW4gPSBmdW5jdGlvbiAoc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgICAgIGlmIChzdHJlYW0ubWF0Y2goZW5kVGFnQSwgZmFsc2UpKSB7XG4gICAgICAgICAgICBzdGF0ZS50b2tlbiA9IGh0bWw7XG4gICAgICAgICAgICBzdGF0ZS5sb2NhbFN0YXRlID0gc3RhdGUubG9jYWxNb2RlID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWF5YmVCYWNrdXAoc3RyZWFtLCBlbmRUYWcsIHN0YXRlLmxvY2FsTW9kZS50b2tlbihzdHJlYW0sIHN0YXRlLmxvY2FsU3RhdGUpKTtcbiAgICAgICAgfTtcbiAgICAgICAgc3RhdGUubG9jYWxNb2RlID0gbW9kZTtcbiAgICAgICAgc3RhdGUubG9jYWxTdGF0ZSA9IENvZGVNaXJyb3Iuc3RhcnRTdGF0ZShtb2RlLCBodG1sTW9kZS5pbmRlbnQoc3RhdGUuaHRtbFN0YXRlLCBcIlwiLCBcIlwiKSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmluVGFnKSB7XG4gICAgICAgIHN0YXRlLmluVGFnICs9IHN0cmVhbS5jdXJyZW50KClcbiAgICAgICAgaWYgKHN0cmVhbS5lb2woKSkgc3RhdGUuaW5UYWcgKz0gXCIgXCJcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gQ29kZU1pcnJvci5zdGFydFN0YXRlKGh0bWxNb2RlKTtcbiAgICAgICAgcmV0dXJuIHt0b2tlbjogaHRtbCwgaW5UYWc6IG51bGwsIGxvY2FsTW9kZTogbnVsbCwgbG9jYWxTdGF0ZTogbnVsbCwgaHRtbFN0YXRlOiBzdGF0ZX07XG4gICAgICB9LFxuXG4gICAgICBjb3B5U3RhdGU6IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgbG9jYWw7XG4gICAgICAgIGlmIChzdGF0ZS5sb2NhbFN0YXRlKSB7XG4gICAgICAgICAgbG9jYWwgPSBDb2RlTWlycm9yLmNvcHlTdGF0ZShzdGF0ZS5sb2NhbE1vZGUsIHN0YXRlLmxvY2FsU3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7dG9rZW46IHN0YXRlLnRva2VuLCBpblRhZzogc3RhdGUuaW5UYWcsXG4gICAgICAgICAgICAgICAgbG9jYWxNb2RlOiBzdGF0ZS5sb2NhbE1vZGUsIGxvY2FsU3RhdGU6IGxvY2FsLFxuICAgICAgICAgICAgICAgIGh0bWxTdGF0ZTogQ29kZU1pcnJvci5jb3B5U3RhdGUoaHRtbE1vZGUsIHN0YXRlLmh0bWxTdGF0ZSl9O1xuICAgICAgfSxcblxuICAgICAgdG9rZW46IGZ1bmN0aW9uIChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS50b2tlbihzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH0sXG5cbiAgICAgIGluZGVudDogZnVuY3Rpb24gKHN0YXRlLCB0ZXh0QWZ0ZXIsIGxpbmUpIHtcbiAgICAgICAgaWYgKCFzdGF0ZS5sb2NhbE1vZGUgfHwgL15cXHMqPFxcLy8udGVzdCh0ZXh0QWZ0ZXIpKVxuICAgICAgICAgIHJldHVybiBodG1sTW9kZS5pbmRlbnQoc3RhdGUuaHRtbFN0YXRlLCB0ZXh0QWZ0ZXIsIGxpbmUpO1xuICAgICAgICBlbHNlIGlmIChzdGF0ZS5sb2NhbE1vZGUuaW5kZW50KVxuICAgICAgICAgIHJldHVybiBzdGF0ZS5sb2NhbE1vZGUuaW5kZW50KHN0YXRlLmxvY2FsU3RhdGUsIHRleHRBZnRlciwgbGluZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXR1cm4gQ29kZU1pcnJvci5QYXNzO1xuICAgICAgfSxcblxuICAgICAgaW5uZXJNb2RlOiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHtzdGF0ZTogc3RhdGUubG9jYWxTdGF0ZSB8fCBzdGF0ZS5odG1sU3RhdGUsIG1vZGU6IHN0YXRlLmxvY2FsTW9kZSB8fCBodG1sTW9kZX07XG4gICAgICB9XG4gICAgfTtcbiAgfSwgXCJ4bWxcIiwgXCJqYXZhc2NyaXB0XCIsIFwiY3NzXCIpO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQvaHRtbFwiLCBcImh0bWxtaXhlZFwiKTtcbn0pO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcblwidXNlIHN0cmljdFwiO1xuXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoXCJodHRwXCIsIGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBmYWlsRmlyc3RMaW5lKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgc3RhdGUuY3VyID0gaGVhZGVyO1xuICAgIHJldHVybiBcImVycm9yXCI7XG4gIH1cblxuICBmdW5jdGlvbiBzdGFydChzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHN0cmVhbS5tYXRjaCgvXkhUVFBcXC9cXGRcXC5cXGQvKSkge1xuICAgICAgc3RhdGUuY3VyID0gcmVzcG9uc2VTdGF0dXNDb2RlO1xuICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKC9eW0EtWl0rLykgJiYgL1sgXFx0XS8udGVzdChzdHJlYW0ucGVlaygpKSkge1xuICAgICAgc3RhdGUuY3VyID0gcmVxdWVzdFBhdGg7XG4gICAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWlsRmlyc3RMaW5lKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc3BvbnNlU3RhdHVzQ29kZShzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGNvZGUgPSBzdHJlYW0ubWF0Y2goL15cXGQrLyk7XG4gICAgaWYgKCFjb2RlKSByZXR1cm4gZmFpbEZpcnN0TGluZShzdHJlYW0sIHN0YXRlKTtcblxuICAgIHN0YXRlLmN1ciA9IHJlc3BvbnNlU3RhdHVzVGV4dDtcbiAgICB2YXIgc3RhdHVzID0gTnVtYmVyKGNvZGVbMF0pO1xuICAgIGlmIChzdGF0dXMgPj0gMTAwICYmIHN0YXR1cyA8IDIwMCkge1xuICAgICAgcmV0dXJuIFwicG9zaXRpdmUgaW5mb3JtYXRpb25hbFwiO1xuICAgIH0gZWxzZSBpZiAoc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDApIHtcbiAgICAgIHJldHVybiBcInBvc2l0aXZlIHN1Y2Nlc3NcIjtcbiAgICB9IGVsc2UgaWYgKHN0YXR1cyA+PSAzMDAgJiYgc3RhdHVzIDwgNDAwKSB7XG4gICAgICByZXR1cm4gXCJwb3NpdGl2ZSByZWRpcmVjdFwiO1xuICAgIH0gZWxzZSBpZiAoc3RhdHVzID49IDQwMCAmJiBzdGF0dXMgPCA1MDApIHtcbiAgICAgIHJldHVybiBcIm5lZ2F0aXZlIGNsaWVudC1lcnJvclwiO1xuICAgIH0gZWxzZSBpZiAoc3RhdHVzID49IDUwMCAmJiBzdGF0dXMgPCA2MDApIHtcbiAgICAgIHJldHVybiBcIm5lZ2F0aXZlIHNlcnZlci1lcnJvclwiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJlcnJvclwiO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc3BvbnNlU3RhdHVzVGV4dChzdHJlYW0sIHN0YXRlKSB7XG4gICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgIHN0YXRlLmN1ciA9IGhlYWRlcjtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcXVlc3RQYXRoKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBzdHJlYW0uZWF0V2hpbGUoL1xcUy8pO1xuICAgIHN0YXRlLmN1ciA9IHJlcXVlc3RQcm90b2NvbDtcbiAgICByZXR1cm4gXCJzdHJpbmctMlwiO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVxdWVzdFByb3RvY29sKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RyZWFtLm1hdGNoKC9eSFRUUFxcL1xcZFxcLlxcZCQvKSkge1xuICAgICAgc3RhdGUuY3VyID0gaGVhZGVyO1xuICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFpbEZpcnN0TGluZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoZWFkZXIoc3RyZWFtKSB7XG4gICAgaWYgKHN0cmVhbS5zb2woKSAmJiAhc3RyZWFtLmVhdCgvWyBcXHRdLykpIHtcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goL14uKj86LykpIHtcbiAgICAgICAgcmV0dXJuIFwiYXRvbVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICByZXR1cm4gXCJlcnJvclwiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBib2R5KHN0cmVhbSkge1xuICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBjdXIgPSBzdGF0ZS5jdXI7XG4gICAgICBpZiAoY3VyICE9IGhlYWRlciAmJiBjdXIgIT0gYm9keSAmJiBzdHJlYW0uZWF0U3BhY2UoKSkgcmV0dXJuIG51bGw7XG4gICAgICByZXR1cm4gY3VyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH0sXG5cbiAgICBibGFua0xpbmU6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICBzdGF0ZS5jdXIgPSBib2R5O1xuICAgIH0sXG5cbiAgICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7Y3VyOiBzdGFydH07XG4gICAgfVxuICB9O1xufSk7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcIm1lc3NhZ2UvaHR0cFwiLCBcImh0dHBcIik7XG5cbn0pO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgZnVuY3Rpb24gd29yZFJlZ2V4cCh3b3Jkcykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKCdeKCgnICsgd29yZHMuam9pbignKXwoJykgKyAnKSlcXFxcYicsICdpJyk7XG4gIH07XG5cbiAgdmFyIGJ1aWx0aW5BcnJheSA9IFtcbiAgICAnYV9jb3JyZWxhdGUnLCAnYWJzJywgJ2Fjb3MnLCAnYWRhcHRfaGlzdF9lcXVhbCcsICdhbG9nJyxcbiAgICAnYWxvZzInLCAnYWxvZzEwJywgJ2Ftb2ViYScsICdhbm5vdGF0ZScsICdhcHBfdXNlcl9kaXInLFxuICAgICdhcHBfdXNlcl9kaXJfcXVlcnknLCAnYXJnX3ByZXNlbnQnLCAnYXJyYXlfZXF1YWwnLCAnYXJyYXlfaW5kaWNlcycsXG4gICAgJ2Fycm93JywgJ2FzY2lpX3RlbXBsYXRlJywgJ2FzaW4nLCAnYXNzb2MnLCAnYXRhbicsXG4gICAgJ2F4aXMnLCAnYXhpcycsICdiYW5kcGFzc19maWx0ZXInLCAnYmFuZHJlamVjdF9maWx0ZXInLCAnYmFycGxvdCcsXG4gICAgJ2Jhcl9wbG90JywgJ2Jlc2VsaScsICdiZXNlbGonLCAnYmVzZWxrJywgJ2Jlc2VseScsXG4gICAgJ2JldGEnLCAnYmlnaW50ZWdlcicsICdiaWxpbmVhcicsICdiaW5fZGF0ZScsICdiaW5hcnlfdGVtcGxhdGUnLFxuICAgICdiaW5kZ2VuJywgJ2Jpbm9taWFsJywgJ2JpdF9mZnMnLCAnYml0X3BvcHVsYXRpb24nLCAnYmxhc19heHB5JyxcbiAgICAnYmxrX2NvbicsICdib29sYXJyJywgJ2Jvb2xlYW4nLCAnYm94cGxvdCcsICdib3hfY3Vyc29yJyxcbiAgICAnYnJlYWtwb2ludCcsICdicm95ZGVuJywgJ2J1YmJsZXBsb3QnLCAnYnV0dGVyd29ydGgnLCAnYnl0YXJyJyxcbiAgICAnYnl0ZScsICdieXRlb3JkZXInLCAnYnl0c2NsJywgJ2NfY29ycmVsYXRlJywgJ2NhbGVuZGFyJyxcbiAgICAnY2FsZGF0JywgJ2NhbGxfZXh0ZXJuYWwnLCAnY2FsbF9mdW5jdGlvbicsICdjYWxsX21ldGhvZCcsXG4gICAgJ2NhbGxfcHJvY2VkdXJlJywgJ2Nhbm55JywgJ2NhdGNoJywgJ2NkJywgJ2NkZicsICdjZWlsJyxcbiAgICAnY2hlYnlzaGV2JywgJ2NoZWNrX21hdGgnLCAnY2hpc3FyX2N2ZicsICdjaGlzcXJfcGRmJywgJ2Nob2xkYycsXG4gICAgJ2Nob2xzb2wnLCAnY2luZGdlbicsICdjaXJfM3BudCcsICdjbGlwYm9hcmQnLCAnY2xvc2UnLFxuICAgICdjbHVzdF93dHMnLCAnY2x1c3RlcicsICdjbHVzdGVyX3RyZWUnLCAnY215a19jb252ZXJ0JywgJ2NvZGVfY292ZXJhZ2UnLFxuICAgICdjb2xvcl9jb252ZXJ0JywgJ2NvbG9yX2V4Y2hhbmdlJywgJ2NvbG9yX3F1YW4nLCAnY29sb3JfcmFuZ2VfbWFwJyxcbiAgICAnY29sb3JiYXInLCAnY29sb3JpemVfc2FtcGxlJywgJ2NvbG9ybWFwX2FwcGxpY2FibGUnLFxuICAgICdjb2xvcm1hcF9ncmFkaWVudCcsICdjb2xvcm1hcF9yb3RhdGlvbicsICdjb2xvcnRhYmxlJyxcbiAgICAnY29tZml0JywgJ2NvbW1hbmRfbGluZV9hcmdzJywgJ2NvbW1vbicsICdjb21waWxlX29wdCcsICdjb21wbGV4JyxcbiAgICAnY29tcGxleGFycicsICdjb21wbGV4cm91bmQnLCAnY29tcHV0ZV9tZXNoX25vcm1hbHMnLCAnY29uZCcsICdjb25ncmlkJyxcbiAgICAnY29uaicsICdjb25zdHJhaW5lZF9taW4nLCAnY29udG91cicsICdjb250b3VyJywgJ2NvbnZlcnRfY29vcmQnLFxuICAgICdjb252b2wnLCAnY29udm9sX2ZmdCcsICdjb29yZDJ0bzMnLCAnY29weV9sdW4nLCAnY29ycmVsYXRlJyxcbiAgICAnY29zJywgJ2Nvc2gnLCAnY3B1JywgJ2NyYW1lcicsICdjcmVhdGVib3hwbG90ZGF0YScsXG4gICAgJ2NyZWF0ZV9jdXJzb3InLCAnY3JlYXRlX3N0cnVjdCcsICdjcmVhdGVfdmlldycsICdjcm9zc3AnLCAnY3J2bGVuZ3RoJyxcbiAgICAnY3RfbHVtaW5hbmNlJywgJ2N0aV90ZXN0JywgJ2N1cnNvcicsICdjdXJ2ZWZpdCcsICdjdl9jb29yZCcsXG4gICAgJ2N2dHRvYm0nLCAnY3dfYW5pbWF0ZScsICdjd19hbmltYXRlX2dldHAnLCAnY3dfYW5pbWF0ZV9sb2FkJyxcbiAgICAnY3dfYW5pbWF0ZV9ydW4nLCAnY3dfYXJjYmFsbCcsICdjd19iZ3JvdXAnLCAnY3dfY2xyX2luZGV4JyxcbiAgICAnY3dfY29sb3JzZWwnLCAnY3dfZGVmcm9pJywgJ2N3X2ZpZWxkJywgJ2N3X2ZpbGVzZWwnLCAnY3dfZm9ybScsXG4gICAgJ2N3X2ZzbGlkZXInLCAnY3dfbGlnaHRfZWRpdG9yJywgJ2N3X2xpZ2h0X2VkaXRvcl9nZXQnLFxuICAgICdjd19saWdodF9lZGl0b3Jfc2V0JywgJ2N3X29yaWVudCcsICdjd19wYWxldHRlX2VkaXRvcicsXG4gICAgJ2N3X3BhbGV0dGVfZWRpdG9yX2dldCcsICdjd19wYWxldHRlX2VkaXRvcl9zZXQnLCAnY3dfcGRtZW51JyxcbiAgICAnY3dfcmdic2xpZGVyJywgJ2N3X3RtcGwnLCAnY3dfem9vbScsICdkYl9leGlzdHMnLFxuICAgICdkYmxhcnInLCAnZGNpbmRnZW4nLCAnZGNvbXBsZXgnLCAnZGNvbXBsZXhhcnInLCAnZGVmaW5lX2tleScsXG4gICAgJ2RlZmluZV9tc2dibGsnLCAnZGVmaW5lX21zZ2Jsa19mcm9tX2ZpbGUnLCAnZGVmcm9pJywgJ2RlZnN5c3YnLFxuICAgICdkZWx2YXInLCAnZGVuZHJvX3Bsb3QnLCAnZGVuZHJvZ3JhbScsICdkZXJpdicsICdkZXJpdnNpZycsXG4gICAgJ2RldGVybScsICdkZXZpY2UnLCAnZGZwbWluJywgJ2RpYWdfbWF0cml4JywgJ2RpYWxvZ19kYmNvbm5lY3QnLFxuICAgICdkaWFsb2dfbWVzc2FnZScsICdkaWFsb2dfcGlja2ZpbGUnLCAnZGlhbG9nX3ByaW50ZXJzZXR1cCcsXG4gICAgJ2RpYWxvZ19wcmludGpvYicsICdkaWFsb2dfcmVhZF9pbWFnZScsXG4gICAgJ2RpYWxvZ193cml0ZV9pbWFnZScsICdkaWN0aW9uYXJ5JywgJ2RpZ2l0YWxfZmlsdGVyJywgJ2RpbGF0ZScsICdkaW5kZ2VuJyxcbiAgICAnZGlzc29sdmUnLCAnZGlzdCcsICdkaXN0YW5jZV9tZWFzdXJlJywgJ2RsbV9sb2FkJywgJ2RsbV9yZWdpc3RlcicsXG4gICAgJ2RvY19saWJyYXJ5JywgJ2RvdWJsZScsICdkcmF3X3JvaScsICdlZGdlX2RvZycsICdlZm9udCcsXG4gICAgJ2VpZ2VucWwnLCAnZWlnZW52ZWMnLCAnZWxsaXBzZScsICdlbG1oZXMnLCAnZW1ib3NzJyxcbiAgICAnZW1wdHknLCAnZW5hYmxlX3N5c3J0bicsICdlb2YnLCAnZW9zJywgJ2VyYXNlJyxcbiAgICAnZXJmJywgJ2VyZmMnLCAnZXJmY3gnLCAnZXJvZGUnLCAnZXJyb3JwbG90JyxcbiAgICAnZXJycGxvdCcsICdlc3RpbWF0b3JfZmlsdGVyJywgJ2V4ZWN1dGUnLCAnZXhpdCcsICdleHAnLFxuICAgICdleHBhbmQnLCAnZXhwYW5kX3BhdGgnLCAnZXhwaW50JywgJ2V4dHJhY3QnLCAnZXh0cmFjdF9zbGljZScsXG4gICAgJ2ZfY3ZmJywgJ2ZfcGRmJywgJ2ZhY3RvcmlhbCcsICdmZnQnLCAnZmlsZV9iYXNlbmFtZScsXG4gICAgJ2ZpbGVfY2htb2QnLCAnZmlsZV9jb3B5JywgJ2ZpbGVfZGVsZXRlJywgJ2ZpbGVfZGlybmFtZScsXG4gICAgJ2ZpbGVfZXhwYW5kX3BhdGgnLCAnZmlsZV9ndW56aXAnLCAnZmlsZV9nemlwJywgJ2ZpbGVfaW5mbycsXG4gICAgJ2ZpbGVfbGluZXMnLCAnZmlsZV9saW5rJywgJ2ZpbGVfbWtkaXInLCAnZmlsZV9tb3ZlJyxcbiAgICAnZmlsZV9wb2xsX2lucHV0JywgJ2ZpbGVfcmVhZGxpbmsnLCAnZmlsZV9zYW1lJyxcbiAgICAnZmlsZV9zZWFyY2gnLCAnZmlsZV90YXInLCAnZmlsZV90ZXN0JywgJ2ZpbGVfdW50YXInLCAnZmlsZV91bnppcCcsXG4gICAgJ2ZpbGVfd2hpY2gnLCAnZmlsZV96aXAnLCAnZmlsZXBhdGgnLCAnZmluZGdlbicsICdmaW5pdGUnLFxuICAgICdmaXgnLCAnZmxpY2snLCAnZmxvYXQnLCAnZmxvb3InLCAnZmxvdzMnLFxuICAgICdmbHRhcnInLCAnZmx1c2gnLCAnZm9ybWF0X2F4aXNfdmFsdWVzJywgJ2ZvcndhcmRfZnVuY3Rpb24nLCAnZnJlZV9sdW4nLFxuICAgICdmc3RhdCcsICdmdWxzdHInLCAnZnVuY3QnLCAnZnVuY3Rpb24nLCAnZnZfdGVzdCcsXG4gICAgJ2Z4X3Jvb3QnLCAnZnpfcm9vdHMnLCAnZ2FtbWEnLCAnZ2FtbWFfY3QnLCAnZ2F1c3NfY3ZmJyxcbiAgICAnZ2F1c3NfcGRmJywgJ2dhdXNzX3Ntb290aCcsICdnYXVzczJkZml0JywgJ2dhdXNzZml0JyxcbiAgICAnZ2F1c3NpYW5fZnVuY3Rpb24nLCAnZ2F1c3NpbnQnLCAnZ2V0X2RyaXZlX2xpc3QnLCAnZ2V0X2R4Zl9vYmplY3RzJyxcbiAgICAnZ2V0X2ticmQnLCAnZ2V0X2xvZ2luX2luZm8nLFxuICAgICdnZXRfbHVuJywgJ2dldF9zY3JlZW5fc2l6ZScsICdnZXRlbnYnLCAnZ2V0d2luZG93cycsICdncmVnMmp1bCcsXG4gICAgJ2dyaWInLCAnZ3JpZF9pbnB1dCcsICdncmlkX3RwcycsICdncmlkMycsICdncmlkZGF0YScsXG4gICAgJ2dzX2l0ZXInLCAnaF9lcV9jdCcsICdoX2VxX2ludCcsICdoYW5uaW5nJywgJ2hhc2gnLFxuICAgICdoZGYnLCAnaGRmNScsICdoZWFwX2ZyZWUnLCAnaGVhcF9nYycsICdoZWFwX25vc2F2ZScsXG4gICAgJ2hlYXBfcmVmY291bnQnLCAnaGVhcF9zYXZlJywgJ2hlbHAnLCAnaGlsYmVydCcsICdoaXN0XzJkJyxcbiAgICAnaGlzdF9lcXVhbCcsICdoaXN0b2dyYW0nLCAnaGxzJywgJ2hvdWdoJywgJ2hxcicsXG4gICAgJ2hzdicsICdpMThuX211bHRpYnl0ZXRvdXRmOCcsXG4gICAgJ2kxOG5fbXVsdGlieXRldG93aWRlY2hhcicsICdpMThuX3V0Zjh0b211bHRpYnl0ZScsXG4gICAgJ2kxOG5fd2lkZWNoYXJ0b211bHRpYnl0ZScsXG4gICAgJ2liZXRhJywgJ2ljb250b3VyJywgJ2ljb252ZXJ0Y29vcmQnLCAnaWRlbGV0ZScsICdpZGVudGl0eScsXG4gICAgJ2lkbF9iYXNlNjQnLCAnaWRsX2NvbnRhaW5lcicsICdpZGxfdmFsaWRuYW1lJyxcbiAgICAnaWRsZXhicl9hc3Npc3RhbnQnLCAnaWRsaXRzeXNfY3JlYXRldG9vbCcsXG4gICAgJ2lkbHVuaXQnLCAnaWVsbGlwc2UnLCAnaWdhbW1hJywgJ2lnZXRjdXJyZW50JywgJ2lnZXRkYXRhJyxcbiAgICAnaWdldGlkJywgJ2lnZXRwcm9wZXJ0eScsICdpaW1hZ2UnLCAnaW1hZ2UnLCAnaW1hZ2VfY29udCcsXG4gICAgJ2ltYWdlX3N0YXRpc3RpY3MnLCAnaW1hZ2VfdGhyZXNob2xkJywgJ2ltYWdpbmFyeScsICdpbWFwJywgJ2luZGdlbicsXG4gICAgJ2ludF8yZCcsICdpbnRfM2QnLCAnaW50X3RhYnVsYXRlZCcsICdpbnRhcnInLCAnaW50ZXJwb2wnLFxuICAgICdpbnRlcnBvbGF0ZScsICdpbnRlcnZhbF92b2x1bWUnLCAnaW52ZXJ0JywgJ2lvY3RsJywgJ2lvcGVuJyxcbiAgICAnaXJfZmlsdGVyJywgJ2lwbG90JywgJ2lwb2x5Z29uJywgJ2lwb2x5bGluZScsICdpcHV0ZGF0YScsXG4gICAgJ2lyZWdpc3RlcicsICdpcmVzZXQnLCAnaXJlc29sdmUnLCAnaXJvdGF0ZScsICdpc2EnLFxuICAgICdpc2F2ZScsICdpc2NhbGUnLCAnaXNldGN1cnJlbnQnLCAnaXNldHByb3BlcnR5JywgJ2lzaGZ0JyxcbiAgICAnaXNvY29udG91cicsICdpc29zdXJmYWNlJywgJ2lzdXJmYWNlJywgJ2l0ZXh0JywgJ2l0cmFuc2xhdGUnLFxuICAgICdpdmVjdG9yJywgJ2l2b2x1bWUnLCAnaXpvb20nLCAnam91cm5hbCcsICdqc29uX3BhcnNlJyxcbiAgICAnanNvbl9zZXJpYWxpemUnLCAnanVsMmdyZWcnLCAnanVsZGF5JywgJ2tleXdvcmRfc2V0JywgJ2tyaWcyZCcsXG4gICAgJ2t1cnRvc2lzJywgJ2t3X3Rlc3QnLCAnbDY0aW5kZ2VuJywgJ2xhX2Nob2xkYycsICdsYV9jaG9sbXByb3ZlJyxcbiAgICAnbGFfY2hvbHNvbCcsICdsYV9kZXRlcm0nLCAnbGFfZWlnZW5wcm9ibGVtJywgJ2xhX2VpZ2VucWwnLCAnbGFfZWlnZW52ZWMnLFxuICAgICdsYV9lbG1oZXMnLCAnbGFfZ21fbGluZWFyX21vZGVsJywgJ2xhX2hxcicsICdsYV9pbnZlcnQnLFxuICAgICdsYV9sZWFzdF9zcXVhcmVfZXF1YWxpdHknLCAnbGFfbGVhc3Rfc3F1YXJlcycsICdsYV9saW5lYXJfZXF1YXRpb24nLFxuICAgICdsYV9sdWRjJywgJ2xhX2x1bXByb3ZlJywgJ2xhX2x1c29sJyxcbiAgICAnbGFfc3ZkJywgJ2xhX3RyaWRjJywgJ2xhX3RyaW1wcm92ZScsICdsYV90cmlxbCcsICdsYV90cmlyZWQnLFxuICAgICdsYV90cmlzb2wnLCAnbGFiZWxfZGF0ZScsICdsYWJlbF9yZWdpb24nLCAnbGFkZml0JywgJ2xhZ3VlcnJlJyxcbiAgICAnbGFtYmRhJywgJ2xhbWJkYXAnLCAnbGFtYmVydHcnLCAnbGFwbGFjaWFuJywgJ2xlYXN0X3NxdWFyZXNfZmlsdGVyJyxcbiAgICAnbGVlZmlsdCcsICdsZWdlbmQnLCAnbGVnZW5kcmUnLCAnbGluYmNnJywgJ2xpbmRnZW4nLFxuICAgICdsaW5maXQnLCAnbGlua2ltYWdlJywgJ2xpc3QnLCAnbGxfYXJjX2Rpc3RhbmNlJywgJ2xtZml0JyxcbiAgICAnbG1ncicsICdsbmdhbW1hJywgJ2xucF90ZXN0JywgJ2xvYWRjdCcsICdsb2NhbGVfZ2V0JyxcbiAgICAnbG9naWNhbF9hbmQnLCAnbG9naWNhbF9vcicsICdsb2dpY2FsX3RydWUnLCAnbG9uNjRhcnInLCAnbG9uYXJyJyxcbiAgICAnbG9uZycsICdsb25nNjQnLCAnbHNvZGUnLCAnbHVfY29tcGxleCcsICdsdWRjJyxcbiAgICAnbHVtcHJvdmUnLCAnbHVzb2wnLCAnbV9jb3JyZWxhdGUnLCAnbWFjaGFyJywgJ21ha2VfYXJyYXknLFxuICAgICdtYWtlX2RsbCcsICdtYWtlX3J0JywgJ21hcCcsICdtYXBjb250aW5lbnRzJywgJ21hcGdyaWQnLFxuICAgICdtYXBfMnBvaW50cycsICdtYXBfY29udGluZW50cycsICdtYXBfZ3JpZCcsICdtYXBfaW1hZ2UnLCAnbWFwX3BhdGNoJyxcbiAgICAnbWFwX3Byb2pfZm9yd2FyZCcsICdtYXBfcHJval9pbWFnZScsICdtYXBfcHJval9pbmZvJyxcbiAgICAnbWFwX3Byb2pfaW5pdCcsICdtYXBfcHJval9pbnZlcnNlJyxcbiAgICAnbWFwX3NldCcsICdtYXRyaXhfbXVsdGlwbHknLCAnbWF0cml4X3Bvd2VyJywgJ21heCcsICdtZF90ZXN0JyxcbiAgICAnbWVhbicsICdtZWFuYWJzZGV2JywgJ21lYW5fZmlsdGVyJywgJ21lZGlhbicsICdtZW1vcnknLFxuICAgICdtZXNoX2NsaXAnLCAnbWVzaF9kZWNpbWF0ZScsICdtZXNoX2lzc29saWQnLFxuICAgICdtZXNoX21lcmdlJywgJ21lc2hfbnVtdHJpYW5nbGVzJyxcbiAgICAnbWVzaF9vYmonLCAnbWVzaF9zbW9vdGgnLCAnbWVzaF9zdXJmYWNlYXJlYScsXG4gICAgJ21lc2hfdmFsaWRhdGUnLCAnbWVzaF92b2x1bWUnLFxuICAgICdtZXNzYWdlJywgJ21pbicsICdtaW5fY3VydmVfc3VyZicsICdta19odG1sX2hlbHAnLCAnbW9kaWZ5Y3QnLFxuICAgICdtb21lbnQnLCAnbW9ycGhfY2xvc2UnLCAnbW9ycGhfZGlzdGFuY2UnLFxuICAgICdtb3JwaF9ncmFkaWVudCcsICdtb3JwaF9oaXRvcm1pc3MnLFxuICAgICdtb3JwaF9vcGVuJywgJ21vcnBoX3RoaW4nLCAnbW9ycGhfdG9waGF0JywgJ211bHRpJywgJ25fZWxlbWVudHMnLFxuICAgICduX3BhcmFtcycsICduX3RhZ3MnLCAnbmNkZicsICduZXd0b24nLCAnbm9pc2VfaHVybCcsXG4gICAgJ25vaXNlX3BpY2snLCAnbm9pc2Vfc2NhdHRlcicsICdub2lzZV9zbHVyJywgJ25vcm0nLCAnb2JqX2NsYXNzJyxcbiAgICAnb2JqX2Rlc3Ryb3knLCAnb2JqX2hhc21ldGhvZCcsICdvYmpfaXNhJywgJ29ial9uZXcnLCAnb2JqX3ZhbGlkJyxcbiAgICAnb2JqYXJyJywgJ29uX2Vycm9yJywgJ29uX2lvZXJyb3InLCAnb25saW5lX2hlbHAnLCAnb3BlbnInLFxuICAgICdvcGVudScsICdvcGVudycsICdvcGxvdCcsICdvcGxvdGVycicsICdvcmRlcmVkaGFzaCcsXG4gICAgJ3BfY29ycmVsYXRlJywgJ3BhcnNlX3VybCcsICdwYXJ0aWNsZV90cmFjZScsICdwYXRoX2NhY2hlJywgJ3BhdGhfc2VwJyxcbiAgICAncGNvbXAnLCAncGxvdCcsICdwbG90M2QnLCAncGxvdCcsICdwbG90XzNkYm94JyxcbiAgICAncGxvdF9maWVsZCcsICdwbG90ZXJyJywgJ3Bsb3RzJywgJ3BvbGFyX2NvbnRvdXInLCAncG9sYXJfc3VyZmFjZScsXG4gICAgJ3BvbHlmaWxsJywgJ3BvbHlzaGFkZScsICdwbnRfbGluZScsICdwb2ludF9sdW4nLCAncG9sYXJwbG90JyxcbiAgICAncG9seScsICdwb2x5XzJkJywgJ3BvbHlfYXJlYScsICdwb2x5X2ZpdCcsICdwb2x5ZmlsbHYnLFxuICAgICdwb2x5Z29uJywgJ3BvbHlsaW5lJywgJ3BvbHl3YXJwJywgJ3BvcGQnLCAncG93ZWxsJyxcbiAgICAncHJlZl9jb21taXQnLCAncHJlZl9nZXQnLCAncHJlZl9zZXQnLCAncHJld2l0dCcsICdwcmltZXMnLFxuICAgICdwcmludCcsICdwcmludGYnLCAncHJpbnRkJywgJ3BybycsICdwcm9kdWN0JyxcbiAgICAncHJvZmlsZScsICdwcm9maWxlcicsICdwcm9maWxlcycsICdwcm9qZWN0X3ZvbCcsICdwc19zaG93X2ZvbnRzJyxcbiAgICAncHNhZm0nLCAncHNldWRvJywgJ3B0cl9mcmVlJywgJ3B0cl9uZXcnLCAncHRyX3ZhbGlkJyxcbiAgICAncHRyYXJyJywgJ3B1c2hkJywgJ3FncmlkMycsICdxaHVsbCcsICdxcm9tYicsXG4gICAgJ3Fyb21vJywgJ3FzaW1wJywgJ3F1ZXJ5XyonLCAncXVlcnlfYXNjaWknLCAncXVlcnlfYm1wJyxcbiAgICAncXVlcnlfY3N2JywgJ3F1ZXJ5X2RpY29tJywgJ3F1ZXJ5X2dpZicsICdxdWVyeV9pbWFnZScsICdxdWVyeV9qcGVnJyxcbiAgICAncXVlcnlfanBlZzIwMDAnLCAncXVlcnlfbXJzaWQnLCAncXVlcnlfcGljdCcsICdxdWVyeV9wbmcnLCAncXVlcnlfcHBtJyxcbiAgICAncXVlcnlfc3JmJywgJ3F1ZXJ5X3RpZmYnLCAncXVlcnlfdmlkZW8nLCAncXVlcnlfd2F2JywgJ3JfY29ycmVsYXRlJyxcbiAgICAncl90ZXN0JywgJ3JhZG9uJywgJ3JhbmRvbW4nLCAncmFuZG9tdScsICdyYW5rcycsXG4gICAgJ3JkcGl4JywgJ3JlYWQnLCAncmVhZGYnLCAncmVhZF9hc2NpaScsICdyZWFkX2JpbmFyeScsXG4gICAgJ3JlYWRfYm1wJywgJ3JlYWRfY3N2JywgJ3JlYWRfZGljb20nLCAncmVhZF9naWYnLCAncmVhZF9pbWFnZScsXG4gICAgJ3JlYWRfaW50ZXJmaWxlJywgJ3JlYWRfanBlZycsICdyZWFkX2pwZWcyMDAwJywgJ3JlYWRfbXJzaWQnLCAncmVhZF9waWN0JyxcbiAgICAncmVhZF9wbmcnLCAncmVhZF9wcG0nLCAncmVhZF9zcHInLCAncmVhZF9zcmYnLCAncmVhZF9zeWxrJyxcbiAgICAncmVhZF90aWZmJywgJ3JlYWRfdmlkZW8nLCAncmVhZF93YXYnLCAncmVhZF93YXZlJywgJ3JlYWRfeDExX2JpdG1hcCcsXG4gICAgJ3JlYWRfeHdkJywgJ3JlYWRzJywgJ3JlYWR1JywgJ3JlYWxfcGFydCcsICdyZWJpbicsXG4gICAgJ3JlY2FsbF9jb21tYW5kcycsICdyZWNvbjMnLCAncmVkdWNlX2NvbG9ycycsICdyZWZvcm0nLCAncmVnaW9uX2dyb3cnLFxuICAgICdyZWdpc3Rlcl9jdXJzb3InLCAncmVncmVzcycsICdyZXBsaWNhdGUnLFxuICAgICdyZXBsaWNhdGVfaW5wbGFjZScsICdyZXNvbHZlX2FsbCcsXG4gICAgJ3Jlc29sdmVfcm91dGluZScsICdyZXN0b3JlJywgJ3JldGFsbCcsICdyZXR1cm4nLCAncmV2ZXJzZScsXG4gICAgJ3JrNCcsICdyb2JlcnRzJywgJ3JvdCcsICdyb3RhdGUnLCAncm91bmQnLFxuICAgICdyb3V0aW5lX2ZpbGVwYXRoJywgJ3JvdXRpbmVfaW5mbycsICdyc190ZXN0JywgJ3NfdGVzdCcsICdzYXZlJyxcbiAgICAnc2F2Z29sJywgJ3NjYWxlMycsICdzY2FsZTNkJywgJ3NjYXR0ZXJwbG90JywgJ3NjYXR0ZXJwbG90M2QnLFxuICAgICdzY29wZV9sZXZlbCcsICdzY29wZV90cmFjZWJhY2snLCAnc2NvcGVfdmFyZmV0Y2gnLFxuICAgICdzY29wZV92YXJuYW1lJywgJ3NlYXJjaDJkJyxcbiAgICAnc2VhcmNoM2QnLCAnc2VtX2NyZWF0ZScsICdzZW1fZGVsZXRlJywgJ3NlbV9sb2NrJywgJ3NlbV9yZWxlYXNlJyxcbiAgICAnc2V0X3Bsb3QnLCAnc2V0X3NoYWRpbmcnLCAnc2V0ZW52JywgJ3NmaXQnLCAnc2hhZGVfc3VyZicsXG4gICAgJ3NoYWRlX3N1cmZfaXJyJywgJ3NoYWRlX3ZvbHVtZScsICdzaGlmdCcsICdzaGlmdF9kaWZmJywgJ3NobWRlYnVnJyxcbiAgICAnc2htbWFwJywgJ3NobXVubWFwJywgJ3NobXZhcicsICdzaG93MycsICdzaG93Zm9udCcsXG4gICAgJ3NpZ251bScsICdzaW1wbGV4JywgJ3NpbicsICdzaW5kZ2VuJywgJ3NpbmgnLFxuICAgICdzaXplJywgJ3NrZXduZXNzJywgJ3NraXBfbHVuJywgJ3NsaWNlcjMnLCAnc2xpZGVfaW1hZ2UnLFxuICAgICdzbW9vdGgnLCAnc29iZWwnLCAnc29ja2V0JywgJ3NvcnQnLCAnc3Bhd24nLFxuICAgICdzcGhfNHBudCcsICdzcGhfc2NhdCcsICdzcGhlcl9oYXJtJywgJ3NwbF9pbml0JywgJ3NwbF9pbnRlcnAnLFxuICAgICdzcGxpbmUnLCAnc3BsaW5lX3AnLCAnc3Byc2FiJywgJ3NwcnNheCcsICdzcHJzaW4nLFxuICAgICdzcHJzdHAnLCAnc3FydCcsICdzdGFuZGFyZGl6ZScsICdzdGRkZXYnLCAnc3RvcCcsXG4gICAgJ3N0cmFycicsICdzdHJjbXAnLCAnc3RyY29tcHJlc3MnLCAnc3RyZWFtbGluZScsICdzdHJlYW1saW5lJyxcbiAgICAnc3RyZWdleCcsICdzdHJldGNoJywgJ3N0cmluZycsICdzdHJqb2luJywgJ3N0cmxlbicsXG4gICAgJ3N0cmxvd2Nhc2UnLCAnc3RybWF0Y2gnLCAnc3RybWVzc2FnZScsICdzdHJtaWQnLCAnc3RycG9zJyxcbiAgICAnc3RycHV0JywgJ3N0cnNwbGl0JywgJ3N0cnRyaW0nLCAnc3RydWN0X2Fzc2lnbicsICdzdHJ1Y3RfaGlkZScsXG4gICAgJ3N0cnVwY2FzZScsICdzdXJmYWNlJywgJ3N1cmZhY2UnLCAnc3VyZnInLCAnc3ZkYycsXG4gICAgJ3N2ZGZpdCcsICdzdnNvbCcsICdzd2FwX2VuZGlhbicsICdzd2FwX2VuZGlhbl9pbnBsYWNlJywgJ3N5bWJvbCcsXG4gICAgJ3N5c3RpbWUnLCAndF9jdmYnLCAndF9wZGYnLCAndDNkJywgJ3RhZ19uYW1lcycsXG4gICAgJ3RhbicsICd0YW5oJywgJ3Rla19jb2xvcicsICd0ZW1wb3JhcnknLCAndGVybWluYWxfc2l6ZScsXG4gICAgJ3RldHJhX2NsaXAnLCAndGV0cmFfc3VyZmFjZScsICd0ZXRyYV92b2x1bWUnLCAndGV4dCcsICd0aGluJyxcbiAgICAndGhyZWFkJywgJ3RocmVlZCcsICd0aWMnLCAndGltZV90ZXN0MicsICd0aW1lZ2VuJyxcbiAgICAndGltZXInLCAndGltZXN0YW1wJywgJ3RpbWVzdGFtcHRvdmFsdWVzJywgJ3RtX3Rlc3QnLCAndG9jJyxcbiAgICAndG90YWwnLCAndHJhY2UnLCAndHJhbnNwb3NlJywgJ3RyaV9zdXJmJywgJ3RyaWFuZ3VsYXRlJyxcbiAgICAndHJpZ3JpZCcsICd0cmlxbCcsICd0cmlyZWQnLCAndHJpc29sJywgJ3RydW5jYXRlX2x1bicsXG4gICAgJ3RzX2NvZWYnLCAndHNfZGlmZicsICd0c19mY2FzdCcsICd0c19zbW9vdGgnLCAndHYnLFxuICAgICd0dmNycycsICd0dmxjdCcsICd0dnJkJywgJ3R2c2NsJywgJ3R5cGVuYW1lJyxcbiAgICAndWluZGdlbicsICd1aW50JywgJ3VpbnRhcnInLCAndWw2NGluZGdlbicsICd1bGluZGdlbicsXG4gICAgJ3Vsb242NGFycicsICd1bG9uYXJyJywgJ3Vsb25nJywgJ3Vsb25nNjQnLCAndW5pcScsXG4gICAgJ3Vuc2hhcnBfbWFzaycsICd1c2Vyc3ltJywgJ3ZhbHVlX2xvY2F0ZScsICd2YXJpYW5jZScsICd2ZWN0b3InLFxuICAgICd2ZWN0b3JfZmllbGQnLCAndmVsJywgJ3ZlbG92ZWN0JywgJ3ZlcnRfdDNkJywgJ3ZvaWd0JyxcbiAgICAndm9sdW1lJywgJ3Zvcm9ub2knLCAndm94ZWxfcHJvaicsICd3YWl0JywgJ3dhcnBfdHJpJyxcbiAgICAnd2F0ZXJzaGVkJywgJ3dkZWxldGUnLCAnd2ZfZHJhdycsICd3aGVyZScsICd3aWRnZXRfYmFzZScsXG4gICAgJ3dpZGdldF9idXR0b24nLCAnd2lkZ2V0X2NvbWJvYm94JywgJ3dpZGdldF9jb250cm9sJyxcbiAgICAnd2lkZ2V0X2Rpc3BsYXljb250ZXh0bWVudScsICd3aWRnZXRfZHJhdycsXG4gICAgJ3dpZGdldF9kcm9wbGlzdCcsICd3aWRnZXRfZXZlbnQnLCAnd2lkZ2V0X2luZm8nLFxuICAgICd3aWRnZXRfbGFiZWwnLCAnd2lkZ2V0X2xpc3QnLFxuICAgICd3aWRnZXRfcHJvcGVydHlzaGVldCcsICd3aWRnZXRfc2xpZGVyJywgJ3dpZGdldF90YWInLFxuICAgICd3aWRnZXRfdGFibGUnLCAnd2lkZ2V0X3RleHQnLFxuICAgICd3aWRnZXRfdHJlZScsICd3aWRnZXRfdHJlZV9tb3ZlJywgJ3dpZGdldF93aW5kb3cnLFxuICAgICd3aWVuZXJfZmlsdGVyJywgJ3dpbmRvdycsXG4gICAgJ3dpbmRvdycsICd3cml0ZV9ibXAnLCAnd3JpdGVfY3N2JywgJ3dyaXRlX2dpZicsICd3cml0ZV9pbWFnZScsXG4gICAgJ3dyaXRlX2pwZWcnLCAnd3JpdGVfanBlZzIwMDAnLCAnd3JpdGVfbnJpZicsICd3cml0ZV9waWN0JywgJ3dyaXRlX3BuZycsXG4gICAgJ3dyaXRlX3BwbScsICd3cml0ZV9zcHInLCAnd3JpdGVfc3JmJywgJ3dyaXRlX3N5bGsnLCAnd3JpdGVfdGlmZicsXG4gICAgJ3dyaXRlX3ZpZGVvJywgJ3dyaXRlX3dhdicsICd3cml0ZV93YXZlJywgJ3dyaXRldScsICd3c2V0JyxcbiAgICAnd3Nob3cnLCAnd3RuJywgJ3d2X2FwcGxldCcsICd3dl9jd3QnLCAnd3ZfY3dfd2F2ZWxldCcsXG4gICAgJ3d2X2Rlbm9pc2UnLCAnd3ZfZHd0JywgJ3d2X2ZuX2NvaWZsZXQnLFxuICAgICd3dl9mbl9kYXViZWNoaWVzJywgJ3d2X2ZuX2dhdXNzaWFuJyxcbiAgICAnd3ZfZm5faGFhcicsICd3dl9mbl9tb3JsZXQnLCAnd3ZfZm5fcGF1bCcsXG4gICAgJ3d2X2ZuX3N5bWxldCcsICd3dl9pbXBvcnRfZGF0YScsXG4gICAgJ3d2X2ltcG9ydF93YXZlbGV0JywgJ3d2X3Bsb3QzZF93cHMnLCAnd3ZfcGxvdF9tdWx0aXJlcycsXG4gICAgJ3d2X3B3dCcsICd3dl90b29sX2Rlbm9pc2UnLFxuICAgICd4Ym1fZWRpdCcsICd4ZGlzcGxheWZpbGUnLCAneGR4ZicsICd4Zm9udCcsICd4aW50ZXJhbmltYXRlJyxcbiAgICAneGxvYWRjdCcsICd4bWFuYWdlcicsICd4bW5nX3RtcGwnLCAneG10b29sJywgJ3hvYmp2aWV3JyxcbiAgICAneG9ianZpZXdfcm90YXRlJywgJ3hvYmp2aWV3X3dyaXRlX2ltYWdlJyxcbiAgICAneHBhbGV0dGUnLCAneHBjb2xvcicsICd4cGxvdDNkJyxcbiAgICAneHJlZ2lzdGVyZWQnLCAneHJvaScsICd4c3FfdGVzdCcsICd4c3VyZmFjZScsICd4dmFyZWRpdCcsXG4gICAgJ3h2b2x1bWUnLCAneHZvbHVtZV9yb3RhdGUnLCAneHZvbHVtZV93cml0ZV9pbWFnZScsXG4gICAgJ3h5b3V0cycsICd6bGliX2NvbXByZXNzJywgJ3psaWJfdW5jb21wcmVzcycsICd6b29tJywgJ3pvb21fMjQnXG4gIF07XG4gIHZhciBidWlsdGlucyA9IHdvcmRSZWdleHAoYnVpbHRpbkFycmF5KTtcblxuICB2YXIga2V5d29yZEFycmF5ID0gW1xuICAgICdiZWdpbicsICdlbmQnLCAnZW5kY2FzZScsICdlbmRmb3InLFxuICAgICdlbmR3aGlsZScsICdlbmRpZicsICdlbmRyZXAnLCAnZW5kZm9yZWFjaCcsXG4gICAgJ2JyZWFrJywgJ2Nhc2UnLCAnY29udGludWUnLCAnZm9yJyxcbiAgICAnZm9yZWFjaCcsICdnb3RvJywgJ2lmJywgJ3RoZW4nLCAnZWxzZScsXG4gICAgJ3JlcGVhdCcsICd1bnRpbCcsICdzd2l0Y2gnLCAnd2hpbGUnLFxuICAgICdkbycsICdwcm8nLCAnZnVuY3Rpb24nXG4gIF07XG4gIHZhciBrZXl3b3JkcyA9IHdvcmRSZWdleHAoa2V5d29yZEFycmF5KTtcblxuICBDb2RlTWlycm9yLnJlZ2lzdGVySGVscGVyKFwiaGludFdvcmRzXCIsIFwiaWRsXCIsIGJ1aWx0aW5BcnJheS5jb25jYXQoa2V5d29yZEFycmF5KSk7XG5cbiAgdmFyIGlkZW50aWZpZXJzID0gbmV3IFJlZ0V4cCgnXltfYS16XFx4YTEtXFx1ZmZmZl1bX2EtejAtOVxceGExLVxcdWZmZmZdKicsICdpJyk7XG5cbiAgdmFyIHNpbmdsZU9wZXJhdG9ycyA9IC9bK1xcLSomPTw+XFwvQCN+JF0vO1xuICB2YXIgYm9vbE9wZXJhdG9ycyA9IG5ldyBSZWdFeHAoJyhhbmR8b3J8ZXF8bHR8bGV8Z3R8Z2V8bmV8bm90KScsICdpJyk7XG5cbiAgZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSkge1xuICAgIC8vIHdoaXRlc3BhY2VzXG4gICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSByZXR1cm4gbnVsbDtcblxuICAgIC8vIEhhbmRsZSBvbmUgbGluZSBDb21tZW50c1xuICAgIGlmIChzdHJlYW0ubWF0Y2goJzsnKSkge1xuICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgcmV0dXJuICdjb21tZW50JztcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgTnVtYmVyIExpdGVyYWxzXG4gICAgaWYgKHN0cmVhbS5tYXRjaCgvXlswLTlcXC4rLV0vLCBmYWxzZSkpIHtcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goL15bKy1dPzB4WzAtOWEtZkEtRl0rLykpXG4gICAgICAgIHJldHVybiAnbnVtYmVyJztcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goL15bKy1dP1xcZCpcXC5cXGQrKFtFZURkXVsrLV0/XFxkKyk/LykpXG4gICAgICAgIHJldHVybiAnbnVtYmVyJztcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goL15bKy1dP1xcZCsoW0VlRGRdWystXT9cXGQrKT8vKSlcbiAgICAgICAgcmV0dXJuICdudW1iZXInO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBTdHJpbmdzXG4gICAgaWYgKHN0cmVhbS5tYXRjaCgvXlwiKFteXCJdfChcIlwiKSkqXCIvKSkgeyByZXR1cm4gJ3N0cmluZyc7IH1cbiAgICBpZiAoc3RyZWFtLm1hdGNoKC9eJyhbXiddfCgnJykpKicvKSkgeyByZXR1cm4gJ3N0cmluZyc7IH1cblxuICAgIC8vIEhhbmRsZSB3b3Jkc1xuICAgIGlmIChzdHJlYW0ubWF0Y2goa2V5d29yZHMpKSB7IHJldHVybiAna2V5d29yZCc7IH1cbiAgICBpZiAoc3RyZWFtLm1hdGNoKGJ1aWx0aW5zKSkgeyByZXR1cm4gJ2J1aWx0aW4nOyB9XG4gICAgaWYgKHN0cmVhbS5tYXRjaChpZGVudGlmaWVycykpIHsgcmV0dXJuICd2YXJpYWJsZSc7IH1cblxuICAgIGlmIChzdHJlYW0ubWF0Y2goc2luZ2xlT3BlcmF0b3JzKSB8fCBzdHJlYW0ubWF0Y2goYm9vbE9wZXJhdG9ycykpIHtcbiAgICAgIHJldHVybiAnb3BlcmF0b3InOyB9XG5cbiAgICAvLyBIYW5kbGUgbm9uLWRldGVjdGVkIGl0ZW1zXG4gICAgc3RyZWFtLm5leHQoKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBDb2RlTWlycm9yLmRlZmluZU1vZGUoJ2lkbCcsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgIHJldHVybiB0b2tlbkJhc2Uoc3RyZWFtKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcblxuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoJ3RleHQveC1pZGwnLCAnaWRsJyk7XG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lTW9kZShcImppbmphMlwiLCBmdW5jdGlvbigpIHtcbiAgICB2YXIga2V5d29yZHMgPSBbXCJhbmRcIiwgXCJhc1wiLCBcImJsb2NrXCIsIFwiZW5kYmxvY2tcIiwgXCJieVwiLCBcImN5Y2xlXCIsIFwiZGVidWdcIiwgXCJlbHNlXCIsIFwiZWxpZlwiLFxuICAgICAgXCJleHRlbmRzXCIsIFwiZmlsdGVyXCIsIFwiZW5kZmlsdGVyXCIsIFwiZmlyc3RvZlwiLCBcImZvclwiLFxuICAgICAgXCJlbmRmb3JcIiwgXCJpZlwiLCBcImVuZGlmXCIsIFwiaWZjaGFuZ2VkXCIsIFwiZW5kaWZjaGFuZ2VkXCIsXG4gICAgICBcImlmZXF1YWxcIiwgXCJlbmRpZmVxdWFsXCIsIFwiaWZub3RlcXVhbFwiLFxuICAgICAgXCJlbmRpZm5vdGVxdWFsXCIsIFwiaW5cIiwgXCJpbmNsdWRlXCIsIFwibG9hZFwiLCBcIm5vdFwiLCBcIm5vd1wiLCBcIm9yXCIsXG4gICAgICBcInBhcnNlZFwiLCBcInJlZ3JvdXBcIiwgXCJyZXZlcnNlZFwiLCBcInNwYWNlbGVzc1wiLFxuICAgICAgXCJlbmRzcGFjZWxlc3NcIiwgXCJzc2lcIiwgXCJ0ZW1wbGF0ZXRhZ1wiLCBcIm9wZW5ibG9ja1wiLFxuICAgICAgXCJjbG9zZWJsb2NrXCIsIFwib3BlbnZhcmlhYmxlXCIsIFwiY2xvc2V2YXJpYWJsZVwiLFxuICAgICAgXCJvcGVuYnJhY2VcIiwgXCJjbG9zZWJyYWNlXCIsIFwib3BlbmNvbW1lbnRcIixcbiAgICAgIFwiY2xvc2Vjb21tZW50XCIsIFwid2lkdGhyYXRpb1wiLCBcInVybFwiLCBcIndpdGhcIiwgXCJlbmR3aXRoXCIsXG4gICAgICBcImdldF9jdXJyZW50X2xhbmd1YWdlXCIsIFwidHJhbnNcIiwgXCJlbmR0cmFuc1wiLCBcIm5vb3BcIiwgXCJibG9ja3RyYW5zXCIsXG4gICAgICBcImVuZGJsb2NrdHJhbnNcIiwgXCJnZXRfYXZhaWxhYmxlX2xhbmd1YWdlc1wiLFxuICAgICAgXCJnZXRfY3VycmVudF9sYW5ndWFnZV9iaWRpXCIsIFwicGx1cmFsXCJdLFxuICAgIG9wZXJhdG9yID0gL15bK1xcLSomJT08PiE/fH5eXS8sXG4gICAgc2lnbiA9IC9eWzpcXFtcXChcXHtdLyxcbiAgICBhdG9tID0gW1widHJ1ZVwiLCBcImZhbHNlXCJdLFxuICAgIG51bWJlciA9IC9eKFxcZFsrXFwtXFwqXFwvXSk/XFxkKyhcXC5cXGQrKT8vO1xuXG4gICAga2V5d29yZHMgPSBuZXcgUmVnRXhwKFwiKChcIiArIGtleXdvcmRzLmpvaW4oXCIpfChcIikgKyBcIikpXFxcXGJcIik7XG4gICAgYXRvbSA9IG5ldyBSZWdFeHAoXCIoKFwiICsgYXRvbS5qb2luKFwiKXwoXCIpICsgXCIpKVxcXFxiXCIpO1xuXG4gICAgZnVuY3Rpb24gdG9rZW5CYXNlIChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgY2ggPSBzdHJlYW0ucGVlaygpO1xuXG4gICAgICAvL0NvbW1lbnRcbiAgICAgIGlmIChzdGF0ZS5pbmNvbW1lbnQpIHtcbiAgICAgICAgaWYoIXN0cmVhbS5za2lwVG8oXCIjfVwiKSkge1xuICAgICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1xcI3x9Lyk7XG4gICAgICAgICAgc3RhdGUuaW5jb21tZW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgICAgLy9UYWdcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuaW50YWcpIHtcbiAgICAgICAgLy9BZnRlciBvcGVyYXRvclxuICAgICAgICBpZihzdGF0ZS5vcGVyYXRvcikge1xuICAgICAgICAgIHN0YXRlLm9wZXJhdG9yID0gZmFsc2U7XG4gICAgICAgICAgaWYoc3RyZWFtLm1hdGNoKGF0b20pKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJhdG9tXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKHN0cmVhbS5tYXRjaChudW1iZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy9BZnRlciBzaWduXG4gICAgICAgIGlmKHN0YXRlLnNpZ24pIHtcbiAgICAgICAgICBzdGF0ZS5zaWduID0gZmFsc2U7XG4gICAgICAgICAgaWYoc3RyZWFtLm1hdGNoKGF0b20pKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJhdG9tXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKHN0cmVhbS5tYXRjaChudW1iZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZihzdGF0ZS5pbnN0cmluZykge1xuICAgICAgICAgIGlmKGNoID09IHN0YXRlLmluc3RyaW5nKSB7XG4gICAgICAgICAgICBzdGF0ZS5pbnN0cmluZyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgICB9IGVsc2UgaWYoY2ggPT0gXCInXCIgfHwgY2ggPT0gJ1wiJykge1xuICAgICAgICAgIHN0YXRlLmluc3RyaW5nID0gY2g7XG4gICAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICAgICAgfSBlbHNlIGlmKHN0cmVhbS5tYXRjaChzdGF0ZS5pbnRhZyArIFwifVwiKSB8fCBzdHJlYW0uZWF0KFwiLVwiKSAmJiBzdHJlYW0ubWF0Y2goc3RhdGUuaW50YWcgKyBcIn1cIikpIHtcbiAgICAgICAgICBzdGF0ZS5pbnRhZyA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBcInRhZ1wiO1xuICAgICAgICB9IGVsc2UgaWYoc3RyZWFtLm1hdGNoKG9wZXJhdG9yKSkge1xuICAgICAgICAgIHN0YXRlLm9wZXJhdG9yID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICAgICAgICB9IGVsc2UgaWYoc3RyZWFtLm1hdGNoKHNpZ24pKSB7XG4gICAgICAgICAgc3RhdGUuc2lnbiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYoc3RyZWFtLmVhdChcIiBcIikgfHwgc3RyZWFtLnNvbCgpKSB7XG4gICAgICAgICAgICBpZihzdHJlYW0ubWF0Y2goa2V5d29yZHMpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHN0cmVhbS5tYXRjaChhdG9tKSkge1xuICAgICAgICAgICAgICByZXR1cm4gXCJhdG9tXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihzdHJlYW0ubWF0Y2gobnVtYmVyKSkge1xuICAgICAgICAgICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHN0cmVhbS5zb2woKSkge1xuICAgICAgICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcInZhcmlhYmxlXCI7XG4gICAgICB9IGVsc2UgaWYgKHN0cmVhbS5lYXQoXCJ7XCIpKSB7XG4gICAgICAgIGlmIChzdHJlYW0uZWF0KFwiI1wiKSkge1xuICAgICAgICAgIHN0YXRlLmluY29tbWVudCA9IHRydWU7XG4gICAgICAgICAgaWYoIXN0cmVhbS5za2lwVG8oXCIjfVwiKSkge1xuICAgICAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1xcI3x9Lyk7XG4gICAgICAgICAgICBzdGF0ZS5pbmNvbW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgICAgICAvL09wZW4gdGFnXG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPSBzdHJlYW0uZWF0KC9cXHt8JS8pKSB7XG4gICAgICAgICAgLy9DYWNoZSBjbG9zZSB0YWdcbiAgICAgICAgICBzdGF0ZS5pbnRhZyA9IGNoO1xuICAgICAgICAgIGlmKGNoID09IFwie1wiKSB7XG4gICAgICAgICAgICBzdGF0ZS5pbnRhZyA9IFwifVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHJlYW0uZWF0KFwiLVwiKTtcbiAgICAgICAgICByZXR1cm4gXCJ0YWdcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHt0b2tlbml6ZTogdG9rZW5CYXNlfTtcbiAgICAgIH0sXG4gICAgICB0b2tlbjogZnVuY3Rpb24gKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgfSxcbiAgICAgIGJsb2NrQ29tbWVudFN0YXJ0OiBcInsjXCIsXG4gICAgICBibG9ja0NvbW1lbnRFbmQ6IFwiI31cIlxuICAgIH07XG4gIH0pO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQvamluamEyXCIsIFwiamluamEyXCIpO1xufSk7XG4iLCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpLCByZXF1aXJlKFwiLi4veG1sL3htbFwiKSwgcmVxdWlyZShcIi4uL2phdmFzY3JpcHQvamF2YXNjcmlwdFwiKSlcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIsIFwiLi4veG1sL3htbFwiLCBcIi4uL2phdmFzY3JpcHQvamF2YXNjcmlwdFwiXSwgbW9kKVxuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpXG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG4gIFwidXNlIHN0cmljdFwiXG5cbiAgLy8gRGVwdGggbWVhbnMgdGhlIGFtb3VudCBvZiBvcGVuIGJyYWNlcyBpbiBKUyBjb250ZXh0LCBpbiBYTUxcbiAgLy8gY29udGV4dCAwIG1lYW5zIG5vdCBpbiB0YWcsIDEgbWVhbnMgaW4gdGFnLCBhbmQgMiBtZWFucyBpbiB0YWdcbiAgLy8gYW5kIGpzIGJsb2NrIGNvbW1lbnQuXG4gIGZ1bmN0aW9uIENvbnRleHQoc3RhdGUsIG1vZGUsIGRlcHRoLCBwcmV2KSB7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlOyB0aGlzLm1vZGUgPSBtb2RlOyB0aGlzLmRlcHRoID0gZGVwdGg7IHRoaXMucHJldiA9IHByZXZcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvcHlDb250ZXh0KGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IENvbnRleHQoQ29kZU1pcnJvci5jb3B5U3RhdGUoY29udGV4dC5tb2RlLCBjb250ZXh0LnN0YXRlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5tb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmRlcHRoLFxuICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnByZXYgJiYgY29weUNvbnRleHQoY29udGV4dC5wcmV2KSlcbiAgfVxuXG4gIENvZGVNaXJyb3IuZGVmaW5lTW9kZShcImpzeFwiLCBmdW5jdGlvbihjb25maWcsIG1vZGVDb25maWcpIHtcbiAgICB2YXIgeG1sTW9kZSA9IENvZGVNaXJyb3IuZ2V0TW9kZShjb25maWcsIHtuYW1lOiBcInhtbFwiLCBhbGxvd01pc3Npbmc6IHRydWUsIG11bHRpbGluZVRhZ0luZGVudFBhc3RUYWc6IGZhbHNlLCBhbGxvd01pc3NpbmdUYWdOYW1lOiB0cnVlfSlcbiAgICB2YXIganNNb2RlID0gQ29kZU1pcnJvci5nZXRNb2RlKGNvbmZpZywgbW9kZUNvbmZpZyAmJiBtb2RlQ29uZmlnLmJhc2UgfHwgXCJqYXZhc2NyaXB0XCIpXG5cbiAgICBmdW5jdGlvbiBmbGF0WE1MSW5kZW50KHN0YXRlKSB7XG4gICAgICB2YXIgdGFnTmFtZSA9IHN0YXRlLnRhZ05hbWVcbiAgICAgIHN0YXRlLnRhZ05hbWUgPSBudWxsXG4gICAgICB2YXIgcmVzdWx0ID0geG1sTW9kZS5pbmRlbnQoc3RhdGUsIFwiXCIsIFwiXCIpXG4gICAgICBzdGF0ZS50YWdOYW1lID0gdGFnTmFtZVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRva2VuKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmIChzdGF0ZS5jb250ZXh0Lm1vZGUgPT0geG1sTW9kZSlcbiAgICAgICAgcmV0dXJuIHhtbFRva2VuKHN0cmVhbSwgc3RhdGUsIHN0YXRlLmNvbnRleHQpXG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBqc1Rva2VuKHN0cmVhbSwgc3RhdGUsIHN0YXRlLmNvbnRleHQpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24geG1sVG9rZW4oc3RyZWFtLCBzdGF0ZSwgY3gpIHtcbiAgICAgIGlmIChjeC5kZXB0aCA9PSAyKSB7IC8vIEluc2lkZSBhIEpTIC8qICovIGNvbW1lbnRcbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXi4qP1xcKlxcLy8pKSBjeC5kZXB0aCA9IDFcbiAgICAgICAgZWxzZSBzdHJlYW0uc2tpcFRvRW5kKClcbiAgICAgICAgcmV0dXJuIFwiY29tbWVudFwiXG4gICAgICB9XG5cbiAgICAgIGlmIChzdHJlYW0ucGVlaygpID09IFwie1wiKSB7XG4gICAgICAgIHhtbE1vZGUuc2tpcEF0dHJpYnV0ZShjeC5zdGF0ZSlcblxuICAgICAgICB2YXIgaW5kZW50ID0gZmxhdFhNTEluZGVudChjeC5zdGF0ZSksIHhtbENvbnRleHQgPSBjeC5zdGF0ZS5jb250ZXh0XG4gICAgICAgIC8vIElmIEpTIHN0YXJ0cyBvbiBzYW1lIGxpbmUgYXMgdGFnXG4gICAgICAgIGlmICh4bWxDb250ZXh0ICYmIHN0cmVhbS5tYXRjaCgvXltePl0qPlxccyokLywgZmFsc2UpKSB7XG4gICAgICAgICAgd2hpbGUgKHhtbENvbnRleHQucHJldiAmJiAheG1sQ29udGV4dC5zdGFydE9mTGluZSlcbiAgICAgICAgICAgIHhtbENvbnRleHQgPSB4bWxDb250ZXh0LnByZXZcbiAgICAgICAgICAvLyBJZiB0YWcgc3RhcnRzIHRoZSBsaW5lLCB1c2UgWE1MIGluZGVudGF0aW9uIGxldmVsXG4gICAgICAgICAgaWYgKHhtbENvbnRleHQuc3RhcnRPZkxpbmUpIGluZGVudCAtPSBjb25maWcuaW5kZW50VW5pdFxuICAgICAgICAgIC8vIEVsc2UgdXNlIEpTIGluZGVudGF0aW9uIGxldmVsXG4gICAgICAgICAgZWxzZSBpZiAoY3gucHJldi5zdGF0ZS5sZXhpY2FsKSBpbmRlbnQgPSBjeC5wcmV2LnN0YXRlLmxleGljYWwuaW5kZW50ZWRcbiAgICAgICAgLy8gRWxzZSBpZiBpbnNpZGUgb2YgdGFnXG4gICAgICAgIH0gZWxzZSBpZiAoY3guZGVwdGggPT0gMSkge1xuICAgICAgICAgIGluZGVudCArPSBjb25maWcuaW5kZW50VW5pdFxuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuY29udGV4dCA9IG5ldyBDb250ZXh0KENvZGVNaXJyb3Iuc3RhcnRTdGF0ZShqc01vZGUsIGluZGVudCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc01vZGUsIDAsIHN0YXRlLmNvbnRleHQpXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG5cbiAgICAgIGlmIChjeC5kZXB0aCA9PSAxKSB7IC8vIEluc2lkZSBvZiB0YWdcbiAgICAgICAgaWYgKHN0cmVhbS5wZWVrKCkgPT0gXCI8XCIpIHsgLy8gVGFnIGluc2lkZSBvZiB0YWdcbiAgICAgICAgICB4bWxNb2RlLnNraXBBdHRyaWJ1dGUoY3guc3RhdGUpXG4gICAgICAgICAgc3RhdGUuY29udGV4dCA9IG5ldyBDb250ZXh0KENvZGVNaXJyb3Iuc3RhcnRTdGF0ZSh4bWxNb2RlLCBmbGF0WE1MSW5kZW50KGN4LnN0YXRlKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhtbE1vZGUsIDAsIHN0YXRlLmNvbnRleHQpXG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goXCIvL1wiKSkge1xuICAgICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKVxuICAgICAgICAgIHJldHVybiBcImNvbW1lbnRcIlxuICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaChcIi8qXCIpKSB7XG4gICAgICAgICAgY3guZGVwdGggPSAyXG4gICAgICAgICAgcmV0dXJuIHRva2VuKHN0cmVhbSwgc3RhdGUpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHN0eWxlID0geG1sTW9kZS50b2tlbihzdHJlYW0sIGN4LnN0YXRlKSwgY3VyID0gc3RyZWFtLmN1cnJlbnQoKSwgc3RvcFxuICAgICAgaWYgKC9cXGJ0YWdcXGIvLnRlc3Qoc3R5bGUpKSB7XG4gICAgICAgIGlmICgvPiQvLnRlc3QoY3VyKSkge1xuICAgICAgICAgIGlmIChjeC5zdGF0ZS5jb250ZXh0KSBjeC5kZXB0aCA9IDBcbiAgICAgICAgICBlbHNlIHN0YXRlLmNvbnRleHQgPSBzdGF0ZS5jb250ZXh0LnByZXZcbiAgICAgICAgfSBlbHNlIGlmICgvXjwvLnRlc3QoY3VyKSkge1xuICAgICAgICAgIGN4LmRlcHRoID0gMVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFzdHlsZSAmJiAoc3RvcCA9IGN1ci5pbmRleE9mKFwie1wiKSkgPiAtMSkge1xuICAgICAgICBzdHJlYW0uYmFja1VwKGN1ci5sZW5ndGggLSBzdG9wKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0eWxlXG4gICAgfVxuXG4gICAgZnVuY3Rpb24ganNUb2tlbihzdHJlYW0sIHN0YXRlLCBjeCkge1xuICAgICAgaWYgKHN0cmVhbS5wZWVrKCkgPT0gXCI8XCIgJiYganNNb2RlLmV4cHJlc3Npb25BbGxvd2VkKHN0cmVhbSwgY3guc3RhdGUpKSB7XG4gICAgICAgIHN0YXRlLmNvbnRleHQgPSBuZXcgQ29udGV4dChDb2RlTWlycm9yLnN0YXJ0U3RhdGUoeG1sTW9kZSwganNNb2RlLmluZGVudChjeC5zdGF0ZSwgXCJcIiwgXCJcIikpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeG1sTW9kZSwgMCwgc3RhdGUuY29udGV4dClcbiAgICAgICAganNNb2RlLnNraXBFeHByZXNzaW9uKGN4LnN0YXRlKVxuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICB2YXIgc3R5bGUgPSBqc01vZGUudG9rZW4oc3RyZWFtLCBjeC5zdGF0ZSlcbiAgICAgIGlmICghc3R5bGUgJiYgY3guZGVwdGggIT0gbnVsbCkge1xuICAgICAgICB2YXIgY3VyID0gc3RyZWFtLmN1cnJlbnQoKVxuICAgICAgICBpZiAoY3VyID09IFwie1wiKSB7XG4gICAgICAgICAgY3guZGVwdGgrK1xuICAgICAgICB9IGVsc2UgaWYgKGN1ciA9PSBcIn1cIikge1xuICAgICAgICAgIGlmICgtLWN4LmRlcHRoID09IDApIHN0YXRlLmNvbnRleHQgPSBzdGF0ZS5jb250ZXh0LnByZXZcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0eWxlXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge2NvbnRleHQ6IG5ldyBDb250ZXh0KENvZGVNaXJyb3Iuc3RhcnRTdGF0ZShqc01vZGUpLCBqc01vZGUpfVxuICAgICAgfSxcblxuICAgICAgY29weVN0YXRlOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICByZXR1cm4ge2NvbnRleHQ6IGNvcHlDb250ZXh0KHN0YXRlLmNvbnRleHQpfVxuICAgICAgfSxcblxuICAgICAgdG9rZW46IHRva2VuLFxuXG4gICAgICBpbmRlbnQ6IGZ1bmN0aW9uKHN0YXRlLCB0ZXh0QWZ0ZXIsIGZ1bGxMaW5lKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5jb250ZXh0Lm1vZGUuaW5kZW50KHN0YXRlLmNvbnRleHQuc3RhdGUsIHRleHRBZnRlciwgZnVsbExpbmUpXG4gICAgICB9LFxuXG4gICAgICBpbm5lck1vZGU6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5jb250ZXh0XG4gICAgICB9XG4gICAgfVxuICB9LCBcInhtbFwiLCBcImphdmFzY3JpcHRcIilcblxuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L2pzeFwiLCBcImpzeFwiKVxuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3R5cGVzY3JpcHQtanN4XCIsIHtuYW1lOiBcImpzeFwiLCBiYXNlOiB7bmFtZTogXCJqYXZhc2NyaXB0XCIsIHR5cGVzY3JpcHQ6IHRydWV9fSlcbn0pO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuLyoqXG4gKiBMaW5rIHRvIHRoZSBwcm9qZWN0J3MgR2l0SHViIHBhZ2U6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZHVyYWxvZy9Db2RlTWlycm9yXG4gKi9cblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNb2RlKCdsaXZlc2NyaXB0JywgZnVuY3Rpb24oKXtcbiAgICB2YXIgdG9rZW5CYXNlID0gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIG5leHRfcnVsZSA9IHN0YXRlLm5leHQgfHwgXCJzdGFydFwiO1xuICAgICAgaWYgKG5leHRfcnVsZSkge1xuICAgICAgICBzdGF0ZS5uZXh0ID0gc3RhdGUubmV4dDtcbiAgICAgICAgdmFyIG5yID0gUnVsZXNbbmV4dF9ydWxlXTtcbiAgICAgICAgaWYgKG5yLnNwbGljZSkge1xuICAgICAgICAgIGZvciAodmFyIGkkID0gMDsgaSQgPCBuci5sZW5ndGg7ICsraSQpIHtcbiAgICAgICAgICAgIHZhciByID0gbnJbaSRdO1xuICAgICAgICAgICAgaWYgKHIucmVnZXggJiYgc3RyZWFtLm1hdGNoKHIucmVnZXgpKSB7XG4gICAgICAgICAgICAgIHN0YXRlLm5leHQgPSByLm5leHQgfHwgc3RhdGUubmV4dDtcbiAgICAgICAgICAgICAgcmV0dXJuIHIudG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgICAgcmV0dXJuICdlcnJvcic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaChyID0gUnVsZXNbbmV4dF9ydWxlXSkpIHtcbiAgICAgICAgICBpZiAoci5yZWdleCAmJiBzdHJlYW0ubWF0Y2goci5yZWdleCkpIHtcbiAgICAgICAgICAgIHN0YXRlLm5leHQgPSByLm5leHQ7XG4gICAgICAgICAgICByZXR1cm4gci50b2tlbjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiAnZXJyb3InO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHJldHVybiAnZXJyb3InO1xuICAgIH07XG4gICAgdmFyIGV4dGVybmFsID0ge1xuICAgICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuZXh0OiAnc3RhcnQnLFxuICAgICAgICAgIGxhc3RUb2tlbjoge3N0eWxlOiBudWxsLCBpbmRlbnQ6IDAsIGNvbnRlbnQ6IFwiXCJ9XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpe1xuICAgICAgICB3aGlsZSAoc3RyZWFtLnBvcyA9PSBzdHJlYW0uc3RhcnQpXG4gICAgICAgICAgdmFyIHN0eWxlID0gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICBzdGF0ZS5sYXN0VG9rZW4gPSB7XG4gICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgIGluZGVudDogc3RyZWFtLmluZGVudGF0aW9uKCksXG4gICAgICAgICAgY29udGVudDogc3RyZWFtLmN1cnJlbnQoKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gc3R5bGUucmVwbGFjZSgvXFwuL2csICcgJyk7XG4gICAgICB9LFxuICAgICAgaW5kZW50OiBmdW5jdGlvbihzdGF0ZSl7XG4gICAgICAgIHZhciBpbmRlbnRhdGlvbiA9IHN0YXRlLmxhc3RUb2tlbi5pbmRlbnQ7XG4gICAgICAgIGlmIChzdGF0ZS5sYXN0VG9rZW4uY29udGVudC5tYXRjaChpbmRlbnRlcikpIHtcbiAgICAgICAgICBpbmRlbnRhdGlvbiArPSAyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRlbnRhdGlvbjtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBleHRlcm5hbDtcbiAgfSk7XG5cbiAgdmFyIGlkZW50aWZpZXIgPSAnKD8hW1xcXFxkXFxcXHNdKVskXFxcXHdcXFxceEFBLVxcXFx1RkZEQ10oPzooPyFcXFxccylbJFxcXFx3XFxcXHhBQS1cXFxcdUZGRENdfC1bQS1aYS16XSkqJztcbiAgdmFyIGluZGVudGVyID0gUmVnRXhwKCcoPzpbKHtbPTpdfFstfl0+fFxcXFxiKD86ZSg/OmxzZXx4cG9ydCl8ZCg/Om98ZWZhdWx0KXx0KD86cnl8aGVuKXxmaW5hbGx5fGltcG9ydCg/OlxcXFxzKmFsbCk/fGNvbnN0fHZhcnxsZXR8bmV3fGNhdGNoKD86XFxcXHMqJyArIGlkZW50aWZpZXIgKyAnKT8pKVxcXFxzKiQnKTtcbiAgdmFyIGtleXdvcmRlbmQgPSAnKD8hWyRcXFxcd118LVtBLVphLXpdfFxcXFxzKjooPyFbOj1dKSknO1xuICB2YXIgc3RyaW5nZmlsbCA9IHtcbiAgICB0b2tlbjogJ3N0cmluZycsXG4gICAgcmVnZXg6ICcuKydcbiAgfTtcbiAgdmFyIFJ1bGVzID0ge1xuICAgIHN0YXJ0OiBbXG4gICAgICB7XG4gICAgICAgIHRva2VuOiAnY29tbWVudC5kb2MnLFxuICAgICAgICByZWdleDogJy9cXFxcKicsXG4gICAgICAgIG5leHQ6ICdjb21tZW50J1xuICAgICAgfSwge1xuICAgICAgICB0b2tlbjogJ2NvbW1lbnQnLFxuICAgICAgICByZWdleDogJyMuKidcbiAgICAgIH0sIHtcbiAgICAgICAgdG9rZW46ICdrZXl3b3JkJyxcbiAgICAgICAgcmVnZXg6ICcoPzp0KD86aCg/OmlzfHJvd3xlbil8cnl8eXBlb2YhPyl8Yyg/Om9uKD86dGludWV8c3QpfGEoPzpzZXx0Y2gpfGxhc3MpfGkoPzpuKD86c3RhbmNlb2YpP3xtcCg/Om9ydCg/OlxcXFxzK2FsbCk/fGxlbWVudHMpfFtmc10pfGQoPzplKD86ZmF1bHR8bGV0ZXxidWdnZXIpfG8pfGYoPzpvcig/OlxcXFxzK293bik/fGluYWxseXx1bmN0aW9uKXxzKD86dXBlcnx3aXRjaCl8ZSg/OmxzZXx4KD86dGVuZHN8cG9ydCl8dmFsKXxhKD86bmR8cmd1bWVudHMpfG4oPzpld3xvdCl8dW4oPzpsZXNzfHRpbCl8dyg/OmhpbGV8aXRoKXxvW2ZyXXxyZXR1cm58YnJlYWt8bGV0fHZhcnxsb29wKScgKyBrZXl3b3JkZW5kXG4gICAgICB9LCB7XG4gICAgICAgIHRva2VuOiAnY29uc3RhbnQubGFuZ3VhZ2UnLFxuICAgICAgICByZWdleDogJyg/OnRydWV8ZmFsc2V8eWVzfG5vfG9ufG9mZnxudWxsfHZvaWR8dW5kZWZpbmVkKScgKyBrZXl3b3JkZW5kXG4gICAgICB9LCB7XG4gICAgICAgIHRva2VuOiAnaW52YWxpZC5pbGxlZ2FsJyxcbiAgICAgICAgcmVnZXg6ICcoPzpwKD86YWNrYWdlfHIoPzppdmF0ZXxvdGVjdGVkKXx1YmxpYyl8aSg/Om1wbGVtZW50c3xudGVyZmFjZSl8ZW51bXxzdGF0aWN8eWllbGQpJyArIGtleXdvcmRlbmRcbiAgICAgIH0sIHtcbiAgICAgICAgdG9rZW46ICdsYW5ndWFnZS5zdXBwb3J0LmNsYXNzJyxcbiAgICAgICAgcmVnZXg6ICcoPzpSKD86ZSg/OmdFeHB8ZmVyZW5jZUVycm9yKXxhbmdlRXJyb3IpfFMoPzp0cmluZ3x5bnRheEVycm9yKXxFKD86cnJvcnx2YWxFcnJvcil8QXJyYXl8Qm9vbGVhbnxEYXRlfEZ1bmN0aW9ufE51bWJlcnxPYmplY3R8VHlwZUVycm9yfFVSSUVycm9yKScgKyBrZXl3b3JkZW5kXG4gICAgICB9LCB7XG4gICAgICAgIHRva2VuOiAnbGFuZ3VhZ2Uuc3VwcG9ydC5mdW5jdGlvbicsXG4gICAgICAgIHJlZ2V4OiAnKD86aXMoPzpOYU58RmluaXRlKXxwYXJzZSg/OkludHxGbG9hdCl8TWF0aHxKU09OfCg/OmVufGRlKWNvZGVVUkkoPzpDb21wb25lbnQpPyknICsga2V5d29yZGVuZFxuICAgICAgfSwge1xuICAgICAgICB0b2tlbjogJ3ZhcmlhYmxlLmxhbmd1YWdlJyxcbiAgICAgICAgcmVnZXg6ICcoPzp0KD86aGF0fGlsfG8pfGYoPzpyb218YWxsdGhyb3VnaCl8aXR8Ynl8ZSknICsga2V5d29yZGVuZFxuICAgICAgfSwge1xuICAgICAgICB0b2tlbjogJ2lkZW50aWZpZXInLFxuICAgICAgICByZWdleDogaWRlbnRpZmllciArICdcXFxccyo6KD8hWzo9XSknXG4gICAgICB9LCB7XG4gICAgICAgIHRva2VuOiAndmFyaWFibGUnLFxuICAgICAgICByZWdleDogaWRlbnRpZmllclxuICAgICAgfSwge1xuICAgICAgICB0b2tlbjogJ2tleXdvcmQub3BlcmF0b3InLFxuICAgICAgICByZWdleDogJyg/OlxcXFwuezN9fFxcXFxzK1xcXFw/KSdcbiAgICAgIH0sIHtcbiAgICAgICAgdG9rZW46ICdrZXl3b3JkLnZhcmlhYmxlJyxcbiAgICAgICAgcmVnZXg6ICcoPzpAK3w6OnxcXFxcLlxcXFwuKScsXG4gICAgICAgIG5leHQ6ICdrZXknXG4gICAgICB9LCB7XG4gICAgICAgIHRva2VuOiAna2V5d29yZC5vcGVyYXRvcicsXG4gICAgICAgIHJlZ2V4OiAnXFxcXC5cXFxccyonLFxuICAgICAgICBuZXh0OiAna2V5J1xuICAgICAgfSwge1xuICAgICAgICB0b2tlbjogJ3N0cmluZycsXG4gICAgICAgIHJlZ2V4OiAnXFxcXFxcXFxcXFxcU1teXFxcXHMsOyl9XFxcXF1dKidcbiAgICAgIH0sIHtcbiAgICAgICAgdG9rZW46ICdzdHJpbmcuZG9jJyxcbiAgICAgICAgcmVnZXg6ICdcXCdcXCdcXCcnLFxuICAgICAgICBuZXh0OiAncWRvYydcbiAgICAgIH0sIHtcbiAgICAgICAgdG9rZW46ICdzdHJpbmcuZG9jJyxcbiAgICAgICAgcmVnZXg6ICdcIlwiXCInLFxuICAgICAgICBuZXh0OiAncXFkb2MnXG4gICAgICB9LCB7XG4gICAgICAgIHRva2VuOiAnc3RyaW5nJyxcbiAgICAgICAgcmVnZXg6ICdcXCcnLFxuICAgICAgICBuZXh0OiAncXN0cmluZydcbiAgICAgIH0sIHtcbiAgICAgICAgdG9rZW46ICdzdHJpbmcnLFxuICAgICAgICByZWdleDogJ1wiJyxcbiAgICAgICAgbmV4dDogJ3Fxc3RyaW5nJ1xuICAgICAgfSwge1xuICAgICAgICB0b2tlbjogJ3N0cmluZycsXG4gICAgICAgIHJlZ2V4OiAnYCcsXG4gICAgICAgIG5leHQ6ICdqcydcbiAgICAgIH0sIHtcbiAgICAgICAgdG9rZW46ICdzdHJpbmcnLFxuICAgICAgICByZWdleDogJzxcXFxcWycsXG4gICAgICAgIG5leHQ6ICd3b3JkcydcbiAgICAgIH0sIHtcbiAgICAgICAgdG9rZW46ICdzdHJpbmcucmVnZXgnLFxuICAgICAgICByZWdleDogJy8vJyxcbiAgICAgICAgbmV4dDogJ2hlcmVnZXgnXG4gICAgICB9LCB7XG4gICAgICAgIHRva2VuOiAnc3RyaW5nLnJlZ2V4JyxcbiAgICAgICAgcmVnZXg6ICdcXFxcLyg/OlteW1xcXFwvXFxcXG5cXFxcXFxcXF0qKD86KD86XFxcXFxcXFwufFxcXFxbW15cXFxcXVxcXFxuXFxcXFxcXFxdKig/OlxcXFxcXFxcLlteXFxcXF1cXFxcblxcXFxcXFxcXSopKlxcXFxdKVteW1xcXFwvXFxcXG5cXFxcXFxcXF0qKSopXFxcXC9bZ2lteSRdezAsNH0nLFxuICAgICAgICBuZXh0OiAna2V5J1xuICAgICAgfSwge1xuICAgICAgICB0b2tlbjogJ2NvbnN0YW50Lm51bWVyaWMnLFxuICAgICAgICByZWdleDogJyg/OjB4W1xcXFxkYS1mQS1GXVtcXFxcZGEtZkEtRl9dKnwoPzpbMi05XXxbMTJdXFxcXGR8M1swLTZdKXJbXFxcXGRhLXpBLVpdW1xcXFxkYS16QS1aX10qfCg/OlxcXFxkW1xcXFxkX10qKD86XFxcXC5cXFxcZFtcXFxcZF9dKik/fFxcXFwuXFxcXGRbXFxcXGRfXSopKD86ZVsrLV0/XFxcXGRbXFxcXGRfXSopP1tcXFxcdyRdKiknXG4gICAgICB9LCB7XG4gICAgICAgIHRva2VuOiAnbHBhcmVuJyxcbiAgICAgICAgcmVnZXg6ICdbKHtbXSdcbiAgICAgIH0sIHtcbiAgICAgICAgdG9rZW46ICdycGFyZW4nLFxuICAgICAgICByZWdleDogJ1spfVxcXFxdXScsXG4gICAgICAgIG5leHQ6ICdrZXknXG4gICAgICB9LCB7XG4gICAgICAgIHRva2VuOiAna2V5d29yZC5vcGVyYXRvcicsXG4gICAgICAgIHJlZ2V4OiAnXFxcXFMrJ1xuICAgICAgfSwge1xuICAgICAgICB0b2tlbjogJ3RleHQnLFxuICAgICAgICByZWdleDogJ1xcXFxzKydcbiAgICAgIH1cbiAgICBdLFxuICAgIGhlcmVnZXg6IFtcbiAgICAgIHtcbiAgICAgICAgdG9rZW46ICdzdHJpbmcucmVnZXgnLFxuICAgICAgICByZWdleDogJy4qPy8vW2dpbXkkP117MCw0fScsXG4gICAgICAgIG5leHQ6ICdzdGFydCdcbiAgICAgIH0sIHtcbiAgICAgICAgdG9rZW46ICdzdHJpbmcucmVnZXgnLFxuICAgICAgICByZWdleDogJ1xcXFxzKiN7J1xuICAgICAgfSwge1xuICAgICAgICB0b2tlbjogJ2NvbW1lbnQucmVnZXgnLFxuICAgICAgICByZWdleDogJ1xcXFxzKyg/OiMuKik/J1xuICAgICAgfSwge1xuICAgICAgICB0b2tlbjogJ3N0cmluZy5yZWdleCcsXG4gICAgICAgIHJlZ2V4OiAnXFxcXFMrJ1xuICAgICAgfVxuICAgIF0sXG4gICAga2V5OiBbXG4gICAgICB7XG4gICAgICAgIHRva2VuOiAna2V5d29yZC5vcGVyYXRvcicsXG4gICAgICAgIHJlZ2V4OiAnWy4/QCFdKydcbiAgICAgIH0sIHtcbiAgICAgICAgdG9rZW46ICdpZGVudGlmaWVyJyxcbiAgICAgICAgcmVnZXg6IGlkZW50aWZpZXIsXG4gICAgICAgIG5leHQ6ICdzdGFydCdcbiAgICAgIH0sIHtcbiAgICAgICAgdG9rZW46ICd0ZXh0JyxcbiAgICAgICAgcmVnZXg6ICcnLFxuICAgICAgICBuZXh0OiAnc3RhcnQnXG4gICAgICB9XG4gICAgXSxcbiAgICBjb21tZW50OiBbXG4gICAgICB7XG4gICAgICAgIHRva2VuOiAnY29tbWVudC5kb2MnLFxuICAgICAgICByZWdleDogJy4qP1xcXFwqLycsXG4gICAgICAgIG5leHQ6ICdzdGFydCdcbiAgICAgIH0sIHtcbiAgICAgICAgdG9rZW46ICdjb21tZW50LmRvYycsXG4gICAgICAgIHJlZ2V4OiAnLisnXG4gICAgICB9XG4gICAgXSxcbiAgICBxZG9jOiBbXG4gICAgICB7XG4gICAgICAgIHRva2VuOiAnc3RyaW5nJyxcbiAgICAgICAgcmVnZXg6IFwiLio/JycnXCIsXG4gICAgICAgIG5leHQ6ICdrZXknXG4gICAgICB9LCBzdHJpbmdmaWxsXG4gICAgXSxcbiAgICBxcWRvYzogW1xuICAgICAge1xuICAgICAgICB0b2tlbjogJ3N0cmluZycsXG4gICAgICAgIHJlZ2V4OiAnLio/XCJcIlwiJyxcbiAgICAgICAgbmV4dDogJ2tleSdcbiAgICAgIH0sIHN0cmluZ2ZpbGxcbiAgICBdLFxuICAgIHFzdHJpbmc6IFtcbiAgICAgIHtcbiAgICAgICAgdG9rZW46ICdzdHJpbmcnLFxuICAgICAgICByZWdleDogJ1teXFxcXFxcXFxcXCddKig/OlxcXFxcXFxcLlteXFxcXFxcXFxcXCddKikqXFwnJyxcbiAgICAgICAgbmV4dDogJ2tleSdcbiAgICAgIH0sIHN0cmluZ2ZpbGxcbiAgICBdLFxuICAgIHFxc3RyaW5nOiBbXG4gICAgICB7XG4gICAgICAgIHRva2VuOiAnc3RyaW5nJyxcbiAgICAgICAgcmVnZXg6ICdbXlxcXFxcXFxcXCJdKig/OlxcXFxcXFxcLlteXFxcXFxcXFxcIl0qKSpcIicsXG4gICAgICAgIG5leHQ6ICdrZXknXG4gICAgICB9LCBzdHJpbmdmaWxsXG4gICAgXSxcbiAgICBqczogW1xuICAgICAge1xuICAgICAgICB0b2tlbjogJ3N0cmluZycsXG4gICAgICAgIHJlZ2V4OiAnW15cXFxcXFxcXGBdKig/OlxcXFxcXFxcLlteXFxcXFxcXFxgXSopKmAnLFxuICAgICAgICBuZXh0OiAna2V5J1xuICAgICAgfSwgc3RyaW5nZmlsbFxuICAgIF0sXG4gICAgd29yZHM6IFtcbiAgICAgIHtcbiAgICAgICAgdG9rZW46ICdzdHJpbmcnLFxuICAgICAgICByZWdleDogJy4qP1xcXFxdPicsXG4gICAgICAgIG5leHQ6ICdrZXknXG4gICAgICB9LCBzdHJpbmdmaWxsXG4gICAgXVxuICB9O1xuICBmb3IgKHZhciBpZHggaW4gUnVsZXMpIHtcbiAgICB2YXIgciA9IFJ1bGVzW2lkeF07XG4gICAgaWYgKHIuc3BsaWNlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gci5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB2YXIgcnIgPSByW2ldO1xuICAgICAgICBpZiAodHlwZW9mIHJyLnJlZ2V4ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIFJ1bGVzW2lkeF1baV0ucmVnZXggPSBuZXcgUmVnRXhwKCdeJyArIHJyLnJlZ2V4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJyLnJlZ2V4ID09PSAnc3RyaW5nJykge1xuICAgICAgUnVsZXNbaWR4XS5yZWdleCA9IG5ldyBSZWdFeHAoJ14nICsgci5yZWdleCk7XG4gICAgfVxuICB9XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNSU1FKCd0ZXh0L3gtbGl2ZXNjcmlwdCcsICdsaXZlc2NyaXB0Jyk7XG5cbn0pO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuLy8gTFVBIG1vZGUuIFBvcnRlZCB0byBDb2RlTWlycm9yIDIgZnJvbSBGcmFuY2lzemVrIFdhd3J6YWsnc1xuLy8gQ29kZU1pcnJvciAxIG1vZGUuXG4vLyBoaWdobGlnaHRzIGtleXdvcmRzLCBzdHJpbmdzLCBjb21tZW50cyAobm8gbGV2ZWxpbmcgc3VwcG9ydGVkISAoXCJbPT1bXCIpKSwgdG9rZW5zLCBiYXNpYyBpbmRlbnRpbmdcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcblwidXNlIHN0cmljdFwiO1xuXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoXCJsdWFcIiwgZnVuY3Rpb24oY29uZmlnLCBwYXJzZXJDb25maWcpIHtcbiAgdmFyIGluZGVudFVuaXQgPSBjb25maWcuaW5kZW50VW5pdDtcblxuICBmdW5jdGlvbiBwcmVmaXhSRSh3b3Jkcykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiXig/OlwiICsgd29yZHMuam9pbihcInxcIikgKyBcIilcIiwgXCJpXCIpO1xuICB9XG4gIGZ1bmN0aW9uIHdvcmRSRSh3b3Jkcykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiXig/OlwiICsgd29yZHMuam9pbihcInxcIikgKyBcIikkXCIsIFwiaVwiKTtcbiAgfVxuICB2YXIgc3BlY2lhbHMgPSB3b3JkUkUocGFyc2VyQ29uZmlnLnNwZWNpYWxzIHx8IFtdKTtcblxuICAvLyBsb25nIGxpc3Qgb2Ygc3RhbmRhcmQgZnVuY3Rpb25zIGZyb20gbHVhIG1hbnVhbFxuICB2YXIgYnVpbHRpbnMgPSB3b3JkUkUoW1xuICAgIFwiX0dcIixcIl9WRVJTSU9OXCIsXCJhc3NlcnRcIixcImNvbGxlY3RnYXJiYWdlXCIsXCJkb2ZpbGVcIixcImVycm9yXCIsXCJnZXRmZW52XCIsXCJnZXRtZXRhdGFibGVcIixcImlwYWlyc1wiLFwibG9hZFwiLFxuICAgIFwibG9hZGZpbGVcIixcImxvYWRzdHJpbmdcIixcIm1vZHVsZVwiLFwibmV4dFwiLFwicGFpcnNcIixcInBjYWxsXCIsXCJwcmludFwiLFwicmF3ZXF1YWxcIixcInJhd2dldFwiLFwicmF3c2V0XCIsXCJyZXF1aXJlXCIsXG4gICAgXCJzZWxlY3RcIixcInNldGZlbnZcIixcInNldG1ldGF0YWJsZVwiLFwidG9udW1iZXJcIixcInRvc3RyaW5nXCIsXCJ0eXBlXCIsXCJ1bnBhY2tcIixcInhwY2FsbFwiLFxuXG4gICAgXCJjb3JvdXRpbmUuY3JlYXRlXCIsXCJjb3JvdXRpbmUucmVzdW1lXCIsXCJjb3JvdXRpbmUucnVubmluZ1wiLFwiY29yb3V0aW5lLnN0YXR1c1wiLFwiY29yb3V0aW5lLndyYXBcIixcImNvcm91dGluZS55aWVsZFwiLFxuXG4gICAgXCJkZWJ1Zy5kZWJ1Z1wiLFwiZGVidWcuZ2V0ZmVudlwiLFwiZGVidWcuZ2V0aG9va1wiLFwiZGVidWcuZ2V0aW5mb1wiLFwiZGVidWcuZ2V0bG9jYWxcIixcImRlYnVnLmdldG1ldGF0YWJsZVwiLFxuICAgIFwiZGVidWcuZ2V0cmVnaXN0cnlcIixcImRlYnVnLmdldHVwdmFsdWVcIixcImRlYnVnLnNldGZlbnZcIixcImRlYnVnLnNldGhvb2tcIixcImRlYnVnLnNldGxvY2FsXCIsXCJkZWJ1Zy5zZXRtZXRhdGFibGVcIixcbiAgICBcImRlYnVnLnNldHVwdmFsdWVcIixcImRlYnVnLnRyYWNlYmFja1wiLFxuXG4gICAgXCJjbG9zZVwiLFwiZmx1c2hcIixcImxpbmVzXCIsXCJyZWFkXCIsXCJzZWVrXCIsXCJzZXR2YnVmXCIsXCJ3cml0ZVwiLFxuXG4gICAgXCJpby5jbG9zZVwiLFwiaW8uZmx1c2hcIixcImlvLmlucHV0XCIsXCJpby5saW5lc1wiLFwiaW8ub3BlblwiLFwiaW8ub3V0cHV0XCIsXCJpby5wb3BlblwiLFwiaW8ucmVhZFwiLFwiaW8uc3RkZXJyXCIsXCJpby5zdGRpblwiLFxuICAgIFwiaW8uc3Rkb3V0XCIsXCJpby50bXBmaWxlXCIsXCJpby50eXBlXCIsXCJpby53cml0ZVwiLFxuXG4gICAgXCJtYXRoLmFic1wiLFwibWF0aC5hY29zXCIsXCJtYXRoLmFzaW5cIixcIm1hdGguYXRhblwiLFwibWF0aC5hdGFuMlwiLFwibWF0aC5jZWlsXCIsXCJtYXRoLmNvc1wiLFwibWF0aC5jb3NoXCIsXCJtYXRoLmRlZ1wiLFxuICAgIFwibWF0aC5leHBcIixcIm1hdGguZmxvb3JcIixcIm1hdGguZm1vZFwiLFwibWF0aC5mcmV4cFwiLFwibWF0aC5odWdlXCIsXCJtYXRoLmxkZXhwXCIsXCJtYXRoLmxvZ1wiLFwibWF0aC5sb2cxMFwiLFwibWF0aC5tYXhcIixcbiAgICBcIm1hdGgubWluXCIsXCJtYXRoLm1vZGZcIixcIm1hdGgucGlcIixcIm1hdGgucG93XCIsXCJtYXRoLnJhZFwiLFwibWF0aC5yYW5kb21cIixcIm1hdGgucmFuZG9tc2VlZFwiLFwibWF0aC5zaW5cIixcIm1hdGguc2luaFwiLFxuICAgIFwibWF0aC5zcXJ0XCIsXCJtYXRoLnRhblwiLFwibWF0aC50YW5oXCIsXG5cbiAgICBcIm9zLmNsb2NrXCIsXCJvcy5kYXRlXCIsXCJvcy5kaWZmdGltZVwiLFwib3MuZXhlY3V0ZVwiLFwib3MuZXhpdFwiLFwib3MuZ2V0ZW52XCIsXCJvcy5yZW1vdmVcIixcIm9zLnJlbmFtZVwiLFwib3Muc2V0bG9jYWxlXCIsXG4gICAgXCJvcy50aW1lXCIsXCJvcy50bXBuYW1lXCIsXG5cbiAgICBcInBhY2thZ2UuY3BhdGhcIixcInBhY2thZ2UubG9hZGVkXCIsXCJwYWNrYWdlLmxvYWRlcnNcIixcInBhY2thZ2UubG9hZGxpYlwiLFwicGFja2FnZS5wYXRoXCIsXCJwYWNrYWdlLnByZWxvYWRcIixcbiAgICBcInBhY2thZ2Uuc2VlYWxsXCIsXG5cbiAgICBcInN0cmluZy5ieXRlXCIsXCJzdHJpbmcuY2hhclwiLFwic3RyaW5nLmR1bXBcIixcInN0cmluZy5maW5kXCIsXCJzdHJpbmcuZm9ybWF0XCIsXCJzdHJpbmcuZ21hdGNoXCIsXCJzdHJpbmcuZ3N1YlwiLFxuICAgIFwic3RyaW5nLmxlblwiLFwic3RyaW5nLmxvd2VyXCIsXCJzdHJpbmcubWF0Y2hcIixcInN0cmluZy5yZXBcIixcInN0cmluZy5yZXZlcnNlXCIsXCJzdHJpbmcuc3ViXCIsXCJzdHJpbmcudXBwZXJcIixcblxuICAgIFwidGFibGUuY29uY2F0XCIsXCJ0YWJsZS5pbnNlcnRcIixcInRhYmxlLm1heG5cIixcInRhYmxlLnJlbW92ZVwiLFwidGFibGUuc29ydFwiXG4gIF0pO1xuICB2YXIga2V5d29yZHMgPSB3b3JkUkUoW1wiYW5kXCIsXCJicmVha1wiLFwiZWxzZWlmXCIsXCJmYWxzZVwiLFwibmlsXCIsXCJub3RcIixcIm9yXCIsXCJyZXR1cm5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICBcInRydWVcIixcImZ1bmN0aW9uXCIsIFwiZW5kXCIsIFwiaWZcIiwgXCJ0aGVuXCIsIFwiZWxzZVwiLCBcImRvXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aGlsZVwiLCBcInJlcGVhdFwiLCBcInVudGlsXCIsIFwiZm9yXCIsIFwiaW5cIiwgXCJsb2NhbFwiIF0pO1xuXG4gIHZhciBpbmRlbnRUb2tlbnMgPSB3b3JkUkUoW1wiZnVuY3Rpb25cIiwgXCJpZlwiLFwicmVwZWF0XCIsXCJkb1wiLCBcIlxcXFwoXCIsIFwie1wiXSk7XG4gIHZhciBkZWRlbnRUb2tlbnMgPSB3b3JkUkUoW1wiZW5kXCIsIFwidW50aWxcIiwgXCJcXFxcKVwiLCBcIn1cIl0pO1xuICB2YXIgZGVkZW50UGFydGlhbCA9IHByZWZpeFJFKFtcImVuZFwiLCBcInVudGlsXCIsIFwiXFxcXClcIiwgXCJ9XCIsIFwiZWxzZVwiLCBcImVsc2VpZlwiXSk7XG5cbiAgZnVuY3Rpb24gcmVhZEJyYWNrZXQoc3RyZWFtKSB7XG4gICAgdmFyIGxldmVsID0gMDtcbiAgICB3aGlsZSAoc3RyZWFtLmVhdChcIj1cIikpICsrbGV2ZWw7XG4gICAgc3RyZWFtLmVhdChcIltcIik7XG4gICAgcmV0dXJuIGxldmVsO1xuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICAgIGlmIChjaCA9PSBcIi1cIiAmJiBzdHJlYW0uZWF0KFwiLVwiKSkge1xuICAgICAgaWYgKHN0cmVhbS5lYXQoXCJbXCIpICYmIHN0cmVhbS5lYXQoXCJbXCIpKVxuICAgICAgICByZXR1cm4gKHN0YXRlLmN1ciA9IGJyYWNrZXRlZChyZWFkQnJhY2tldChzdHJlYW0pLCBcImNvbW1lbnRcIikpKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgIH1cbiAgICBpZiAoY2ggPT0gXCJcXFwiXCIgfHwgY2ggPT0gXCInXCIpXG4gICAgICByZXR1cm4gKHN0YXRlLmN1ciA9IHN0cmluZyhjaCkpKHN0cmVhbSwgc3RhdGUpO1xuICAgIGlmIChjaCA9PSBcIltcIiAmJiAvW1xcWz1dLy50ZXN0KHN0cmVhbS5wZWVrKCkpKVxuICAgICAgcmV0dXJuIChzdGF0ZS5jdXIgPSBicmFja2V0ZWQocmVhZEJyYWNrZXQoc3RyZWFtKSwgXCJzdHJpbmdcIikpKHN0cmVhbSwgc3RhdGUpO1xuICAgIGlmICgvXFxkLy50ZXN0KGNoKSkge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3LiVdLyk7XG4gICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICB9XG4gICAgaWYgKC9bXFx3X10vLnRlc3QoY2gpKSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXFxcXFwtXy5dLyk7XG4gICAgICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJyYWNrZXRlZChsZXZlbCwgc3R5bGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIGN1cmxldiA9IG51bGwsIGNoO1xuICAgICAgd2hpbGUgKChjaCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGN1cmxldiA9PSBudWxsKSB7aWYgKGNoID09IFwiXVwiKSBjdXJsZXYgPSAwO31cbiAgICAgICAgZWxzZSBpZiAoY2ggPT0gXCI9XCIpICsrY3VybGV2O1xuICAgICAgICBlbHNlIGlmIChjaCA9PSBcIl1cIiAmJiBjdXJsZXYgPT0gbGV2ZWwpIHsgc3RhdGUuY3VyID0gbm9ybWFsOyBicmVhazsgfVxuICAgICAgICBlbHNlIGN1cmxldiA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0cmluZyhxdW90ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgZXNjYXBlZCA9IGZhbHNlLCBjaDtcbiAgICAgIHdoaWxlICgoY2ggPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChjaCA9PSBxdW90ZSAmJiAhZXNjYXBlZCkgYnJlYWs7XG4gICAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZCAmJiBjaCA9PSBcIlxcXFxcIjtcbiAgICAgIH1cbiAgICAgIGlmICghZXNjYXBlZCkgc3RhdGUuY3VyID0gbm9ybWFsO1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oYmFzZWNvbCkge1xuICAgICAgcmV0dXJuIHtiYXNlY29sOiBiYXNlY29sIHx8IDAsIGluZGVudERlcHRoOiAwLCBjdXI6IG5vcm1hbH07XG4gICAgfSxcblxuICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xuICAgICAgdmFyIHN0eWxlID0gc3RhdGUuY3VyKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgdmFyIHdvcmQgPSBzdHJlYW0uY3VycmVudCgpO1xuICAgICAgaWYgKHN0eWxlID09IFwidmFyaWFibGVcIikge1xuICAgICAgICBpZiAoa2V5d29yZHMudGVzdCh3b3JkKSkgc3R5bGUgPSBcImtleXdvcmRcIjtcbiAgICAgICAgZWxzZSBpZiAoYnVpbHRpbnMudGVzdCh3b3JkKSkgc3R5bGUgPSBcImJ1aWx0aW5cIjtcbiAgICAgICAgZWxzZSBpZiAoc3BlY2lhbHMudGVzdCh3b3JkKSkgc3R5bGUgPSBcInZhcmlhYmxlLTJcIjtcbiAgICAgIH1cbiAgICAgIGlmICgoc3R5bGUgIT0gXCJjb21tZW50XCIpICYmIChzdHlsZSAhPSBcInN0cmluZ1wiKSl7XG4gICAgICAgIGlmIChpbmRlbnRUb2tlbnMudGVzdCh3b3JkKSkgKytzdGF0ZS5pbmRlbnREZXB0aDtcbiAgICAgICAgZWxzZSBpZiAoZGVkZW50VG9rZW5zLnRlc3Qod29yZCkpIC0tc3RhdGUuaW5kZW50RGVwdGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfSxcblxuICAgIGluZGVudDogZnVuY3Rpb24oc3RhdGUsIHRleHRBZnRlcikge1xuICAgICAgdmFyIGNsb3NpbmcgPSBkZWRlbnRQYXJ0aWFsLnRlc3QodGV4dEFmdGVyKTtcbiAgICAgIHJldHVybiBzdGF0ZS5iYXNlY29sICsgaW5kZW50VW5pdCAqIChzdGF0ZS5pbmRlbnREZXB0aCAtIChjbG9zaW5nID8gMSA6IDApKTtcbiAgICB9LFxuXG4gICAgZWxlY3RyaWNJbnB1dDogL15cXHMqKD86ZW5kfHVudGlsfGVsc2V8XFwpfFxcfSkkLyxcbiAgICBsaW5lQ29tbWVudDogXCItLVwiLFxuICAgIGJsb2NrQ29tbWVudFN0YXJ0OiBcIi0tW1tcIixcbiAgICBibG9ja0NvbW1lbnRFbmQ6IFwiXV1cIlxuICB9O1xufSk7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQveC1sdWFcIiwgXCJsdWFcIik7XG5cbn0pO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuLy8gTWF0aGVtYXRpY2EgbW9kZSBjb3B5cmlnaHQgKGMpIDIwMTUgYnkgQ2FsaW4gQmFyYmF0XG4vLyBCYXNlZCBvbiBjb2RlIGJ5IFBhdHJpY2sgU2NoZWliZSAoaGFsaXJ1dGFuKVxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vaGFsaXJ1dGFuL01hdGhlbWF0aWNhLVNvdXJjZS1IaWdobGlnaHRpbmcvdHJlZS9tYXN0ZXIvc3JjL2xhbmctbW1hLmpzXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuQ29kZU1pcnJvci5kZWZpbmVNb2RlKCdtYXRoZW1hdGljYScsIGZ1bmN0aW9uKF9jb25maWcsIF9wYXJzZXJDb25maWcpIHtcblxuICAvLyB1c2VkIHBhdHRlcm4gYnVpbGRpbmcgYmxvY2tzXG4gIHZhciBJZGVudGlmaWVyID0gJ1thLXpBLVpcXFxcJF1bYS16QS1aMC05XFxcXCRdKic7XG4gIHZhciBwQmFzZSAgICAgID0gXCIoPzpcXFxcZCspXCI7XG4gIHZhciBwRmxvYXQgICAgID0gXCIoPzpcXFxcLlxcXFxkK3xcXFxcZCtcXFxcLlxcXFxkKnxcXFxcZCspXCI7XG4gIHZhciBwRmxvYXRCYXNlID0gXCIoPzpcXFxcLlxcXFx3K3xcXFxcdytcXFxcLlxcXFx3KnxcXFxcdyspXCI7XG4gIHZhciBwUHJlY2lzaW9uID0gXCIoPzpgKD86YD9cIitwRmxvYXQrXCIpPylcIjtcblxuICAvLyByZWd1bGFyIGV4cHJlc3Npb25zXG4gIHZhciByZUJhc2VGb3JtICAgICAgICA9IG5ldyBSZWdFeHAoJyg/OicrcEJhc2UrJyg/OlxcXFxeXFxcXF4nK3BGbG9hdEJhc2UrcFByZWNpc2lvbisnPyg/OlxcXFwqXFxcXF5bKy1dP1xcXFxkKyk/KSknKTtcbiAgdmFyIHJlRmxvYXRGb3JtICAgICAgID0gbmV3IFJlZ0V4cCgnKD86JyArIHBGbG9hdCArIHBQcmVjaXNpb24gKyAnPyg/OlxcXFwqXFxcXF5bKy1dP1xcXFxkKyk/KScpO1xuICB2YXIgcmVJZEluQ29udGV4dCAgICAgPSBuZXcgUmVnRXhwKCcoPzpgPykoPzonICsgSWRlbnRpZmllciArICcpKD86YCg/OicgKyBJZGVudGlmaWVyICsgJykpKig/OmA/KScpO1xuXG4gIGZ1bmN0aW9uIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGNoO1xuXG4gICAgLy8gZ2V0IG5leHQgY2hhcmFjdGVyXG4gICAgY2ggPSBzdHJlYW0ubmV4dCgpO1xuXG4gICAgLy8gc3RyaW5nXG4gICAgaWYgKGNoID09PSAnXCInKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuU3RyaW5nO1xuICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIC8vIGNvbW1lbnRcbiAgICBpZiAoY2ggPT09ICcoJykge1xuICAgICAgaWYgKHN0cmVhbS5lYXQoJyonKSkge1xuICAgICAgICBzdGF0ZS5jb21tZW50TGV2ZWwrKztcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkNvbW1lbnQ7XG4gICAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBnbyBiYWNrIG9uZSBjaGFyYWN0ZXJcbiAgICBzdHJlYW0uYmFja1VwKDEpO1xuXG4gICAgLy8gbG9vayBmb3IgbnVtYmVyc1xuICAgIC8vIE51bWJlcnMgaW4gYSBiYXNlZm9ybVxuICAgIGlmIChzdHJlYW0ubWF0Y2gocmVCYXNlRm9ybSwgdHJ1ZSwgZmFsc2UpKSB7XG4gICAgICByZXR1cm4gJ251bWJlcic7XG4gICAgfVxuXG4gICAgLy8gTWF0aGVtYXRpY2EgbnVtYmVycy4gRmxvYXRzICgxLjIsIC4yLCAxLikgY2FuIGhhdmUgb3B0aW9uYWxseSBhIHByZWNpc2lvbiAoYGZsb2F0KSBvciBhbiBhY2N1cmFjeSBkZWZpbml0aW9uXG4gICAgLy8gKGBgZmxvYXQpLiBOb3RlOiB3aGlsZSAxLjJgIGlzIHBvc3NpYmxlIDEuMmBgIGlzIG5vdC4gQXQgdGhlIGVuZCBhbiBleHBvbmVudCAoZmxvYXQqXisxMikgY2FuIGZvbGxvdy5cbiAgICBpZiAoc3RyZWFtLm1hdGNoKHJlRmxvYXRGb3JtLCB0cnVlLCBmYWxzZSkpIHtcbiAgICAgIHJldHVybiAnbnVtYmVyJztcbiAgICB9XG5cbiAgICAvKiBJblsyM10gYW5kIE91dFszNF0gKi9cbiAgICBpZiAoc3RyZWFtLm1hdGNoKC8oPzpJbnxPdXQpXFxbWzAtOV0qXFxdLywgdHJ1ZSwgZmFsc2UpKSB7XG4gICAgICByZXR1cm4gJ2F0b20nO1xuICAgIH1cblxuICAgIC8vIHVzYWdlXG4gICAgaWYgKHN0cmVhbS5tYXRjaCgvKFthLXpBLVpcXCRdW2EtekEtWjAtOVxcJF0qKD86YFthLXpBLVowLTlcXCRdKykqOjp1c2FnZSkvLCB0cnVlLCBmYWxzZSkpIHtcbiAgICAgIHJldHVybiAnbWV0YSc7XG4gICAgfVxuXG4gICAgLy8gbWVzc2FnZVxuICAgIGlmIChzdHJlYW0ubWF0Y2goLyhbYS16QS1aXFwkXVthLXpBLVowLTlcXCRdKig/OmBbYS16QS1aMC05XFwkXSspKjo6W2EtekEtWlxcJF1bYS16QS1aMC05XFwkXSopOj8vLCB0cnVlLCBmYWxzZSkpIHtcbiAgICAgIHJldHVybiAnc3RyaW5nLTInO1xuICAgIH1cblxuICAgIC8vIHRoaXMgbWFrZXMgYSBsb29rLWFoZWFkIG1hdGNoIGZvciBzb21ldGhpbmcgbGlrZSB2YXJpYWJsZTp7X0ludGVnZXJ9XG4gICAgLy8gdGhlIG1hdGNoIGlzIHRoZW4gZm9yd2FyZGVkIHRvIHRoZSBtbWEtcGF0dGVybnMgdG9rZW5pemVyLlxuICAgIGlmIChzdHJlYW0ubWF0Y2goLyhbYS16QS1aXFwkXVthLXpBLVowLTlcXCRdKlxccyo6KSg/Oig/OlthLXpBLVpcXCRdW2EtekEtWjAtOVxcJF0qKXwoPzpbXjo9Pn5AXFxeXFwmXFwqXFwpXFxbXFxdJ1xcPyxcXHxdKSkuKi8sIHRydWUsIGZhbHNlKSkge1xuICAgICAgcmV0dXJuICd2YXJpYWJsZS0yJztcbiAgICB9XG5cbiAgICAvLyBjYXRjaCB2YXJpYWJsZXMgd2hpY2ggYXJlIHVzZWQgdG9nZXRoZXIgd2l0aCBCbGFuayAoXyksIEJsYW5rU2VxdWVuY2UgKF9fKSBvciBCbGFua051bGxTZXF1ZW5jZSAoX19fKVxuICAgIC8vIENhbm5vdCBzdGFydCB3aXRoIGEgbnVtYmVyLCBidXQgY2FuIGhhdmUgbnVtYmVycyBhdCBhbnkgb3RoZXIgcG9zaXRpb24uIEV4YW1wbGVzXG4gICAgLy8gYmx1Yl9fSW50ZWdlciwgYTFfLCBiMzRfSW50ZWdlcjMyXG4gICAgaWYgKHN0cmVhbS5tYXRjaCgvW2EtekEtWlxcJF1bYS16QS1aMC05XFwkXSpfK1thLXpBLVpcXCRdW2EtekEtWjAtOVxcJF0qLywgdHJ1ZSwgZmFsc2UpKSB7XG4gICAgICByZXR1cm4gJ3ZhcmlhYmxlLTInO1xuICAgIH1cbiAgICBpZiAoc3RyZWFtLm1hdGNoKC9bYS16QS1aXFwkXVthLXpBLVowLTlcXCRdKl8rLywgdHJ1ZSwgZmFsc2UpKSB7XG4gICAgICByZXR1cm4gJ3ZhcmlhYmxlLTInO1xuICAgIH1cbiAgICBpZiAoc3RyZWFtLm1hdGNoKC9fK1thLXpBLVpcXCRdW2EtekEtWjAtOVxcJF0qLywgdHJ1ZSwgZmFsc2UpKSB7XG4gICAgICByZXR1cm4gJ3ZhcmlhYmxlLTInO1xuICAgIH1cblxuICAgIC8vIE5hbWVkIGNoYXJhY3RlcnMgaW4gTWF0aGVtYXRpY2EsIGxpa2UgXFxbR2FtbWFdLlxuICAgIGlmIChzdHJlYW0ubWF0Y2goL1xcXFxcXFtbYS16QS1aXFwkXVthLXpBLVowLTlcXCRdKlxcXS8sIHRydWUsIGZhbHNlKSkge1xuICAgICAgcmV0dXJuICd2YXJpYWJsZS0zJztcbiAgICB9XG5cbiAgICAvLyBNYXRjaCBhbGwgYnJhY2VzIHNlcGFyYXRlbHlcbiAgICBpZiAoc3RyZWFtLm1hdGNoKC8oPzpcXFt8XFxdfHt8fXxcXCh8XFwpKS8sIHRydWUsIGZhbHNlKSkge1xuICAgICAgcmV0dXJuICdicmFja2V0JztcbiAgICB9XG5cbiAgICAvLyBDYXRjaCBTbG90cyAoIywgIyMsICMzLCAjIzkgYW5kIHRoZSBWMTAgbmFtZWQgc2xvdHMgI25hbWUpLiBJIGhhdmUgbmV2ZXIgc2VlbiBzb21lb25lIHVzaW5nIG1vcmUgdGhhbiBvbmUgZGlnaXQgYWZ0ZXIgIywgc28gd2UgbWF0Y2hcbiAgICAvLyBvbmx5IG9uZS5cbiAgICBpZiAoc3RyZWFtLm1hdGNoKC8oPzojW2EtekEtWlxcJF1bYS16QS1aMC05XFwkXSp8IytbMC05XT8pLywgdHJ1ZSwgZmFsc2UpKSB7XG4gICAgICByZXR1cm4gJ3ZhcmlhYmxlLTInO1xuICAgIH1cblxuICAgIC8vIExpdGVyYWxzIGxpa2UgdmFyaWFibGVzLCBrZXl3b3JkcywgZnVuY3Rpb25zXG4gICAgaWYgKHN0cmVhbS5tYXRjaChyZUlkSW5Db250ZXh0LCB0cnVlLCBmYWxzZSkpIHtcbiAgICAgIHJldHVybiAna2V5d29yZCc7XG4gICAgfVxuXG4gICAgLy8gb3BlcmF0b3JzLiBOb3RlIHRoYXQgb3BlcmF0b3JzIGxpa2UgQEAgb3IgLzsgYXJlIG1hdGNoZWQgc2VwYXJhdGVseSBmb3IgZWFjaCBzeW1ib2wuXG4gICAgaWYgKHN0cmVhbS5tYXRjaCgvKD86XFxcXHxcXCt8XFwtfFxcKnxcXC98LHw7fFxcLnw6fEB8fnw9fD58PHwmfFxcfHxffGB8J3xcXF58XFw/fCF8JSkvLCB0cnVlLCBmYWxzZSkpIHtcbiAgICAgIHJldHVybiAnb3BlcmF0b3InO1xuICAgIH1cblxuICAgIC8vIGV2ZXJ5dGhpbmcgZWxzZSBpcyBhbiBlcnJvclxuICAgIHN0cmVhbS5uZXh0KCk7IC8vIGFkdmFuY2UgdGhlIHN0cmVhbS5cbiAgICByZXR1cm4gJ2Vycm9yJztcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuU3RyaW5nKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgbmV4dCwgZW5kID0gZmFsc2UsIGVzY2FwZWQgPSBmYWxzZTtcbiAgICB3aGlsZSAoKG5leHQgPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICBpZiAobmV4dCA9PT0gJ1wiJyAmJiAhZXNjYXBlZCkge1xuICAgICAgICBlbmQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZCAmJiBuZXh0ID09PSAnXFxcXCc7XG4gICAgfVxuICAgIGlmIChlbmQgJiYgIWVzY2FwZWQpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgIH1cbiAgICByZXR1cm4gJ3N0cmluZyc7XG4gIH07XG5cbiAgZnVuY3Rpb24gdG9rZW5Db21tZW50KHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgcHJldiwgbmV4dDtcbiAgICB3aGlsZShzdGF0ZS5jb21tZW50TGV2ZWwgPiAwICYmIChuZXh0ID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgaWYgKHByZXYgPT09ICcoJyAmJiBuZXh0ID09PSAnKicpIHN0YXRlLmNvbW1lbnRMZXZlbCsrO1xuICAgICAgaWYgKHByZXYgPT09ICcqJyAmJiBuZXh0ID09PSAnKScpIHN0YXRlLmNvbW1lbnRMZXZlbC0tO1xuICAgICAgcHJldiA9IG5leHQ7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5jb21tZW50TGV2ZWwgPD0gMCkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgfVxuICAgIHJldHVybiAnY29tbWVudCc7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKCkge3JldHVybiB7dG9rZW5pemU6IHRva2VuQmFzZSwgY29tbWVudExldmVsOiAwfTt9LFxuICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xuICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIH0sXG4gICAgYmxvY2tDb21tZW50U3RhcnQ6IFwiKCpcIixcbiAgICBibG9ja0NvbW1lbnRFbmQ6IFwiKilcIlxuICB9O1xufSk7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTUlNRSgndGV4dC94LW1hdGhlbWF0aWNhJywge1xuICBuYW1lOiAnbWF0aGVtYXRpY2EnXG59KTtcblxufSk7XG4iLCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciByZmMyODIyID0gW1xuICBcIkZyb21cIiwgXCJTZW5kZXJcIiwgXCJSZXBseS1Ub1wiLCBcIlRvXCIsIFwiQ2NcIiwgXCJCY2NcIiwgXCJNZXNzYWdlLUlEXCIsXG4gIFwiSW4tUmVwbHktVG9cIiwgXCJSZWZlcmVuY2VzXCIsIFwiUmVzZW50LUZyb21cIiwgXCJSZXNlbnQtU2VuZGVyXCIsIFwiUmVzZW50LVRvXCIsXG4gIFwiUmVzZW50LUNjXCIsIFwiUmVzZW50LUJjY1wiLCBcIlJlc2VudC1NZXNzYWdlLUlEXCIsIFwiUmV0dXJuLVBhdGhcIiwgXCJSZWNlaXZlZFwiXG5dO1xudmFyIHJmYzI4MjJOb0VtYWlsID0gW1xuICBcIkRhdGVcIiwgXCJTdWJqZWN0XCIsIFwiQ29tbWVudHNcIiwgXCJLZXl3b3Jkc1wiLCBcIlJlc2VudC1EYXRlXCJcbl07XG5cbkNvZGVNaXJyb3IucmVnaXN0ZXJIZWxwZXIoXCJoaW50V29yZHNcIiwgXCJtYm94XCIsIHJmYzI4MjIuY29uY2F0KHJmYzI4MjJOb0VtYWlsKSk7XG5cbnZhciB3aGl0ZXNwYWNlID0gL15bIFxcdF0vO1xudmFyIHNlcGFyYXRvciA9IC9eRnJvbSAvOyAvLyBTZWUgUkZDIDQxNTVcbnZhciByZmMyODIySGVhZGVyID0gbmV3IFJlZ0V4cChcIl4oXCIgKyByZmMyODIyLmpvaW4oXCJ8XCIpICsgXCIpOiBcIik7XG52YXIgcmZjMjgyMkhlYWRlck5vRW1haWwgPSBuZXcgUmVnRXhwKFwiXihcIiArIHJmYzI4MjJOb0VtYWlsLmpvaW4oXCJ8XCIpICsgXCIpOiBcIik7XG52YXIgaGVhZGVyID0gL15bXjpdKzovOyAvLyBPcHRpb25hbCBmaWVsZHMgZGVmaW5lZCBpbiBSRkMgMjgyMlxudmFyIGVtYWlsID0gL15bXiBdK0BbXiBdKy87XG52YXIgdW50aWxFbWFpbCA9IC9eLio/KD89W14gXSs/QFteIF0rKS87XG52YXIgYnJhY2tldGVkRW1haWwgPSAvXjwuKj8+LztcbnZhciB1bnRpbEJyYWNrZXRlZEVtYWlsID0gL14uKj8oPz08Lio+KS87XG5cbmZ1bmN0aW9uIHN0eWxlRm9ySGVhZGVyKGhlYWRlcikge1xuICBpZiAoaGVhZGVyID09PSBcIlN1YmplY3RcIikgcmV0dXJuIFwiaGVhZGVyXCI7XG4gIHJldHVybiBcInN0cmluZ1wiO1xufVxuXG5mdW5jdGlvbiByZWFkVG9rZW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RyZWFtLnNvbCgpKSB7XG4gICAgLy8gRnJvbSBsYXN0IGxpbmVcbiAgICBzdGF0ZS5pblNlcGFyYXRvciA9IGZhbHNlO1xuICAgIGlmIChzdGF0ZS5pbkhlYWRlciAmJiBzdHJlYW0ubWF0Y2god2hpdGVzcGFjZSkpIHtcbiAgICAgIC8vIEhlYWRlciBmb2xkaW5nXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuaW5IZWFkZXIgPSBmYWxzZTtcbiAgICAgIHN0YXRlLmhlYWRlciA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHN0cmVhbS5tYXRjaChzZXBhcmF0b3IpKSB7XG4gICAgICBzdGF0ZS5pbkhlYWRlcnMgPSB0cnVlO1xuICAgICAgc3RhdGUuaW5TZXBhcmF0b3IgPSB0cnVlO1xuICAgICAgcmV0dXJuIFwiYXRvbVwiO1xuICAgIH1cblxuICAgIHZhciBtYXRjaDtcbiAgICB2YXIgZW1haWxQZXJtaXR0ZWQgPSBmYWxzZTtcbiAgICBpZiAoKG1hdGNoID0gc3RyZWFtLm1hdGNoKHJmYzI4MjJIZWFkZXJOb0VtYWlsKSkgfHxcbiAgICAgICAgKGVtYWlsUGVybWl0dGVkID0gdHJ1ZSkgJiYgKG1hdGNoID0gc3RyZWFtLm1hdGNoKHJmYzI4MjJIZWFkZXIpKSkge1xuICAgICAgc3RhdGUuaW5IZWFkZXJzID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmluSGVhZGVyID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtYWlsUGVybWl0dGVkID0gZW1haWxQZXJtaXR0ZWQ7XG4gICAgICBzdGF0ZS5oZWFkZXIgPSBtYXRjaFsxXTtcbiAgICAgIHJldHVybiBcImF0b21cIjtcbiAgICB9XG5cbiAgICAvLyBVc2UgdmltJ3MgaGV1cmlzdGljczogcmVjb2duaXplIGN1c3RvbSBoZWFkZXJzIG9ubHkgaWYgdGhlIGxpbmUgaXMgaW4gYVxuICAgIC8vIGJsb2NrIG9mIGxlZ2l0aW1hdGUgaGVhZGVycy5cbiAgICBpZiAoc3RhdGUuaW5IZWFkZXJzICYmIChtYXRjaCA9IHN0cmVhbS5tYXRjaChoZWFkZXIpKSkge1xuICAgICAgc3RhdGUuaW5IZWFkZXIgPSB0cnVlO1xuICAgICAgc3RhdGUuZW1haWxQZXJtaXR0ZWQgPSB0cnVlO1xuICAgICAgc3RhdGUuaGVhZGVyID0gbWF0Y2hbMV07XG4gICAgICByZXR1cm4gXCJhdG9tXCI7XG4gICAgfVxuXG4gICAgc3RhdGUuaW5IZWFkZXJzID0gZmFsc2U7XG4gICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHN0YXRlLmluU2VwYXJhdG9yKSB7XG4gICAgaWYgKHN0cmVhbS5tYXRjaChlbWFpbCkpIHJldHVybiBcImxpbmtcIjtcbiAgICBpZiAoc3RyZWFtLm1hdGNoKHVudGlsRW1haWwpKSByZXR1cm4gXCJhdG9tXCI7XG4gICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgIHJldHVybiBcImF0b21cIjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5pbkhlYWRlcikge1xuICAgIHZhciBzdHlsZSA9IHN0eWxlRm9ySGVhZGVyKHN0YXRlLmhlYWRlcik7XG5cbiAgICBpZiAoc3RhdGUuZW1haWxQZXJtaXR0ZWQpIHtcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goYnJhY2tldGVkRW1haWwpKSByZXR1cm4gc3R5bGUgKyBcIiBsaW5rXCI7XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKHVudGlsQnJhY2tldGVkRW1haWwpKSByZXR1cm4gc3R5bGU7XG4gICAgfVxuICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cblxuICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gIHJldHVybiBudWxsO1xufTtcblxuQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwibWJveFwiLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC8vIElzIGluIGEgbWJveCBzZXBhcmF0b3JcbiAgICAgICAgaW5TZXBhcmF0b3I6IGZhbHNlLFxuICAgICAgICAvLyBJcyBpbiBhIG1haWwgaGVhZGVyXG4gICAgICAgIGluSGVhZGVyOiBmYWxzZSxcbiAgICAgICAgLy8gSWYgYnJhY2tldGVkIGVtYWlsIGlzIHBlcm1pdHRlZC4gT25seSBhcHBsaWNhYmxlIHdoZW4gaW5IZWFkZXJcbiAgICAgICAgZW1haWxQZXJtaXR0ZWQ6IGZhbHNlLFxuICAgICAgICAvLyBOYW1lIG9mIGN1cnJlbnQgaGVhZGVyXG4gICAgICAgIGhlYWRlcjogbnVsbCxcbiAgICAgICAgLy8gSXMgaW4gYSByZWdpb24gb2YgbWFpbCBoZWFkZXJzXG4gICAgICAgIGluSGVhZGVyczogZmFsc2VcbiAgICAgIH07XG4gICAgfSxcbiAgICB0b2tlbjogcmVhZFRva2VuLFxuICAgIGJsYW5rTGluZTogZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgIHN0YXRlLmluSGVhZGVycyA9IHN0YXRlLmluU2VwYXJhdG9yID0gc3RhdGUuaW5IZWFkZXIgPSBmYWxzZTtcbiAgICB9XG4gIH07XG59KTtcblxuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwiYXBwbGljYXRpb24vbWJveFwiLCBcIm1ib3hcIik7XG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbi8vbUlSQyBtb2RlIGJ5IEZvcmRfTGF3bm1vd2VyIDo6IEJhc2VkIG9uIFZlbG9jaXR5IG1vZGUgYnkgU3RldmUgTydIYXJhXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC9taXJjXCIsIFwibWlyY1wiKTtcbkNvZGVNaXJyb3IuZGVmaW5lTW9kZShcIm1pcmNcIiwgZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIHBhcnNlV29yZHMoc3RyKSB7XG4gICAgdmFyIG9iaiA9IHt9LCB3b3JkcyA9IHN0ci5zcGxpdChcIiBcIik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7ICsraSkgb2JqW3dvcmRzW2ldXSA9IHRydWU7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICB2YXIgc3BlY2lhbHMgPSBwYXJzZVdvcmRzKFwiJCEgJCQgJCYgJD8gJCsgJGFib29rICRhYnMgJGFjdGl2ZSAkYWN0aXZlY2lkIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiRhY3RpdmV3aWQgJGFkZHJlc3MgJGFkZHRvayAkYWdlbnQgJGFnZW50bmFtZSAkYWdlbnRzdGF0ICRhZ2VudHZlciBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIkYWxpYXMgJGFuZCAkYW5pY2sgJGFuc2kybWlyYyAkYW9wICRhcHBhY3RpdmUgJGFwcHN0YXRlICRhc2MgJGFzY3RpbWUgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiJGFzaW4gJGF0YW4gJGF2b2ljZSAkYXdheSAkYXdheW1zZyAkYXdheXRpbWUgJGJhbm1hc2sgJGJhc2UgJGJmaW5kIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiRiaW5vZmYgJGJpdG9uICRibmljayAkYnZhciAkYnl0ZXMgJGNhbGMgJGNiICRjZCAkY2VpbCAkY2hhbiAkY2hhbm1vZGVzIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiRjaGFudHlwZXMgJGNoYXQgJGNociAkY2lkICRjbGV2ZWwgJGNsaWNrICRjbWRib3ggJGNtZGxpbmUgJGNuaWNrICRjb2xvciBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIkY29tICRjb21jYWxsICRjb21jaGFuICRjb21lcnIgJGNvbXBhY3QgJGNvbXByZXNzICRjb212YWwgJGNvcyAkY291bnQgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiJGNyICRjcmMgJGNyZXEgJGNybGYgJGN0aW1lICRjdGltZXIgJGN0cmxlbnRlciAkZGF0ZSAkZGF5ICRkYXlsaWdodCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIkZGJ1aCAkZGJ1dyAkZGNjaWdub3JlICRkY2Nwb3J0ICRkZGUgJGRkZW5hbWUgJGRlYnVnICRkZWNvZGUgJGRlY29tcHJlc3MgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiJGRlbHRvayAkZGV2ZW50ICRkaWFsb2cgJGRpZCAkZGlkcmVnICRkaWR0b2sgJGRpZHdtICRkaXNrICRkbGV2ZWwgJGRsbCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIkZGxsY2FsbCAkZG5hbWUgJGRucyAkZHVyYXRpb24gJGViZWVwcyAkZWRpdGJveCAkZW1haWxhZGRyICRlbmNvZGUgJGVycm9yIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiRldmFsICRldmVudCAkZXhpc3QgJGZlb2YgJGZlcnIgJGZnZXRjICRmaWxlICRmaWxlbmFtZSAkZmlsdGVyZWQgJGZpbmRkaXIgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiJGZpbmRkaXJuICRmaW5kZmlsZSAkZmluZGZpbGVuICRmaW5kdG9rICRmbGluZSAkZmxvb3IgJGZvcGVuICRmcmVhZCAkZnNlcnZlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiRmdWxsYWRkcmVzcyAkZnVsbGRhdGUgJGZ1bGxuYW1lICRmdWxsc2NyZWVuICRnZXQgJGdldGRpciAkZ2V0ZG90ICRnZXR0b2sgJGdtdCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIkZ3JvdXAgJGhhbHRlZCAkaGFzaCAkaGVpZ2h0ICRoZmluZCAkaGdldCAkaGlnaGxpZ2h0ICRobmljayAkaG90bGluZSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIkaG90bGluZXBvcyAkaWFsICRpYWxjaGFuICRpYmwgJGlkbGUgJGllbCAkaWZtYXRjaCAkaWdub3JlICRpaWYgJGlpbCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIkaW5lbGlwc2UgJGluaSAkaW5taWRpICRpbnBhc3RlICRpbnBvbHkgJGlucHV0ICRpbnJlY3QgJGlucm91bmRyZWN0IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiRpbnNvbmcgJGluc3RvayAkaW50ICRpbndhdmUgJGlwICRpc2FsaWFzICRpc2JpdCAkaXNkZGUgJGlzZGlyICRpc2ZpbGUgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiJGlzaWQgJGlzbG93ZXIgJGlzdG9rICRpc3VwcGVyICRrZXljaGFyICRrZXlycHQgJGtleXZhbCAka25pY2sgJGxhY3RpdmUgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiJGxhY3RpdmVjaWQgJGxhY3RpdmV3aWQgJGxlZnQgJGxlbiAkbGV2ZWwgJGxmICRsaW5lICRsaW5lcyAkbGluayAkbG9jayBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIkbG9jayAkbG9ja2VkICRsb2cgJGxvZ3N0YW1wICRsb2dzdGFtcGZtdCAkbG9uZ2ZuICRsb25naXAgJGxvd2VyICRsdGltZXIgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiJG1hZGRyZXNzICRtYXNrICRtYXRjaGtleSAkbWF0Y2h0b2sgJG1kNSAkbWUgJG1lbnUgJG1lbnViYXIgJG1lbnVjb250ZXh0IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiRtZW51dHlwZSAkbWlkICRtaWRkaXIgJG1pcmNkaXIgJG1pcmNleGUgJG1pcmNpbmkgJG1rbG9nZm4gJG1uaWNrICRtb2RlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiRtb2RlZmlyc3QgJG1vZGVsYXN0ICRtb2Rlc3BsICRtb3VzZSAkbXNmaWxlICRuZXR3b3JrICRuZXduaWNrICRuaWNrICRub2ZpbGUgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiJG5vcGF0aCAkbm9xdCAkbm90ICRub3RhZ3MgJG5vdGlmeSAkbnVsbCAkbnVtZXJpYyAkbnVtb2sgJG9saW5lICRvbnBvbHkgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiJG9wbmljayAkb3IgJG9yZCAkb3MgJHBhc3NpdmVkY2MgJHBpYyAkcGxheSAkcG5pY2sgJHBvcnQgJHBvcnRhYmxlICRwb3J0ZnJlZSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIkcG9zICRwcmVmaXggJHByb3AgJHByb3RlY3QgJHB1dHRvayAkcXQgJHF1ZXJ5ICRyYW5kICRyICRyYXdtc2cgJHJlYWQgJHJlYWRvbW8gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiJHJlYWRuICRyZWdleCAkcmVnbWwgJHJlZ3N1YiAkcmVnc3ViZXggJHJlbW92ZSAkcmVtdG9rICRyZXBsYWNlICRyZXBsYWNleCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIkcmVwdG9rICRyZXN1bHQgJHJnYiAkcmlnaHQgJHJvdW5kICRzY2lkICRzY29uICRzY3JpcHQgJHNjcmlwdGRpciAkc2NyaXB0bGluZSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIkc2RpciAkc2VuZCAkc2VydmVyICRzZXJ2ZXJpcCAkc2ZpbGUgJHNoYTEgJHNob3J0Zm4gJHNob3cgJHNpZ25hbCAkc2luIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiRzaXRlICRzbGluZSAkc25pY2sgJHNuaWNrcyAkc25vdGlmeSAkc29jayAkc29ja2JyICRzb2NrZXJyICRzb2NrbmFtZSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIkc29ydHRvayAkc291bmQgJHNxcnQgJHNzbCAkc3JlcSAkc3NscmVhZHkgJHN0YXR1cyAkc3RyaXAgJHN0ciAkc3RyaXBwZWQgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiJHN5bGUgJHN1Ym1lbnUgJHN3aXRjaGJhciAkdGFuICR0YXJnZXQgJHRpY2tzICR0aW1lICR0aW1lciAkdGltZXN0YW1wIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiR0aW1lc3RhbXBmbXQgJHRpbWV6b25lICR0aXAgJHRpdGxlYmFyICR0b29sYmFyICR0cmVlYmFyICR0cnVzdCAkdWxldmVsIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiR1bGlzdCAkdXBwZXIgJHVwdGltZSAkdXJsICR1c2VybW9kZSAkdjEgJHYyICR2YXIgJHZjbWQgJHZjbWRzdGF0ICR2Y21kdmVyIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiR2ZXJzaW9uICR2bmljayAkdm9sICR3aWQgJHdpZHRoICR3aWxkc2l0ZSAkd2lsZHRvayAkd2luZG93ICR3cmFwICR4b3JcIik7XG4gIHZhciBrZXl3b3JkcyA9IHBhcnNlV29yZHMoXCJhYm9vayBhamludml0ZSBhbGlhcyBhbGluZSBhbWUgYW1zZyBhbmljayBhb3AgYXVzZXIgYXV0b2pvaW4gYXZvaWNlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImF3YXkgYmFja2dyb3VuZCBiYW4gYmNvcHkgYmVlcCBicmVhZCBicmVhayBicmVwbGFjZSBic2V0IGJ0cnVuYyBidW5zZXQgYndyaXRlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNoYW5uZWwgY2xlYXIgY2xlYXJhbGwgY2xpbmUgY2xpcGJvYXJkIGNsb3NlIGNuaWNrIGNvbG9yIGNvbWNsb3NlIGNvbW9wZW4gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY29tcmVnIGNvbnRpbnVlIGNvcHkgY3JlcSBjdGNwcmVwbHkgY3RjcHMgZGNjIGRjY3NlcnZlciBkZGUgZGRlc2VydmVyIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRlYnVnIGRlYyBkZXNjcmliZSBkaWFsb2cgZGlkIGRpZHRvayBkaXNhYmxlIGRpc2Nvbm5lY3QgZGxldmVsIGRsaW5lIGRsbCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkbnMgZHF3aW5kb3cgZHJhd2NvcHkgZHJhd2RvdCBkcmF3ZmlsbCBkcmF3bGluZSBkcmF3cGljIGRyYXdyZWN0IGRyYXdyZXBsYWNlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRyYXdyb3QgZHJhd3NhdmUgZHJhd3Njcm9sbCBkcmF3dGV4dCBlYmVlcHMgZWNobyBlZGl0Ym94IGVtYWlsYWRkciBlbmFibGUgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZXZlbnRzIGV4aXQgZmNsb3NlIGZpbHRlciBmaW5kdGV4dCBmaW5nZXIgZmlyZXdhbGwgZmxhc2ggZmxpc3QgZmxvb2QgZmx1c2ggXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZmx1c2hpbmkgZm9udCBmb3BlbiBmc2VlayBmc2VuZCBmc2VydmUgZnVsbG5hbWUgZndyaXRlIGdoaWRlIGdsb2FkIGdtb3ZlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImdvcHRzIGdvdG8gZ3BsYXkgZ3BvaW50IGdxcmVxIGdyb3VwcyBnc2hvdyBnc2l6ZSBnc3RvcCBndGFsayBndW5sb2FkIGhhZGQgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaGFsdCBoYWx0ZGVmIGhkZWMgaGRlbCBoZWxwIGhmcmVlIGhpbmMgaGxvYWQgaG1ha2UgaG9wIGhzYXZlIGlhbCBpYWxjbGVhciBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpYWxtYXJrIGlkZW50ZCBpZiBpZ25vcmUgaWxpbmUgaW5jIGludml0ZSBpdXNlciBqb2luIGtpY2sgbGluZXNlcCBsaW5rcyBsaXN0IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImxvYWQgbG9hZGJ1ZiBsb2NhbGluZm8gbG9nIG1kaSBtZSBtZW51YmFyIG1rZGlyIG1uaWNrIG1vZGUgbXNnIG5pY2sgbm9vcCBub3RpY2UgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibm90aWZ5IG9tc2cgb25vdGljZSBwYXJ0IHBhcnRhbGwgcGRjYyBwZXJmb3JtIHBsYXkgcGxheWN0cmwgcG9wIHByb3RlY3QgcHZvaWNlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInFtZSBxbXNnIHF1ZXJ5IHF1ZXJ5biBxdWl0IHJhdyByZWxvYWQgcmVtaW5pIHJlbW90ZSByZW1vdmUgcmVuYW1lIHJlbndpbiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJyZXNldGVycm9yIHJlc2V0aWRsZSByZXR1cm4gcmxldmVsIHJsaW5lIHJtZGlyIHJ1biBydXNlciBzYXZlIHNhdmVidWYgc2F2ZWluaSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzYXkgc2NpZCBzY29uIHNlcnZlciBzZXQgc2hvd21pcmMgc2lnbmFtIHNsaW5lIHNvY2thY2NlcHQgc29ja2Nsb3NlIHNvY2tsaXN0IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNvY2tsaXN0ZW4gc29ja21hcmsgc29ja29wZW4gc29ja3BhdXNlIHNvY2tyZWFkIHNvY2tyZW5hbWUgc29ja3VkcCBzb2Nrd3JpdGUgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic291bmQgc3BlYWsgc3BsYXkgc3JlcSBzdHJpcCBzd2l0Y2hiYXIgdGltZXIgdGltZXN0YW1wIHRpdGxlYmFyIHRuaWNrIHRva2VuaXplIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRvb2xiYXIgdG9waWMgdHJheSB0cmVlYmFyIHVsaXN0IHVubG9hZCB1bnNldCB1bnNldGFsbCB1cGRhdGVubCB1cmwgdXdobyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ2YXIgdmNhZGQgdmNtZCB2Y3JlbSB2b2wgd2hpbGUgd2hvaXMgd2luZG93IHdpbmhlbHAgd3JpdGUgd3JpdGVpbnQgaWYgaXNhbG51bSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpc2FscGhhIGlzYW9wIGlzYXZvaWNlIGlzYmFuIGlzY2hhbiBpc2hvcCBpc2lnbm9yZSBpc2luIGlzaW5jcyBpc2xldHRlciBpc2xvd2VyIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImlzbm90aWZ5IGlzbnVtIGlzb24gaXNvcCBpc3Byb3RlY3QgaXNyZWcgaXN1cHBlciBpc3ZvaWNlIGlzd20gaXN3bWNzIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImVsc2VpZiBlbHNlIGdvdG8gbWVudSBuaWNrbGlzdCBzdGF0dXMgdGl0bGUgaWNvbiBzaXplIG9wdGlvbiB0ZXh0IGVkaXQgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYnV0dG9uIGNoZWNrIHJhZGlvIGJveCBzY3JvbGwgbGlzdCBjb21ibyBsaW5rIHRhYiBpdGVtXCIpO1xuICB2YXIgZnVuY3Rpb25zID0gcGFyc2VXb3JkcyhcImlmIGVsc2VpZiBlbHNlIGFuZCBub3Qgb3IgZXEgbmUgaW4gbmkgZm9yIGZvcmVhY2ggd2hpbGUgc3dpdGNoXCIpO1xuICB2YXIgaXNPcGVyYXRvckNoYXIgPSAvWytcXC0qJiU9PD4hP15cXC9cXHxdLztcbiAgZnVuY3Rpb24gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgZikge1xuICAgIHN0YXRlLnRva2VuaXplID0gZjtcbiAgICByZXR1cm4gZihzdHJlYW0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBiZWZvcmVQYXJhbXMgPSBzdGF0ZS5iZWZvcmVQYXJhbXM7XG4gICAgc3RhdGUuYmVmb3JlUGFyYW1zID0gZmFsc2U7XG4gICAgdmFyIGNoID0gc3RyZWFtLm5leHQoKTtcbiAgICBpZiAoL1tcXFtcXF17fVxcKFxcKSxcXC5dLy50ZXN0KGNoKSkge1xuICAgICAgaWYgKGNoID09IFwiKFwiICYmIGJlZm9yZVBhcmFtcykgc3RhdGUuaW5QYXJhbXMgPSB0cnVlO1xuICAgICAgZWxzZSBpZiAoY2ggPT0gXCIpXCIpIHN0YXRlLmluUGFyYW1zID0gZmFsc2U7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSBpZiAoL1xcZC8udGVzdChjaCkpIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcLl0vKTtcbiAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaCA9PSBcIlxcXFxcIikge1xuICAgICAgc3RyZWFtLmVhdChcIlxcXFxcIik7XG4gICAgICBzdHJlYW0uZWF0KC8uLyk7XG4gICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2ggPT0gXCIvXCIgJiYgc3RyZWFtLmVhdChcIipcIikpIHtcbiAgICAgIHJldHVybiBjaGFpbihzdHJlYW0sIHN0YXRlLCB0b2tlbkNvbW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaCA9PSBcIjtcIiAmJiBzdHJlYW0ubWF0Y2goLyAqXFwoICpcXCgvKSkge1xuICAgICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIHRva2VuVW5wYXJzZWQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaCA9PSBcIjtcIiAmJiAhc3RhdGUuaW5QYXJhbXMpIHtcbiAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2ggPT0gJ1wiJykge1xuICAgICAgc3RyZWFtLmVhdCgvXCIvKTtcbiAgICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2ggPT0gXCIkXCIpIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvWyRfYS16MC05QS1aXFwuOl0vKTtcbiAgICAgIGlmIChzcGVjaWFscyAmJiBzcGVjaWFscy5wcm9wZXJ0eUlzRW51bWVyYWJsZShzdHJlYW0uY3VycmVudCgpLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzdGF0ZS5iZWZvcmVQYXJhbXMgPSB0cnVlO1xuICAgICAgICByZXR1cm4gXCJidWlsdGluXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGNoID09IFwiJVwiKSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1teLFxccygpXS8pO1xuICAgICAgc3RhdGUuYmVmb3JlUGFyYW1zID0gdHJ1ZTtcbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc09wZXJhdG9yQ2hhci50ZXN0KGNoKSkge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKGlzT3BlcmF0b3JDaGFyKTtcbiAgICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwkX3t9XS8pO1xuICAgICAgdmFyIHdvcmQgPSBzdHJlYW0uY3VycmVudCgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoa2V5d29yZHMgJiYga2V5d29yZHMucHJvcGVydHlJc0VudW1lcmFibGUod29yZCkpXG4gICAgICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgICAgIGlmIChmdW5jdGlvbnMgJiYgZnVuY3Rpb25zLnByb3BlcnR5SXNFbnVtZXJhYmxlKHdvcmQpKSB7XG4gICAgICAgIHN0YXRlLmJlZm9yZVBhcmFtcyA9IHRydWU7XG4gICAgICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0b2tlbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBtYXliZUVuZCA9IGZhbHNlLCBjaDtcbiAgICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgICBpZiAoY2ggPT0gXCIvXCIgJiYgbWF5YmVFbmQpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbWF5YmVFbmQgPSAoY2ggPT0gXCIqXCIpO1xuICAgIH1cbiAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gIH1cbiAgZnVuY3Rpb24gdG9rZW5VbnBhcnNlZChzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIG1heWJlRW5kID0gMCwgY2g7XG4gICAgd2hpbGUgKGNoID0gc3RyZWFtLm5leHQoKSkge1xuICAgICAgaWYgKGNoID09IFwiO1wiICYmIG1heWJlRW5kID09IDIpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGNoID09IFwiKVwiKVxuICAgICAgICBtYXliZUVuZCsrO1xuICAgICAgZWxzZSBpZiAoY2ggIT0gXCIgXCIpXG4gICAgICAgIG1heWJlRW5kID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIFwibWV0YVwiO1xuICB9XG4gIHJldHVybiB7XG4gICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b2tlbml6ZTogdG9rZW5CYXNlLFxuICAgICAgICBiZWZvcmVQYXJhbXM6IGZhbHNlLFxuICAgICAgICBpblBhcmFtczogZmFsc2VcbiAgICAgIH07XG4gICAgfSxcbiAgICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSByZXR1cm4gbnVsbDtcbiAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH07XG59KTtcblxufSk7XG4iLCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTW9kZSgnbWxsaWtlJywgZnVuY3Rpb24oX2NvbmZpZywgcGFyc2VyQ29uZmlnKSB7XG4gIHZhciB3b3JkcyA9IHtcbiAgICAnYXMnOiAna2V5d29yZCcsXG4gICAgJ2RvJzogJ2tleXdvcmQnLFxuICAgICdlbHNlJzogJ2tleXdvcmQnLFxuICAgICdlbmQnOiAna2V5d29yZCcsXG4gICAgJ2V4Y2VwdGlvbic6ICdrZXl3b3JkJyxcbiAgICAnZnVuJzogJ2tleXdvcmQnLFxuICAgICdmdW5jdG9yJzogJ2tleXdvcmQnLFxuICAgICdpZic6ICdrZXl3b3JkJyxcbiAgICAnaW4nOiAna2V5d29yZCcsXG4gICAgJ2luY2x1ZGUnOiAna2V5d29yZCcsXG4gICAgJ2xldCc6ICdrZXl3b3JkJyxcbiAgICAnb2YnOiAna2V5d29yZCcsXG4gICAgJ29wZW4nOiAna2V5d29yZCcsXG4gICAgJ3JlYyc6ICdrZXl3b3JkJyxcbiAgICAnc3RydWN0JzogJ2tleXdvcmQnLFxuICAgICd0aGVuJzogJ2tleXdvcmQnLFxuICAgICd0eXBlJzogJ2tleXdvcmQnLFxuICAgICd2YWwnOiAna2V5d29yZCcsXG4gICAgJ3doaWxlJzogJ2tleXdvcmQnLFxuICAgICd3aXRoJzogJ2tleXdvcmQnXG4gIH07XG5cbiAgdmFyIGV4dHJhV29yZHMgPSBwYXJzZXJDb25maWcuZXh0cmFXb3JkcyB8fCB7fTtcbiAgZm9yICh2YXIgcHJvcCBpbiBleHRyYVdvcmRzKSB7XG4gICAgaWYgKGV4dHJhV29yZHMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgIHdvcmRzW3Byb3BdID0gcGFyc2VyQ29uZmlnLmV4dHJhV29yZHNbcHJvcF07XG4gICAgfVxuICB9XG4gIHZhciBoaW50V29yZHMgPSBbXTtcbiAgZm9yICh2YXIgayBpbiB3b3JkcykgeyBoaW50V29yZHMucHVzaChrKTsgfVxuICBDb2RlTWlycm9yLnJlZ2lzdGVySGVscGVyKFwiaGludFdvcmRzXCIsIFwibWxsaWtlXCIsIGhpbnRXb3Jkcyk7XG5cbiAgZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuXG4gICAgaWYgKGNoID09PSAnXCInKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuU3RyaW5nO1xuICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgICBpZiAoY2ggPT09ICd7Jykge1xuICAgICAgaWYgKHN0cmVhbS5lYXQoJ3wnKSkge1xuICAgICAgICBzdGF0ZS5sb25nU3RyaW5nID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkxvbmdTdHJpbmc7XG4gICAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNoID09PSAnKCcpIHtcbiAgICAgIGlmIChzdHJlYW0uZWF0KCcqJykpIHtcbiAgICAgICAgc3RhdGUuY29tbWVudExldmVsKys7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5Db21tZW50O1xuICAgICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjaCA9PT0gJ34nIHx8IGNoID09PSAnPycpIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvXFx3Lyk7XG4gICAgICByZXR1cm4gJ3ZhcmlhYmxlLTInO1xuICAgIH1cbiAgICBpZiAoY2ggPT09ICdgJykge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9cXHcvKTtcbiAgICAgIHJldHVybiAncXVvdGUnO1xuICAgIH1cbiAgICBpZiAoY2ggPT09ICcvJyAmJiBwYXJzZXJDb25maWcuc2xhc2hDb21tZW50cyAmJiBzdHJlYW0uZWF0KCcvJykpIHtcbiAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgIHJldHVybiAnY29tbWVudCc7XG4gICAgfVxuICAgIGlmICgvXFxkLy50ZXN0KGNoKSkge1xuICAgICAgaWYgKGNoID09PSAnMCcgJiYgc3RyZWFtLmVhdCgvW2JCXS8pKSB7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvWzAxXS8pO1xuICAgICAgfSBpZiAoY2ggPT09ICcwJyAmJiBzdHJlYW0uZWF0KC9beFhdLykpIHtcbiAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bMC05YS1mQS1GXS8pXG4gICAgICB9IGlmIChjaCA9PT0gJzAnICYmIHN0cmVhbS5lYXQoL1tvT10vKSkge1xuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1swLTddLyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXGRfXS8pO1xuICAgICAgICBpZiAoc3RyZWFtLmVhdCgnLicpKSB7XG4gICAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFxkXS8pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJlYW0uZWF0KC9bZUVdLykpIHtcbiAgICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXGRcXC0rXS8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gJ251bWJlcic7XG4gICAgfVxuICAgIGlmICggL1srXFwtKiYlPTw+IT98QFxcLn46XS8udGVzdChjaCkpIHtcbiAgICAgIHJldHVybiAnb3BlcmF0b3InO1xuICAgIH1cbiAgICBpZiAoL1tcXHdcXHhhMS1cXHVmZmZmXS8udGVzdChjaCkpIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xceGExLVxcdWZmZmZdLyk7XG4gICAgICB2YXIgY3VyID0gc3RyZWFtLmN1cnJlbnQoKTtcbiAgICAgIHJldHVybiB3b3Jkcy5oYXNPd25Qcm9wZXJ0eShjdXIpID8gd29yZHNbY3VyXSA6ICd2YXJpYWJsZSc7XG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBmdW5jdGlvbiB0b2tlblN0cmluZyhzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIG5leHQsIGVuZCA9IGZhbHNlLCBlc2NhcGVkID0gZmFsc2U7XG4gICAgd2hpbGUgKChuZXh0ID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgaWYgKG5leHQgPT09ICdcIicgJiYgIWVzY2FwZWQpIHtcbiAgICAgICAgZW5kID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBlc2NhcGVkID0gIWVzY2FwZWQgJiYgbmV4dCA9PT0gJ1xcXFwnO1xuICAgIH1cbiAgICBpZiAoZW5kICYmICFlc2NhcGVkKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICB9XG4gICAgcmV0dXJuICdzdHJpbmcnO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHRva2VuQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIHByZXYsIG5leHQ7XG4gICAgd2hpbGUoc3RhdGUuY29tbWVudExldmVsID4gMCAmJiAobmV4dCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgIGlmIChwcmV2ID09PSAnKCcgJiYgbmV4dCA9PT0gJyonKSBzdGF0ZS5jb21tZW50TGV2ZWwrKztcbiAgICAgIGlmIChwcmV2ID09PSAnKicgJiYgbmV4dCA9PT0gJyknKSBzdGF0ZS5jb21tZW50TGV2ZWwtLTtcbiAgICAgIHByZXYgPSBuZXh0O1xuICAgIH1cbiAgICBpZiAoc3RhdGUuY29tbWVudExldmVsIDw9IDApIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgIH1cbiAgICByZXR1cm4gJ2NvbW1lbnQnO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5Mb25nU3RyaW5nKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgcHJldiwgbmV4dDtcbiAgICB3aGlsZSAoc3RhdGUubG9uZ1N0cmluZyAmJiAobmV4dCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgIGlmIChwcmV2ID09PSAnfCcgJiYgbmV4dCA9PT0gJ30nKSBzdGF0ZS5sb25nU3RyaW5nID0gZmFsc2U7XG4gICAgICBwcmV2ID0gbmV4dDtcbiAgICB9XG4gICAgaWYgKCFzdGF0ZS5sb25nU3RyaW5nKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICB9XG4gICAgcmV0dXJuICdzdHJpbmcnO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtyZXR1cm4ge3Rva2VuaXplOiB0b2tlbkJhc2UsIGNvbW1lbnRMZXZlbDogMCwgbG9uZ1N0cmluZzogZmFsc2V9O30sXG4gICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkgcmV0dXJuIG51bGw7XG4gICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSxcblxuICAgIGJsb2NrQ29tbWVudFN0YXJ0OiBcIigqXCIsXG4gICAgYmxvY2tDb21tZW50RW5kOiBcIiopXCIsXG4gICAgbGluZUNvbW1lbnQ6IHBhcnNlckNvbmZpZy5zbGFzaENvbW1lbnRzID8gXCIvL1wiIDogbnVsbFxuICB9O1xufSk7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTUlNRSgndGV4dC94LW9jYW1sJywge1xuICBuYW1lOiAnbWxsaWtlJyxcbiAgZXh0cmFXb3Jkczoge1xuICAgICdhbmQnOiAna2V5d29yZCcsXG4gICAgJ2Fzc2VydCc6ICdrZXl3b3JkJyxcbiAgICAnYmVnaW4nOiAna2V5d29yZCcsXG4gICAgJ2NsYXNzJzogJ2tleXdvcmQnLFxuICAgICdjb25zdHJhaW50JzogJ2tleXdvcmQnLFxuICAgICdkb25lJzogJ2tleXdvcmQnLFxuICAgICdkb3dudG8nOiAna2V5d29yZCcsXG4gICAgJ2V4dGVybmFsJzogJ2tleXdvcmQnLFxuICAgICdmdW5jdGlvbic6ICdrZXl3b3JkJyxcbiAgICAnaW5pdGlhbGl6ZXInOiAna2V5d29yZCcsXG4gICAgJ2xhenknOiAna2V5d29yZCcsXG4gICAgJ21hdGNoJzogJ2tleXdvcmQnLFxuICAgICdtZXRob2QnOiAna2V5d29yZCcsXG4gICAgJ21vZHVsZSc6ICdrZXl3b3JkJyxcbiAgICAnbXV0YWJsZSc6ICdrZXl3b3JkJyxcbiAgICAnbmV3JzogJ2tleXdvcmQnLFxuICAgICdub25yZWMnOiAna2V5d29yZCcsXG4gICAgJ29iamVjdCc6ICdrZXl3b3JkJyxcbiAgICAncHJpdmF0ZSc6ICdrZXl3b3JkJyxcbiAgICAnc2lnJzogJ2tleXdvcmQnLFxuICAgICd0byc6ICdrZXl3b3JkJyxcbiAgICAndHJ5JzogJ2tleXdvcmQnLFxuICAgICd2YWx1ZSc6ICdrZXl3b3JkJyxcbiAgICAndmlydHVhbCc6ICdrZXl3b3JkJyxcbiAgICAnd2hlbic6ICdrZXl3b3JkJyxcblxuICAgIC8vIGJ1aWx0aW5zXG4gICAgJ3JhaXNlJzogJ2J1aWx0aW4nLFxuICAgICdmYWlsd2l0aCc6ICdidWlsdGluJyxcbiAgICAndHJ1ZSc6ICdidWlsdGluJyxcbiAgICAnZmFsc2UnOiAnYnVpbHRpbicsXG5cbiAgICAvLyBQZXJ2YXNpdmVzIGJ1aWx0aW5zXG4gICAgJ2Fzcic6ICdidWlsdGluJyxcbiAgICAnbGFuZCc6ICdidWlsdGluJyxcbiAgICAnbG9yJzogJ2J1aWx0aW4nLFxuICAgICdsc2wnOiAnYnVpbHRpbicsXG4gICAgJ2xzcic6ICdidWlsdGluJyxcbiAgICAnbHhvcic6ICdidWlsdGluJyxcbiAgICAnbW9kJzogJ2J1aWx0aW4nLFxuICAgICdvcic6ICdidWlsdGluJyxcblxuICAgIC8vIE1vcmUgUGVydmFzaXZlc1xuICAgICdyYWlzZV9ub3RyYWNlJzogJ2J1aWx0aW4nLFxuICAgICd0cmFjZSc6ICdidWlsdGluJyxcbiAgICAnZXhpdCc6ICdidWlsdGluJyxcbiAgICAncHJpbnRfc3RyaW5nJzogJ2J1aWx0aW4nLFxuICAgICdwcmludF9lbmRsaW5lJzogJ2J1aWx0aW4nLFxuXG4gICAgICdpbnQnOiAndHlwZScsXG4gICAgICdmbG9hdCc6ICd0eXBlJyxcbiAgICAgJ2Jvb2wnOiAndHlwZScsXG4gICAgICdjaGFyJzogJ3R5cGUnLFxuICAgICAnc3RyaW5nJzogJ3R5cGUnLFxuICAgICAndW5pdCc6ICd0eXBlJyxcblxuICAgICAvLyBNb2R1bGVzXG4gICAgICdMaXN0JzogJ2J1aWx0aW4nXG4gIH1cbn0pO1xuXG5Db2RlTWlycm9yLmRlZmluZU1JTUUoJ3RleHQveC1mc2hhcnAnLCB7XG4gIG5hbWU6ICdtbGxpa2UnLFxuICBleHRyYVdvcmRzOiB7XG4gICAgJ2Fic3RyYWN0JzogJ2tleXdvcmQnLFxuICAgICdhc3NlcnQnOiAna2V5d29yZCcsXG4gICAgJ2Jhc2UnOiAna2V5d29yZCcsXG4gICAgJ2JlZ2luJzogJ2tleXdvcmQnLFxuICAgICdjbGFzcyc6ICdrZXl3b3JkJyxcbiAgICAnZGVmYXVsdCc6ICdrZXl3b3JkJyxcbiAgICAnZGVsZWdhdGUnOiAna2V5d29yZCcsXG4gICAgJ2RvISc6ICdrZXl3b3JkJyxcbiAgICAnZG9uZSc6ICdrZXl3b3JkJyxcbiAgICAnZG93bmNhc3QnOiAna2V5d29yZCcsXG4gICAgJ2Rvd250byc6ICdrZXl3b3JkJyxcbiAgICAnZWxpZic6ICdrZXl3b3JkJyxcbiAgICAnZXh0ZXJuJzogJ2tleXdvcmQnLFxuICAgICdmaW5hbGx5JzogJ2tleXdvcmQnLFxuICAgICdmb3InOiAna2V5d29yZCcsXG4gICAgJ2Z1bmN0aW9uJzogJ2tleXdvcmQnLFxuICAgICdnbG9iYWwnOiAna2V5d29yZCcsXG4gICAgJ2luaGVyaXQnOiAna2V5d29yZCcsXG4gICAgJ2lubGluZSc6ICdrZXl3b3JkJyxcbiAgICAnaW50ZXJmYWNlJzogJ2tleXdvcmQnLFxuICAgICdpbnRlcm5hbCc6ICdrZXl3b3JkJyxcbiAgICAnbGF6eSc6ICdrZXl3b3JkJyxcbiAgICAnbGV0ISc6ICdrZXl3b3JkJyxcbiAgICAnbWF0Y2gnOiAna2V5d29yZCcsXG4gICAgJ21lbWJlcic6ICdrZXl3b3JkJyxcbiAgICAnbW9kdWxlJzogJ2tleXdvcmQnLFxuICAgICdtdXRhYmxlJzogJ2tleXdvcmQnLFxuICAgICduYW1lc3BhY2UnOiAna2V5d29yZCcsXG4gICAgJ25ldyc6ICdrZXl3b3JkJyxcbiAgICAnbnVsbCc6ICdrZXl3b3JkJyxcbiAgICAnb3ZlcnJpZGUnOiAna2V5d29yZCcsXG4gICAgJ3ByaXZhdGUnOiAna2V5d29yZCcsXG4gICAgJ3B1YmxpYyc6ICdrZXl3b3JkJyxcbiAgICAncmV0dXJuISc6ICdrZXl3b3JkJyxcbiAgICAncmV0dXJuJzogJ2tleXdvcmQnLFxuICAgICdzZWxlY3QnOiAna2V5d29yZCcsXG4gICAgJ3N0YXRpYyc6ICdrZXl3b3JkJyxcbiAgICAndG8nOiAna2V5d29yZCcsXG4gICAgJ3RyeSc6ICdrZXl3b3JkJyxcbiAgICAndXBjYXN0JzogJ2tleXdvcmQnLFxuICAgICd1c2UhJzogJ2tleXdvcmQnLFxuICAgICd1c2UnOiAna2V5d29yZCcsXG4gICAgJ3ZvaWQnOiAna2V5d29yZCcsXG4gICAgJ3doZW4nOiAna2V5d29yZCcsXG4gICAgJ3lpZWxkISc6ICdrZXl3b3JkJyxcbiAgICAneWllbGQnOiAna2V5d29yZCcsXG5cbiAgICAvLyBSZXNlcnZlZCB3b3Jkc1xuICAgICdhdG9taWMnOiAna2V5d29yZCcsXG4gICAgJ2JyZWFrJzogJ2tleXdvcmQnLFxuICAgICdjaGVja2VkJzogJ2tleXdvcmQnLFxuICAgICdjb21wb25lbnQnOiAna2V5d29yZCcsXG4gICAgJ2NvbnN0JzogJ2tleXdvcmQnLFxuICAgICdjb25zdHJhaW50JzogJ2tleXdvcmQnLFxuICAgICdjb25zdHJ1Y3Rvcic6ICdrZXl3b3JkJyxcbiAgICAnY29udGludWUnOiAna2V5d29yZCcsXG4gICAgJ2VhZ2VyJzogJ2tleXdvcmQnLFxuICAgICdldmVudCc6ICdrZXl3b3JkJyxcbiAgICAnZXh0ZXJuYWwnOiAna2V5d29yZCcsXG4gICAgJ2ZpeGVkJzogJ2tleXdvcmQnLFxuICAgICdtZXRob2QnOiAna2V5d29yZCcsXG4gICAgJ21peGluJzogJ2tleXdvcmQnLFxuICAgICdvYmplY3QnOiAna2V5d29yZCcsXG4gICAgJ3BhcmFsbGVsJzogJ2tleXdvcmQnLFxuICAgICdwcm9jZXNzJzogJ2tleXdvcmQnLFxuICAgICdwcm90ZWN0ZWQnOiAna2V5d29yZCcsXG4gICAgJ3B1cmUnOiAna2V5d29yZCcsXG4gICAgJ3NlYWxlZCc6ICdrZXl3b3JkJyxcbiAgICAndGFpbGNhbGwnOiAna2V5d29yZCcsXG4gICAgJ3RyYWl0JzogJ2tleXdvcmQnLFxuICAgICd2aXJ0dWFsJzogJ2tleXdvcmQnLFxuICAgICd2b2xhdGlsZSc6ICdrZXl3b3JkJyxcblxuICAgIC8vIGJ1aWx0aW5zXG4gICAgJ0xpc3QnOiAnYnVpbHRpbicsXG4gICAgJ1NlcSc6ICdidWlsdGluJyxcbiAgICAnTWFwJzogJ2J1aWx0aW4nLFxuICAgICdTZXQnOiAnYnVpbHRpbicsXG4gICAgJ09wdGlvbic6ICdidWlsdGluJyxcbiAgICAnaW50JzogJ2J1aWx0aW4nLFxuICAgICdzdHJpbmcnOiAnYnVpbHRpbicsXG4gICAgJ25vdCc6ICdidWlsdGluJyxcbiAgICAndHJ1ZSc6ICdidWlsdGluJyxcbiAgICAnZmFsc2UnOiAnYnVpbHRpbicsXG5cbiAgICAncmFpc2UnOiAnYnVpbHRpbicsXG4gICAgJ2ZhaWx3aXRoJzogJ2J1aWx0aW4nXG4gIH0sXG4gIHNsYXNoQ29tbWVudHM6IHRydWVcbn0pO1xuXG5cbkNvZGVNaXJyb3IuZGVmaW5lTUlNRSgndGV4dC94LXNtbCcsIHtcbiAgbmFtZTogJ21sbGlrZScsXG4gIGV4dHJhV29yZHM6IHtcbiAgICAnYWJzdHlwZSc6ICdrZXl3b3JkJyxcbiAgICAnYW5kJzogJ2tleXdvcmQnLFxuICAgICdhbmRhbHNvJzogJ2tleXdvcmQnLFxuICAgICdjYXNlJzogJ2tleXdvcmQnLFxuICAgICdkYXRhdHlwZSc6ICdrZXl3b3JkJyxcbiAgICAnZm4nOiAna2V5d29yZCcsXG4gICAgJ2hhbmRsZSc6ICdrZXl3b3JkJyxcbiAgICAnaW5maXgnOiAna2V5d29yZCcsXG4gICAgJ2luZml4cic6ICdrZXl3b3JkJyxcbiAgICAnbG9jYWwnOiAna2V5d29yZCcsXG4gICAgJ25vbmZpeCc6ICdrZXl3b3JkJyxcbiAgICAnb3AnOiAna2V5d29yZCcsXG4gICAgJ29yZWxzZSc6ICdrZXl3b3JkJyxcbiAgICAncmFpc2UnOiAna2V5d29yZCcsXG4gICAgJ3dpdGh0eXBlJzogJ2tleXdvcmQnLFxuICAgICdlcXR5cGUnOiAna2V5d29yZCcsXG4gICAgJ3NoYXJpbmcnOiAna2V5d29yZCcsXG4gICAgJ3NpZyc6ICdrZXl3b3JkJyxcbiAgICAnc2lnbmF0dXJlJzogJ2tleXdvcmQnLFxuICAgICdzdHJ1Y3R1cmUnOiAna2V5d29yZCcsXG4gICAgJ3doZXJlJzogJ2tleXdvcmQnLFxuICAgICd0cnVlJzogJ2tleXdvcmQnLFxuICAgICdmYWxzZSc6ICdrZXl3b3JkJyxcblxuICAgIC8vIHR5cGVzXG4gICAgJ2ludCc6ICdidWlsdGluJyxcbiAgICAncmVhbCc6ICdidWlsdGluJyxcbiAgICAnc3RyaW5nJzogJ2J1aWx0aW4nLFxuICAgICdjaGFyJzogJ2J1aWx0aW4nLFxuICAgICdib29sJzogJ2J1aWx0aW4nXG4gIH0sXG4gIHNsYXNoQ29tbWVudHM6IHRydWVcbn0pO1xuXG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbi8vIE1vZGVsaWNhIHN1cHBvcnQgZm9yIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTGVubmFydCBPY2hlbFxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSlcblxuKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwibW9kZWxpY2FcIiwgZnVuY3Rpb24oY29uZmlnLCBwYXJzZXJDb25maWcpIHtcblxuICAgIHZhciBpbmRlbnRVbml0ID0gY29uZmlnLmluZGVudFVuaXQ7XG4gICAgdmFyIGtleXdvcmRzID0gcGFyc2VyQ29uZmlnLmtleXdvcmRzIHx8IHt9O1xuICAgIHZhciBidWlsdGluID0gcGFyc2VyQ29uZmlnLmJ1aWx0aW4gfHwge307XG4gICAgdmFyIGF0b21zID0gcGFyc2VyQ29uZmlnLmF0b21zIHx8IHt9O1xuXG4gICAgdmFyIGlzU2luZ2xlT3BlcmF0b3JDaGFyID0gL1s7PVxcKDpcXCkse30uKjw+K1xcLVxcL15cXFtcXF1dLztcbiAgICB2YXIgaXNEb3VibGVPcGVyYXRvckNoYXIgPSAvKDo9fDw9fD49fD09fDw+fFxcLlxcK3xcXC5cXC18XFwuXFwqfFxcLlxcL3xcXC5cXF4pLztcbiAgICB2YXIgaXNEaWdpdCA9IC9bMC05XS87XG4gICAgdmFyIGlzTm9uRGlnaXQgPSAvW19hLXpBLVpdLztcblxuICAgIGZ1bmN0aW9uIHRva2VuTGluZUNvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgc3RhdGUudG9rZW5pemUgPSBudWxsO1xuICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRva2VuQmxvY2tDb21tZW50KHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBtYXliZUVuZCA9IGZhbHNlLCBjaDtcbiAgICAgIHdoaWxlIChjaCA9IHN0cmVhbS5uZXh0KCkpIHtcbiAgICAgICAgaWYgKG1heWJlRW5kICYmIGNoID09IFwiL1wiKSB7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG1heWJlRW5kID0gKGNoID09IFwiKlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b2tlblN0cmluZyhzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgZXNjYXBlZCA9IGZhbHNlLCBjaDtcbiAgICAgIHdoaWxlICgoY2ggPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChjaCA9PSAnXCInICYmICFlc2NhcGVkKSB7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSBudWxsO1xuICAgICAgICAgIHN0YXRlLnNvbCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZCAmJiBjaCA9PSBcIlxcXFxcIjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9rZW5JZGVudChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoaXNEaWdpdCk7XG4gICAgICB3aGlsZSAoc3RyZWFtLmVhdChpc0RpZ2l0KSB8fCBzdHJlYW0uZWF0KGlzTm9uRGlnaXQpKSB7IH1cblxuXG4gICAgICB2YXIgY3VyID0gc3RyZWFtLmN1cnJlbnQoKTtcblxuICAgICAgaWYoc3RhdGUuc29sICYmIChjdXIgPT0gXCJwYWNrYWdlXCIgfHwgY3VyID09IFwibW9kZWxcIiB8fCBjdXIgPT0gXCJ3aGVuXCIgfHwgY3VyID09IFwiY29ubmVjdG9yXCIpKSBzdGF0ZS5sZXZlbCsrO1xuICAgICAgZWxzZSBpZihzdGF0ZS5zb2wgJiYgY3VyID09IFwiZW5kXCIgJiYgc3RhdGUubGV2ZWwgPiAwKSBzdGF0ZS5sZXZlbC0tO1xuXG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IG51bGw7XG4gICAgICBzdGF0ZS5zb2wgPSBmYWxzZTtcblxuICAgICAgaWYgKGtleXdvcmRzLnByb3BlcnR5SXNFbnVtZXJhYmxlKGN1cikpIHJldHVybiBcImtleXdvcmRcIjtcbiAgICAgIGVsc2UgaWYgKGJ1aWx0aW4ucHJvcGVydHlJc0VudW1lcmFibGUoY3VyKSkgcmV0dXJuIFwiYnVpbHRpblwiO1xuICAgICAgZWxzZSBpZiAoYXRvbXMucHJvcGVydHlJc0VudW1lcmFibGUoY3VyKSkgcmV0dXJuIFwiYXRvbVwiO1xuICAgICAgZWxzZSByZXR1cm4gXCJ2YXJpYWJsZVwiO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRva2VuUUlkZW50KHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHdoaWxlIChzdHJlYW0uZWF0KC9bXiddLykpIHsgfVxuXG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IG51bGw7XG4gICAgICBzdGF0ZS5zb2wgPSBmYWxzZTtcblxuICAgICAgaWYoc3RyZWFtLmVhdChcIidcIikpXG4gICAgICAgIHJldHVybiBcInZhcmlhYmxlXCI7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBcImVycm9yXCI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9rZW5VbnNpZ25lZE51bWJlcihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoaXNEaWdpdCk7XG4gICAgICBpZiAoc3RyZWFtLmVhdCgnLicpKSB7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZShpc0RpZ2l0KTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHJlYW0uZWF0KCdlJykgfHwgc3RyZWFtLmVhdCgnRScpKSB7XG4gICAgICAgIGlmICghc3RyZWFtLmVhdCgnLScpKVxuICAgICAgICAgIHN0cmVhbS5lYXQoJysnKTtcbiAgICAgICAgc3RyZWFtLmVhdFdoaWxlKGlzRGlnaXQpO1xuICAgICAgfVxuXG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IG51bGw7XG4gICAgICBzdGF0ZS5zb2wgPSBmYWxzZTtcbiAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgIH1cblxuICAgIC8vIEludGVyZmFjZVxuICAgIHJldHVybiB7XG4gICAgICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0b2tlbml6ZTogbnVsbCxcbiAgICAgICAgICBsZXZlbDogMCxcbiAgICAgICAgICBzb2w6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH0sXG5cbiAgICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIGlmKHN0YXRlLnRva2VuaXplICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihzdHJlYW0uc29sKCkpIHtcbiAgICAgICAgICBzdGF0ZS5zb2wgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV0hJVEVTUEFDRVxuICAgICAgICBpZihzdHJlYW0uZWF0U3BhY2UoKSkge1xuICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG5cbiAgICAgICAgLy8gTElORUNPTU1FTlRcbiAgICAgICAgaWYoY2ggPT0gJy8nICYmIHN0cmVhbS5lYXQoJy8nKSkge1xuICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5MaW5lQ29tbWVudDtcbiAgICAgICAgfVxuICAgICAgICAvLyBCTE9DS0NPTU1FTlRcbiAgICAgICAgZWxzZSBpZihjaCA9PSAnLycgJiYgc3RyZWFtLmVhdCgnKicpKSB7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJsb2NrQ29tbWVudDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUV08gU1lNQk9MIFRPS0VOU1xuICAgICAgICBlbHNlIGlmKGlzRG91YmxlT3BlcmF0b3JDaGFyLnRlc3QoY2grc3RyZWFtLnBlZWsoKSkpIHtcbiAgICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNJTkdMRSBTWU1CT0wgVE9LRU5TXG4gICAgICAgIGVsc2UgaWYoaXNTaW5nbGVPcGVyYXRvckNoYXIudGVzdChjaCkpIHtcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJREVOVFxuICAgICAgICBlbHNlIGlmKGlzTm9uRGlnaXQudGVzdChjaCkpIHtcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuSWRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUS1JREVOVFxuICAgICAgICBlbHNlIGlmKGNoID09IFwiJ1wiICYmIHN0cmVhbS5wZWVrKCkgJiYgc3RyZWFtLnBlZWsoKSAhPSBcIidcIikge1xuICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5RSWRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU1RSSU5HXG4gICAgICAgIGVsc2UgaWYoY2ggPT0gJ1wiJykge1xuICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5TdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVU5TSUdORURfTlVNQkVSXG4gICAgICAgIGVsc2UgaWYoaXNEaWdpdC50ZXN0KGNoKSkge1xuICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5VbnNpZ25lZE51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBFUlJPUlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIFwiZXJyb3JcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH0sXG5cbiAgICAgIGluZGVudDogZnVuY3Rpb24oc3RhdGUsIHRleHRBZnRlcikge1xuICAgICAgICBpZiAoc3RhdGUudG9rZW5pemUgIT0gbnVsbCkgcmV0dXJuIENvZGVNaXJyb3IuUGFzcztcblxuICAgICAgICB2YXIgbGV2ZWwgPSBzdGF0ZS5sZXZlbDtcbiAgICAgICAgaWYoLyhhbGdvcml0aG0pLy50ZXN0KHRleHRBZnRlcikpIGxldmVsLS07XG4gICAgICAgIGlmKC8oZXF1YXRpb24pLy50ZXN0KHRleHRBZnRlcikpIGxldmVsLS07XG4gICAgICAgIGlmKC8oaW5pdGlhbCBhbGdvcml0aG0pLy50ZXN0KHRleHRBZnRlcikpIGxldmVsLS07XG4gICAgICAgIGlmKC8oaW5pdGlhbCBlcXVhdGlvbikvLnRlc3QodGV4dEFmdGVyKSkgbGV2ZWwtLTtcbiAgICAgICAgaWYoLyhlbmQpLy50ZXN0KHRleHRBZnRlcikpIGxldmVsLS07XG5cbiAgICAgICAgaWYobGV2ZWwgPiAwKVxuICAgICAgICAgIHJldHVybiBpbmRlbnRVbml0KmxldmVsO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9LFxuXG4gICAgICBibG9ja0NvbW1lbnRTdGFydDogXCIvKlwiLFxuICAgICAgYmxvY2tDb21tZW50RW5kOiBcIiovXCIsXG4gICAgICBsaW5lQ29tbWVudDogXCIvL1wiXG4gICAgfTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gd29yZHMoc3RyKSB7XG4gICAgdmFyIG9iaiA9IHt9LCB3b3JkcyA9IHN0ci5zcGxpdChcIiBcIik7XG4gICAgZm9yICh2YXIgaT0wOyBpPHdvcmRzLmxlbmd0aDsgKytpKVxuICAgICAgb2JqW3dvcmRzW2ldXSA9IHRydWU7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciBtb2RlbGljYUtleXdvcmRzID0gXCJhbGdvcml0aG0gYW5kIGFubm90YXRpb24gYXNzZXJ0IGJsb2NrIGJyZWFrIGNsYXNzIGNvbm5lY3QgY29ubmVjdG9yIGNvbnN0YW50IGNvbnN0cmFpbmVkYnkgZGVyIGRpc2NyZXRlIGVhY2ggZWxzZSBlbHNlaWYgZWxzZXdoZW4gZW5jYXBzdWxhdGVkIGVuZCBlbnVtZXJhdGlvbiBlcXVhdGlvbiBleHBhbmRhYmxlIGV4dGVuZHMgZXh0ZXJuYWwgZmFsc2UgZmluYWwgZmxvdyBmb3IgZnVuY3Rpb24gaWYgaW1wb3J0IGltcHVyZSBpbiBpbml0aWFsIGlubmVyIGlucHV0IGxvb3AgbW9kZWwgbm90IG9wZXJhdG9yIG9yIG91dGVyIG91dHB1dCBwYWNrYWdlIHBhcmFtZXRlciBwYXJ0aWFsIHByb3RlY3RlZCBwdWJsaWMgcHVyZSByZWNvcmQgcmVkZWNsYXJlIHJlcGxhY2VhYmxlIHJldHVybiBzdHJlYW0gdGhlbiB0cnVlIHR5cGUgd2hlbiB3aGlsZSB3aXRoaW5cIjtcbiAgdmFyIG1vZGVsaWNhQnVpbHRpbiA9IFwiYWJzIGFjb3MgYWN0dWFsU3RyZWFtIGFzaW4gYXRhbiBhdGFuMiBjYXJkaW5hbGl0eSBjZWlsIGNvcyBjb3NoIGRlbGF5IGRpdiBlZGdlIGV4cCBmbG9vciBnZXRJbnN0YW5jZU5hbWUgaG9tb3RvcHkgaW5TdHJlYW0gaW50ZWdlciBsb2cgbG9nMTAgbW9kIHByZSByZWluaXQgcmVtIHNlbWlMaW5lYXIgc2lnbiBzaW4gc2luaCBzcGF0aWFsRGlzdHJpYnV0aW9uIHNxcnQgdGFuIHRhbmhcIjtcbiAgdmFyIG1vZGVsaWNhQXRvbXMgPSBcIlJlYWwgQm9vbGVhbiBJbnRlZ2VyIFN0cmluZ1wiO1xuXG4gIGZ1bmN0aW9uIGRlZihtaW1lcywgbW9kZSkge1xuICAgIGlmICh0eXBlb2YgbWltZXMgPT0gXCJzdHJpbmdcIilcbiAgICAgIG1pbWVzID0gW21pbWVzXTtcblxuICAgIHZhciB3b3JkcyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gYWRkKG9iaikge1xuICAgICAgaWYgKG9iailcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBvYmopXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSlcbiAgICAgICAgICAgIHdvcmRzLnB1c2gocHJvcCk7XG4gICAgfVxuXG4gICAgYWRkKG1vZGUua2V5d29yZHMpO1xuICAgIGFkZChtb2RlLmJ1aWx0aW4pO1xuICAgIGFkZChtb2RlLmF0b21zKTtcblxuICAgIGlmICh3b3Jkcy5sZW5ndGgpIHtcbiAgICAgIG1vZGUuaGVscGVyVHlwZSA9IG1pbWVzWzBdO1xuICAgICAgQ29kZU1pcnJvci5yZWdpc3RlckhlbHBlcihcImhpbnRXb3Jkc1wiLCBtaW1lc1swXSwgd29yZHMpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGk9MDsgaTxtaW1lcy5sZW5ndGg7ICsraSlcbiAgICAgIENvZGVNaXJyb3IuZGVmaW5lTUlNRShtaW1lc1tpXSwgbW9kZSk7XG4gIH1cblxuICBkZWYoW1widGV4dC94LW1vZGVsaWNhXCJdLCB7XG4gICAgbmFtZTogXCJtb2RlbGljYVwiLFxuICAgIGtleXdvcmRzOiB3b3Jkcyhtb2RlbGljYUtleXdvcmRzKSxcbiAgICBidWlsdGluOiB3b3Jkcyhtb2RlbGljYUJ1aWx0aW4pLFxuICAgIGF0b21zOiB3b3Jkcyhtb2RlbGljYUF0b21zKVxuICB9KTtcbn0pO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuLy8gbW9kZShzKSBmb3IgdGhlIHNlcXVlbmNlIGNoYXJ0IGRzbCdzIG1zY2dlbiwgeMO5IGFuZCBtc2dlbm55XG4vLyBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBtc2NnZW4sIHNlZSB0aGUgc2l0ZSBvZiB0aGUgb3JpZ2luYWwgYXV0aG9yOlxuLy8gaHR0cDovL3d3dy5tY3Rlcm5hbi5tZS51ay9tc2NnZW5cbi8vXG4vLyBUaGlzIG1vZGUgZm9yIG1zY2dlbiBhbmQgdGhlIHR3byBkZXJpdmF0aXZlIGxhbmd1YWdlcyB3ZXJlXG4vLyBvcmlnaW5hbGx5IG1hZGUgZm9yIHVzZSBpbiB0aGUgbXNjZ2VuX2pzIGludGVycHJldGVyXG4vLyAoaHR0cHM6Ly9zdmVyd2Vpai5naXRodWIuaW8vbXNjZ2VuX2pzKVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICggdHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAoIHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBsYW5ndWFnZXMgPSB7XG4gICAgbXNjZ2VuOiB7XG4gICAgICBcImtleXdvcmRzXCIgOiBbXCJtc2NcIl0sXG4gICAgICBcIm9wdGlvbnNcIiA6IFtcImhzY2FsZVwiLCBcIndpZHRoXCIsIFwiYXJjZ3JhZGllbnRcIiwgXCJ3b3Jkd3JhcGFyY3NcIl0sXG4gICAgICBcImNvbnN0YW50c1wiIDogW1widHJ1ZVwiLCBcImZhbHNlXCIsIFwib25cIiwgXCJvZmZcIl0sXG4gICAgICBcImF0dHJpYnV0ZXNcIiA6IFtcImxhYmVsXCIsIFwiaWR1cmxcIiwgXCJpZFwiLCBcInVybFwiLCBcImxpbmVjb2xvclwiLCBcImxpbmVjb2xvdXJcIiwgXCJ0ZXh0Y29sb3JcIiwgXCJ0ZXh0Y29sb3VyXCIsIFwidGV4dGJnY29sb3JcIiwgXCJ0ZXh0Ymdjb2xvdXJcIiwgXCJhcmNsaW5lY29sb3JcIiwgXCJhcmNsaW5lY29sb3VyXCIsIFwiYXJjdGV4dGNvbG9yXCIsIFwiYXJjdGV4dGNvbG91clwiLCBcImFyY3RleHRiZ2NvbG9yXCIsIFwiYXJjdGV4dGJnY29sb3VyXCIsIFwiYXJjc2tpcFwiXSxcbiAgICAgIFwiYnJhY2tldHNcIiA6IFtcIlxcXFx7XCIsIFwiXFxcXH1cIl0sIC8vIFsgYW5kICBdIGFyZSBicmFja2V0cyB0b28sIGJ1dCB0aGVzZSBnZXQgaGFuZGxlZCBpbiB3aXRoIGxpc3RzXG4gICAgICBcImFyY3NXb3Jkc1wiIDogW1wibm90ZVwiLCBcImFib3hcIiwgXCJyYm94XCIsIFwiYm94XCJdLFxuICAgICAgXCJhcmNzT3RoZXJzXCIgOiBbXCJcXFxcfFxcXFx8XFxcXHxcIiwgXCJcXFxcLlxcXFwuXFxcXC5cIiwgXCItLS1cIiwgXCItLVwiLCBcIjwtPlwiLCBcIj09XCIsIFwiPDw9Pj5cIiwgXCI8PT5cIiwgXCJcXFxcLlxcXFwuXCIsIFwiPDw+PlwiLCBcIjo6XCIsIFwiPDo+XCIsIFwiLT5cIiwgXCI9Pj5cIiwgXCI9PlwiLCBcIj4+XCIsIFwiOj5cIiwgXCI8LVwiLCBcIjw8PVwiLCBcIjw9XCIsIFwiPDxcIiwgXCI8OlwiLCBcIngtXCIsIFwiLXhcIl0sXG4gICAgICBcInNpbmdsZWNvbW1lbnRcIiA6IFtcIi8vXCIsIFwiI1wiXSxcbiAgICAgIFwib3BlcmF0b3JzXCIgOiBbXCI9XCJdXG4gICAgfSxcbiAgICB4dToge1xuICAgICAgXCJrZXl3b3Jkc1wiIDogW1wibXNjXCIsIFwieHVcIl0sXG4gICAgICBcIm9wdGlvbnNcIiA6IFtcImhzY2FsZVwiLCBcIndpZHRoXCIsIFwiYXJjZ3JhZGllbnRcIiwgXCJ3b3Jkd3JhcGFyY3NcIiwgXCJ3b3Jkd3JhcGVudGl0aWVzXCIsIFwid2F0ZXJtYXJrXCJdLFxuICAgICAgXCJjb25zdGFudHNcIiA6IFtcInRydWVcIiwgXCJmYWxzZVwiLCBcIm9uXCIsIFwib2ZmXCIsIFwiYXV0b1wiXSxcbiAgICAgIFwiYXR0cmlidXRlc1wiIDogW1wibGFiZWxcIiwgXCJpZHVybFwiLCBcImlkXCIsIFwidXJsXCIsIFwibGluZWNvbG9yXCIsIFwibGluZWNvbG91clwiLCBcInRleHRjb2xvclwiLCBcInRleHRjb2xvdXJcIiwgXCJ0ZXh0Ymdjb2xvclwiLCBcInRleHRiZ2NvbG91clwiLCBcImFyY2xpbmVjb2xvclwiLCBcImFyY2xpbmVjb2xvdXJcIiwgXCJhcmN0ZXh0Y29sb3JcIiwgXCJhcmN0ZXh0Y29sb3VyXCIsIFwiYXJjdGV4dGJnY29sb3JcIiwgXCJhcmN0ZXh0Ymdjb2xvdXJcIiwgXCJhcmNza2lwXCIsIFwidGl0bGVcIiwgXCJkZWFjdGl2YXRlXCIsIFwiYWN0aXZhdGVcIiwgXCJhY3RpdmF0aW9uXCJdLFxuICAgICAgXCJicmFja2V0c1wiIDogW1wiXFxcXHtcIiwgXCJcXFxcfVwiXSwgIC8vIFsgYW5kICBdIGFyZSBicmFja2V0cyB0b28sIGJ1dCB0aGVzZSBnZXQgaGFuZGxlZCBpbiB3aXRoIGxpc3RzXG4gICAgICBcImFyY3NXb3Jkc1wiIDogW1wibm90ZVwiLCBcImFib3hcIiwgXCJyYm94XCIsIFwiYm94XCIsIFwiYWx0XCIsIFwiZWxzZVwiLCBcIm9wdFwiLCBcImJyZWFrXCIsIFwicGFyXCIsIFwic2VxXCIsIFwic3RyaWN0XCIsIFwibmVnXCIsIFwiY3JpdGljYWxcIiwgXCJpZ25vcmVcIiwgXCJjb25zaWRlclwiLCBcImFzc2VydFwiLCBcImxvb3BcIiwgXCJyZWZcIiwgXCJleGNcIl0sXG4gICAgICBcImFyY3NPdGhlcnNcIiA6IFtcIlxcXFx8XFxcXHxcXFxcfFwiLCBcIlxcXFwuXFxcXC5cXFxcLlwiLCBcIi0tLVwiLCBcIi0tXCIsIFwiPC0+XCIsIFwiPT1cIiwgXCI8PD0+PlwiLCBcIjw9PlwiLCBcIlxcXFwuXFxcXC5cIiwgXCI8PD4+XCIsIFwiOjpcIiwgXCI8Oj5cIiwgXCItPlwiLCBcIj0+PlwiLCBcIj0+XCIsIFwiPj5cIiwgXCI6PlwiLCBcIjwtXCIsIFwiPDw9XCIsIFwiPD1cIiwgXCI8PFwiLCBcIjw6XCIsIFwieC1cIiwgXCIteFwiXSxcbiAgICAgIFwic2luZ2xlY29tbWVudFwiIDogW1wiLy9cIiwgXCIjXCJdLFxuICAgICAgXCJvcGVyYXRvcnNcIiA6IFtcIj1cIl1cbiAgICB9LFxuICAgIG1zZ2Vubnk6IHtcbiAgICAgIFwia2V5d29yZHNcIiA6IG51bGwsXG4gICAgICBcIm9wdGlvbnNcIiA6IFtcImhzY2FsZVwiLCBcIndpZHRoXCIsIFwiYXJjZ3JhZGllbnRcIiwgXCJ3b3Jkd3JhcGFyY3NcIiwgXCJ3b3Jkd3JhcGVudGl0aWVzXCIsIFwid2F0ZXJtYXJrXCJdLFxuICAgICAgXCJjb25zdGFudHNcIiA6IFtcInRydWVcIiwgXCJmYWxzZVwiLCBcIm9uXCIsIFwib2ZmXCIsIFwiYXV0b1wiXSxcbiAgICAgIFwiYXR0cmlidXRlc1wiIDogbnVsbCxcbiAgICAgIFwiYnJhY2tldHNcIiA6IFtcIlxcXFx7XCIsIFwiXFxcXH1cIl0sXG4gICAgICBcImFyY3NXb3Jkc1wiIDogW1wibm90ZVwiLCBcImFib3hcIiwgXCJyYm94XCIsIFwiYm94XCIsIFwiYWx0XCIsIFwiZWxzZVwiLCBcIm9wdFwiLCBcImJyZWFrXCIsIFwicGFyXCIsIFwic2VxXCIsIFwic3RyaWN0XCIsIFwibmVnXCIsIFwiY3JpdGljYWxcIiwgXCJpZ25vcmVcIiwgXCJjb25zaWRlclwiLCBcImFzc2VydFwiLCBcImxvb3BcIiwgXCJyZWZcIiwgXCJleGNcIl0sXG4gICAgICBcImFyY3NPdGhlcnNcIiA6IFtcIlxcXFx8XFxcXHxcXFxcfFwiLCBcIlxcXFwuXFxcXC5cXFxcLlwiLCBcIi0tLVwiLCBcIi0tXCIsIFwiPC0+XCIsIFwiPT1cIiwgXCI8PD0+PlwiLCBcIjw9PlwiLCBcIlxcXFwuXFxcXC5cIiwgXCI8PD4+XCIsIFwiOjpcIiwgXCI8Oj5cIiwgXCItPlwiLCBcIj0+PlwiLCBcIj0+XCIsIFwiPj5cIiwgXCI6PlwiLCBcIjwtXCIsIFwiPDw9XCIsIFwiPD1cIiwgXCI8PFwiLCBcIjw6XCIsIFwieC1cIiwgXCIteFwiXSxcbiAgICAgIFwic2luZ2xlY29tbWVudFwiIDogW1wiLy9cIiwgXCIjXCJdLFxuICAgICAgXCJvcGVyYXRvcnNcIiA6IFtcIj1cIl1cbiAgICB9XG4gIH1cblxuICBDb2RlTWlycm9yLmRlZmluZU1vZGUoXCJtc2NnZW5cIiwgZnVuY3Rpb24oXywgbW9kZUNvbmZpZykge1xuICAgIHZhciBsYW5ndWFnZSA9IGxhbmd1YWdlc1ttb2RlQ29uZmlnICYmIG1vZGVDb25maWcubGFuZ3VhZ2UgfHwgXCJtc2NnZW5cIl1cbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnRTdGF0ZTogc3RhcnRTdGF0ZUZuLFxuICAgICAgY29weVN0YXRlOiBjb3B5U3RhdGVGbixcbiAgICAgIHRva2VuOiBwcm9kdWNlVG9rZW5GdW5jdGlvbihsYW5ndWFnZSksXG4gICAgICBsaW5lQ29tbWVudCA6IFwiI1wiLFxuICAgICAgYmxvY2tDb21tZW50U3RhcnQgOiBcIi8qXCIsXG4gICAgICBibG9ja0NvbW1lbnRFbmQgOiBcIiovXCJcbiAgICB9O1xuICB9KTtcblxuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3gtbXNjZ2VuXCIsIFwibXNjZ2VuXCIpO1xuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3gteHVcIiwge25hbWU6IFwibXNjZ2VuXCIsIGxhbmd1YWdlOiBcInh1XCJ9KTtcbiAgQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LW1zZ2VubnlcIiwge25hbWU6IFwibXNjZ2VuXCIsIGxhbmd1YWdlOiBcIm1zZ2VubnlcIn0pO1xuXG4gIGZ1bmN0aW9uIHdvcmRSZWdleHBCb3VuZGFyeShwV29yZHMpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChcIl5cXFxcYig/OlwiICsgcFdvcmRzLmpvaW4oXCJ8XCIpICsgXCIpXFxcXGJcIiwgXCJpXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gd29yZFJlZ2V4cChwV29yZHMpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChcIl4oPzpcIiArIHBXb3Jkcy5qb2luKFwifFwiKSArIFwiKVwiLCBcImlcIik7XG4gIH1cblxuICBmdW5jdGlvbiBzdGFydFN0YXRlRm4oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluQ29tbWVudCA6IGZhbHNlLFxuICAgICAgaW5TdHJpbmcgOiBmYWxzZSxcbiAgICAgIGluQXR0cmlidXRlTGlzdCA6IGZhbHNlLFxuICAgICAgaW5TY3JpcHQgOiBmYWxzZVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjb3B5U3RhdGVGbihwU3RhdGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW5Db21tZW50IDogcFN0YXRlLmluQ29tbWVudCxcbiAgICAgIGluU3RyaW5nIDogcFN0YXRlLmluU3RyaW5nLFxuICAgICAgaW5BdHRyaWJ1dGVMaXN0IDogcFN0YXRlLmluQXR0cmlidXRlTGlzdCxcbiAgICAgIGluU2NyaXB0IDogcFN0YXRlLmluU2NyaXB0XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2R1Y2VUb2tlbkZ1bmN0aW9uKHBDb25maWcpIHtcblxuICAgIHJldHVybiBmdW5jdGlvbihwU3RyZWFtLCBwU3RhdGUpIHtcbiAgICAgIGlmIChwU3RyZWFtLm1hdGNoKHdvcmRSZWdleHAocENvbmZpZy5icmFja2V0cyksIHRydWUsIHRydWUpKSB7XG4gICAgICAgIHJldHVybiBcImJyYWNrZXRcIjtcbiAgICAgIH1cbiAgICAgIC8qIGNvbW1lbnRzICovXG4gICAgICBpZiAoIXBTdGF0ZS5pbkNvbW1lbnQpIHtcbiAgICAgICAgaWYgKHBTdHJlYW0ubWF0Y2goL1xcL1xcKlteXFwqXFwvXSovLCB0cnVlLCB0cnVlKSkge1xuICAgICAgICAgIHBTdGF0ZS5pbkNvbW1lbnQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocFN0cmVhbS5tYXRjaCh3b3JkUmVnZXhwKHBDb25maWcuc2luZ2xlY29tbWVudCksIHRydWUsIHRydWUpKSB7XG4gICAgICAgICAgcFN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwU3RhdGUuaW5Db21tZW50KSB7XG4gICAgICAgIGlmIChwU3RyZWFtLm1hdGNoKC9bXlxcKlxcL10qXFwqXFwvLywgdHJ1ZSwgdHJ1ZSkpXG4gICAgICAgICAgcFN0YXRlLmluQ29tbWVudCA9IGZhbHNlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcFN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgICAgfVxuICAgICAgLyogc3RyaW5ncyAqL1xuICAgICAgaWYgKCFwU3RhdGUuaW5TdHJpbmcgJiYgcFN0cmVhbS5tYXRjaCgvXFxcIihcXFxcXFxcInxbXlxcXCJdKSovLCB0cnVlLCB0cnVlKSkge1xuICAgICAgICBwU3RhdGUuaW5TdHJpbmcgPSB0cnVlO1xuICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICAgIH1cbiAgICAgIGlmIChwU3RhdGUuaW5TdHJpbmcpIHtcbiAgICAgICAgaWYgKHBTdHJlYW0ubWF0Y2goL1teXFxcIl0qXFxcIi8sIHRydWUsIHRydWUpKVxuICAgICAgICAgIHBTdGF0ZS5pblN0cmluZyA9IGZhbHNlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcFN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgICB9XG4gICAgICAvKiBrZXl3b3JkcyAmIG9wZXJhdG9ycyAqL1xuICAgICAgaWYgKCEhcENvbmZpZy5rZXl3b3JkcyAmJiBwU3RyZWFtLm1hdGNoKHdvcmRSZWdleHBCb3VuZGFyeShwQ29uZmlnLmtleXdvcmRzKSwgdHJ1ZSwgdHJ1ZSkpXG4gICAgICAgIHJldHVybiBcImtleXdvcmRcIjtcblxuICAgICAgaWYgKHBTdHJlYW0ubWF0Y2god29yZFJlZ2V4cEJvdW5kYXJ5KHBDb25maWcub3B0aW9ucyksIHRydWUsIHRydWUpKVxuICAgICAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG5cbiAgICAgIGlmIChwU3RyZWFtLm1hdGNoKHdvcmRSZWdleHBCb3VuZGFyeShwQ29uZmlnLmFyY3NXb3JkcyksIHRydWUsIHRydWUpKVxuICAgICAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG5cbiAgICAgIGlmIChwU3RyZWFtLm1hdGNoKHdvcmRSZWdleHAocENvbmZpZy5hcmNzT3RoZXJzKSwgdHJ1ZSwgdHJ1ZSkpXG4gICAgICAgIHJldHVybiBcImtleXdvcmRcIjtcblxuICAgICAgaWYgKCEhcENvbmZpZy5vcGVyYXRvcnMgJiYgcFN0cmVhbS5tYXRjaCh3b3JkUmVnZXhwKHBDb25maWcub3BlcmF0b3JzKSwgdHJ1ZSwgdHJ1ZSkpXG4gICAgICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG5cbiAgICAgIGlmICghIXBDb25maWcuY29uc3RhbnRzICYmIHBTdHJlYW0ubWF0Y2god29yZFJlZ2V4cChwQ29uZmlnLmNvbnN0YW50cyksIHRydWUsIHRydWUpKVxuICAgICAgICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xuXG4gICAgICAvKiBhdHRyaWJ1dGUgbGlzdHMgKi9cbiAgICAgIGlmICghcENvbmZpZy5pbkF0dHJpYnV0ZUxpc3QgJiYgISFwQ29uZmlnLmF0dHJpYnV0ZXMgJiYgcFN0cmVhbS5tYXRjaCgnWycsIHRydWUsIHRydWUpKSB7XG4gICAgICAgIHBDb25maWcuaW5BdHRyaWJ1dGVMaXN0ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIFwiYnJhY2tldFwiO1xuICAgICAgfVxuICAgICAgaWYgKHBDb25maWcuaW5BdHRyaWJ1dGVMaXN0KSB7XG4gICAgICAgIGlmIChwQ29uZmlnLmF0dHJpYnV0ZXMgIT09IG51bGwgJiYgcFN0cmVhbS5tYXRjaCh3b3JkUmVnZXhwQm91bmRhcnkocENvbmZpZy5hdHRyaWJ1dGVzKSwgdHJ1ZSwgdHJ1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gXCJhdHRyaWJ1dGVcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocFN0cmVhbS5tYXRjaCgnXScsIHRydWUsIHRydWUpKSB7XG4gICAgICAgICAgcENvbmZpZy5pbkF0dHJpYnV0ZUxpc3QgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gXCJicmFja2V0XCI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcFN0cmVhbS5uZXh0KCk7XG4gICAgICByZXR1cm4gXCJiYXNlXCI7XG4gICAgfTtcbiAgfVxuXG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbi8qXG4gIFRoaXMgTVVNUFMgTGFuZ3VhZ2Ugc2NyaXB0IHdhcyBjb25zdHJ1Y3RlZCB1c2luZyB2YnNjcmlwdC5qcyBhcyBhIHRlbXBsYXRlLlxuKi9cblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwibXVtcHNcIiwgZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gd29yZFJlZ2V4cCh3b3Jkcykge1xuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoXCJeKChcIiArIHdvcmRzLmpvaW4oXCIpfChcIikgKyBcIikpXFxcXGJcIiwgXCJpXCIpO1xuICAgIH1cblxuICAgIHZhciBzaW5nbGVPcGVyYXRvcnMgPSBuZXcgUmVnRXhwKFwiXltcXFxcK1xcXFwtXFxcXCovJiMhXz9cXFxcXFxcXDw+PVxcXFwnXFxcXFtcXFxcXV1cIik7XG4gICAgdmFyIGRvdWJsZU9wZXJhdG9ycyA9IG5ldyBSZWdFeHAoXCJeKCgnPSl8KDw9KXwoPj0pfCgnPil8KCc8KXwoW1spfChdXSl8KF4kKSlcIik7XG4gICAgdmFyIHNpbmdsZURlbGltaXRlcnMgPSBuZXcgUmVnRXhwKFwiXltcXFxcLiw6XVwiKTtcbiAgICB2YXIgYnJhY2tldHMgPSBuZXcgUmVnRXhwKFwiWygpXVwiKTtcbiAgICB2YXIgaWRlbnRpZmllcnMgPSBuZXcgUmVnRXhwKFwiXlslQS1aYS16XVtBLVphLXowLTldKlwiKTtcbiAgICB2YXIgY29tbWFuZEtleXdvcmRzID0gW1wiYnJlYWtcIixcImNsb3NlXCIsXCJkb1wiLFwiZWxzZVwiLFwiZm9yXCIsXCJnb3RvXCIsIFwiaGFsdFwiLCBcImhhbmdcIiwgXCJpZlwiLCBcImpvYlwiLFwia2lsbFwiLFwibG9ja1wiLFwibWVyZ2VcIixcIm5ld1wiLFwib3BlblwiLCBcInF1aXRcIiwgXCJyZWFkXCIsIFwic2V0XCIsIFwidGNvbW1pdFwiLCBcInRyb2xsYmFja1wiLCBcInRzdGFydFwiLCBcInVzZVwiLCBcInZpZXdcIiwgXCJ3cml0ZVwiLCBcInhlY3V0ZVwiLCBcImJcIixcImNcIixcImRcIixcImVcIixcImZcIixcImdcIiwgXCJoXCIsIFwiaVwiLCBcImpcIixcImtcIixcImxcIixcIm1cIixcIm5cIixcIm9cIiwgXCJxXCIsIFwiclwiLCBcInNcIiwgXCJ0Y1wiLCBcInRyb1wiLCBcInRzXCIsIFwidVwiLCBcInZcIiwgXCJ3XCIsIFwieFwiXTtcbiAgICAvLyBUaGUgZm9sbG93aW5nIGxpc3QgaW5jbHVkZXMgaW50cmluc2ljIGZ1bmN0aW9ucyBfYW5kXyBzcGVjaWFsIHZhcmlhYmxlc1xuICAgIHZhciBpbnRyaW5zaWNGdW5jc1dvcmRzID0gW1wiXFxcXCRhc2NpaVwiLCBcIlxcXFwkY2hhclwiLCBcIlxcXFwkZGF0YVwiLCBcIlxcXFwkZWNvZGVcIiwgXCJcXFxcJGVzdGFja1wiLCBcIlxcXFwkZXRyYXBcIiwgXCJcXFxcJGV4dHJhY3RcIiwgXCJcXFxcJGZpbmRcIiwgXCJcXFxcJGZudW1iZXJcIiwgXCJcXFxcJGdldFwiLCBcIlxcXFwkaG9yb2xvZ1wiLCBcIlxcXFwkaW9cIiwgXCJcXFxcJGluY3JlbWVudFwiLCBcIlxcXFwkam9iXCIsIFwiXFxcXCRqdXN0aWZ5XCIsIFwiXFxcXCRsZW5ndGhcIiwgXCJcXFxcJG5hbWVcIiwgXCJcXFxcJG5leHRcIiwgXCJcXFxcJG9yZGVyXCIsIFwiXFxcXCRwaWVjZVwiLCBcIlxcXFwkcWxlbmd0aFwiLCBcIlxcXFwkcXN1YnNjcmlwdFwiLCBcIlxcXFwkcXVlcnlcIiwgXCJcXFxcJHF1aXRcIiwgXCJcXFxcJHJhbmRvbVwiLCBcIlxcXFwkcmV2ZXJzZVwiLCBcIlxcXFwkc2VsZWN0XCIsIFwiXFxcXCRzdGFja1wiLCBcIlxcXFwkdGVzdFwiLCBcIlxcXFwkdGV4dFwiLCBcIlxcXFwkdHJhbnNsYXRlXCIsIFwiXFxcXCR2aWV3XCIsIFwiXFxcXCR4XCIsIFwiXFxcXCR5XCIsIFwiXFxcXCRhXCIsIFwiXFxcXCRjXCIsIFwiXFxcXCRkXCIsIFwiXFxcXCRlXCIsIFwiXFxcXCRlY1wiLCBcIlxcXFwkZXNcIiwgXCJcXFxcJGV0XCIsIFwiXFxcXCRmXCIsIFwiXFxcXCRmblwiLCBcIlxcXFwkZ1wiLCBcIlxcXFwkaFwiLCBcIlxcXFwkaVwiLCBcIlxcXFwkalwiLCBcIlxcXFwkbFwiLCBcIlxcXFwkblwiLCBcIlxcXFwkbmFcIiwgXCJcXFxcJG9cIiwgXCJcXFxcJHBcIiwgXCJcXFxcJHFcIiwgXCJcXFxcJHFsXCIsIFwiXFxcXCRxc1wiLCBcIlxcXFwkclwiLCBcIlxcXFwkcmVcIiwgXCJcXFxcJHNcIiwgXCJcXFxcJHN0XCIsIFwiXFxcXCR0XCIsIFwiXFxcXCR0clwiLCBcIlxcXFwkdlwiLCBcIlxcXFwkelwiXTtcbiAgICB2YXIgaW50cmluc2ljRnVuY3MgPSB3b3JkUmVnZXhwKGludHJpbnNpY0Z1bmNzV29yZHMpO1xuICAgIHZhciBjb21tYW5kID0gd29yZFJlZ2V4cChjb21tYW5kS2V5d29yZHMpO1xuXG4gICAgZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmIChzdHJlYW0uc29sKCkpIHtcbiAgICAgICAgc3RhdGUubGFiZWwgPSB0cnVlO1xuICAgICAgICBzdGF0ZS5jb21tYW5kTW9kZSA9IDA7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSA8c3BhY2U+IGNoYXJhY3RlciBoYXMgbWVhbmluZyBpbiBNVU1QUy4gSWdub3JpbmcgY29uc2VjdXRpdmVcbiAgICAgIC8vIHNwYWNlcyB3b3VsZCBpbnRlcmZlcmUgd2l0aCBpbnRlcnByZXRpbmcgd2hldGhlciB0aGUgbmV4dCBub24tc3BhY2VcbiAgICAgIC8vIGNoYXJhY3RlciBiZWxvbmdzIHRvIHRoZSBjb21tYW5kIG9yIGFyZ3VtZW50IGNvbnRleHQuXG5cbiAgICAgIC8vIEV4YW1pbmUgZWFjaCBjaGFyYWN0ZXIgYW5kIHVwZGF0ZSBhIG1vZGUgdmFyaWFibGUgd2hvc2UgaW50ZXJwcmV0YXRpb24gaXM6XG4gICAgICAvLyAgID4wID0+IGNvbW1hbmQgICAgMCA9PiBhcmd1bWVudCAgICA8MCA9PiBjb21tYW5kIHBvc3QtY29uZGl0aW9uYWxcbiAgICAgIHZhciBjaCA9IHN0cmVhbS5wZWVrKCk7XG5cbiAgICAgIGlmIChjaCA9PSBcIiBcIiB8fCBjaCA9PSBcIlxcdFwiKSB7IC8vIFByZS1wcm9jZXNzIDxzcGFjZT5cbiAgICAgICAgc3RhdGUubGFiZWwgPSBmYWxzZTtcbiAgICAgICAgaWYgKHN0YXRlLmNvbW1hbmRNb2RlID09IDApXG4gICAgICAgICAgc3RhdGUuY29tbWFuZE1vZGUgPSAxO1xuICAgICAgICBlbHNlIGlmICgoc3RhdGUuY29tbWFuZE1vZGUgPCAwKSB8fCAoc3RhdGUuY29tbWFuZE1vZGUgPT0gMikpXG4gICAgICAgICAgc3RhdGUuY29tbWFuZE1vZGUgPSAwO1xuICAgICAgfSBlbHNlIGlmICgoY2ggIT0gXCIuXCIpICYmIChzdGF0ZS5jb21tYW5kTW9kZSA+IDApKSB7XG4gICAgICAgIGlmIChjaCA9PSBcIjpcIilcbiAgICAgICAgICBzdGF0ZS5jb21tYW5kTW9kZSA9IC0xOyAgIC8vIFNJUyAtIENvbW1hbmQgcG9zdC1jb25kaXRpb25hbFxuICAgICAgICBlbHNlXG4gICAgICAgICAgc3RhdGUuY29tbWFuZE1vZGUgPSAyO1xuICAgICAgfVxuXG4gICAgICAvLyBEbyBub3QgY29sb3IgcGFyYW1ldGVyIGxpc3QgYXMgbGluZSB0YWdcbiAgICAgIGlmICgoY2ggPT09IFwiKFwiKSB8fCAoY2ggPT09IFwiXFx1MDAwOVwiKSlcbiAgICAgICAgc3RhdGUubGFiZWwgPSBmYWxzZTtcblxuICAgICAgLy8gTVVNUFMgY29tbWVudCBzdGFydHMgd2l0aCBcIjtcIlxuICAgICAgaWYgKGNoID09PSBcIjtcIikge1xuICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICAgIH1cblxuICAgICAgLy8gTnVtYmVyIExpdGVyYWxzIC8vIFNJUy9STE0gLSBNVU1QUyBwZXJtaXRzIGNhbm9uaWMgbnVtYmVyIGZvbGxvd2VkIGJ5IGNvbmNhdGVuYXRlIG9wZXJhdG9yXG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eWy0rXT9cXGQrKFxcLlxcZCspPyhbZUVdWy0rXT9cXGQrKT8vKSlcbiAgICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG5cbiAgICAgIC8vIEhhbmRsZSBTdHJpbmdzXG4gICAgICBpZiAoY2ggPT0gJ1wiJykge1xuICAgICAgICBpZiAoc3RyZWFtLnNraXBUbygnXCInKSkge1xuICAgICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICAgIHJldHVybiBcImVycm9yXCI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSGFuZGxlIG9wZXJhdG9ycyBhbmQgRGVsaW1pdGVyc1xuICAgICAgaWYgKHN0cmVhbS5tYXRjaChkb3VibGVPcGVyYXRvcnMpIHx8IHN0cmVhbS5tYXRjaChzaW5nbGVPcGVyYXRvcnMpKVxuICAgICAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuXG4gICAgICAvLyBQcmV2ZW50cyBsZWFkaW5nIFwiLlwiIGluIERPIGJsb2NrIGZyb20gZmFsbGluZyB0aHJvdWdoIHRvIGVycm9yXG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKHNpbmdsZURlbGltaXRlcnMpKVxuICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgaWYgKGJyYWNrZXRzLnRlc3QoY2gpKSB7XG4gICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIHJldHVybiBcImJyYWNrZXRcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlLmNvbW1hbmRNb2RlID4gMCAmJiBzdHJlYW0ubWF0Y2goY29tbWFuZCkpXG4gICAgICAgIHJldHVybiBcInZhcmlhYmxlLTJcIjtcblxuICAgICAgaWYgKHN0cmVhbS5tYXRjaChpbnRyaW5zaWNGdW5jcykpXG4gICAgICAgIHJldHVybiBcImJ1aWx0aW5cIjtcblxuICAgICAgaWYgKHN0cmVhbS5tYXRjaChpZGVudGlmaWVycykpXG4gICAgICAgIHJldHVybiBcInZhcmlhYmxlXCI7XG5cbiAgICAgIC8vIERldGVjdCBkb2xsYXItc2lnbiB3aGVuIG5vdCBhIGRvY3VtZW50ZWQgaW50cmluc2ljIGZ1bmN0aW9uXG4gICAgICAvLyBcIl5cIiBtYXkgaW50cm9kdWNlIGEgR1ZOIG9yIFNTVk4gLSBDb2xvciBzYW1lIGFzIGZ1bmN0aW9uXG4gICAgICBpZiAoY2ggPT09IFwiJFwiIHx8IGNoID09PSBcIl5cIikge1xuICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICByZXR1cm4gXCJidWlsdGluXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIE1VTVBTIEluZGlyZWN0aW9uXG4gICAgICBpZiAoY2ggPT09IFwiQFwiKSB7XG4gICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIHJldHVybiBcInN0cmluZy0yXCI7XG4gICAgICB9XG5cbiAgICAgIGlmICgvW1xcdyVdLy50ZXN0KGNoKSkge1xuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHclXS8pO1xuICAgICAgICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xuICAgICAgfVxuXG4gICAgICAvLyBIYW5kbGUgbm9uLWRldGVjdGVkIGl0ZW1zXG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgcmV0dXJuIFwiZXJyb3JcIjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGFiZWw6IGZhbHNlLFxuICAgICAgICAgIGNvbW1hbmRNb2RlOiAwXG4gICAgICAgIH07XG4gICAgICB9LFxuXG4gICAgICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgICB2YXIgc3R5bGUgPSB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIGlmIChzdGF0ZS5sYWJlbCkgcmV0dXJuIFwidGFnXCI7XG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcblxuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3gtbXVtcHNcIiwgXCJtdW1wc1wiKTtcbn0pO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcblwidXNlIHN0cmljdFwiO1xuXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoXCJuZ2lueFwiLCBmdW5jdGlvbihjb25maWcpIHtcblxuICBmdW5jdGlvbiB3b3JkcyhzdHIpIHtcbiAgICB2YXIgb2JqID0ge30sIHdvcmRzID0gc3RyLnNwbGl0KFwiIFwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgKytpKSBvYmpbd29yZHNbaV1dID0gdHJ1ZTtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIGtleXdvcmRzID0gd29yZHMoXG4gICAgLyogbmd4RGlyZWN0aXZlQ29udHJvbCAqLyBcImJyZWFrIHJldHVybiByZXdyaXRlIHNldFwiICtcbiAgICAvKiBuZ3hEaXJlY3RpdmUgKi8gXCIgYWNjZXB0X211dGV4IGFjY2VwdF9tdXRleF9kZWxheSBhY2Nlc3NfbG9nIGFkZF9hZnRlcl9ib2R5IGFkZF9iZWZvcmVfYm9keSBhZGRfaGVhZGVyIGFkZGl0aW9uX3R5cGVzIGFpbyBhbGlhcyBhbGxvdyBhbmNpZW50X2Jyb3dzZXIgYW5jaWVudF9icm93c2VyX3ZhbHVlIGF1dGhfYmFzaWMgYXV0aF9iYXNpY191c2VyX2ZpbGUgYXV0aF9odHRwIGF1dGhfaHR0cF9oZWFkZXIgYXV0aF9odHRwX3RpbWVvdXQgYXV0b2luZGV4IGF1dG9pbmRleF9leGFjdF9zaXplIGF1dG9pbmRleF9sb2NhbHRpbWUgY2hhcnNldCBjaGFyc2V0X3R5cGVzIGNsaWVudF9ib2R5X2J1ZmZlcl9zaXplIGNsaWVudF9ib2R5X2luX2ZpbGVfb25seSBjbGllbnRfYm9keV9pbl9zaW5nbGVfYnVmZmVyIGNsaWVudF9ib2R5X3RlbXBfcGF0aCBjbGllbnRfYm9keV90aW1lb3V0IGNsaWVudF9oZWFkZXJfYnVmZmVyX3NpemUgY2xpZW50X2hlYWRlcl90aW1lb3V0IGNsaWVudF9tYXhfYm9keV9zaXplIGNvbm5lY3Rpb25fcG9vbF9zaXplIGNyZWF0ZV9mdWxsX3B1dF9wYXRoIGRhZW1vbiBkYXZfYWNjZXNzIGRhdl9tZXRob2RzIGRlYnVnX2Nvbm5lY3Rpb24gZGVidWdfcG9pbnRzIGRlZmF1bHRfdHlwZSBkZWdyYWRhdGlvbiBkZWdyYWRlIGRlbnkgZGV2cG9sbF9jaGFuZ2VzIGRldnBvbGxfZXZlbnRzIGRpcmVjdGlvIGRpcmVjdGlvX2FsaWdubWVudCBlbXB0eV9naWYgZW52IGVwb2xsX2V2ZW50cyBlcnJvcl9sb2cgZXZlbnRwb3J0X2V2ZW50cyBleHBpcmVzIGZhc3RjZ2lfYmluZCBmYXN0Y2dpX2J1ZmZlcl9zaXplIGZhc3RjZ2lfYnVmZmVycyBmYXN0Y2dpX2J1c3lfYnVmZmVyc19zaXplIGZhc3RjZ2lfY2FjaGUgZmFzdGNnaV9jYWNoZV9rZXkgZmFzdGNnaV9jYWNoZV9tZXRob2RzIGZhc3RjZ2lfY2FjaGVfbWluX3VzZXMgZmFzdGNnaV9jYWNoZV9wYXRoIGZhc3RjZ2lfY2FjaGVfdXNlX3N0YWxlIGZhc3RjZ2lfY2FjaGVfdmFsaWQgZmFzdGNnaV9jYXRjaF9zdGRlcnIgZmFzdGNnaV9jb25uZWN0X3RpbWVvdXQgZmFzdGNnaV9oaWRlX2hlYWRlciBmYXN0Y2dpX2lnbm9yZV9jbGllbnRfYWJvcnQgZmFzdGNnaV9pZ25vcmVfaGVhZGVycyBmYXN0Y2dpX2luZGV4IGZhc3RjZ2lfaW50ZXJjZXB0X2Vycm9ycyBmYXN0Y2dpX21heF90ZW1wX2ZpbGVfc2l6ZSBmYXN0Y2dpX25leHRfdXBzdHJlYW0gZmFzdGNnaV9wYXJhbSBmYXN0Y2dpX3Bhc3NfaGVhZGVyIGZhc3RjZ2lfcGFzc19yZXF1ZXN0X2JvZHkgZmFzdGNnaV9wYXNzX3JlcXVlc3RfaGVhZGVycyBmYXN0Y2dpX3JlYWRfdGltZW91dCBmYXN0Y2dpX3NlbmRfbG93YXQgZmFzdGNnaV9zZW5kX3RpbWVvdXQgZmFzdGNnaV9zcGxpdF9wYXRoX2luZm8gZmFzdGNnaV9zdG9yZSBmYXN0Y2dpX3N0b3JlX2FjY2VzcyBmYXN0Y2dpX3RlbXBfZmlsZV93cml0ZV9zaXplIGZhc3RjZ2lfdGVtcF9wYXRoIGZhc3RjZ2lfdXBzdHJlYW1fZmFpbF90aW1lb3V0IGZhc3RjZ2lfdXBzdHJlYW1fbWF4X2ZhaWxzIGZsdiBnZW9pcF9jaXR5IGdlb2lwX2NvdW50cnkgZ29vZ2xlX3BlcmZ0b29sc19wcm9maWxlcyBnemlwIGd6aXBfYnVmZmVycyBnemlwX2NvbXBfbGV2ZWwgZ3ppcF9kaXNhYmxlIGd6aXBfaGFzaCBnemlwX2h0dHBfdmVyc2lvbiBnemlwX21pbl9sZW5ndGggZ3ppcF9ub19idWZmZXIgZ3ppcF9wcm94aWVkIGd6aXBfc3RhdGljIGd6aXBfdHlwZXMgZ3ppcF92YXJ5IGd6aXBfd2luZG93IGlmX21vZGlmaWVkX3NpbmNlIGlnbm9yZV9pbnZhbGlkX2hlYWRlcnMgaW1hZ2VfZmlsdGVyIGltYWdlX2ZpbHRlcl9idWZmZXIgaW1hZ2VfZmlsdGVyX2pwZWdfcXVhbGl0eSBpbWFnZV9maWx0ZXJfdHJhbnNwYXJlbmN5IGltYXBfYXV0aCBpbWFwX2NhcGFiaWxpdGllcyBpbWFwX2NsaWVudF9idWZmZXIgaW5kZXggaXBfaGFzaCBrZWVwYWxpdmVfcmVxdWVzdHMga2VlcGFsaXZlX3RpbWVvdXQga3F1ZXVlX2NoYW5nZXMga3F1ZXVlX2V2ZW50cyBsYXJnZV9jbGllbnRfaGVhZGVyX2J1ZmZlcnMgbGltaXRfY29ubiBsaW1pdF9jb25uX2xvZ19sZXZlbCBsaW1pdF9yYXRlIGxpbWl0X3JhdGVfYWZ0ZXIgbGltaXRfcmVxIGxpbWl0X3JlcV9sb2dfbGV2ZWwgbGltaXRfcmVxX3pvbmUgbGltaXRfem9uZSBsaW5nZXJpbmdfdGltZSBsaW5nZXJpbmdfdGltZW91dCBsb2NrX2ZpbGUgbG9nX2Zvcm1hdCBsb2dfbm90X2ZvdW5kIGxvZ19zdWJyZXF1ZXN0IG1hcF9oYXNoX2J1Y2tldF9zaXplIG1hcF9oYXNoX21heF9zaXplIG1hc3Rlcl9wcm9jZXNzIG1lbWNhY2hlZF9iaW5kIG1lbWNhY2hlZF9idWZmZXJfc2l6ZSBtZW1jYWNoZWRfY29ubmVjdF90aW1lb3V0IG1lbWNhY2hlZF9uZXh0X3Vwc3RyZWFtIG1lbWNhY2hlZF9yZWFkX3RpbWVvdXQgbWVtY2FjaGVkX3NlbmRfdGltZW91dCBtZW1jYWNoZWRfdXBzdHJlYW1fZmFpbF90aW1lb3V0IG1lbWNhY2hlZF91cHN0cmVhbV9tYXhfZmFpbHMgbWVyZ2Vfc2xhc2hlcyBtaW5fZGVsZXRlX2RlcHRoIG1vZGVybl9icm93c2VyIG1vZGVybl9icm93c2VyX3ZhbHVlIG1zaWVfcGFkZGluZyBtc2llX3JlZnJlc2ggbXVsdGlfYWNjZXB0IG9wZW5fZmlsZV9jYWNoZSBvcGVuX2ZpbGVfY2FjaGVfZXJyb3JzIG9wZW5fZmlsZV9jYWNoZV9ldmVudHMgb3Blbl9maWxlX2NhY2hlX21pbl91c2VzIG9wZW5fZmlsZV9jYWNoZV92YWxpZCBvcGVuX2xvZ19maWxlX2NhY2hlIG91dHB1dF9idWZmZXJzIG92ZXJyaWRlX2NoYXJzZXQgcGVybCBwZXJsX21vZHVsZXMgcGVybF9yZXF1aXJlIHBlcmxfc2V0IHBpZCBwb3AzX2F1dGggcG9wM19jYXBhYmlsaXRpZXMgcG9ydF9pbl9yZWRpcmVjdCBwb3N0cG9uZV9nemlwcGluZyBwb3N0cG9uZV9vdXRwdXQgcHJvdG9jb2wgcHJveHkgcHJveHlfYmluZCBwcm94eV9idWZmZXIgcHJveHlfYnVmZmVyX3NpemUgcHJveHlfYnVmZmVyaW5nIHByb3h5X2J1ZmZlcnMgcHJveHlfYnVzeV9idWZmZXJzX3NpemUgcHJveHlfY2FjaGUgcHJveHlfY2FjaGVfa2V5IHByb3h5X2NhY2hlX21ldGhvZHMgcHJveHlfY2FjaGVfbWluX3VzZXMgcHJveHlfY2FjaGVfcGF0aCBwcm94eV9jYWNoZV91c2Vfc3RhbGUgcHJveHlfY2FjaGVfdmFsaWQgcHJveHlfY29ubmVjdF90aW1lb3V0IHByb3h5X2hlYWRlcnNfaGFzaF9idWNrZXRfc2l6ZSBwcm94eV9oZWFkZXJzX2hhc2hfbWF4X3NpemUgcHJveHlfaGlkZV9oZWFkZXIgcHJveHlfaWdub3JlX2NsaWVudF9hYm9ydCBwcm94eV9pZ25vcmVfaGVhZGVycyBwcm94eV9pbnRlcmNlcHRfZXJyb3JzIHByb3h5X21heF90ZW1wX2ZpbGVfc2l6ZSBwcm94eV9tZXRob2QgcHJveHlfbmV4dF91cHN0cmVhbSBwcm94eV9wYXNzX2Vycm9yX21lc3NhZ2UgcHJveHlfcGFzc19oZWFkZXIgcHJveHlfcGFzc19yZXF1ZXN0X2JvZHkgcHJveHlfcGFzc19yZXF1ZXN0X2hlYWRlcnMgcHJveHlfcmVhZF90aW1lb3V0IHByb3h5X3JlZGlyZWN0IHByb3h5X3NlbmRfbG93YXQgcHJveHlfc2VuZF90aW1lb3V0IHByb3h5X3NldF9ib2R5IHByb3h5X3NldF9oZWFkZXIgcHJveHlfc3NsX3Nlc3Npb25fcmV1c2UgcHJveHlfc3RvcmUgcHJveHlfc3RvcmVfYWNjZXNzIHByb3h5X3RlbXBfZmlsZV93cml0ZV9zaXplIHByb3h5X3RlbXBfcGF0aCBwcm94eV90aW1lb3V0IHByb3h5X3Vwc3RyZWFtX2ZhaWxfdGltZW91dCBwcm94eV91cHN0cmVhbV9tYXhfZmFpbHMgcmFuZG9tX2luZGV4IHJlYWRfYWhlYWQgcmVhbF9pcF9oZWFkZXIgcmVjdXJzaXZlX2Vycm9yX3BhZ2VzIHJlcXVlc3RfcG9vbF9zaXplIHJlc2V0X3RpbWVkb3V0X2Nvbm5lY3Rpb24gcmVzb2x2ZXIgcmVzb2x2ZXJfdGltZW91dCByZXdyaXRlX2xvZyBydHNpZ19vdmVyZmxvd19ldmVudHMgcnRzaWdfb3ZlcmZsb3dfdGVzdCBydHNpZ19vdmVyZmxvd190aHJlc2hvbGQgcnRzaWdfc2lnbm8gc2F0aXNmeSBzZWN1cmVfbGlua19zZWNyZXQgc2VuZF9sb3dhdCBzZW5kX3RpbWVvdXQgc2VuZGZpbGUgc2VuZGZpbGVfbWF4X2NodW5rIHNlcnZlcl9uYW1lX2luX3JlZGlyZWN0IHNlcnZlcl9uYW1lc19oYXNoX2J1Y2tldF9zaXplIHNlcnZlcl9uYW1lc19oYXNoX21heF9zaXplIHNlcnZlcl90b2tlbnMgc2V0X3JlYWxfaXBfZnJvbSBzbXRwX2F1dGggc210cF9jYXBhYmlsaXRpZXMgc210cF9jbGllbnRfYnVmZmVyIHNtdHBfZ3JlZXRpbmdfZGVsYXkgc29fa2VlcGFsaXZlIHNvdXJjZV9jaGFyc2V0IHNzaSBzc2lfaWdub3JlX3JlY3ljbGVkX2J1ZmZlcnMgc3NpX21pbl9maWxlX2NodW5rIHNzaV9zaWxlbnRfZXJyb3JzIHNzaV90eXBlcyBzc2lfdmFsdWVfbGVuZ3RoIHNzbCBzc2xfY2VydGlmaWNhdGUgc3NsX2NlcnRpZmljYXRlX2tleSBzc2xfY2lwaGVycyBzc2xfY2xpZW50X2NlcnRpZmljYXRlIHNzbF9jcmwgc3NsX2RocGFyYW0gc3NsX2VuZ2luZSBzc2xfcHJlZmVyX3NlcnZlcl9jaXBoZXJzIHNzbF9wcm90b2NvbHMgc3NsX3Nlc3Npb25fY2FjaGUgc3NsX3Nlc3Npb25fdGltZW91dCBzc2xfdmVyaWZ5X2NsaWVudCBzc2xfdmVyaWZ5X2RlcHRoIHN0YXJ0dGxzIHN0dWJfc3RhdHVzIHN1Yl9maWx0ZXIgc3ViX2ZpbHRlcl9vbmNlIHN1Yl9maWx0ZXJfdHlwZXMgdGNwX25vZGVsYXkgdGNwX25vcHVzaCB0aHJlYWRfc3RhY2tfc2l6ZSB0aW1lb3V0IHRpbWVyX3Jlc29sdXRpb24gdHlwZXNfaGFzaF9idWNrZXRfc2l6ZSB0eXBlc19oYXNoX21heF9zaXplIHVuZGVyc2NvcmVzX2luX2hlYWRlcnMgdW5pbml0aWFsaXplZF92YXJpYWJsZV93YXJuIHVzZSB1c2VyIHVzZXJpZCB1c2VyaWRfZG9tYWluIHVzZXJpZF9leHBpcmVzIHVzZXJpZF9tYXJrIHVzZXJpZF9uYW1lIHVzZXJpZF9wM3AgdXNlcmlkX3BhdGggdXNlcmlkX3NlcnZpY2UgdmFsaWRfcmVmZXJlcnMgdmFyaWFibGVzX2hhc2hfYnVja2V0X3NpemUgdmFyaWFibGVzX2hhc2hfbWF4X3NpemUgd29ya2VyX2Nvbm5lY3Rpb25zIHdvcmtlcl9jcHVfYWZmaW5pdHkgd29ya2VyX3ByaW9yaXR5IHdvcmtlcl9wcm9jZXNzZXMgd29ya2VyX3JsaW1pdF9jb3JlIHdvcmtlcl9ybGltaXRfbm9maWxlIHdvcmtlcl9ybGltaXRfc2lncGVuZGluZyB3b3JrZXJfdGhyZWFkcyB3b3JraW5nX2RpcmVjdG9yeSB4Y2xpZW50IHhtbF9lbnRpdGllcyB4c2x0X3N0eWxlc2hlZXQgeHNsdF90eXBlc2RyZXdAbGkyMjktMjNcIlxuICAgICk7XG5cbiAgdmFyIGtleXdvcmRzX2Jsb2NrID0gd29yZHMoXG4gICAgLyogbmd4RGlyZWN0aXZlQmxvY2sgKi8gXCJodHRwIG1haWwgZXZlbnRzIHNlcnZlciB0eXBlcyBsb2NhdGlvbiB1cHN0cmVhbSBjaGFyc2V0X21hcCBsaW1pdF9leGNlcHQgaWYgZ2VvIG1hcFwiXG4gICAgKTtcblxuICB2YXIga2V5d29yZHNfaW1wb3J0YW50ID0gd29yZHMoXG4gICAgLyogbmd4RGlyZWN0aXZlSW1wb3J0YW50ICovIFwiaW5jbHVkZSByb290IHNlcnZlciBzZXJ2ZXJfbmFtZSBsaXN0ZW4gaW50ZXJuYWwgcHJveHlfcGFzcyBtZW1jYWNoZWRfcGFzcyBmYXN0Y2dpX3Bhc3MgdHJ5X2ZpbGVzXCJcbiAgICApO1xuXG4gIHZhciBpbmRlbnRVbml0ID0gY29uZmlnLmluZGVudFVuaXQsIHR5cGU7XG4gIGZ1bmN0aW9uIHJldChzdHlsZSwgdHApIHt0eXBlID0gdHA7IHJldHVybiBzdHlsZTt9XG5cbiAgZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcblxuXG4gICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwkX10vKTtcblxuICAgIHZhciBjdXIgPSBzdHJlYW0uY3VycmVudCgpO1xuXG5cbiAgICBpZiAoa2V5d29yZHMucHJvcGVydHlJc0VudW1lcmFibGUoY3VyKSkge1xuICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChrZXl3b3Jkc19ibG9jay5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSB7XG4gICAgICByZXR1cm4gXCJ2YXJpYWJsZS0yXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtleXdvcmRzX2ltcG9ydGFudC5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSB7XG4gICAgICByZXR1cm4gXCJzdHJpbmctMlwiO1xuICAgIH1cbiAgICAvKiovXG5cbiAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICAgIGlmIChjaCA9PSBcIkBcIikge3N0cmVhbS5lYXRXaGlsZSgvW1xcd1xcXFxcXC1dLyk7IHJldHVybiByZXQoXCJtZXRhXCIsIHN0cmVhbS5jdXJyZW50KCkpO31cbiAgICBlbHNlIGlmIChjaCA9PSBcIi9cIiAmJiBzdHJlYW0uZWF0KFwiKlwiKSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkNDb21tZW50O1xuICAgICAgcmV0dXJuIHRva2VuQ0NvbW1lbnQoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNoID09IFwiPFwiICYmIHN0cmVhbS5lYXQoXCIhXCIpKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuU0dNTENvbW1lbnQ7XG4gICAgICByZXR1cm4gdG9rZW5TR01MQ29tbWVudChzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2ggPT0gXCI9XCIpIHJldChudWxsLCBcImNvbXBhcmVcIik7XG4gICAgZWxzZSBpZiAoKGNoID09IFwiflwiIHx8IGNoID09IFwifFwiKSAmJiBzdHJlYW0uZWF0KFwiPVwiKSkgcmV0dXJuIHJldChudWxsLCBcImNvbXBhcmVcIik7XG4gICAgZWxzZSBpZiAoY2ggPT0gXCJcXFwiXCIgfHwgY2ggPT0gXCInXCIpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5TdHJpbmcoY2gpO1xuICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaCA9PSBcIiNcIikge1xuICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgcmV0dXJuIHJldChcImNvbW1lbnRcIiwgXCJjb21tZW50XCIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaCA9PSBcIiFcIikge1xuICAgICAgc3RyZWFtLm1hdGNoKC9eXFxzKlxcdyovKTtcbiAgICAgIHJldHVybiByZXQoXCJrZXl3b3JkXCIsIFwiaW1wb3J0YW50XCIpO1xuICAgIH1cbiAgICBlbHNlIGlmICgvXFxkLy50ZXN0KGNoKSkge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3LiVdLyk7XG4gICAgICByZXR1cm4gcmV0KFwibnVtYmVyXCIsIFwidW5pdFwiKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoL1ssLis+KlxcL10vLnRlc3QoY2gpKSB7XG4gICAgICByZXR1cm4gcmV0KG51bGwsIFwic2VsZWN0LW9wXCIpO1xuICAgIH1cbiAgICBlbHNlIGlmICgvWzt7fTpcXFtcXF1dLy50ZXN0KGNoKSkge1xuICAgICAgcmV0dXJuIHJldChudWxsLCBjaCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFxcXFxcLV0vKTtcbiAgICAgIHJldHVybiByZXQoXCJ2YXJpYWJsZVwiLCBcInZhcmlhYmxlXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuQ0NvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBtYXliZUVuZCA9IGZhbHNlLCBjaDtcbiAgICB3aGlsZSAoKGNoID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgaWYgKG1heWJlRW5kICYmIGNoID09IFwiL1wiKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG1heWJlRW5kID0gKGNoID09IFwiKlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldChcImNvbW1lbnRcIiwgXCJjb21tZW50XCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5TR01MQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGRhc2hlcyA9IDAsIGNoO1xuICAgIHdoaWxlICgoY2ggPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICBpZiAoZGFzaGVzID49IDIgJiYgY2ggPT0gXCI+XCIpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGFzaGVzID0gKGNoID09IFwiLVwiKSA/IGRhc2hlcyArIDEgOiAwO1xuICAgIH1cbiAgICByZXR1cm4gcmV0KFwiY29tbWVudFwiLCBcImNvbW1lbnRcIik7XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlblN0cmluZyhxdW90ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgZXNjYXBlZCA9IGZhbHNlLCBjaDtcbiAgICAgIHdoaWxlICgoY2ggPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChjaCA9PSBxdW90ZSAmJiAhZXNjYXBlZClcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkICYmIGNoID09IFwiXFxcXFwiO1xuICAgICAgfVxuICAgICAgaWYgKCFlc2NhcGVkKSBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgIHJldHVybiByZXQoXCJzdHJpbmdcIiwgXCJzdHJpbmdcIik7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oYmFzZSkge1xuICAgICAgcmV0dXJuIHt0b2tlbml6ZTogdG9rZW5CYXNlLFxuICAgICAgICAgICAgICBiYXNlSW5kZW50OiBiYXNlIHx8IDAsXG4gICAgICAgICAgICAgIHN0YWNrOiBbXX07XG4gICAgfSxcblxuICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xuICAgICAgdHlwZSA9IG51bGw7XG4gICAgICB2YXIgc3R5bGUgPSBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcblxuICAgICAgdmFyIGNvbnRleHQgPSBzdGF0ZS5zdGFja1tzdGF0ZS5zdGFjay5sZW5ndGgtMV07XG4gICAgICBpZiAodHlwZSA9PSBcImhhc2hcIiAmJiBjb250ZXh0ID09IFwicnVsZVwiKSBzdHlsZSA9IFwiYXRvbVwiO1xuICAgICAgZWxzZSBpZiAoc3R5bGUgPT0gXCJ2YXJpYWJsZVwiKSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09IFwicnVsZVwiKSBzdHlsZSA9IFwibnVtYmVyXCI7XG4gICAgICAgIGVsc2UgaWYgKCFjb250ZXh0IHx8IGNvbnRleHQgPT0gXCJAbWVkaWF7XCIpIHN0eWxlID0gXCJ0YWdcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbnRleHQgPT0gXCJydWxlXCIgJiYgL15bXFx7XFx9O10kLy50ZXN0KHR5cGUpKVxuICAgICAgICBzdGF0ZS5zdGFjay5wb3AoKTtcbiAgICAgIGlmICh0eXBlID09IFwie1wiKSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09IFwiQG1lZGlhXCIpIHN0YXRlLnN0YWNrW3N0YXRlLnN0YWNrLmxlbmd0aC0xXSA9IFwiQG1lZGlhe1wiO1xuICAgICAgICBlbHNlIHN0YXRlLnN0YWNrLnB1c2goXCJ7XCIpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZSA9PSBcIn1cIikgc3RhdGUuc3RhY2sucG9wKCk7XG4gICAgICBlbHNlIGlmICh0eXBlID09IFwiQG1lZGlhXCIpIHN0YXRlLnN0YWNrLnB1c2goXCJAbWVkaWFcIik7XG4gICAgICBlbHNlIGlmIChjb250ZXh0ID09IFwie1wiICYmIHR5cGUgIT0gXCJjb21tZW50XCIpIHN0YXRlLnN0YWNrLnB1c2goXCJydWxlXCIpO1xuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH0sXG5cbiAgICBpbmRlbnQ6IGZ1bmN0aW9uKHN0YXRlLCB0ZXh0QWZ0ZXIpIHtcbiAgICAgIHZhciBuID0gc3RhdGUuc3RhY2subGVuZ3RoO1xuICAgICAgaWYgKC9eXFx9Ly50ZXN0KHRleHRBZnRlcikpXG4gICAgICAgIG4gLT0gc3RhdGUuc3RhY2tbc3RhdGUuc3RhY2subGVuZ3RoLTFdID09IFwicnVsZVwiID8gMiA6IDE7XG4gICAgICByZXR1cm4gc3RhdGUuYmFzZUluZGVudCArIG4gKiBpbmRlbnRVbml0O1xuICAgIH0sXG5cbiAgICBlbGVjdHJpY0NoYXJzOiBcIn1cIlxuICB9O1xufSk7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQveC1uZ2lueC1jb25mXCIsIFwibmdpbnhcIik7XG5cbn0pO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuLy8gQXV0aG9yOiBKYW4gVC4gU290dCAoaHR0cDovL2dpdGh1Yi5jb20vaWRsZWJlcmcpXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIiksIHJlcXVpcmUoXCIuLi8uLi9hZGRvbi9tb2RlL3NpbXBsZVwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiLCBcIi4uLy4uL2FkZG9uL21vZGUvc2ltcGxlXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbkNvZGVNaXJyb3IuZGVmaW5lU2ltcGxlTW9kZShcIm5zaXNcIix7XG4gIHN0YXJ0OltcbiAgICAvLyBOdW1iZXJzXG4gICAge3JlZ2V4OiAvKD86WystXT8pKD86MHhbXFxkLGEtZl0rKXwoPzowb1swLTddKyl8KD86MGJbMCwxXSspfCg/OlxcZCsuP1xcZCopLywgdG9rZW46IFwibnVtYmVyXCJ9LFxuXG4gICAgLy8gU3RyaW5nc1xuICAgIHsgcmVnZXg6IC9cIig/OlteXFxcXFwiXXxcXFxcLikqXCI/LywgdG9rZW46IFwic3RyaW5nXCIgfSxcbiAgICB7IHJlZ2V4OiAvJyg/OlteXFxcXCddfFxcXFwuKSonPy8sIHRva2VuOiBcInN0cmluZ1wiIH0sXG4gICAgeyByZWdleDogL2AoPzpbXlxcXFxgXXxcXFxcLikqYD8vLCB0b2tlbjogXCJzdHJpbmdcIiB9LFxuXG4gICAgLy8gQ29tcGlsZSBUaW1lIENvbW1hbmRzXG4gICAge3JlZ2V4OiAvXlxccyooPzpcXCEoaW5jbHVkZXxhZGRpbmNsdWRlZGlyfGFkZHBsdWdpbmRpcnxhcHBlbmRmaWxlfGNkfGRlbGZpbGV8ZWNob3xlcnJvcnxleGVjdXRlfHBhY2toZHJ8cHJhZ21hfGZpbmFsaXplfGdldGRsbHZlcnNpb258Z2V0dGxidmVyc2lvbnxzeXN0ZW18dGVtcGZpbGV8d2FybmluZ3x2ZXJib3NlfGRlZmluZXx1bmRlZnxpbnNlcnRtYWNyb3xtYWNyb3xtYWNyb2VuZHxtYWtlbnNpc3xzZWFyY2hwYXJzZXxzZWFyY2hyZXBsYWNlKSlcXGIvLCB0b2tlbjogXCJrZXl3b3JkXCJ9LFxuXG4gICAgLy8gQ29uZGl0aW9uYWwgQ29tcGlsYXRpb25cbiAgICB7cmVnZXg6IC9eXFxzKig/OlxcIShpZig/Om4/ZGVmKT98aWZtYWNyb24/ZGVmfG1hY3JvKSlcXGIvLCB0b2tlbjogXCJrZXl3b3JkXCIsIGluZGVudDogdHJ1ZX0sXG4gICAge3JlZ2V4OiAvXlxccyooPzpcXCEoZWxzZXxlbmRpZnxtYWNyb2VuZCkpXFxiLywgdG9rZW46IFwia2V5d29yZFwiLCBkZWRlbnQ6IHRydWV9LFxuXG4gICAgLy8gUnVudGltZSBDb21tYW5kc1xuICAgIHtyZWdleDogL15cXHMqKD86QWJvcnR8QWRkQnJhbmRpbmdJbWFnZXxBZGRTaXplfEFsbG93Um9vdERpckluc3RhbGx8QWxsb3dTa2lwRmlsZXN8QXV0b0Nsb3NlV2luZG93fEJHRm9udHxCR0dyYWRpZW50fEJyYW5kaW5nVGV4dHxCcmluZ1RvRnJvbnR8Q2FsbHxDYWxsSW5zdERMTHxDYXB0aW9ufENoYW5nZVVJfENoZWNrQml0bWFwfENsZWFyRXJyb3JzfENvbXBsZXRlZFRleHR8Q29tcG9uZW50VGV4dHxDb3B5RmlsZXN8Q1JDQ2hlY2t8Q3JlYXRlRGlyZWN0b3J5fENyZWF0ZUZvbnR8Q3JlYXRlU2hvcnRDdXR8RGVsZXRlfERlbGV0ZUlOSVNlY3xEZWxldGVJTklTdHJ8RGVsZXRlUmVnS2V5fERlbGV0ZVJlZ1ZhbHVlfERldGFpbFByaW50fERldGFpbHNCdXR0b25UZXh0fERpclRleHR8RGlyVmFyfERpclZlcmlmeXxFbmFibGVXaW5kb3d8RW51bVJlZ0tleXxFbnVtUmVnVmFsdWV8RXhjaHxFeGVjfEV4ZWNTaGVsbHxFeGVjU2hlbGxXYWl0fEV4ZWNXYWl0fEV4cGFuZEVudlN0cmluZ3N8RmlsZXxGaWxlQnVmU2l6ZXxGaWxlQ2xvc2V8RmlsZUVycm9yVGV4dHxGaWxlT3BlbnxGaWxlUmVhZHxGaWxlUmVhZEJ5dGV8RmlsZVJlYWRVVEYxNkxFfEZpbGVSZWFkV29yZHxGaWxlV3JpdGVVVEYxNkxFfEZpbGVTZWVrfEZpbGVXcml0ZXxGaWxlV3JpdGVCeXRlfEZpbGVXcml0ZVdvcmR8RmluZENsb3NlfEZpbmRGaXJzdHxGaW5kTmV4dHxGaW5kV2luZG93fEZsdXNoSU5JfEdldEN1ckluc3RUeXBlfEdldEN1cnJlbnRBZGRyZXNzfEdldERsZ0l0ZW18R2V0RExMVmVyc2lvbnxHZXRETExWZXJzaW9uTG9jYWx8R2V0RXJyb3JMZXZlbHxHZXRGaWxlVGltZXxHZXRGaWxlVGltZUxvY2FsfEdldEZ1bGxQYXRoTmFtZXxHZXRGdW5jdGlvbkFkZHJlc3N8R2V0SW5zdERpckVycm9yfEdldEtub3duRm9sZGVyUGF0aHxHZXRMYWJlbEFkZHJlc3N8R2V0VGVtcEZpbGVOYW1lfEdvdG98SGlkZVdpbmRvd3xJY29ufElmQWJvcnR8SWZFcnJvcnN8SWZGaWxlRXhpc3RzfElmUmVib290RmxhZ3xJZlJ0bExhbmd1YWdlfElmU2hlbGxWYXJDb250ZXh0QWxsfElmU2lsZW50fEluaXRQbHVnaW5zRGlyfEluc3RhbGxCdXR0b25UZXh0fEluc3RhbGxDb2xvcnN8SW5zdGFsbERpcnxJbnN0YWxsRGlyUmVnS2V5fEluc3RQcm9ncmVzc0ZsYWdzfEluc3RUeXBlfEluc3RUeXBlR2V0VGV4dHxJbnN0VHlwZVNldFRleHR8SW50NjRDbXB8SW50NjRDbXBVfEludDY0Rm10fEludENtcHxJbnRDbXBVfEludEZtdHxJbnRPcHxJbnRQdHJDbXB8SW50UHRyQ21wVXxJbnRQdHJPcHxJc1dpbmRvd3xMYW5nU3RyaW5nfExpY2Vuc2VCa0NvbG9yfExpY2Vuc2VEYXRhfExpY2Vuc2VGb3JjZVNlbGVjdGlvbnxMaWNlbnNlTGFuZ1N0cmluZ3xMaWNlbnNlVGV4dHxMb2FkQW5kU2V0SW1hZ2V8TG9hZExhbmd1YWdlRmlsZXxMb2NrV2luZG93fExvZ1NldHxMb2dUZXh0fE1hbmlmZXN0RFBJQXdhcmV8TWFuaWZlc3RMb25nUGF0aEF3YXJlfE1hbmlmZXN0TWF4VmVyc2lvblRlc3RlZHxNYW5pZmVzdFN1cHBvcnRlZE9TfE1lc3NhZ2VCb3h8TWlzY0J1dHRvblRleHR8TmFtZXxOb3B8T3V0RmlsZXxQYWdlfFBhZ2VDYWxsYmFja3N8UEVBZGRSZXNvdXJjZXxQRURsbENoYXJhY3RlcmlzdGljc3xQRVJlbW92ZVJlc291cmNlfFBFU3Vic3lzVmVyfFBvcHxQdXNofFF1aXR8UmVhZEVudlN0cnxSZWFkSU5JU3RyfFJlYWRSZWdEV09SRHxSZWFkUmVnU3RyfFJlYm9vdHxSZWdETEx8UmVuYW1lfFJlcXVlc3RFeGVjdXRpb25MZXZlbHxSZXNlcnZlRmlsZXxSZXR1cm58Uk1EaXJ8U2VhcmNoUGF0aHxTZWN0aW9uR2V0RmxhZ3N8U2VjdGlvbkdldEluc3RUeXBlc3xTZWN0aW9uR2V0U2l6ZXxTZWN0aW9uR2V0VGV4dHxTZWN0aW9uSW58U2VjdGlvblNldEZsYWdzfFNlY3Rpb25TZXRJbnN0VHlwZXN8U2VjdGlvblNldFNpemV8U2VjdGlvblNldFRleHR8U2VuZE1lc3NhZ2V8U2V0QXV0b0Nsb3NlfFNldEJyYW5kaW5nSW1hZ2V8U2V0Q29tcHJlc3N8U2V0Q29tcHJlc3NvcnxTZXRDb21wcmVzc29yRGljdFNpemV8U2V0Q3RsQ29sb3JzfFNldEN1ckluc3RUeXBlfFNldERhdGFibG9ja09wdGltaXplfFNldERhdGVTYXZlfFNldERldGFpbHNQcmludHxTZXREZXRhaWxzVmlld3xTZXRFcnJvckxldmVsfFNldEVycm9yc3xTZXRGaWxlQXR0cmlidXRlc3xTZXRGb250fFNldE91dFBhdGh8U2V0T3ZlcndyaXRlfFNldFJlYm9vdEZsYWd8U2V0UmVnVmlld3xTZXRTaGVsbFZhckNvbnRleHR8U2V0U2lsZW50fFNob3dJbnN0RGV0YWlsc3xTaG93VW5pbnN0RGV0YWlsc3xTaG93V2luZG93fFNpbGVudEluc3RhbGx8U2lsZW50VW5JbnN0YWxsfFNsZWVwfFNwYWNlVGV4dHN8U3RyQ21wfFN0ckNtcFN8U3RyQ3B5fFN0ckxlbnxTdWJDYXB0aW9ufFVuaWNvZGV8VW5pbnN0YWxsQnV0dG9uVGV4dHxVbmluc3RhbGxDYXB0aW9ufFVuaW5zdGFsbEljb258VW5pbnN0YWxsU3ViQ2FwdGlvbnxVbmluc3RhbGxUZXh0fFVuaW5zdFBhZ2V8VW5SZWdETEx8VmFyfFZJQWRkVmVyc2lvbktleXxWSUZpbGVWZXJzaW9ufFZJUHJvZHVjdFZlcnNpb258V2luZG93SWNvbnxXcml0ZUlOSVN0cnxXcml0ZVJlZ0JpbnxXcml0ZVJlZ0RXT1JEfFdyaXRlUmVnRXhwYW5kU3RyfFdyaXRlUmVnTXVsdGlTdHJ8V3JpdGVSZWdOb25lfFdyaXRlUmVnU3RyfFdyaXRlVW5pbnN0YWxsZXJ8WFBTdHlsZSlcXGIvLCB0b2tlbjogXCJrZXl3b3JkXCJ9LFxuICAgIHtyZWdleDogL15cXHMqKD86RnVuY3Rpb258UGFnZUV4fFNlY3Rpb24oPzpHcm91cCk/KVxcYi8sIHRva2VuOiBcImtleXdvcmRcIiwgaW5kZW50OiB0cnVlfSxcbiAgICB7cmVnZXg6IC9eXFxzKig/OihGdW5jdGlvbnxQYWdlRXh8U2VjdGlvbig/Okdyb3VwKT8pRW5kKVxcYi8sIHRva2VuOiBcImtleXdvcmRcIiwgZGVkZW50OiB0cnVlfSxcblxuICAgIC8vIENvbW1hbmQgT3B0aW9uc1xuICAgIHtyZWdleDogL1xcYig/OkFSQ0hJVkV8RklMRV9BVFRSSUJVVEVfQVJDSElWRXxGSUxFX0FUVFJJQlVURV9ISURERU58RklMRV9BVFRSSUJVVEVfTk9STUFMfEZJTEVfQVRUUklCVVRFX09GRkxJTkV8RklMRV9BVFRSSUJVVEVfUkVBRE9OTFl8RklMRV9BVFRSSUJVVEVfU1lTVEVNfEZJTEVfQVRUUklCVVRFX1RFTVBPUkFSWXxISURERU58SEtDQ3xIS0NSKDMyfDY0KT98SEtDVSgzMnw2NCk/fEhLRER8SEtFWV9DTEFTU0VTX1JPT1R8SEtFWV9DVVJSRU5UX0NPTkZJR3xIS0VZX0NVUlJFTlRfVVNFUnxIS0VZX0RZTl9EQVRBfEhLRVlfTE9DQUxfTUFDSElORXxIS0VZX1BFUkZPUk1BTkNFX0RBVEF8SEtFWV9VU0VSU3xIS0xNKDMyfDY0KT98SEtQRHxIS1V8SURBQk9SVHxJRENBTkNFTHxJRERfRElSfElERF9JTlNUfElERF9JTlNURklMRVN8SUREX0xJQ0VOU0V8SUREX1NFTENPTXxJRERfVU5JTlNUfElERF9WRVJJRll8SURJR05PUkV8SUROT3xJRE9LfElEUkVUUll8SURZRVN8TUJfQUJPUlRSRVRSWUlHTk9SRXxNQl9ERUZCVVRUT04xfE1CX0RFRkJVVFRPTjJ8TUJfREVGQlVUVE9OM3xNQl9ERUZCVVRUT040fE1CX0lDT05FWENMQU1BVElPTnxNQl9JQ09OSU5GT1JNQVRJT058TUJfSUNPTlFVRVNUSU9OfE1CX0lDT05TVE9QfE1CX09LfE1CX09LQ0FOQ0VMfE1CX1JFVFJZQ0FOQ0VMfE1CX1JJR0hUfE1CX1JUTFJFQURJTkd8TUJfU0VURk9SRUdST1VORHxNQl9UT1BNT1NUfE1CX1VTRVJJQ09OfE1CX1lFU05PfE1CX1lFU05PQ0FOQ0VMfE5PUk1BTHxPRkZMSU5FfFJFQURPTkxZfFNIQ1RYfFNIRUxMX0NPTlRFWFR8U1dfSElERXxTV19TSE9XREVGQVVMVHxTV19TSE9XTUFYSU1JWkVEfFNXX1NIT1dNSU5JTUlaRUR8U1dfU0hPV05PUk1BTHxTWVNURU18VEVNUE9SQVJZKVxcYi8sIHRva2VuOiBcImF0b21cIn0sXG4gICAge3JlZ2V4OiAvXFxiKD86YWRtaW58YWxsfGF1dG98Ym90aHxib3R0b218YnppcDJ8Y29tcG9uZW50c3xjdXJyZW50fGN1c3RvbXxkaXJlY3Rvcnl8ZmFsc2V8Zm9yY2V8aGlkZXxoaWdoZXN0fGlmZGlmZnxpZm5ld2VyfGluc3RmaWxlc3xsYXN0dXNlZHxsZWF2ZXxsZWZ0fGxpY2Vuc2V8bGlzdG9ubHl8bHptYXxuZXZlcnNob3d8bm9uZXxub3JtYWx8bm90c2V0fG9mZnxvbnxyaWdodHxzaG93fHNpbGVudHxzaWxlbnRsb2d8dGV4dG9ubHl8dG9wfHRydWV8dHJ5fHVuXFwuY29tcG9uZW50c3x1blxcLmN1c3RvbXx1blxcLmRpcmVjdG9yeXx1blxcLmluc3RmaWxlc3x1blxcLmxpY2Vuc2V8dW5pbnN0Q29uZmlybXx1c2VyfFdpbjEwfFdpbjd8V2luOHxXaW5WaXN0YXx6bGliKVxcYi8sIHRva2VuOiBcImJ1aWx0aW5cIn0sXG5cbiAgICAvLyBMb2dpY0xpYi5uc2hcbiAgICB7cmVnZXg6IC9cXCRcXHsoPzpBbmQoPzpJZig/Ok5vdCk/fFVubGVzcyl8QnJlYWt8Q2FzZSg/OkVsc2UpP3xDb250aW51ZXxEZWZhdWx0fERvKD86VW50aWx8V2hpbGUpP3xFbHNlKD86SWYoPzpOb3QpP3xVbmxlc3MpP3xFbmQoPzpJZnxTZWxlY3R8U3dpdGNoKXxFeGl0KD86RG98Rm9yfFdoaWxlKXxGb3IoPzpFYWNoKT98SWYoPzpDbWR8Tm90KD86VGhlbik/fFRoZW4pP3xMb29wKD86VW50aWx8V2hpbGUpP3xPcig/OklmKD86Tm90KT98VW5sZXNzKXxTZWxlY3R8U3dpdGNofFVubGVzc3xXaGlsZSlcXH0vLCB0b2tlbjogXCJ2YXJpYWJsZS0yXCIsIGluZGVudDogdHJ1ZX0sXG5cbiAgICAvLyBGaWxlRnVuYy5uc2hcbiAgICB7cmVnZXg6IC9cXCRcXHsoPzpCYW5uZXJUcmltUGF0aHxEaXJTdGF0ZXxEcml2ZVNwYWNlfEdldChCYXNlTmFtZXxEcml2ZXN8RXhlTmFtZXxFeGVQYXRofEZpbGVBdHRyaWJ1dGVzfEZpbGVFeHR8RmlsZU5hbWV8RmlsZVZlcnNpb258T3B0aW9uc3xPcHRpb25zU3xQYXJhbWV0ZXJzfFBhcmVudHxSb290fFNpemV8VGltZSl8TG9jYXRlfFJlZnJlc2hTaGVsbEljb25zKVxcfS8sIHRva2VuOiBcInZhcmlhYmxlLTJcIiwgZGVkZW50OiB0cnVlfSxcblxuICAgIC8vIE1lbWVudG8ubnNoXG4gICAge3JlZ2V4OiAvXFwkXFx7KD86TWVtZW50byg/OlNlY3Rpb24oPzpEb25lfEVuZHxSZXN0b3JlfFNhdmUpP3xVbnNlbGVjdGVkU2VjdGlvbikpXFx9LywgdG9rZW46IFwidmFyaWFibGUtMlwiLCBkZWRlbnQ6IHRydWV9LFxuXG4gICAgLy8gVGV4dEZ1bmMubnNoXG4gICAge3JlZ2V4OiAvXFwkXFx7KD86Q29uZmlnKD86UmVhZHxSZWFkU3xXcml0ZXxXcml0ZVMpfEZpbGUoPzpKb2lufFJlYWRGcm9tRW5kfFJlY29kZSl8TGluZSg/OkZpbmR8UmVhZHxTdW0pfFRleHQoPzpDb21wYXJlfENvbXBhcmVTKXxUcmltTmV3TGluZXMpXFx9LywgdG9rZW46IFwidmFyaWFibGUtMlwiLCBkZWRlbnQ6IHRydWV9LFxuXG4gICAgLy8gV2luVmVyLm5zaFxuICAgIHtyZWdleDogL1xcJFxceyg/Oig/OkF0KD86TGVhc3R8TW9zdCl8SXMpKD86U2VydmljZVBhY2t8V2luKD86N3w4fDEwfDk1fDk4fDIwMCg/OjB8M3w4KD86UjIpPyl8TUV8TlQ0fFZpc3RhfFhQKSl8SXMoPzpOVHxTZXJ2ZXIpKVxcfS8sIHRva2VuOiBcInZhcmlhYmxlXCIsIGRlZGVudDogdHJ1ZX0sXG5cbiAgICAvLyBXb3JkRnVuYy5uc2hcbiAgICB7cmVnZXg6IC9cXCRcXHsoPzpTdHJGaWx0ZXJTP3xWZXJzaW9uKD86Q29tcGFyZXxDb252ZXJ0KXxXb3JkKD86QWRkUz98RmluZCg/Oig/OjJ8MylYKT9TP3xJbnNlcnRTP3xSZXBsYWNlUz8pKVxcfS8sIHRva2VuOiBcInZhcmlhYmxlLTJcIiwgZGVkZW50OiB0cnVlfSxcblxuICAgIC8vIHg2NC5uc2hcbiAgICB7cmVnZXg6IC9cXCRcXHsoPzpSdW5uaW5nWDY0KVxcfS8sIHRva2VuOiBcInZhcmlhYmxlXCIsIGRlZGVudDogdHJ1ZX0sXG4gICAge3JlZ2V4OiAvXFwkXFx7KD86RGlzYWJsZXxFbmFibGUpWDY0RlNSZWRpcmVjdGlvblxcfS8sIHRva2VuOiBcInZhcmlhYmxlLTJcIiwgZGVkZW50OiB0cnVlfSxcblxuICAgIC8vIExpbmUgQ29tbWVudFxuICAgIHtyZWdleDogLygjfDspLiovLCB0b2tlbjogXCJjb21tZW50XCJ9LFxuXG4gICAgLy8gQmxvY2sgQ29tbWVudFxuICAgIHtyZWdleDogL1xcL1xcKi8sIHRva2VuOiBcImNvbW1lbnRcIiwgbmV4dDogXCJjb21tZW50XCJ9LFxuXG4gICAgLy8gT3BlcmF0b3JcbiAgICB7cmVnZXg6IC9bLStcXC8qPTw+IV0rLywgdG9rZW46IFwib3BlcmF0b3JcIn0sXG5cbiAgICAvLyBWYXJpYWJsZVxuICAgIHtyZWdleDogL1xcJFxcdysvLCB0b2tlbjogXCJ2YXJpYWJsZVwifSxcblxuICAgIC8vIENvbnN0YW50XG4gICAge3JlZ2V4OiAvXFwke1tcXHdcXC46LV0rfS8sIHRva2VuOiBcInZhcmlhYmxlLTJcIn0sXG5cbiAgICAvLyBMYW5ndWFnZSBTdHJpbmdcbiAgICB7cmVnZXg6IC9cXCRcXChbXFx3XFwuOi1dK1xcKS8sIHRva2VuOiBcInZhcmlhYmxlLTNcIn1cbiAgXSxcbiAgY29tbWVudDogW1xuICAgIHtyZWdleDogLy4qP1xcKlxcLy8sIHRva2VuOiBcImNvbW1lbnRcIiwgbmV4dDogXCJzdGFydFwifSxcbiAgICB7cmVnZXg6IC8uKi8sIHRva2VuOiBcImNvbW1lbnRcIn1cbiAgXSxcbiAgbWV0YToge1xuICAgIGVsZWN0cmljSW5wdXQ6IC9eXFxzKigoRnVuY3Rpb258UGFnZUV4fFNlY3Rpb258U2VjdGlvbihHcm91cCk/KUVuZHwoXFwhKGVuZGlmfG1hY3JvZW5kKSl8XFwkXFx7KEVuZChJZnxVbmxlc3N8V2hpbGUpfExvb3AoVW50aWwpfE5leHQpXFx9KSQvLFxuICAgIGJsb2NrQ29tbWVudFN0YXJ0OiBcIi8qXCIsXG4gICAgYmxvY2tDb21tZW50RW5kOiBcIiovXCIsXG4gICAgbGluZUNvbW1lbnQ6IFtcIiNcIiwgXCI7XCJdXG4gIH1cbn0pO1xuXG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3gtbnNpc1wiLCBcIm5zaXNcIik7XG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4qIFRoaXMgc2NyaXB0IHByb3ZpZGVzIHN5bnRheCBoaWdobGlnaHRpbmcgc3VwcG9ydCBmb3JcbiogdGhlIE4tVHJpcGxlcyBmb3JtYXQuXG4qIE4tVHJpcGxlcyBmb3JtYXQgc3BlY2lmaWNhdGlvbjpcbiogICAgIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9uLXRyaXBsZXMvXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLypcbiAgICBUaGUgZm9sbG93aW5nIGV4cHJlc3Npb24gZGVmaW5lcyB0aGUgZGVmaW5lZCBBU0YgZ3JhbW1hciB0cmFuc2l0aW9ucy5cblxuICAgIHByZV9zdWJqZWN0IC0+XG4gICAgICAgIHtcbiAgICAgICAgKCB3cml0aW5nX3N1YmplY3RfdXJpIHwgd3JpdGluZ19ibm9kZV91cmkgKVxuICAgICAgICAgICAgLT4gcHJlX3ByZWRpY2F0ZVxuICAgICAgICAgICAgICAgIC0+IHdyaXRpbmdfcHJlZGljYXRlX3VyaVxuICAgICAgICAgICAgICAgICAgICAtPiBwcmVfb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAtPiB3cml0aW5nX29iamVjdF91cmkgfCB3cml0aW5nX29iamVjdF9ibm9kZSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0aW5nX29iamVjdF9saXRlcmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0+IHdyaXRpbmdfbGl0ZXJhbF9sYW5nIHwgd3JpdGluZ19saXRlcmFsX3R5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0+IHBvc3Rfb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0+IEJFR0lOXG4gICAgICAgICB9IG90aGVyd2lzZSB7XG4gICAgICAgICAgICAgLT4gRVJST1JcbiAgICAgICAgIH1cbiovXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwibnRyaXBsZXNcIiwgZnVuY3Rpb24oKSB7XG5cbiAgdmFyIExvY2F0aW9uID0ge1xuICAgIFBSRV9TVUJKRUNUICAgICAgICAgOiAwLFxuICAgIFdSSVRJTkdfU1VCX1VSSSAgICAgOiAxLFxuICAgIFdSSVRJTkdfQk5PREVfVVJJICAgOiAyLFxuICAgIFBSRV9QUkVEICAgICAgICAgICAgOiAzLFxuICAgIFdSSVRJTkdfUFJFRF9VUkkgICAgOiA0LFxuICAgIFBSRV9PQkogICAgICAgICAgICAgOiA1LFxuICAgIFdSSVRJTkdfT0JKX1VSSSAgICAgOiA2LFxuICAgIFdSSVRJTkdfT0JKX0JOT0RFICAgOiA3LFxuICAgIFdSSVRJTkdfT0JKX0xJVEVSQUwgOiA4LFxuICAgIFdSSVRJTkdfTElUX0xBTkcgICAgOiA5LFxuICAgIFdSSVRJTkdfTElUX1RZUEUgICAgOiAxMCxcbiAgICBQT1NUX09CSiAgICAgICAgICAgIDogMTEsXG4gICAgRVJST1IgICAgICAgICAgICAgICA6IDEyXG4gIH07XG4gIGZ1bmN0aW9uIHRyYW5zaXRTdGF0ZShjdXJyU3RhdGUsIGMpIHtcbiAgICB2YXIgY3VyckxvY2F0aW9uID0gY3VyclN0YXRlLmxvY2F0aW9uO1xuICAgIHZhciByZXQ7XG5cbiAgICAvLyBPcGVuaW5nLlxuICAgIGlmICAgICAoY3VyckxvY2F0aW9uID09IExvY2F0aW9uLlBSRV9TVUJKRUNUICYmIGMgPT0gJzwnKSByZXQgPSBMb2NhdGlvbi5XUklUSU5HX1NVQl9VUkk7XG4gICAgZWxzZSBpZihjdXJyTG9jYXRpb24gPT0gTG9jYXRpb24uUFJFX1NVQkpFQ1QgJiYgYyA9PSAnXycpIHJldCA9IExvY2F0aW9uLldSSVRJTkdfQk5PREVfVVJJO1xuICAgIGVsc2UgaWYoY3VyckxvY2F0aW9uID09IExvY2F0aW9uLlBSRV9QUkVEICAgICYmIGMgPT0gJzwnKSByZXQgPSBMb2NhdGlvbi5XUklUSU5HX1BSRURfVVJJO1xuICAgIGVsc2UgaWYoY3VyckxvY2F0aW9uID09IExvY2F0aW9uLlBSRV9PQkogICAgICYmIGMgPT0gJzwnKSByZXQgPSBMb2NhdGlvbi5XUklUSU5HX09CSl9VUkk7XG4gICAgZWxzZSBpZihjdXJyTG9jYXRpb24gPT0gTG9jYXRpb24uUFJFX09CSiAgICAgJiYgYyA9PSAnXycpIHJldCA9IExvY2F0aW9uLldSSVRJTkdfT0JKX0JOT0RFO1xuICAgIGVsc2UgaWYoY3VyckxvY2F0aW9uID09IExvY2F0aW9uLlBSRV9PQkogICAgICYmIGMgPT0gJ1wiJykgcmV0ID0gTG9jYXRpb24uV1JJVElOR19PQkpfTElURVJBTDtcblxuICAgIC8vIENsb3NpbmcuXG4gICAgZWxzZSBpZihjdXJyTG9jYXRpb24gPT0gTG9jYXRpb24uV1JJVElOR19TVUJfVVJJICAgICAmJiBjID09ICc+JykgcmV0ID0gTG9jYXRpb24uUFJFX1BSRUQ7XG4gICAgZWxzZSBpZihjdXJyTG9jYXRpb24gPT0gTG9jYXRpb24uV1JJVElOR19CTk9ERV9VUkkgICAmJiBjID09ICcgJykgcmV0ID0gTG9jYXRpb24uUFJFX1BSRUQ7XG4gICAgZWxzZSBpZihjdXJyTG9jYXRpb24gPT0gTG9jYXRpb24uV1JJVElOR19QUkVEX1VSSSAgICAmJiBjID09ICc+JykgcmV0ID0gTG9jYXRpb24uUFJFX09CSjtcbiAgICBlbHNlIGlmKGN1cnJMb2NhdGlvbiA9PSBMb2NhdGlvbi5XUklUSU5HX09CSl9VUkkgICAgICYmIGMgPT0gJz4nKSByZXQgPSBMb2NhdGlvbi5QT1NUX09CSjtcbiAgICBlbHNlIGlmKGN1cnJMb2NhdGlvbiA9PSBMb2NhdGlvbi5XUklUSU5HX09CSl9CTk9ERSAgICYmIGMgPT0gJyAnKSByZXQgPSBMb2NhdGlvbi5QT1NUX09CSjtcbiAgICBlbHNlIGlmKGN1cnJMb2NhdGlvbiA9PSBMb2NhdGlvbi5XUklUSU5HX09CSl9MSVRFUkFMICYmIGMgPT0gJ1wiJykgcmV0ID0gTG9jYXRpb24uUE9TVF9PQko7XG4gICAgZWxzZSBpZihjdXJyTG9jYXRpb24gPT0gTG9jYXRpb24uV1JJVElOR19MSVRfTEFORyAmJiBjID09ICcgJykgcmV0ID0gTG9jYXRpb24uUE9TVF9PQko7XG4gICAgZWxzZSBpZihjdXJyTG9jYXRpb24gPT0gTG9jYXRpb24uV1JJVElOR19MSVRfVFlQRSAmJiBjID09ICc+JykgcmV0ID0gTG9jYXRpb24uUE9TVF9PQko7XG5cbiAgICAvLyBDbG9zaW5nIHR5cGVkIGFuZCBsYW5ndWFnZSBsaXRlcmFsLlxuICAgIGVsc2UgaWYoY3VyckxvY2F0aW9uID09IExvY2F0aW9uLldSSVRJTkdfT0JKX0xJVEVSQUwgJiYgYyA9PSAnQCcpIHJldCA9IExvY2F0aW9uLldSSVRJTkdfTElUX0xBTkc7XG4gICAgZWxzZSBpZihjdXJyTG9jYXRpb24gPT0gTG9jYXRpb24uV1JJVElOR19PQkpfTElURVJBTCAmJiBjID09ICdeJykgcmV0ID0gTG9jYXRpb24uV1JJVElOR19MSVRfVFlQRTtcblxuICAgIC8vIFNwYWNlcy5cbiAgICBlbHNlIGlmKCBjID09ICcgJyAmJlxuICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgIGN1cnJMb2NhdGlvbiA9PSBMb2NhdGlvbi5QUkVfU1VCSkVDVCB8fFxuICAgICAgICAgICAgICAgY3VyckxvY2F0aW9uID09IExvY2F0aW9uLlBSRV9QUkVEICAgIHx8XG4gICAgICAgICAgICAgICBjdXJyTG9jYXRpb24gPT0gTG9jYXRpb24uUFJFX09CSiAgICAgfHxcbiAgICAgICAgICAgICAgIGN1cnJMb2NhdGlvbiA9PSBMb2NhdGlvbi5QT1NUX09CSlxuICAgICAgICAgICAgIClcbiAgICAgICAgICAgKSByZXQgPSBjdXJyTG9jYXRpb247XG5cbiAgICAvLyBSZXNldC5cbiAgICBlbHNlIGlmKGN1cnJMb2NhdGlvbiA9PSBMb2NhdGlvbi5QT1NUX09CSiAmJiBjID09ICcuJykgcmV0ID0gTG9jYXRpb24uUFJFX1NVQkpFQ1Q7XG5cbiAgICAvLyBFcnJvclxuICAgIGVsc2UgcmV0ID0gTG9jYXRpb24uRVJST1I7XG5cbiAgICBjdXJyU3RhdGUubG9jYXRpb249cmV0O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICByZXR1cm4ge1xuICAgICAgICAgICBsb2NhdGlvbiA6IExvY2F0aW9uLlBSRV9TVUJKRUNULFxuICAgICAgICAgICB1cmlzICAgICA6IFtdLFxuICAgICAgICAgICBhbmNob3JzICA6IFtdLFxuICAgICAgICAgICBibm9kZXMgICA6IFtdLFxuICAgICAgICAgICBsYW5ncyAgICA6IFtdLFxuICAgICAgICAgICB0eXBlcyAgICA6IFtdXG4gICAgICAgfTtcbiAgICB9LFxuICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICAgICAgaWYoY2ggPT0gJzwnKSB7XG4gICAgICAgICB0cmFuc2l0U3RhdGUoc3RhdGUsIGNoKTtcbiAgICAgICAgIHZhciBwYXJzZWRVUkkgPSAnJztcbiAgICAgICAgIHN0cmVhbS5lYXRXaGlsZSggZnVuY3Rpb24oYykgeyBpZiggYyAhPSAnIycgJiYgYyAhPSAnPicgKSB7IHBhcnNlZFVSSSArPSBjOyByZXR1cm4gdHJ1ZTsgfSByZXR1cm4gZmFsc2U7fSApO1xuICAgICAgICAgc3RhdGUudXJpcy5wdXNoKHBhcnNlZFVSSSk7XG4gICAgICAgICBpZiggc3RyZWFtLm1hdGNoKCcjJywgZmFsc2UpICkgcmV0dXJuICd2YXJpYWJsZSc7XG4gICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAgdHJhbnNpdFN0YXRlKHN0YXRlLCAnPicpO1xuICAgICAgICAgcmV0dXJuICd2YXJpYWJsZSc7XG4gICAgICB9XG4gICAgICBpZihjaCA9PSAnIycpIHtcbiAgICAgICAgdmFyIHBhcnNlZEFuY2hvciA9ICcnO1xuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoZnVuY3Rpb24oYykgeyBpZihjICE9ICc+JyAmJiBjICE9ICcgJykgeyBwYXJzZWRBbmNob3IrPSBjOyByZXR1cm4gdHJ1ZTsgfSByZXR1cm4gZmFsc2U7fSk7XG4gICAgICAgIHN0YXRlLmFuY2hvcnMucHVzaChwYXJzZWRBbmNob3IpO1xuICAgICAgICByZXR1cm4gJ3ZhcmlhYmxlLTInO1xuICAgICAgfVxuICAgICAgaWYoY2ggPT0gJz4nKSB7XG4gICAgICAgICAgdHJhbnNpdFN0YXRlKHN0YXRlLCAnPicpO1xuICAgICAgICAgIHJldHVybiAndmFyaWFibGUnO1xuICAgICAgfVxuICAgICAgaWYoY2ggPT0gJ18nKSB7XG4gICAgICAgICAgdHJhbnNpdFN0YXRlKHN0YXRlLCBjaCk7XG4gICAgICAgICAgdmFyIHBhcnNlZEJOb2RlID0gJyc7XG4gICAgICAgICAgc3RyZWFtLmVhdFdoaWxlKGZ1bmN0aW9uKGMpIHsgaWYoIGMgIT0gJyAnICkgeyBwYXJzZWRCTm9kZSArPSBjOyByZXR1cm4gdHJ1ZTsgfSByZXR1cm4gZmFsc2U7fSk7XG4gICAgICAgICAgc3RhdGUuYm5vZGVzLnB1c2gocGFyc2VkQk5vZGUpO1xuICAgICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgICAgdHJhbnNpdFN0YXRlKHN0YXRlLCAnICcpO1xuICAgICAgICAgIHJldHVybiAnYnVpbHRpbic7XG4gICAgICB9XG4gICAgICBpZihjaCA9PSAnXCInKSB7XG4gICAgICAgICAgdHJhbnNpdFN0YXRlKHN0YXRlLCBjaCk7XG4gICAgICAgICAgc3RyZWFtLmVhdFdoaWxlKCBmdW5jdGlvbihjKSB7IHJldHVybiBjICE9ICdcIic7IH0gKTtcbiAgICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAgIGlmKCBzdHJlYW0ucGVlaygpICE9ICdAJyAmJiBzdHJlYW0ucGVlaygpICE9ICdeJyApIHtcbiAgICAgICAgICAgICAgdHJhbnNpdFN0YXRlKHN0YXRlLCAnXCInKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICdzdHJpbmcnO1xuICAgICAgfVxuICAgICAgaWYoIGNoID09ICdAJyApIHtcbiAgICAgICAgICB0cmFuc2l0U3RhdGUoc3RhdGUsICdAJyk7XG4gICAgICAgICAgdmFyIHBhcnNlZExhbmcgPSAnJztcbiAgICAgICAgICBzdHJlYW0uZWF0V2hpbGUoZnVuY3Rpb24oYykgeyBpZiggYyAhPSAnICcgKSB7IHBhcnNlZExhbmcgKz0gYzsgcmV0dXJuIHRydWU7IH0gcmV0dXJuIGZhbHNlO30pO1xuICAgICAgICAgIHN0YXRlLmxhbmdzLnB1c2gocGFyc2VkTGFuZyk7XG4gICAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgICB0cmFuc2l0U3RhdGUoc3RhdGUsICcgJyk7XG4gICAgICAgICAgcmV0dXJuICdzdHJpbmctMic7XG4gICAgICB9XG4gICAgICBpZiggY2ggPT0gJ14nICkge1xuICAgICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgICAgdHJhbnNpdFN0YXRlKHN0YXRlLCAnXicpO1xuICAgICAgICAgIHZhciBwYXJzZWRUeXBlID0gJyc7XG4gICAgICAgICAgc3RyZWFtLmVhdFdoaWxlKGZ1bmN0aW9uKGMpIHsgaWYoIGMgIT0gJz4nICkgeyBwYXJzZWRUeXBlICs9IGM7IHJldHVybiB0cnVlOyB9IHJldHVybiBmYWxzZTt9ICk7XG4gICAgICAgICAgc3RhdGUudHlwZXMucHVzaChwYXJzZWRUeXBlKTtcbiAgICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAgIHRyYW5zaXRTdGF0ZShzdGF0ZSwgJz4nKTtcbiAgICAgICAgICByZXR1cm4gJ3ZhcmlhYmxlJztcbiAgICAgIH1cbiAgICAgIGlmKCBjaCA9PSAnICcgKSB7XG4gICAgICAgICAgdHJhbnNpdFN0YXRlKHN0YXRlLCBjaCk7XG4gICAgICB9XG4gICAgICBpZiggY2ggPT0gJy4nICkge1xuICAgICAgICAgIHRyYW5zaXRTdGF0ZShzdGF0ZSwgY2gpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn0pO1xuXG4vLyBkZWZpbmUgdGhlIHJlZ2lzdGVyZWQgTWVkaWEgVHlwZSBmb3Igbi10cmlwbGVzOlxuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL24tdHJpcGxlcy8jbi10cmlwbGVzLW1lZGlhdHlwZVxuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwiYXBwbGljYXRpb24vbi10cmlwbGVzXCIsIFwibnRyaXBsZXNcIik7XG5cbi8vIE4tUXVhZHMgaXMgYmFzZWQgb24gdGhlIE4tVHJpcGxlcyBmb3JtYXQgKHNvIHNhbWUgaGlnaGxpZ2h0aW5nIHdvcmtzKVxuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL24tcXVhZHMvXG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJhcHBsaWNhdGlvbi9uLXF1YWRzXCIsIFwibnRyaXBsZXNcIik7XG5cbi8vIHByZXZpb3VzbHkgdXNlZCwgdGhvdWdoIHRlY2huaWNhbGx5IGluY29ycmVjdCBtZWRpYSB0eXBlIGZvciBuLXRyaXBsZXNcbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQvbi10cmlwbGVzXCIsIFwibnRyaXBsZXNcIik7XG5cbn0pO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcblwidXNlIHN0cmljdFwiO1xuXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoXCJvY3RhdmVcIiwgZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIHdvcmRSZWdleHAod29yZHMpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChcIl4oKFwiICsgd29yZHMuam9pbihcIil8KFwiKSArIFwiKSlcXFxcYlwiKTtcbiAgfVxuXG4gIHZhciBzaW5nbGVPcGVyYXRvcnMgPSBuZXcgUmVnRXhwKFwiXltcXFxcK1xcXFwtXFxcXCovJnxcXFxcXn48PiFAJ1xcXFxcXFxcXVwiKTtcbiAgdmFyIHNpbmdsZURlbGltaXRlcnMgPSBuZXcgUmVnRXhwKCdeW1xcXFwoXFxcXFtcXFxce1xcXFx9LDo9O1xcXFwuXScpO1xuICB2YXIgZG91YmxlT3BlcmF0b3JzID0gbmV3IFJlZ0V4cChcIl4oKD09KXwofj0pfCg8PSl8KD49KXwoPDwpfCg+Pil8KFxcXFwuW1xcXFwrXFxcXC1cXFxcKi9cXFxcXlxcXFxcXFxcXSkpXCIpO1xuICB2YXIgZG91YmxlRGVsaW1pdGVycyA9IG5ldyBSZWdFeHAoXCJeKCghPSl8KFxcXFwrPSl8KFxcXFwtPSl8KFxcXFwqPSl8KC89KXwoJj0pfChcXFxcfD0pfChcXFxcXj0pKVwiKTtcbiAgdmFyIHRyaXBsZURlbGltaXRlcnMgPSBuZXcgUmVnRXhwKFwiXigoPj49KXwoPDw9KSlcIik7XG4gIHZhciBleHByZXNzaW9uRW5kID0gbmV3IFJlZ0V4cChcIl5bXFxcXF1cXFxcKV1cIik7XG4gIHZhciBpZGVudGlmaWVycyA9IG5ldyBSZWdFeHAoXCJeW19BLVphLXpcXHhhMS1cXHVmZmZmXVtfQS1aYS16MC05XFx4YTEtXFx1ZmZmZl0qXCIpO1xuXG4gIHZhciBidWlsdGlucyA9IHdvcmRSZWdleHAoW1xuICAgICdlcnJvcicsICdldmFsJywgJ2Z1bmN0aW9uJywgJ2FicycsICdhY29zJywgJ2F0YW4nLCAnYXNpbicsICdjb3MnLFxuICAgICdjb3NoJywgJ2V4cCcsICdsb2cnLCAncHJvZCcsICdzdW0nLCAnbG9nMTAnLCAnbWF4JywgJ21pbicsICdzaWduJywgJ3NpbicsICdzaW5oJyxcbiAgICAnc3FydCcsICd0YW4nLCAncmVzaGFwZScsICdicmVhaycsICd6ZXJvcycsICdkZWZhdWx0JywgJ21hcmdpbicsICdyb3VuZCcsICdvbmVzJyxcbiAgICAncmFuZCcsICdzeW4nLCAnY2VpbCcsICdmbG9vcicsICdzaXplJywgJ2NsZWFyJywgJ3plcm9zJywgJ2V5ZScsICdtZWFuJywgJ3N0ZCcsICdjb3YnLFxuICAgICdkZXQnLCAnZWlnJywgJ2ludicsICdub3JtJywgJ3JhbmsnLCAndHJhY2UnLCAnZXhwbScsICdsb2dtJywgJ3NxcnRtJywgJ2xpbnNwYWNlJywgJ3Bsb3QnLFxuICAgICd0aXRsZScsICd4bGFiZWwnLCAneWxhYmVsJywgJ2xlZ2VuZCcsICd0ZXh0JywgJ2dyaWQnLCAnbWVzaGdyaWQnLCAnbWVzaCcsICdudW0yc3RyJyxcbiAgICAnZmZ0JywgJ2lmZnQnLCAnYXJyYXlmdW4nLCAnY2VsbGZ1bicsICdpbnB1dCcsICdmbGlwbHInLCAnZmxpcHVkJywgJ2lzbWVtYmVyJ1xuICBdKTtcblxuICB2YXIga2V5d29yZHMgPSB3b3JkUmVnZXhwKFtcbiAgICAncmV0dXJuJywgJ2Nhc2UnLCAnc3dpdGNoJywgJ2Vsc2UnLCAnZWxzZWlmJywgJ2VuZCcsICdlbmRpZicsICdlbmRmdW5jdGlvbicsXG4gICAgJ2lmJywgJ290aGVyd2lzZScsICdkbycsICdmb3InLCAnd2hpbGUnLCAndHJ5JywgJ2NhdGNoJywgJ2NsYXNzZGVmJywgJ3Byb3BlcnRpZXMnLCAnZXZlbnRzJyxcbiAgICAnbWV0aG9kcycsICdnbG9iYWwnLCAncGVyc2lzdGVudCcsICdlbmRmb3InLCAnZW5kd2hpbGUnLCAncHJpbnRmJywgJ3NwcmludGYnLCAnZGlzcCcsICd1bnRpbCcsXG4gICAgJ2NvbnRpbnVlJywgJ3BrZydcbiAgXSk7XG5cblxuICAvLyB0b2tlbml6ZXJzXG4gIGZ1bmN0aW9uIHRva2VuVHJhbnNwb3NlKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoIXN0cmVhbS5zb2woKSAmJiBzdHJlYW0ucGVlaygpID09PSAnXFwnJykge1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgcmV0dXJuICdvcGVyYXRvcic7XG4gICAgfVxuICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgIHJldHVybiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIHRva2VuQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHN0cmVhbS5tYXRjaCgvXi4qJX0vKSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICByZXR1cm4gJ2NvbW1lbnQnO1xuICAgIH07XG4gICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgIHJldHVybiAnY29tbWVudCc7XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuICAgIC8vIHdoaXRlc3BhY2VzXG4gICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSByZXR1cm4gbnVsbDtcblxuICAgIC8vIEhhbmRsZSBvbmUgbGluZSBDb21tZW50c1xuICAgIGlmIChzdHJlYW0ubWF0Y2goJyV7Jykpe1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkNvbW1lbnQ7XG4gICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICByZXR1cm4gJ2NvbW1lbnQnO1xuICAgIH1cblxuICAgIGlmIChzdHJlYW0ubWF0Y2goL15bJSNdLykpe1xuICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgcmV0dXJuICdjb21tZW50JztcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgTnVtYmVyIExpdGVyYWxzXG4gICAgaWYgKHN0cmVhbS5tYXRjaCgvXlswLTlcXC4rLV0vLCBmYWxzZSkpIHtcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goL15bKy1dPzB4WzAtOWEtZkEtRl0rW2lqXT8vKSkge1xuICAgICAgICBzdHJlYW0udG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgIHJldHVybiAnbnVtYmVyJzsgfTtcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goL15bKy1dP1xcZCpcXC5cXGQrKFtFZURkXVsrLV0/XFxkKyk/W2lqXT8vKSkgeyByZXR1cm4gJ251bWJlcic7IH07XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eWystXT9cXGQrKFtFZURkXVsrLV0/XFxkKyk/W2lqXT8vKSkgeyByZXR1cm4gJ251bWJlcic7IH07XG4gICAgfVxuICAgIGlmIChzdHJlYW0ubWF0Y2god29yZFJlZ2V4cChbJ25hbicsJ05hTicsJ2luZicsJ0luZiddKSkpIHsgcmV0dXJuICdudW1iZXInOyB9O1xuXG4gICAgLy8gSGFuZGxlIFN0cmluZ3NcbiAgICB2YXIgbSA9IHN0cmVhbS5tYXRjaCgvXlwiKD86W15cIl18XCJcIikqKFwifCQpLykgfHwgc3RyZWFtLm1hdGNoKC9eJyg/OlteJ118JycpKignfCQpLylcbiAgICBpZiAobSkgeyByZXR1cm4gbVsxXSA/ICdzdHJpbmcnIDogXCJzdHJpbmcgZXJyb3JcIjsgfVxuXG4gICAgLy8gSGFuZGxlIHdvcmRzXG4gICAgaWYgKHN0cmVhbS5tYXRjaChrZXl3b3JkcykpIHsgcmV0dXJuICdrZXl3b3JkJzsgfSA7XG4gICAgaWYgKHN0cmVhbS5tYXRjaChidWlsdGlucykpIHsgcmV0dXJuICdidWlsdGluJzsgfSA7XG4gICAgaWYgKHN0cmVhbS5tYXRjaChpZGVudGlmaWVycykpIHsgcmV0dXJuICd2YXJpYWJsZSc7IH0gO1xuXG4gICAgaWYgKHN0cmVhbS5tYXRjaChzaW5nbGVPcGVyYXRvcnMpIHx8IHN0cmVhbS5tYXRjaChkb3VibGVPcGVyYXRvcnMpKSB7IHJldHVybiAnb3BlcmF0b3InOyB9O1xuICAgIGlmIChzdHJlYW0ubWF0Y2goc2luZ2xlRGVsaW1pdGVycykgfHwgc3RyZWFtLm1hdGNoKGRvdWJsZURlbGltaXRlcnMpIHx8IHN0cmVhbS5tYXRjaCh0cmlwbGVEZWxpbWl0ZXJzKSkgeyByZXR1cm4gbnVsbDsgfTtcblxuICAgIGlmIChzdHJlYW0ubWF0Y2goZXhwcmVzc2lvbkVuZCkpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5UcmFuc3Bvc2U7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG5cbiAgICAvLyBIYW5kbGUgbm9uLWRldGVjdGVkIGl0ZW1zXG4gICAgc3RyZWFtLm5leHQoKTtcbiAgICByZXR1cm4gJ2Vycm9yJztcbiAgfTtcblxuXG4gIHJldHVybiB7XG4gICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b2tlbml6ZTogdG9rZW5CYXNlXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIHN0eWxlID0gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBpZiAoc3R5bGUgPT09ICdudW1iZXInIHx8IHN0eWxlID09PSAndmFyaWFibGUnKXtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlblRyYW5zcG9zZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9LFxuXG4gICAgbGluZUNvbW1lbnQ6ICclJyxcblxuICAgIGZvbGQ6ICdpbmRlbnQnXG4gIH07XG59KTtcblxuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LW9jdGF2ZVwiLCBcIm9jdGF2ZVwiKTtcblxufSk7XG4iLCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTW9kZShcIm96XCIsIGZ1bmN0aW9uIChjb25mKSB7XG5cbiAgZnVuY3Rpb24gd29yZFJlZ2V4cCh3b3Jkcykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiXigoXCIgKyB3b3Jkcy5qb2luKFwiKXwoXCIpICsgXCIpKVxcXFxiXCIpO1xuICB9XG5cbiAgdmFyIHNpbmdsZU9wZXJhdG9ycyA9IC9bXFxeQCFcXHw8PiN+XFwuXFwqXFwtXFwrXFxcXC8sPV0vO1xuICB2YXIgZG91YmxlT3BlcmF0b3JzID0gLyg8LSl8KDo9KXwoPTwpfCg+PSl8KDw9KXwoPDopfCg+Oil8KD06KXwoXFxcXD0pfChcXFxcPTopfCghISl8KD09KXwoOjopLztcbiAgdmFyIHRyaXBsZU9wZXJhdG9ycyA9IC8oOjo6KXwoXFwuXFwuXFwuKXwoPTw6KXwoPj06KS87XG5cbiAgdmFyIG1pZGRsZSA9IFtcImluXCIsIFwidGhlblwiLCBcImVsc2VcIiwgXCJvZlwiLCBcImVsc2VvZlwiLCBcImVsc2VjYXNlXCIsIFwiZWxzZWlmXCIsIFwiY2F0Y2hcIixcbiAgICBcImZpbmFsbHlcIiwgXCJ3aXRoXCIsIFwicmVxdWlyZVwiLCBcInByZXBhcmVcIiwgXCJpbXBvcnRcIiwgXCJleHBvcnRcIiwgXCJkZWZpbmVcIiwgXCJkb1wiXTtcbiAgdmFyIGVuZCA9IFtcImVuZFwiXTtcblxuICB2YXIgYXRvbXMgPSB3b3JkUmVnZXhwKFtcInRydWVcIiwgXCJmYWxzZVwiLCBcIm5pbFwiLCBcInVuaXRcIl0pO1xuICB2YXIgY29tbW9uS2V5d29yZHMgPSB3b3JkUmVnZXhwKFtcImFuZHRoZW5cIiwgXCJhdFwiLCBcImF0dHJcIiwgXCJkZWNsYXJlXCIsIFwiZmVhdFwiLCBcImZyb21cIiwgXCJsZXhcIixcbiAgICBcIm1vZFwiLCBcImRpdlwiLCBcIm1vZGVcIiwgXCJvcmVsc2VcIiwgXCJwYXJzZXJcIiwgXCJwcm9kXCIsIFwicHJvcFwiLCBcInNjYW5uZXJcIiwgXCJzZWxmXCIsIFwic3luXCIsIFwidG9rZW5cIl0pO1xuICB2YXIgb3BlbmluZ0tleXdvcmRzID0gd29yZFJlZ2V4cChbXCJsb2NhbFwiLCBcInByb2NcIiwgXCJmdW5cIiwgXCJjYXNlXCIsIFwiY2xhc3NcIiwgXCJpZlwiLCBcImNvbmRcIiwgXCJvclwiLCBcImRpc1wiLFxuICAgIFwiY2hvaWNlXCIsIFwibm90XCIsIFwidGhyZWFkXCIsIFwidHJ5XCIsIFwicmFpc2VcIiwgXCJsb2NrXCIsIFwiZm9yXCIsIFwic3VjaHRoYXRcIiwgXCJtZXRoXCIsIFwiZnVuY3RvclwiXSk7XG4gIHZhciBtaWRkbGVLZXl3b3JkcyA9IHdvcmRSZWdleHAobWlkZGxlKTtcbiAgdmFyIGVuZEtleXdvcmRzID0gd29yZFJlZ2V4cChlbmQpO1xuXG4gIC8vIFRva2VuaXplcnNcbiAgZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIEJyYWNrZXRzXG4gICAgaWYoc3RyZWFtLm1hdGNoKC9be31dLykpIHtcbiAgICAgIHJldHVybiBcImJyYWNrZXRcIjtcbiAgICB9XG5cbiAgICAvLyBTcGVjaWFsIFtdIGtleXdvcmRcbiAgICBpZiAoc3RyZWFtLm1hdGNoKCdbXScpKSB7XG4gICAgICAgIHJldHVybiBcImtleXdvcmRcIlxuICAgIH1cblxuICAgIC8vIE9wZXJhdG9yc1xuICAgIGlmIChzdHJlYW0ubWF0Y2godHJpcGxlT3BlcmF0b3JzKSB8fCBzdHJlYW0ubWF0Y2goZG91YmxlT3BlcmF0b3JzKSkge1xuICAgICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgICB9XG5cbiAgICAvLyBBdG9tc1xuICAgIGlmKHN0cmVhbS5tYXRjaChhdG9tcykpIHtcbiAgICAgIHJldHVybiAnYXRvbSc7XG4gICAgfVxuXG4gICAgLy8gT3BlbmluZyBrZXl3b3Jkc1xuICAgIHZhciBtYXRjaGVkID0gc3RyZWFtLm1hdGNoKG9wZW5pbmdLZXl3b3Jkcyk7XG4gICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgIGlmICghc3RhdGUuZG9JbkN1cnJlbnRMaW5lKVxuICAgICAgICBzdGF0ZS5jdXJyZW50SW5kZW50Kys7XG4gICAgICBlbHNlXG4gICAgICAgIHN0YXRlLmRvSW5DdXJyZW50TGluZSA9IGZhbHNlO1xuXG4gICAgICAvLyBTcGVjaWFsIG1hdGNoaW5nIGZvciBzaWduYXR1cmVzXG4gICAgICBpZihtYXRjaGVkWzBdID09IFwicHJvY1wiIHx8IG1hdGNoZWRbMF0gPT0gXCJmdW5cIilcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkZ1blByb2M7XG4gICAgICBlbHNlIGlmKG1hdGNoZWRbMF0gPT0gXCJjbGFzc1wiKVxuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQ2xhc3M7XG4gICAgICBlbHNlIGlmKG1hdGNoZWRbMF0gPT0gXCJtZXRoXCIpXG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5NZXRoO1xuXG4gICAgICByZXR1cm4gJ2tleXdvcmQnO1xuICAgIH1cblxuICAgIC8vIE1pZGRsZSBhbmQgb3RoZXIga2V5d29yZHNcbiAgICBpZiAoc3RyZWFtLm1hdGNoKG1pZGRsZUtleXdvcmRzKSB8fCBzdHJlYW0ubWF0Y2goY29tbW9uS2V5d29yZHMpKSB7XG4gICAgICByZXR1cm4gXCJrZXl3b3JkXCJcbiAgICB9XG5cbiAgICAvLyBFbmQga2V5d29yZHNcbiAgICBpZiAoc3RyZWFtLm1hdGNoKGVuZEtleXdvcmRzKSkge1xuICAgICAgc3RhdGUuY3VycmVudEluZGVudC0tO1xuICAgICAgcmV0dXJuICdrZXl3b3JkJztcbiAgICB9XG5cbiAgICAvLyBFYXQgdGhlIG5leHQgY2hhciBmb3IgbmV4dCBjb21wYXJpc29uc1xuICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG5cbiAgICAvLyBTdHJpbmdzXG4gICAgaWYgKGNoID09ICdcIicgfHwgY2ggPT0gXCInXCIpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5TdHJpbmcoY2gpO1xuICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIC8vIE51bWJlcnNcbiAgICBpZiAoL1t+XFxkXS8udGVzdChjaCkpIHtcbiAgICAgIGlmIChjaCA9PSBcIn5cIikge1xuICAgICAgICBpZighIC9eWzAtOV0vLnRlc3Qoc3RyZWFtLnBlZWsoKSkpXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGVsc2UgaWYgKCggc3RyZWFtLm5leHQoKSA9PSBcIjBcIiAmJiBzdHJlYW0ubWF0Y2goL15beFhdWzAtOWEtZkEtRl0rLykpIHx8IHN0cmVhbS5tYXRjaCgvXlswLTldKihcXC5bMC05XSspPyhbZUVdW34rXT9bMC05XSspPy8pKVxuICAgICAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoKGNoID09IFwiMFwiICYmIHN0cmVhbS5tYXRjaCgvXlt4WF1bMC05YS1mQS1GXSsvKSkgfHwgc3RyZWFtLm1hdGNoKC9eWzAtOV0qKFxcLlswLTldKyk/KFtlRV1bfitdP1swLTldKyk/LykpXG4gICAgICAgIHJldHVybiBcIm51bWJlclwiO1xuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBDb21tZW50c1xuICAgIGlmIChjaCA9PSBcIiVcIikge1xuICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgcmV0dXJuICdjb21tZW50JztcbiAgICB9XG4gICAgZWxzZSBpZiAoY2ggPT0gXCIvXCIpIHtcbiAgICAgIGlmIChzdHJlYW0uZWF0KFwiKlwiKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQ29tbWVudDtcbiAgICAgICAgcmV0dXJuIHRva2VuQ29tbWVudChzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTaW5nbGUgb3BlcmF0b3JzXG4gICAgaWYoc2luZ2xlT3BlcmF0b3JzLnRlc3QoY2gpKSB7XG4gICAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICAgIH1cblxuICAgIC8vIElmIG5vdGhpbmcgbWF0Y2gsIHdlIHNraXAgdGhlIGVudGlyZSBhbHBoYW51bWVyaWMgYmxvY2tcbiAgICBzdHJlYW0uZWF0V2hpbGUoL1xcdy8pO1xuXG4gICAgcmV0dXJuIFwidmFyaWFibGVcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuQ2xhc3Moc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHN0cmVhbS5tYXRjaCgvKFtBLVpdW0EtWmEtejAtOV9dKil8KGAuK2ApLyk7XG4gICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgcmV0dXJuIFwidmFyaWFibGUtM1wiXG4gIH1cblxuICBmdW5jdGlvbiB0b2tlbk1ldGgoc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHN0cmVhbS5tYXRjaCgvKFthLXpBLVpdW0EtWmEtejAtOV9dKil8KGAuK2ApLyk7XG4gICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgcmV0dXJuIFwiZGVmXCJcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuRnVuUHJvYyhzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZighc3RhdGUuaGFzUGFzc2VkRmlyc3RTdGFnZSAmJiBzdHJlYW0uZWF0KFwie1wiKSkge1xuICAgICAgc3RhdGUuaGFzUGFzc2VkRmlyc3RTdGFnZSA9IHRydWU7XG4gICAgICByZXR1cm4gXCJicmFja2V0XCI7XG4gICAgfVxuICAgIGVsc2UgaWYoc3RhdGUuaGFzUGFzc2VkRmlyc3RTdGFnZSkge1xuICAgICAgc3RyZWFtLm1hdGNoKC8oW0EtWl1bQS1aYS16MC05X10qKXwoYC4rYCl8XFwkLyk7XG4gICAgICBzdGF0ZS5oYXNQYXNzZWRGaXJzdFN0YWdlID0gZmFsc2U7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgIHJldHVybiBcImRlZlwiXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBtYXliZUVuZCA9IGZhbHNlLCBjaDtcbiAgICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgICBpZiAoY2ggPT0gXCIvXCIgJiYgbWF5YmVFbmQpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbWF5YmVFbmQgPSAoY2ggPT0gXCIqXCIpO1xuICAgIH1cbiAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlblN0cmluZyhxdW90ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIGVzY2FwZWQgPSBmYWxzZSwgbmV4dCwgZW5kID0gZmFsc2U7XG4gICAgICB3aGlsZSAoKG5leHQgPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChuZXh0ID09IHF1b3RlICYmICFlc2NhcGVkKSB7XG4gICAgICAgICAgZW5kID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQgJiYgbmV4dCA9PSBcIlxcXFxcIjtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQgfHwgIWVzY2FwZWQpXG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkRWxlY3RyaWNJbnB1dFJlZ0V4KCkge1xuICAgIC8vIFJlaW5kZW50YXRpb24gc2hvdWxkIG9jY3VyIG9uIFtdIG9yIG9uIGEgbWF0Y2ggb2YgYW55IG9mXG4gICAgLy8gdGhlIGJsb2NrIGNsb3Npbmcga2V5d29yZHMsIGF0IHRoZSBlbmQgb2YgYSBsaW5lLlxuICAgIHZhciBhbGxDbG9zaW5ncyA9IG1pZGRsZS5jb25jYXQoZW5kKTtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChcIltcXFxcW1xcXFxdXXwoXCIgKyBhbGxDbG9zaW5ncy5qb2luKFwifFwiKSArIFwiKSRcIik7XG4gIH1cblxuICByZXR1cm4ge1xuXG4gICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9rZW5pemU6IHRva2VuQmFzZSxcbiAgICAgICAgY3VycmVudEluZGVudDogMCxcbiAgICAgICAgZG9JbkN1cnJlbnRMaW5lOiBmYWxzZSxcbiAgICAgICAgaGFzUGFzc2VkRmlyc3RTdGFnZTogZmFsc2VcbiAgICAgIH07XG4gICAgfSxcblxuICAgIHRva2VuOiBmdW5jdGlvbiAoc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKHN0cmVhbS5zb2woKSlcbiAgICAgICAgc3RhdGUuZG9JbkN1cnJlbnRMaW5lID0gMDtcblxuICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIH0sXG5cbiAgICBpbmRlbnQ6IGZ1bmN0aW9uIChzdGF0ZSwgdGV4dEFmdGVyKSB7XG4gICAgICB2YXIgdHJ1ZVRleHQgPSB0ZXh0QWZ0ZXIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xuXG4gICAgICBpZiAodHJ1ZVRleHQubWF0Y2goZW5kS2V5d29yZHMpIHx8IHRydWVUZXh0Lm1hdGNoKG1pZGRsZUtleXdvcmRzKSB8fCB0cnVlVGV4dC5tYXRjaCgvKFxcW10pLykpXG4gICAgICAgIHJldHVybiBjb25mLmluZGVudFVuaXQgKiAoc3RhdGUuY3VycmVudEluZGVudCAtIDEpO1xuXG4gICAgICBpZiAoc3RhdGUuY3VycmVudEluZGVudCA8IDApXG4gICAgICAgIHJldHVybiAwO1xuXG4gICAgICByZXR1cm4gc3RhdGUuY3VycmVudEluZGVudCAqIGNvbmYuaW5kZW50VW5pdDtcbiAgICB9LFxuICAgIGZvbGQ6IFwiaW5kZW50XCIsXG4gICAgZWxlY3RyaWNJbnB1dDogYnVpbGRFbGVjdHJpY0lucHV0UmVnRXgoKSxcbiAgICBsaW5lQ29tbWVudDogXCIlXCIsXG4gICAgYmxvY2tDb21tZW50U3RhcnQ6IFwiLypcIixcbiAgICBibG9ja0NvbW1lbnRFbmQ6IFwiKi9cIlxuICB9O1xufSk7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQveC1velwiLCBcIm96XCIpO1xuXG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwicGFzY2FsXCIsIGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiB3b3JkcyhzdHIpIHtcbiAgICB2YXIgb2JqID0ge30sIHdvcmRzID0gc3RyLnNwbGl0KFwiIFwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgKytpKSBvYmpbd29yZHNbaV1dID0gdHJ1ZTtcbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIHZhciBrZXl3b3JkcyA9IHdvcmRzKFxuICAgIFwiYWJzb2x1dGUgYW5kIGFycmF5IGFzbSBiZWdpbiBjYXNlIGNvbnN0IGNvbnN0cnVjdG9yIGRlc3RydWN0b3IgZGl2IGRvIFwiICtcbiAgICBcImRvd250byBlbHNlIGVuZCBmaWxlIGZvciBmdW5jdGlvbiBnb3RvIGlmIGltcGxlbWVudGF0aW9uIGluIGluaGVyaXRlZCBcIiArXG4gICAgXCJpbmxpbmUgaW50ZXJmYWNlIGxhYmVsIG1vZCBuaWwgbm90IG9iamVjdCBvZiBvcGVyYXRvciBvciBwYWNrZWQgcHJvY2VkdXJlIFwiICtcbiAgICBcInByb2dyYW0gcmVjb3JkIHJlaW50cm9kdWNlIHJlcGVhdCBzZWxmIHNldCBzaGwgc2hyIHN0cmluZyB0aGVuIHRvIHR5cGUgXCIgK1xuICAgIFwidW5pdCB1bnRpbCB1c2VzIHZhciB3aGlsZSB3aXRoIHhvciBhcyBjbGFzcyBkaXNwaW50ZXJmYWNlIGV4Y2VwdCBleHBvcnRzIFwiICtcbiAgICBcImZpbmFsaXphdGlvbiBmaW5hbGx5IGluaXRpYWxpemF0aW9uIGlubGluZSBpcyBsaWJyYXJ5IG9uIG91dCBwYWNrZWQgXCIgK1xuICAgIFwicHJvcGVydHkgcmFpc2UgcmVzb3VyY2VzdHJpbmcgdGhyZWFkdmFyIHRyeSBhYnNvbHV0ZSBhYnN0cmFjdCBhbGlhcyBcIiArXG4gICAgXCJhc3NlbWJsZXIgYml0cGFja2VkIGJyZWFrIGNkZWNsIGNvbnRpbnVlIGNwcGRlY2wgY3ZhciBkZWZhdWx0IGRlcHJlY2F0ZWQgXCIgK1xuICAgIFwiZHluYW1pYyBlbnVtZXJhdG9yIGV4cGVyaW1lbnRhbCBleHBvcnQgZXh0ZXJuYWwgZmFyIGZhcjE2IGZvcndhcmQgZ2VuZXJpYyBcIiArXG4gICAgXCJoZWxwZXIgaW1wbGVtZW50cyBpbmRleCBpbnRlcnJ1cHQgaW9jaGVjayBsb2NhbCBtZXNzYWdlIG5hbWUgbmVhciBcIiArXG4gICAgXCJub2RlZmF1bHQgbm9yZXR1cm4gbm9zdGFja2ZyYW1lIG9sZGZwY2NhbGwgb3RoZXJ3aXNlIG92ZXJsb2FkIG92ZXJyaWRlIFwiICtcbiAgICBcInBhc2NhbCBwbGF0Zm9ybSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgcHVibGlzaGVkIHJlYWQgcmVnaXN0ZXIgXCIgK1xuICAgIFwicmVpbnRyb2R1Y2UgcmVzdWx0IHNhZmVjYWxsIHNhdmVyZWdpc3RlcnMgc29mdGZsb2F0IHNwZWNpYWxpemUgc3RhdGljIFwiICtcbiAgICBcInN0ZGNhbGwgc3RvcmVkIHN0cmljdCB1bmFsaWduZWQgdW5pbXBsZW1lbnRlZCB2YXJhcmdzIHZpcnR1YWwgd3JpdGVcIik7XG4gIHZhciBhdG9tcyA9IHtcIm51bGxcIjogdHJ1ZX07XG5cbiAgdmFyIGlzT3BlcmF0b3JDaGFyID0gL1srXFwtKiYlPTw+IT98XFwvXS87XG5cbiAgZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICAgIGlmIChjaCA9PSBcIiNcIiAmJiBzdGF0ZS5zdGFydE9mTGluZSkge1xuICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgcmV0dXJuIFwibWV0YVwiO1xuICAgIH1cbiAgICBpZiAoY2ggPT0gJ1wiJyB8fCBjaCA9PSBcIidcIikge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlblN0cmluZyhjaCk7XG4gICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICAgIGlmIChjaCA9PSBcIihcIiAmJiBzdHJlYW0uZWF0KFwiKlwiKSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkNvbW1lbnQ7XG4gICAgICByZXR1cm4gdG9rZW5Db21tZW50KHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgICBpZiAoY2ggPT0gXCJ7XCIpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5Db21tZW50QnJhY2VzO1xuICAgICAgcmV0dXJuIHRva2VuQ29tbWVudEJyYWNlcyhzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gICAgaWYgKC9bXFxbXFxdXFwoXFwpLDtcXDpcXC5dLy50ZXN0KGNoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICgvXFxkLy50ZXN0KGNoKSkge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwuXS8pO1xuICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgfVxuICAgIGlmIChjaCA9PSBcIi9cIikge1xuICAgICAgaWYgKHN0cmVhbS5lYXQoXCIvXCIpKSB7XG4gICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNPcGVyYXRvckNoYXIudGVzdChjaCkpIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZShpc09wZXJhdG9yQ2hhcik7XG4gICAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICAgIH1cbiAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXCRfXS8pO1xuICAgIHZhciBjdXIgPSBzdHJlYW0uY3VycmVudCgpO1xuICAgIGlmIChrZXl3b3Jkcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSByZXR1cm4gXCJrZXl3b3JkXCI7XG4gICAgaWYgKGF0b21zLnByb3BlcnR5SXNFbnVtZXJhYmxlKGN1cikpIHJldHVybiBcImF0b21cIjtcbiAgICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5TdHJpbmcocXVvdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIGVzY2FwZWQgPSBmYWxzZSwgbmV4dCwgZW5kID0gZmFsc2U7XG4gICAgICB3aGlsZSAoKG5leHQgPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChuZXh0ID09IHF1b3RlICYmICFlc2NhcGVkKSB7ZW5kID0gdHJ1ZTsgYnJlYWs7fVxuICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQgJiYgbmV4dCA9PSBcIlxcXFxcIjtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQgfHwgIWVzY2FwZWQpIHN0YXRlLnRva2VuaXplID0gbnVsbDtcbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBtYXliZUVuZCA9IGZhbHNlLCBjaDtcbiAgICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgICBpZiAoY2ggPT0gXCIpXCIgJiYgbWF5YmVFbmQpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG1heWJlRW5kID0gKGNoID09IFwiKlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5Db21tZW50QnJhY2VzKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgY2g7XG4gICAgd2hpbGUgKGNoID0gc3RyZWFtLm5leHQoKSkge1xuICAgICAgaWYgKGNoID09IFwifVwiKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgfVxuXG4gIC8vIEludGVyZmFjZVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge3Rva2VuaXplOiBudWxsfTtcbiAgICB9LFxuXG4gICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgc3R5bGUgPSAoc3RhdGUudG9rZW5pemUgfHwgdG9rZW5CYXNlKShzdHJlYW0sIHN0YXRlKTtcbiAgICAgIGlmIChzdHlsZSA9PSBcImNvbW1lbnRcIiB8fCBzdHlsZSA9PSBcIm1ldGFcIikgcmV0dXJuIHN0eWxlO1xuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH0sXG5cbiAgICBlbGVjdHJpY0NoYXJzOiBcInt9XCJcbiAgfTtcbn0pO1xuXG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3gtcGFzY2FsXCIsIFwicGFzY2FsXCIpO1xuXG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIiksIHJlcXVpcmUoXCIuLi9qYXZhc2NyaXB0L2phdmFzY3JpcHRcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIiwgXCIuLi9qYXZhc2NyaXB0L2phdmFzY3JpcHRcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwicGVnanNcIiwgZnVuY3Rpb24gKGNvbmZpZykge1xuICB2YXIganNNb2RlID0gQ29kZU1pcnJvci5nZXRNb2RlKGNvbmZpZywgXCJqYXZhc2NyaXB0XCIpO1xuXG4gIGZ1bmN0aW9uIGlkZW50aWZpZXIoc3RyZWFtKSB7XG4gICAgcmV0dXJuIHN0cmVhbS5tYXRjaCgvXlthLXpBLVpfXVthLXpBLVowLTlfXSovKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5TdHJpbmc6IGZhbHNlLFxuICAgICAgICBzdHJpbmdUeXBlOiBudWxsLFxuICAgICAgICBpbkNvbW1lbnQ6IGZhbHNlLFxuICAgICAgICBpbkNoYXJhY3RlckNsYXNzOiBmYWxzZSxcbiAgICAgICAgYnJhY2VkOiAwLFxuICAgICAgICBsaHM6IHRydWUsXG4gICAgICAgIGxvY2FsU3RhdGU6IG51bGxcbiAgICAgIH07XG4gICAgfSxcbiAgICB0b2tlbjogZnVuY3Rpb24gKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmIChzdHJlYW0pXG5cbiAgICAgIC8vY2hlY2sgZm9yIHN0YXRlIGNoYW5nZXNcbiAgICAgIGlmICghc3RhdGUuaW5TdHJpbmcgJiYgIXN0YXRlLmluQ29tbWVudCAmJiAoKHN0cmVhbS5wZWVrKCkgPT0gJ1wiJykgfHwgKHN0cmVhbS5wZWVrKCkgPT0gXCInXCIpKSkge1xuICAgICAgICBzdGF0ZS5zdHJpbmdUeXBlID0gc3RyZWFtLnBlZWsoKTtcbiAgICAgICAgc3RyZWFtLm5leHQoKTsgLy8gU2tpcCBxdW90ZVxuICAgICAgICBzdGF0ZS5pblN0cmluZyA9IHRydWU7IC8vIFVwZGF0ZSBzdGF0ZVxuICAgICAgfVxuICAgICAgaWYgKCFzdGF0ZS5pblN0cmluZyAmJiAhc3RhdGUuaW5Db21tZW50ICYmIHN0cmVhbS5tYXRjaCgnLyonKSkge1xuICAgICAgICBzdGF0ZS5pbkNvbW1lbnQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvL3JldHVybiBzdGF0ZVxuICAgICAgaWYgKHN0YXRlLmluU3RyaW5nKSB7XG4gICAgICAgIHdoaWxlIChzdGF0ZS5pblN0cmluZyAmJiAhc3RyZWFtLmVvbCgpKSB7XG4gICAgICAgICAgaWYgKHN0cmVhbS5wZWVrKCkgPT09IHN0YXRlLnN0cmluZ1R5cGUpIHtcbiAgICAgICAgICAgIHN0cmVhbS5uZXh0KCk7IC8vIFNraXAgcXVvdGVcbiAgICAgICAgICAgIHN0YXRlLmluU3RyaW5nID0gZmFsc2U7IC8vIENsZWFyIGZsYWdcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5wZWVrKCkgPT09ICdcXFxcJykge1xuICAgICAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmVhbS5tYXRjaCgvXi5bXlxcXFxcXFwiXFwnXSovKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlLmxocyA/IFwicHJvcGVydHkgc3RyaW5nXCIgOiBcInN0cmluZ1wiOyAvLyBUb2tlbiBzdHlsZVxuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5pbkNvbW1lbnQpIHtcbiAgICAgICAgd2hpbGUgKHN0YXRlLmluQ29tbWVudCAmJiAhc3RyZWFtLmVvbCgpKSB7XG4gICAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgnKi8nKSkge1xuICAgICAgICAgICAgc3RhdGUuaW5Db21tZW50ID0gZmFsc2U7IC8vIENsZWFyIGZsYWdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyZWFtLm1hdGNoKC9eLlteXFwqXSovKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5pbkNoYXJhY3RlckNsYXNzKSB7XG4gICAgICAgICAgd2hpbGUgKHN0YXRlLmluQ2hhcmFjdGVyQ2xhc3MgJiYgIXN0cmVhbS5lb2woKSkge1xuICAgICAgICAgICAgaWYgKCEoc3RyZWFtLm1hdGNoKC9eW15cXF1cXFxcXSsvKSB8fCBzdHJlYW0ubWF0Y2goL15cXFxcLi8pKSkge1xuICAgICAgICAgICAgICBzdGF0ZS5pbkNoYXJhY3RlckNsYXNzID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzdHJlYW0ucGVlaygpID09PSAnWycpIHtcbiAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgc3RhdGUuaW5DaGFyYWN0ZXJDbGFzcyA9IHRydWU7XG4gICAgICAgIHJldHVybiAnYnJhY2tldCc7XG4gICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaCgnLy8nKSkge1xuICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuYnJhY2VkIHx8IHN0cmVhbS5wZWVrKCkgPT09ICd7Jykge1xuICAgICAgICBpZiAoc3RhdGUubG9jYWxTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHN0YXRlLmxvY2FsU3RhdGUgPSBDb2RlTWlycm9yLnN0YXJ0U3RhdGUoanNNb2RlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdG9rZW4gPSBqc01vZGUudG9rZW4oc3RyZWFtLCBzdGF0ZS5sb2NhbFN0YXRlKTtcbiAgICAgICAgdmFyIHRleHQgPSBzdHJlYW0uY3VycmVudCgpO1xuICAgICAgICBpZiAoIXRva2VuKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGV4dFtpXSA9PT0gJ3snKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmJyYWNlZCsrO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0ZXh0W2ldID09PSAnfScpIHtcbiAgICAgICAgICAgICAgc3RhdGUuYnJhY2VkLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9IGVsc2UgaWYgKGlkZW50aWZpZXIoc3RyZWFtKSkge1xuICAgICAgICBpZiAoc3RyZWFtLnBlZWsoKSA9PT0gJzonKSB7XG4gICAgICAgICAgcmV0dXJuICd2YXJpYWJsZSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICd2YXJpYWJsZS0yJztcbiAgICAgIH0gZWxzZSBpZiAoWydbJywgJ10nLCAnKCcsICcpJ10uaW5kZXhPZihzdHJlYW0ucGVlaygpKSAhPSAtMSkge1xuICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICByZXR1cm4gJ2JyYWNrZXQnO1xuICAgICAgfSBlbHNlIGlmICghc3RyZWFtLmVhdFNwYWNlKCkpIHtcbiAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcbn0sIFwiamF2YXNjcmlwdFwiKTtcblxufSk7XG4iLCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4vLyBDb2RlTWlycm9yMiBtb2RlL3BlcmwvcGVybC5qcyAodGV4dC94LXBlcmwpIGJldGEgMC4xMCAoMjAxMS0xMS0wOClcbi8vIFRoaXMgaXMgYSBwYXJ0IG9mIENvZGVNaXJyb3IgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vc2FiYWNhL0NvZGVNaXJyb3JfbW9kZV9wZXJsIChtYWlsQHNhYmFjYS5jb20pXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwicGVybFwiLGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vIGh0dHA6Ly9wZXJsZG9jLnBlcmwub3JnXG4gICAgICAgIHZhciBQRVJMPXsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgbnVsbCAtIG1hZ2ljIHRvdWNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgMSAtIGtleXdvcmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAyIC0gZGVmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgMyAtIGF0b21cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICA0IC0gb3BlcmF0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICA1IC0gdmFyaWFibGUtMiAocHJlZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBbeCx5XSAtIHg9MSwyLDM7IHk9bXVzdCBiZSBkZWZpbmVkIGlmIHh7Li4ufVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICBQRVJMIG9wZXJhdG9yc1xuICAgICAgICAgICAgICAgICctPicgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgIDQsXG4gICAgICAgICAgICAgICAgJysrJyAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgNCxcbiAgICAgICAgICAgICAgICAnLS0nICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogICA0LFxuICAgICAgICAgICAgICAgICcqKicgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgIDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgISB+IFxcIGFuZCB1bmFyeSArIGFuZCAtXG4gICAgICAgICAgICAgICAgJz1+JyAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgNCxcbiAgICAgICAgICAgICAgICAnIX4nICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogICA0LFxuICAgICAgICAgICAgICAgICcqJyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgIDQsXG4gICAgICAgICAgICAgICAgJy8nICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgNCxcbiAgICAgICAgICAgICAgICAnJScgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogICA0LFxuICAgICAgICAgICAgICAgICd4JyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgIDQsXG4gICAgICAgICAgICAgICAgJysnICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgNCxcbiAgICAgICAgICAgICAgICAnLScgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogICA0LFxuICAgICAgICAgICAgICAgICcuJyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgIDQsXG4gICAgICAgICAgICAgICAgJzw8JyAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgNCxcbiAgICAgICAgICAgICAgICAnPj4nICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogICA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIG5hbWVkIHVuYXJ5IG9wZXJhdG9yc1xuICAgICAgICAgICAgICAgICc8JyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgIDQsXG4gICAgICAgICAgICAgICAgJz4nICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgNCxcbiAgICAgICAgICAgICAgICAnPD0nICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogICA0LFxuICAgICAgICAgICAgICAgICc+PScgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgIDQsXG4gICAgICAgICAgICAgICAgJ2x0JyAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgNCxcbiAgICAgICAgICAgICAgICAnZ3QnICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogICA0LFxuICAgICAgICAgICAgICAgICdsZScgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgIDQsXG4gICAgICAgICAgICAgICAgJ2dlJyAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgNCxcbiAgICAgICAgICAgICAgICAnPT0nICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogICA0LFxuICAgICAgICAgICAgICAgICchPScgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgIDQsXG4gICAgICAgICAgICAgICAgJzw9PicgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgNCxcbiAgICAgICAgICAgICAgICAnZXEnICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogICA0LFxuICAgICAgICAgICAgICAgICduZScgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgIDQsXG4gICAgICAgICAgICAgICAgJ2NtcCcgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgNCxcbiAgICAgICAgICAgICAgICAnfn4nICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogICA0LFxuICAgICAgICAgICAgICAgICcmJyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgIDQsXG4gICAgICAgICAgICAgICAgJ3wnICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgNCxcbiAgICAgICAgICAgICAgICAnXicgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogICA0LFxuICAgICAgICAgICAgICAgICcmJicgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgIDQsXG4gICAgICAgICAgICAgICAgJ3x8JyAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgNCxcbiAgICAgICAgICAgICAgICAnLy8nICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogICA0LFxuICAgICAgICAgICAgICAgICcuLicgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgIDQsXG4gICAgICAgICAgICAgICAgJy4uLicgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgNCxcbiAgICAgICAgICAgICAgICAnPycgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogICA0LFxuICAgICAgICAgICAgICAgICc6JyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgIDQsXG4gICAgICAgICAgICAgICAgJz0nICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgNCxcbiAgICAgICAgICAgICAgICAnKz0nICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogICA0LFxuICAgICAgICAgICAgICAgICctPScgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgIDQsXG4gICAgICAgICAgICAgICAgJyo9JyAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgNCwgIC8vICAgZXRjLiA/Pz9cbiAgICAgICAgICAgICAgICAnLCcgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogICA0LFxuICAgICAgICAgICAgICAgICc9PicgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgIDQsXG4gICAgICAgICAgICAgICAgJzo6JyAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBsaXN0IG9wZXJhdG9ycyAocmlnaHR3YXJkKVxuICAgICAgICAgICAgICAgICdub3QnICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgIDQsXG4gICAgICAgICAgICAgICAgJ2FuZCcgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgNCxcbiAgICAgICAgICAgICAgICAnb3InICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogICA0LFxuICAgICAgICAgICAgICAgICd4b3InICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgIDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgIFBFUkwgcHJlZGVmaW5lZCB2YXJpYWJsZXMgKEkga25vdywgd2hhdCB0aGlzIGlzIGEgcGFyYW5vaWQgaWRlYSwgYnV0IG1heSBiZSBuZWVkZWQgZm9yIHBlb3BsZSwgd2hvIGxlYXJuIFBFUkwsIGFuZCBmb3IgbWUgYXMgd2VsbCwgLi4uYW5kIG1heSBiZSBmb3IgeW91PzspXG4gICAgICAgICAgICAgICAgJ0JFR0lOJyAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgWzUsMV0sXG4gICAgICAgICAgICAgICAgJ0VORCcgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgWzUsMV0sXG4gICAgICAgICAgICAgICAgJ1BSSU5UJyAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgWzUsMV0sXG4gICAgICAgICAgICAgICAgJ1BSSU5URicgICAgICAgICAgICAgICAgICAgICAgICA6ICAgWzUsMV0sXG4gICAgICAgICAgICAgICAgJ0dFVEMnICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgWzUsMV0sXG4gICAgICAgICAgICAgICAgJ1JFQUQnICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgWzUsMV0sXG4gICAgICAgICAgICAgICAgJ1JFQURMSU5FJyAgICAgICAgICAgICAgICAgICAgICA6ICAgWzUsMV0sXG4gICAgICAgICAgICAgICAgJ0RFU1RST1knICAgICAgICAgICAgICAgICAgICAgICA6ICAgWzUsMV0sXG4gICAgICAgICAgICAgICAgJ1RJRScgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgWzUsMV0sXG4gICAgICAgICAgICAgICAgJ1RJRUhBTkRMRScgICAgICAgICAgICAgICAgICAgICA6ICAgWzUsMV0sXG4gICAgICAgICAgICAgICAgJ1VOVElFJyAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgWzUsMV0sXG4gICAgICAgICAgICAgICAgJ1NURElOJyAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJ1NURElOX1RPUCcgICAgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJ1NURE9VVCcgICAgICAgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJ1NURE9VVF9UT1AnICAgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJ1NUREVSUicgICAgICAgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJ1NUREVSUl9UT1AnICAgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyRBUkcnICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyRfJyAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJ0BBUkcnICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJ0BfJyAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyRMSVNUX1NFUEFSQVRPUicgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyRcIicgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckUFJPQ0VTU19JRCcgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckUElEJyAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckJCcgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckUkVBTF9HUk9VUF9JRCcgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckR0lEJyAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckKCcgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckRUZGRUNUSVZFX0dST1VQX0lEJyAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckRUdJRCcgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckKScgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckUFJPR1JBTV9OQU1FJyAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckMCcgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckU1VCU0NSSVBUX1NFUEFSQVRPUicgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckU1VCU0VQJyAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckOycgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckUkVBTF9VU0VSX0lEJyAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckVUlEJyAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckPCcgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckRUZGRUNUSVZFX1VTRVJfSUQnICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckRVVJRCcgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckPicgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckYScgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckYicgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckQ09NUElMSU5HJyAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckXkMnICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckREVCVUdHSU5HJyAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckXkQnICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICcke15FTkNPRElOR30nICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckRU5WJyAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICclRU5WJyAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckU1lTVEVNX0ZEX01BWCcgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckXkYnICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICdARicgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICcke15HTE9CQUxfUEhBU0V9JyAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckXkgnICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICclXkgnICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICdASU5DJyAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICclSU5DJyAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckSU5QTEFDRV9FRElUJyAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckXkknICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckXk0nICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckT1NOQU1FJyAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckXk8nICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICcke15PUEVOfScgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckUEVSTERCJyAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckXlAnICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckU0lHJyAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICclU0lHJyAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckQkFTRVRJTUUnICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckXlQnICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICcke15UQUlOVH0nICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICcke15VTklDT0RFfScgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICcke15VVEY4Q0FDSEV9JyAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICcke15VVEY4TE9DQUxFfScgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckUEVSTF9WRVJTSU9OJyAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckXlYnICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICcke15XSU4zMl9TTE9QUFlfU1RBVH0nICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckRVhFQ1VUQUJMRV9OQU1FJyAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckXlgnICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckMScgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LCAvLyAtIHJlZ2V4cCAkMSwgJDIuLi5cbiAgICAgICAgICAgICAgICAnJE1BVENIJyAgICAgICAgICAgICAgICAgICAgICAgIDogICAgNSxcbiAgICAgICAgICAgICAgICAnJCYnICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogICAgNSxcbiAgICAgICAgICAgICAgICAnJHteTUFUQ0h9JyAgICAgICAgICAgICAgICAgICAgIDogICAgNSxcbiAgICAgICAgICAgICAgICAnJFBSRU1BVENIJyAgICAgICAgICAgICAgICAgICAgIDogICAgNSxcbiAgICAgICAgICAgICAgICAnJGAnICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogICAgNSxcbiAgICAgICAgICAgICAgICAnJHteUFJFTUFUQ0h9JyAgICAgICAgICAgICAgICAgIDogICAgNSxcbiAgICAgICAgICAgICAgICAnJFBPU1RNQVRDSCcgICAgICAgICAgICAgICAgICAgIDogICAgNSxcbiAgICAgICAgICAgICAgICBcIiQnXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICcke15QT1NUTUFUQ0h9JyAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckTEFTVF9QQVJFTl9NQVRDSCcgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckKycgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckTEFTVF9TVUJNQVRDSF9SRVNVTFQnICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckXk4nICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICdATEFTVF9NQVRDSF9FTkQnICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICdAKycgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICclTEFTVF9QQVJFTl9NQVRDSCcgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICclKycgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICdATEFTVF9NQVRDSF9TVEFSVCcgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICdALScgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICclTEFTVF9NQVRDSF9TVEFSVCcgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICclLScgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckTEFTVF9SRUdFWFBfQ09ERV9SRVNVTFQnICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckXlInICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICcke15SRV9ERUJVR19GTEFHU30nICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICcke15SRV9UUklFX01BWEJVRn0nICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckQVJHVicgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICdAQVJHVicgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICdBUkdWJyAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICdBUkdWT1VUJyAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckT1VUUFVUX0ZJRUxEX1NFUEFSQVRPUicgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckT0ZTJyAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckLCcgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckSU5QVVRfTElORV9OVU1CRVInICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckTlInICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckLicgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckSU5QVVRfUkVDT1JEX1NFUEFSQVRPUicgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckUlMnICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckLycgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckT1VUUFVUX1JFQ09SRF9TRVBBUkFUT1InICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckT1JTJyAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICA1LFxuICAgICAgICAgICAgICAgICckXFxcXCcgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyRPVVRQVVRfQVVUT0ZMVVNIJyAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyR8JyAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyRBQ0NVTVVMQVRPUicgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyReQScgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyRGT1JNQVRfRk9STUZFRUQnICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyReTCcgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyRGT1JNQVRfUEFHRV9OVU1CRVInICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyQlJyAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyRGT1JNQVRfTElORVNfTEVGVCcgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyQtJyAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyRGT1JNQVRfTElORV9CUkVBS19DSEFSQUNURVJTJyA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyQ6JyAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyRGT1JNQVRfTElORVNfUEVSX1BBR0UnICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyQ9JyAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyRGT1JNQVRfVE9QX05BTUUnICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyReJyAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyRGT1JNQVRfTkFNRScgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyR+JyAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyR7XkNISUxEX0VSUk9SX05BVElWRX0nICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyRFWFRFTkRFRF9PU19FUlJPUicgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyReRScgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyRFWENFUFRJT05TX0JFSU5HX0NBVUdIVCcgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyReUycgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyRXQVJOSU5HJyAgICAgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyReVycgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyR7XldBUk5JTkdfQklUU30nICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyRPU19FUlJPUicgICAgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyRFUlJOTycgICAgICAgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyQhJyAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyVPU19FUlJPUicgICAgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyVFUlJOTycgICAgICAgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyUhJyAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyRDSElMRF9FUlJPUicgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyQ/JyAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyRFVkFMX0VSUk9SJyAgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyRAJyAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyRPRk1UJyAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyQjJyAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyQqJyAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyRBUlJBWV9CQVNFJyAgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyRbJyAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyRPTERfUEVSTF9WRVJTSU9OJyAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgJyRdJyAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICAgIDUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgIFBFUkwgYmxvY2tzXG4gICAgICAgICAgICAgICAgJ2lmJyAgICAgICAgICAgICAgICAgICAgICAgICAgICA6WzEsMV0sXG4gICAgICAgICAgICAgICAgZWxzaWYgICAgICAgICAgICAgICAgICAgICAgICAgICA6WzEsMV0sXG4gICAgICAgICAgICAgICAgJ2Vsc2UnICAgICAgICAgICAgICAgICAgICAgICAgICA6WzEsMV0sXG4gICAgICAgICAgICAgICAgJ3doaWxlJyAgICAgICAgICAgICAgICAgICAgICAgICA6WzEsMV0sXG4gICAgICAgICAgICAgICAgdW5sZXNzICAgICAgICAgICAgICAgICAgICAgICAgICA6WzEsMV0sXG4gICAgICAgICAgICAgICAgJ2ZvcicgICAgICAgICAgICAgICAgICAgICAgICAgICA6WzEsMV0sXG4gICAgICAgICAgICAgICAgZm9yZWFjaCAgICAgICAgICAgICAgICAgICAgICAgICA6WzEsMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgIFBFUkwgZnVuY3Rpb25zXG4gICAgICAgICAgICAgICAgJ2FicycgICAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gYWJzb2x1dGUgdmFsdWUgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICBhY2NlcHQgICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBhY2NlcHQgYW4gaW5jb21pbmcgc29ja2V0IGNvbm5lY3RcbiAgICAgICAgICAgICAgICBhbGFybSAgICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBzY2hlZHVsZSBhIFNJR0FMUk1cbiAgICAgICAgICAgICAgICAnYXRhbjInICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBhcmN0YW5nZW50IG9mIFkvWCBpbiB0aGUgcmFuZ2UgLVBJIHRvIFBJXG4gICAgICAgICAgICAgICAgYmluZCAgICAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gYmluZHMgYW4gYWRkcmVzcyB0byBhIHNvY2tldFxuICAgICAgICAgICAgICAgIGJpbm1vZGUgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIHByZXBhcmUgYmluYXJ5IGZpbGVzIGZvciBJL09cbiAgICAgICAgICAgICAgICBibGVzcyAgICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBjcmVhdGUgYW4gb2JqZWN0XG4gICAgICAgICAgICAgICAgYm9vdHN0cmFwICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vXG4gICAgICAgICAgICAgICAgJ2JyZWFrJyAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gYnJlYWsgb3V0IG9mIGEgXCJnaXZlblwiIGJsb2NrXG4gICAgICAgICAgICAgICAgY2FsbGVyICAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gZ2V0IGNvbnRleHQgb2YgdGhlIGN1cnJlbnQgc3Vicm91dGluZSBjYWxsXG4gICAgICAgICAgICAgICAgY2hkaXIgICAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gY2hhbmdlIHlvdXIgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeVxuICAgICAgICAgICAgICAgIGNobW9kICAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGNoYW5nZXMgdGhlIHBlcm1pc3Npb25zIG9uIGEgbGlzdCBvZiBmaWxlc1xuICAgICAgICAgICAgICAgIGNob21wICAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIHJlbW92ZSBhIHRyYWlsaW5nIHJlY29yZCBzZXBhcmF0b3IgZnJvbSBhIHN0cmluZ1xuICAgICAgICAgICAgICAgIGNob3AgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIHJlbW92ZSB0aGUgbGFzdCBjaGFyYWN0ZXIgZnJvbSBhIHN0cmluZ1xuICAgICAgICAgICAgICAgIGNob3duICAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGNoYW5nZSB0aGUgb3duZXJzaGlwIG9uIGEgbGlzdCBvZiBmaWxlc1xuICAgICAgICAgICAgICAgIGNociAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGdldCBjaGFyYWN0ZXIgdGhpcyBudW1iZXIgcmVwcmVzZW50c1xuICAgICAgICAgICAgICAgIGNocm9vdCAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIG1ha2UgZGlyZWN0b3J5IG5ldyByb290IGZvciBwYXRoIGxvb2t1cHNcbiAgICAgICAgICAgICAgICBjbG9zZSAgICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBjbG9zZSBmaWxlIChvciBwaXBlIG9yIHNvY2tldCkgaGFuZGxlXG4gICAgICAgICAgICAgICAgY2xvc2VkaXIgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gY2xvc2UgZGlyZWN0b3J5IGhhbmRsZVxuICAgICAgICAgICAgICAgIGNvbm5lY3QgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGNvbm5lY3QgdG8gYSByZW1vdGUgc29ja2V0XG4gICAgICAgICAgICAgICAgJ2NvbnRpbnVlJyAgICAgICAgICAgICAgICAgICAgICA6WzEsMV0sIC8vIC0gb3B0aW9uYWwgdHJhaWxpbmcgYmxvY2sgaW4gYSB3aGlsZSBvciBmb3JlYWNoXG4gICAgICAgICAgICAgICAgJ2NvcycgICAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gY29zaW5lIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgY3J5cHQgICAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gb25lLXdheSBwYXNzd2Qtc3R5bGUgZW5jcnlwdGlvblxuICAgICAgICAgICAgICAgIGRibWNsb3NlICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGJyZWFrcyBiaW5kaW5nIG9uIGEgdGllZCBkYm0gZmlsZVxuICAgICAgICAgICAgICAgIGRibW9wZW4gICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGNyZWF0ZSBiaW5kaW5nIG9uIGEgdGllZCBkYm0gZmlsZVxuICAgICAgICAgICAgICAgICdkZWZhdWx0JyAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvL1xuICAgICAgICAgICAgICAgIGRlZmluZWQgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIHRlc3Qgd2hldGhlciBhIHZhbHVlLCB2YXJpYWJsZSwgb3IgZnVuY3Rpb24gaXMgZGVmaW5lZFxuICAgICAgICAgICAgICAgICdkZWxldGUnICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGRlbGV0ZXMgYSB2YWx1ZSBmcm9tIGEgaGFzaFxuICAgICAgICAgICAgICAgIGRpZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIHJhaXNlIGFuIGV4Y2VwdGlvbiBvciBiYWlsIG91dFxuICAgICAgICAgICAgICAgICdkbycgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIHR1cm4gYSBCTE9DSyBpbnRvIGEgVEVSTVxuICAgICAgICAgICAgICAgIGR1bXAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGNyZWF0ZSBhbiBpbW1lZGlhdGUgY29yZSBkdW1wXG4gICAgICAgICAgICAgICAgZWFjaCAgICAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gcmV0cmlldmUgdGhlIG5leHQga2V5L3ZhbHVlIHBhaXIgZnJvbSBhIGhhc2hcbiAgICAgICAgICAgICAgICBlbmRncmVudCAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBiZSBkb25lIHVzaW5nIGdyb3VwIGZpbGVcbiAgICAgICAgICAgICAgICBlbmRob3N0ZW50ICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBiZSBkb25lIHVzaW5nIGhvc3RzIGZpbGVcbiAgICAgICAgICAgICAgICBlbmRuZXRlbnQgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBiZSBkb25lIHVzaW5nIG5ldHdvcmtzIGZpbGVcbiAgICAgICAgICAgICAgICBlbmRwcm90b2VudCAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBiZSBkb25lIHVzaW5nIHByb3RvY29scyBmaWxlXG4gICAgICAgICAgICAgICAgZW5kcHdlbnQgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gYmUgZG9uZSB1c2luZyBwYXNzd2QgZmlsZVxuICAgICAgICAgICAgICAgIGVuZHNlcnZlbnQgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGJlIGRvbmUgdXNpbmcgc2VydmljZXMgZmlsZVxuICAgICAgICAgICAgICAgIGVvZiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIHRlc3QgYSBmaWxlaGFuZGxlIGZvciBpdHMgZW5kXG4gICAgICAgICAgICAgICAgJ2V2YWwnICAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gY2F0Y2ggZXhjZXB0aW9ucyBvciBjb21waWxlIGFuZCBydW4gY29kZVxuICAgICAgICAgICAgICAgICdleGVjJyAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGFiYW5kb24gdGhpcyBwcm9ncmFtIHRvIHJ1biBhbm90aGVyXG4gICAgICAgICAgICAgICAgZXhpc3RzICAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gdGVzdCB3aGV0aGVyIGEgaGFzaCBrZXkgaXMgcHJlc2VudFxuICAgICAgICAgICAgICAgIGV4aXQgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIHRlcm1pbmF0ZSB0aGlzIHByb2dyYW1cbiAgICAgICAgICAgICAgICAnZXhwJyAgICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSByYWlzZSBJIHRvIGEgcG93ZXJcbiAgICAgICAgICAgICAgICBmY250bCAgICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBmaWxlIGNvbnRyb2wgc3lzdGVtIGNhbGxcbiAgICAgICAgICAgICAgICBmaWxlbm8gICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSByZXR1cm4gZmlsZSBkZXNjcmlwdG9yIGZyb20gZmlsZWhhbmRsZVxuICAgICAgICAgICAgICAgIGZsb2NrICAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGxvY2sgYW4gZW50aXJlIGZpbGUgd2l0aCBhbiBhZHZpc29yeSBsb2NrXG4gICAgICAgICAgICAgICAgZm9yayAgICAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gY3JlYXRlIGEgbmV3IHByb2Nlc3MganVzdCBsaWtlIHRoaXMgb25lXG4gICAgICAgICAgICAgICAgZm9ybWF0ICAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gZGVjbGFyZSBhIHBpY3R1cmUgZm9ybWF0IHdpdGggdXNlIGJ5IHRoZSB3cml0ZSgpIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgZm9ybWxpbmUgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gaW50ZXJuYWwgZnVuY3Rpb24gdXNlZCBmb3IgZm9ybWF0c1xuICAgICAgICAgICAgICAgIGdldGMgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGdldCB0aGUgbmV4dCBjaGFyYWN0ZXIgZnJvbSB0aGUgZmlsZWhhbmRsZVxuICAgICAgICAgICAgICAgIGdldGdyZW50ICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGdldCBuZXh0IGdyb3VwIHJlY29yZFxuICAgICAgICAgICAgICAgIGdldGdyZ2lkICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGdldCBncm91cCByZWNvcmQgZ2l2ZW4gZ3JvdXAgdXNlciBJRFxuICAgICAgICAgICAgICAgIGdldGdybmFtICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGdldCBncm91cCByZWNvcmQgZ2l2ZW4gZ3JvdXAgbmFtZVxuICAgICAgICAgICAgICAgIGdldGhvc3RieWFkZHIgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGdldCBob3N0IHJlY29yZCBnaXZlbiBpdHMgYWRkcmVzc1xuICAgICAgICAgICAgICAgIGdldGhvc3RieW5hbWUgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGdldCBob3N0IHJlY29yZCBnaXZlbiBuYW1lXG4gICAgICAgICAgICAgICAgZ2V0aG9zdGVudCAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gZ2V0IG5leHQgaG9zdHMgcmVjb3JkXG4gICAgICAgICAgICAgICAgZ2V0bG9naW4gICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gcmV0dXJuIHdobyBsb2dnZWQgaW4gYXQgdGhpcyB0dHlcbiAgICAgICAgICAgICAgICBnZXRuZXRieWFkZHIgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBnZXQgbmV0d29yayByZWNvcmQgZ2l2ZW4gaXRzIGFkZHJlc3NcbiAgICAgICAgICAgICAgICBnZXRuZXRieW5hbWUgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBnZXQgbmV0d29ya3MgcmVjb3JkIGdpdmVuIG5hbWVcbiAgICAgICAgICAgICAgICBnZXRuZXRlbnQgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBnZXQgbmV4dCBuZXR3b3JrcyByZWNvcmRcbiAgICAgICAgICAgICAgICBnZXRwZWVybmFtZSAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBmaW5kIHRoZSBvdGhlciBlbmQgb2YgYSBzb2NrZXQgY29ubmVjdGlvblxuICAgICAgICAgICAgICAgIGdldHBncnAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGdldCBwcm9jZXNzIGdyb3VwXG4gICAgICAgICAgICAgICAgZ2V0cHBpZCAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gZ2V0IHBhcmVudCBwcm9jZXNzIElEXG4gICAgICAgICAgICAgICAgZ2V0cHJpb3JpdHkgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gZ2V0IGN1cnJlbnQgbmljZSB2YWx1ZVxuICAgICAgICAgICAgICAgIGdldHByb3RvYnluYW1lICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGdldCBwcm90b2NvbCByZWNvcmQgZ2l2ZW4gbmFtZVxuICAgICAgICAgICAgICAgIGdldHByb3RvYnludW1iZXIgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGdldCBwcm90b2NvbCByZWNvcmQgbnVtZXJpYyBwcm90b2NvbFxuICAgICAgICAgICAgICAgIGdldHByb3RvZW50ICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGdldCBuZXh0IHByb3RvY29scyByZWNvcmRcbiAgICAgICAgICAgICAgICBnZXRwd2VudCAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBnZXQgbmV4dCBwYXNzd2QgcmVjb3JkXG4gICAgICAgICAgICAgICAgZ2V0cHduYW0gICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gZ2V0IHBhc3N3ZCByZWNvcmQgZ2l2ZW4gdXNlciBsb2dpbiBuYW1lXG4gICAgICAgICAgICAgICAgZ2V0cHd1aWQgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gZ2V0IHBhc3N3ZCByZWNvcmQgZ2l2ZW4gdXNlciBJRFxuICAgICAgICAgICAgICAgIGdldHNlcnZieW5hbWUgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGdldCBzZXJ2aWNlcyByZWNvcmQgZ2l2ZW4gaXRzIG5hbWVcbiAgICAgICAgICAgICAgICBnZXRzZXJ2Ynlwb3J0ICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBnZXQgc2VydmljZXMgcmVjb3JkIGdpdmVuIG51bWVyaWMgcG9ydFxuICAgICAgICAgICAgICAgIGdldHNlcnZlbnQgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGdldCBuZXh0IHNlcnZpY2VzIHJlY29yZFxuICAgICAgICAgICAgICAgIGdldHNvY2tuYW1lICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIHJldHJpZXZlIHRoZSBzb2NrYWRkciBmb3IgYSBnaXZlbiBzb2NrZXRcbiAgICAgICAgICAgICAgICBnZXRzb2Nrb3B0ICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBnZXQgc29ja2V0IG9wdGlvbnMgb24gYSBnaXZlbiBzb2NrZXRcbiAgICAgICAgICAgICAgICBnaXZlbiAgICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy9cbiAgICAgICAgICAgICAgICBnbG9iICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBleHBhbmQgZmlsZW5hbWVzIHVzaW5nIHdpbGRjYXJkc1xuICAgICAgICAgICAgICAgIGdtdGltZSAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGNvbnZlcnQgVU5JWCB0aW1lIGludG8gcmVjb3JkIG9yIHN0cmluZyB1c2luZyBHcmVlbndpY2ggdGltZVxuICAgICAgICAgICAgICAgICdnb3RvJyAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGNyZWF0ZSBzcGFnaGV0dGkgY29kZVxuICAgICAgICAgICAgICAgIGdyZXAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGxvY2F0ZSBlbGVtZW50cyBpbiBhIGxpc3QgdGVzdCB0cnVlIGFnYWluc3QgYSBnaXZlbiBjcml0ZXJpb25cbiAgICAgICAgICAgICAgICBoZXggICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBjb252ZXJ0IGEgc3RyaW5nIHRvIGEgaGV4YWRlY2ltYWwgbnVtYmVyXG4gICAgICAgICAgICAgICAgJ2ltcG9ydCcgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gcGF0Y2ggYSBtb2R1bGUncyBuYW1lc3BhY2UgaW50byB5b3VyIG93blxuICAgICAgICAgICAgICAgIGluZGV4ICAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGZpbmQgYSBzdWJzdHJpbmcgd2l0aGluIGEgc3RyaW5nXG4gICAgICAgICAgICAgICAgJ2ludCcgICAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gZ2V0IHRoZSBpbnRlZ2VyIHBvcnRpb24gb2YgYSBudW1iZXJcbiAgICAgICAgICAgICAgICBpb2N0bCAgICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBzeXN0ZW0tZGVwZW5kZW50IGRldmljZSBjb250cm9sIHN5c3RlbSBjYWxsXG4gICAgICAgICAgICAgICAgJ2pvaW4nICAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gam9pbiBhIGxpc3QgaW50byBhIHN0cmluZyB1c2luZyBhIHNlcGFyYXRvclxuICAgICAgICAgICAgICAgIGtleXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIHJldHJpZXZlIGxpc3Qgb2YgaW5kaWNlcyBmcm9tIGEgaGFzaFxuICAgICAgICAgICAgICAgIGtpbGwgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIHNlbmQgYSBzaWduYWwgdG8gYSBwcm9jZXNzIG9yIHByb2Nlc3MgZ3JvdXBcbiAgICAgICAgICAgICAgICBsYXN0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBleGl0IGEgYmxvY2sgcHJlbWF0dXJlbHlcbiAgICAgICAgICAgICAgICBsYyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSByZXR1cm4gbG93ZXItY2FzZSB2ZXJzaW9uIG9mIGEgc3RyaW5nXG4gICAgICAgICAgICAgICAgbGNmaXJzdCAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gcmV0dXJuIGEgc3RyaW5nIHdpdGgganVzdCB0aGUgbmV4dCBsZXR0ZXIgaW4gbG93ZXIgY2FzZVxuICAgICAgICAgICAgICAgIGxlbmd0aCAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIHJldHVybiB0aGUgbnVtYmVyIG9mIGJ5dGVzIGluIGEgc3RyaW5nXG4gICAgICAgICAgICAgICAgJ2xpbmsnICAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gY3JlYXRlIGEgaGFyZCBsaW5rIGluIHRoZSBmaWxlc3lzdGVtXG4gICAgICAgICAgICAgICAgbGlzdGVuICAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gcmVnaXN0ZXIgeW91ciBzb2NrZXQgYXMgYSBzZXJ2ZXJcbiAgICAgICAgICAgICAgICBsb2NhbCAgICAgICAgICAgICAgICAgICAgICAgICAgIDogMiwgICAgLy8gLSBjcmVhdGUgYSB0ZW1wb3JhcnkgdmFsdWUgZm9yIGEgZ2xvYmFsIHZhcmlhYmxlIChkeW5hbWljIHNjb3BpbmcpXG4gICAgICAgICAgICAgICAgbG9jYWx0aW1lICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gY29udmVydCBVTklYIHRpbWUgaW50byByZWNvcmQgb3Igc3RyaW5nIHVzaW5nIGxvY2FsIHRpbWVcbiAgICAgICAgICAgICAgICBsb2NrICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBnZXQgYSB0aHJlYWQgbG9jayBvbiBhIHZhcmlhYmxlLCBzdWJyb3V0aW5lLCBvciBtZXRob2RcbiAgICAgICAgICAgICAgICAnbG9nJyAgICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSByZXRyaWV2ZSB0aGUgbmF0dXJhbCBsb2dhcml0aG0gZm9yIGEgbnVtYmVyXG4gICAgICAgICAgICAgICAgbHN0YXQgICAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gc3RhdCBhIHN5bWJvbGljIGxpbmtcbiAgICAgICAgICAgICAgICBtICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpudWxsLCAgLy8gLSBtYXRjaCBhIHN0cmluZyB3aXRoIGEgcmVndWxhciBleHByZXNzaW9uIHBhdHRlcm5cbiAgICAgICAgICAgICAgICBtYXAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBhcHBseSBhIGNoYW5nZSB0byBhIGxpc3QgdG8gZ2V0IGJhY2sgYSBuZXcgbGlzdCB3aXRoIHRoZSBjaGFuZ2VzXG4gICAgICAgICAgICAgICAgbWtkaXIgICAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gY3JlYXRlIGEgZGlyZWN0b3J5XG4gICAgICAgICAgICAgICAgbXNnY3RsICAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gU3lzViBJUEMgbWVzc2FnZSBjb250cm9sIG9wZXJhdGlvbnNcbiAgICAgICAgICAgICAgICBtc2dnZXQgICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBnZXQgU3lzViBJUEMgbWVzc2FnZSBxdWV1ZVxuICAgICAgICAgICAgICAgIG1zZ3JjdiAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIHJlY2VpdmUgYSBTeXNWIElQQyBtZXNzYWdlIGZyb20gYSBtZXNzYWdlIHF1ZXVlXG4gICAgICAgICAgICAgICAgbXNnc25kICAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gc2VuZCBhIFN5c1YgSVBDIG1lc3NhZ2UgdG8gYSBtZXNzYWdlIHF1ZXVlXG4gICAgICAgICAgICAgICAgbXkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IDIsICAgIC8vIC0gZGVjbGFyZSBhbmQgYXNzaWduIGEgbG9jYWwgdmFyaWFibGUgKGxleGljYWwgc2NvcGluZylcbiAgICAgICAgICAgICAgICAnbmV3JyAgICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy9cbiAgICAgICAgICAgICAgICBuZXh0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBpdGVyYXRlIGEgYmxvY2sgcHJlbWF0dXJlbHlcbiAgICAgICAgICAgICAgICBubyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSB1bmltcG9ydCBzb21lIG1vZHVsZSBzeW1ib2xzIG9yIHNlbWFudGljcyBhdCBjb21waWxlIHRpbWVcbiAgICAgICAgICAgICAgICBvY3QgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBjb252ZXJ0IGEgc3RyaW5nIHRvIGFuIG9jdGFsIG51bWJlclxuICAgICAgICAgICAgICAgIG9wZW4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIG9wZW4gYSBmaWxlLCBwaXBlLCBvciBkZXNjcmlwdG9yXG4gICAgICAgICAgICAgICAgb3BlbmRpciAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gb3BlbiBhIGRpcmVjdG9yeVxuICAgICAgICAgICAgICAgIG9yZCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGZpbmQgYSBjaGFyYWN0ZXIncyBudW1lcmljIHJlcHJlc2VudGF0aW9uXG4gICAgICAgICAgICAgICAgb3VyICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IDIsICAgIC8vIC0gZGVjbGFyZSBhbmQgYXNzaWduIGEgcGFja2FnZSB2YXJpYWJsZSAobGV4aWNhbCBzY29waW5nKVxuICAgICAgICAgICAgICAgIHBhY2sgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGNvbnZlcnQgYSBsaXN0IGludG8gYSBiaW5hcnkgcmVwcmVzZW50YXRpb25cbiAgICAgICAgICAgICAgICAncGFja2FnZScgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBkZWNsYXJlIGEgc2VwYXJhdGUgZ2xvYmFsIG5hbWVzcGFjZVxuICAgICAgICAgICAgICAgIHBpcGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIG9wZW4gYSBwYWlyIG9mIGNvbm5lY3RlZCBmaWxlaGFuZGxlc1xuICAgICAgICAgICAgICAgIHBvcCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIHJlbW92ZSB0aGUgbGFzdCBlbGVtZW50IGZyb20gYW4gYXJyYXkgYW5kIHJldHVybiBpdFxuICAgICAgICAgICAgICAgIHBvcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGZpbmQgb3Igc2V0IHRoZSBvZmZzZXQgZm9yIHRoZSBsYXN0L25leHQgbS8vZyBzZWFyY2hcbiAgICAgICAgICAgICAgICBwcmludCAgICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBvdXRwdXQgYSBsaXN0IHRvIGEgZmlsZWhhbmRsZVxuICAgICAgICAgICAgICAgIHByaW50ZiAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIG91dHB1dCBhIGZvcm1hdHRlZCBsaXN0IHRvIGEgZmlsZWhhbmRsZVxuICAgICAgICAgICAgICAgIHByb3RvdHlwZSAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGdldCB0aGUgcHJvdG90eXBlIChpZiBhbnkpIG9mIGEgc3Vicm91dGluZVxuICAgICAgICAgICAgICAgIHB1c2ggICAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGFwcGVuZCBvbmUgb3IgbW9yZSBlbGVtZW50cyB0byBhbiBhcnJheVxuICAgICAgICAgICAgICAgIHEgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOm51bGwsICAvLyAtIHNpbmdseSBxdW90ZSBhIHN0cmluZ1xuICAgICAgICAgICAgICAgIHFxICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOm51bGwsICAvLyAtIGRvdWJseSBxdW90ZSBhIHN0cmluZ1xuICAgICAgICAgICAgICAgIHFyICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOm51bGwsICAvLyAtIENvbXBpbGUgcGF0dGVyblxuICAgICAgICAgICAgICAgIHF1b3RlbWV0YSAgICAgICAgICAgICAgICAgICAgICAgOm51bGwsICAvLyAtIHF1b3RlIHJlZ3VsYXIgZXhwcmVzc2lvbiBtYWdpYyBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgcXcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6bnVsbCwgIC8vIC0gcXVvdGUgYSBsaXN0IG9mIHdvcmRzXG4gICAgICAgICAgICAgICAgcXggICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6bnVsbCwgIC8vIC0gYmFja3F1b3RlIHF1b3RlIGEgc3RyaW5nXG4gICAgICAgICAgICAgICAgcmFuZCAgICAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gcmV0cmlldmUgdGhlIG5leHQgcHNldWRvcmFuZG9tIG51bWJlclxuICAgICAgICAgICAgICAgIHJlYWQgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGZpeGVkLWxlbmd0aCBidWZmZXJlZCBpbnB1dCBmcm9tIGEgZmlsZWhhbmRsZVxuICAgICAgICAgICAgICAgIHJlYWRkaXIgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGdldCBhIGRpcmVjdG9yeSBmcm9tIGEgZGlyZWN0b3J5IGhhbmRsZVxuICAgICAgICAgICAgICAgIHJlYWRsaW5lICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGZldGNoIGEgcmVjb3JkIGZyb20gYSBmaWxlXG4gICAgICAgICAgICAgICAgcmVhZGxpbmsgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gZGV0ZXJtaW5lIHdoZXJlIGEgc3ltYm9saWMgbGluayBpcyBwb2ludGluZ1xuICAgICAgICAgICAgICAgIHJlYWRwaXBlICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGV4ZWN1dGUgYSBzeXN0ZW0gY29tbWFuZCBhbmQgY29sbGVjdCBzdGFuZGFyZCBvdXRwdXRcbiAgICAgICAgICAgICAgICByZWN2ICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSByZWNlaXZlIGEgbWVzc2FnZSBvdmVyIGEgU29ja2V0XG4gICAgICAgICAgICAgICAgcmVkbyAgICAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gc3RhcnQgdGhpcyBsb29wIGl0ZXJhdGlvbiBvdmVyIGFnYWluXG4gICAgICAgICAgICAgICAgcmVmICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gZmluZCBvdXQgdGhlIHR5cGUgb2YgdGhpbmcgYmVpbmcgcmVmZXJlbmNlZFxuICAgICAgICAgICAgICAgIHJlbmFtZSAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGNoYW5nZSBhIGZpbGVuYW1lXG4gICAgICAgICAgICAgICAgcmVxdWlyZSAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gbG9hZCBpbiBleHRlcm5hbCBmdW5jdGlvbnMgZnJvbSBhIGxpYnJhcnkgYXQgcnVudGltZVxuICAgICAgICAgICAgICAgIHJlc2V0ICAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGNsZWFyIGFsbCB2YXJpYWJsZXMgb2YgYSBnaXZlbiBuYW1lXG4gICAgICAgICAgICAgICAgJ3JldHVybicgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gZ2V0IG91dCBvZiBhIGZ1bmN0aW9uIGVhcmx5XG4gICAgICAgICAgICAgICAgcmV2ZXJzZSAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gZmxpcCBhIHN0cmluZyBvciBhIGxpc3RcbiAgICAgICAgICAgICAgICByZXdpbmRkaXIgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSByZXNldCBkaXJlY3RvcnkgaGFuZGxlXG4gICAgICAgICAgICAgICAgcmluZGV4ICAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gcmlnaHQtdG8tbGVmdCBzdWJzdHJpbmcgc2VhcmNoXG4gICAgICAgICAgICAgICAgcm1kaXIgICAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gcmVtb3ZlIGEgZGlyZWN0b3J5XG4gICAgICAgICAgICAgICAgcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6bnVsbCwgIC8vIC0gcmVwbGFjZSBhIHBhdHRlcm4gd2l0aCBhIHN0cmluZ1xuICAgICAgICAgICAgICAgIHNheSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIHByaW50IHdpdGggbmV3bGluZVxuICAgICAgICAgICAgICAgIHNjYWxhciAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGZvcmNlIGEgc2NhbGFyIGNvbnRleHRcbiAgICAgICAgICAgICAgICBzZWVrICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSByZXBvc2l0aW9uIGZpbGUgcG9pbnRlciBmb3IgcmFuZG9tLWFjY2VzcyBJL09cbiAgICAgICAgICAgICAgICBzZWVrZGlyICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSByZXBvc2l0aW9uIGRpcmVjdG9yeSBwb2ludGVyXG4gICAgICAgICAgICAgICAgc2VsZWN0ICAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gcmVzZXQgZGVmYXVsdCBvdXRwdXQgb3IgZG8gSS9PIG11bHRpcGxleGluZ1xuICAgICAgICAgICAgICAgIHNlbWN0bCAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIFN5c1Ygc2VtYXBob3JlIGNvbnRyb2wgb3BlcmF0aW9uc1xuICAgICAgICAgICAgICAgIHNlbWdldCAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGdldCBzZXQgb2YgU3lzViBzZW1hcGhvcmVzXG4gICAgICAgICAgICAgICAgc2Vtb3AgICAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gU3lzViBzZW1hcGhvcmUgb3BlcmF0aW9uc1xuICAgICAgICAgICAgICAgIHNlbmQgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIHNlbmQgYSBtZXNzYWdlIG92ZXIgYSBzb2NrZXRcbiAgICAgICAgICAgICAgICBzZXRncmVudCAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBwcmVwYXJlIGdyb3VwIGZpbGUgZm9yIHVzZVxuICAgICAgICAgICAgICAgIHNldGhvc3RlbnQgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIHByZXBhcmUgaG9zdHMgZmlsZSBmb3IgdXNlXG4gICAgICAgICAgICAgICAgc2V0bmV0ZW50ICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gcHJlcGFyZSBuZXR3b3JrcyBmaWxlIGZvciB1c2VcbiAgICAgICAgICAgICAgICBzZXRwZ3JwICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBzZXQgdGhlIHByb2Nlc3MgZ3JvdXAgb2YgYSBwcm9jZXNzXG4gICAgICAgICAgICAgICAgc2V0cHJpb3JpdHkgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gc2V0IGEgcHJvY2VzcydzIG5pY2UgdmFsdWVcbiAgICAgICAgICAgICAgICBzZXRwcm90b2VudCAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBwcmVwYXJlIHByb3RvY29scyBmaWxlIGZvciB1c2VcbiAgICAgICAgICAgICAgICBzZXRwd2VudCAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBwcmVwYXJlIHBhc3N3ZCBmaWxlIGZvciB1c2VcbiAgICAgICAgICAgICAgICBzZXRzZXJ2ZW50ICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBwcmVwYXJlIHNlcnZpY2VzIGZpbGUgZm9yIHVzZVxuICAgICAgICAgICAgICAgIHNldHNvY2tvcHQgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIHNldCBzb21lIHNvY2tldCBvcHRpb25zXG4gICAgICAgICAgICAgICAgc2hpZnQgICAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gcmVtb3ZlIHRoZSBmaXJzdCBlbGVtZW50IG9mIGFuIGFycmF5LCBhbmQgcmV0dXJuIGl0XG4gICAgICAgICAgICAgICAgc2htY3RsICAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gU3lzViBzaGFyZWQgbWVtb3J5IG9wZXJhdGlvbnNcbiAgICAgICAgICAgICAgICBzaG1nZXQgICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBnZXQgU3lzViBzaGFyZWQgbWVtb3J5IHNlZ21lbnQgaWRlbnRpZmllclxuICAgICAgICAgICAgICAgIHNobXJlYWQgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIHJlYWQgU3lzViBzaGFyZWQgbWVtb3J5XG4gICAgICAgICAgICAgICAgc2htd3JpdGUgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gd3JpdGUgU3lzViBzaGFyZWQgbWVtb3J5XG4gICAgICAgICAgICAgICAgc2h1dGRvd24gICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gY2xvc2UgZG93biBqdXN0IGhhbGYgb2YgYSBzb2NrZXQgY29ubmVjdGlvblxuICAgICAgICAgICAgICAgICdzaW4nICAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIHJldHVybiB0aGUgc2luZSBvZiBhIG51bWJlclxuICAgICAgICAgICAgICAgIHNsZWVwICAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGJsb2NrIGZvciBzb21lIG51bWJlciBvZiBzZWNvbmRzXG4gICAgICAgICAgICAgICAgc29ja2V0ICAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gY3JlYXRlIGEgc29ja2V0XG4gICAgICAgICAgICAgICAgc29ja2V0cGFpciAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gY3JlYXRlIGEgcGFpciBvZiBzb2NrZXRzXG4gICAgICAgICAgICAgICAgJ3NvcnQnICAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gc29ydCBhIGxpc3Qgb2YgdmFsdWVzXG4gICAgICAgICAgICAgICAgc3BsaWNlICAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gYWRkIG9yIHJlbW92ZSBlbGVtZW50cyBhbnl3aGVyZSBpbiBhbiBhcnJheVxuICAgICAgICAgICAgICAgICdzcGxpdCcgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIHNwbGl0IHVwIGEgc3RyaW5nIHVzaW5nIGEgcmVnZXhwIGRlbGltaXRlclxuICAgICAgICAgICAgICAgIHNwcmludGYgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGZvcm1hdHRlZCBwcmludCBpbnRvIGEgc3RyaW5nXG4gICAgICAgICAgICAgICAgJ3NxcnQnICAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gc3F1YXJlIHJvb3QgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICBzcmFuZCAgICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBzZWVkIHRoZSByYW5kb20gbnVtYmVyIGdlbmVyYXRvclxuICAgICAgICAgICAgICAgIHN0YXQgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGdldCBhIGZpbGUncyBzdGF0dXMgaW5mb3JtYXRpb25cbiAgICAgICAgICAgICAgICBzdGF0ZSAgICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBkZWNsYXJlIGFuZCBhc3NpZ24gYSBzdGF0ZSB2YXJpYWJsZSAocGVyc2lzdGVudCBsZXhpY2FsIHNjb3BpbmcpXG4gICAgICAgICAgICAgICAgc3R1ZHkgICAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gb3B0aW1pemUgaW5wdXQgZGF0YSBmb3IgcmVwZWF0ZWQgc2VhcmNoZXNcbiAgICAgICAgICAgICAgICAnc3ViJyAgICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBkZWNsYXJlIGEgc3Vicm91dGluZSwgcG9zc2libHkgYW5vbnltb3VzbHlcbiAgICAgICAgICAgICAgICAnc3Vic3RyJyAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBnZXQgb3IgYWx0ZXIgYSBwb3J0aW9uIG9mIGEgc3RyaW5nXG4gICAgICAgICAgICAgICAgc3ltbGluayAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gY3JlYXRlIGEgc3ltYm9saWMgbGluayB0byBhIGZpbGVcbiAgICAgICAgICAgICAgICBzeXNjYWxsICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBleGVjdXRlIGFuIGFyYml0cmFyeSBzeXN0ZW0gY2FsbFxuICAgICAgICAgICAgICAgIHN5c29wZW4gICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIG9wZW4gYSBmaWxlLCBwaXBlLCBvciBkZXNjcmlwdG9yXG4gICAgICAgICAgICAgICAgc3lzcmVhZCAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gZml4ZWQtbGVuZ3RoIHVuYnVmZmVyZWQgaW5wdXQgZnJvbSBhIGZpbGVoYW5kbGVcbiAgICAgICAgICAgICAgICBzeXNzZWVrICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBwb3NpdGlvbiBJL08gcG9pbnRlciBvbiBoYW5kbGUgdXNlZCB3aXRoIHN5c3JlYWQgYW5kIHN5c3dyaXRlXG4gICAgICAgICAgICAgICAgc3lzdGVtICAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gcnVuIGEgc2VwYXJhdGUgcHJvZ3JhbVxuICAgICAgICAgICAgICAgIHN5c3dyaXRlICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGZpeGVkLWxlbmd0aCB1bmJ1ZmZlcmVkIG91dHB1dCB0byBhIGZpbGVoYW5kbGVcbiAgICAgICAgICAgICAgICB0ZWxsICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBnZXQgY3VycmVudCBzZWVrcG9pbnRlciBvbiBhIGZpbGVoYW5kbGVcbiAgICAgICAgICAgICAgICB0ZWxsZGlyICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBnZXQgY3VycmVudCBzZWVrcG9pbnRlciBvbiBhIGRpcmVjdG9yeSBoYW5kbGVcbiAgICAgICAgICAgICAgICB0aWUgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBiaW5kIGEgdmFyaWFibGUgdG8gYW4gb2JqZWN0IGNsYXNzXG4gICAgICAgICAgICAgICAgdGllZCAgICAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gZ2V0IGEgcmVmZXJlbmNlIHRvIHRoZSBvYmplY3QgdW5kZXJseWluZyBhIHRpZWQgdmFyaWFibGVcbiAgICAgICAgICAgICAgICB0aW1lICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSByZXR1cm4gbnVtYmVyIG9mIHNlY29uZHMgc2luY2UgMTk3MFxuICAgICAgICAgICAgICAgIHRpbWVzICAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIHJldHVybiBlbGFwc2VkIHRpbWUgZm9yIHNlbGYgYW5kIGNoaWxkIHByb2Nlc3Nlc1xuICAgICAgICAgICAgICAgIHRyICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOm51bGwsICAvLyAtIHRyYW5zbGl0ZXJhdGUgYSBzdHJpbmdcbiAgICAgICAgICAgICAgICB0cnVuY2F0ZSAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBzaG9ydGVuIGEgZmlsZVxuICAgICAgICAgICAgICAgIHVjICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIHJldHVybiB1cHBlci1jYXNlIHZlcnNpb24gb2YgYSBzdHJpbmdcbiAgICAgICAgICAgICAgICB1Y2ZpcnN0ICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSByZXR1cm4gYSBzdHJpbmcgd2l0aCBqdXN0IHRoZSBuZXh0IGxldHRlciBpbiB1cHBlciBjYXNlXG4gICAgICAgICAgICAgICAgdW1hc2sgICAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gc2V0IGZpbGUgY3JlYXRpb24gbW9kZSBtYXNrXG4gICAgICAgICAgICAgICAgdW5kZWYgICAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gcmVtb3ZlIGEgdmFyaWFibGUgb3IgZnVuY3Rpb24gZGVmaW5pdGlvblxuICAgICAgICAgICAgICAgIHVubGluayAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIHJlbW92ZSBvbmUgbGluayB0byBhIGZpbGVcbiAgICAgICAgICAgICAgICB1bnBhY2sgICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBjb252ZXJ0IGJpbmFyeSBzdHJ1Y3R1cmUgaW50byBub3JtYWwgcGVybCB2YXJpYWJsZXNcbiAgICAgICAgICAgICAgICB1bnNoaWZ0ICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBwcmVwZW5kIG1vcmUgZWxlbWVudHMgdG8gdGhlIGJlZ2lubmluZyBvZiBhIGxpc3RcbiAgICAgICAgICAgICAgICB1bnRpZSAgICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBicmVhayBhIHRpZSBiaW5kaW5nIHRvIGEgdmFyaWFibGVcbiAgICAgICAgICAgICAgICB1c2UgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBsb2FkIGluIGEgbW9kdWxlIGF0IGNvbXBpbGUgdGltZVxuICAgICAgICAgICAgICAgIHV0aW1lICAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIHNldCBhIGZpbGUncyBsYXN0IGFjY2VzcyBhbmQgbW9kaWZ5IHRpbWVzXG4gICAgICAgICAgICAgICAgdmFsdWVzICAgICAgICAgICAgICAgICAgICAgICAgICA6MSwgICAgIC8vIC0gcmV0dXJuIGEgbGlzdCBvZiB0aGUgdmFsdWVzIGluIGEgaGFzaFxuICAgICAgICAgICAgICAgIHZlYyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIHRlc3Qgb3Igc2V0IHBhcnRpY3VsYXIgYml0cyBpbiBhIHN0cmluZ1xuICAgICAgICAgICAgICAgIHdhaXQgICAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIHdhaXQgZm9yIGFueSBjaGlsZCBwcm9jZXNzIHRvIGRpZVxuICAgICAgICAgICAgICAgIHdhaXRwaWQgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIHdhaXQgZm9yIGEgcGFydGljdWxhciBjaGlsZCBwcm9jZXNzIHRvIGRpZVxuICAgICAgICAgICAgICAgIHdhbnRhcnJheSAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIGdldCB2b2lkIHZzIHNjYWxhciB2cyBsaXN0IGNvbnRleHQgb2YgY3VycmVudCBzdWJyb3V0aW5lIGNhbGxcbiAgICAgICAgICAgICAgICB3YXJuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoxLCAgICAgLy8gLSBwcmludCBkZWJ1Z2dpbmcgaW5mb1xuICAgICAgICAgICAgICAgIHdoZW4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvL1xuICAgICAgICAgICAgICAgIHdyaXRlICAgICAgICAgICAgICAgICAgICAgICAgICAgOjEsICAgICAvLyAtIHByaW50IGEgcGljdHVyZSByZWNvcmRcbiAgICAgICAgICAgICAgICB5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpudWxsfTsgLy8gLSB0cmFuc2xpdGVyYXRlIGEgc3RyaW5nXG5cbiAgICAgICAgdmFyIFJYc3R5bGU9XCJzdHJpbmctMlwiO1xuICAgICAgICB2YXIgUlhtb2RpZmllcnM9L1tnb3NleGltYWNwbHVkXS87ICAgICAgICAgICAgICAvLyBOT1RFOiBcIm1cIiwgXCJzXCIsIFwieVwiIGFuZCBcInRyXCIgbmVlZCB0byBjb3JyZWN0IHJlYWwgbW9kaWZpZXJzIGZvciBlYWNoIHJlZ2V4cCB0eXBlXG5cbiAgICAgICAgZnVuY3Rpb24gdG9rZW5DaGFpbihzdHJlYW0sc3RhdGUsY2hhaW4sc3R5bGUsdGFpbCl7ICAgICAvLyBOT1RFOiBjaGFpbi5sZW5ndGggPiAyIGlzIG5vdCB3b3JraW5nIG5vdyAoaXQncyBmb3Igc1suLi5dWy4uLl1nZW9zOylcbiAgICAgICAgICAgICAgICBzdGF0ZS5jaGFpbj1udWxsOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMiAgIDN0YWlsXG4gICAgICAgICAgICAgICAgc3RhdGUuc3R5bGU9bnVsbDtcbiAgICAgICAgICAgICAgICBzdGF0ZS50YWlsPW51bGw7XG4gICAgICAgICAgICAgICAgc3RhdGUudG9rZW5pemU9ZnVuY3Rpb24oc3RyZWFtLHN0YXRlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlPWZhbHNlLGMsaT0wO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUoYz1zdHJlYW0ubmV4dCgpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYz09PWNoYWluW2ldJiYhZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2hhaW5bKytpXSE9PXVuZGVmaW5lZCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jaGFpbj1jaGFpbltpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnN0eWxlPXN0eWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUudGFpbD10YWlsO31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHRhaWwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0uZWF0V2hpbGUodGFpbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUudG9rZW5pemU9dG9rZW5QZXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHlsZTt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGU9IWUmJmM9PVwiXFxcXFwiO31cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHlsZTt9O1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sc3RhdGUpO31cblxuICAgICAgICBmdW5jdGlvbiB0b2tlblNPTUVUSElORyhzdHJlYW0sc3RhdGUsc3RyaW5nKXtcbiAgICAgICAgICAgICAgICBzdGF0ZS50b2tlbml6ZT1mdW5jdGlvbihzdHJlYW0sc3RhdGUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3RyZWFtLnN0cmluZz09c3RyaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS50b2tlbml6ZT10b2tlblBlcmw7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjt9O1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sc3RhdGUpO31cblxuICAgICAgICBmdW5jdGlvbiB0b2tlblBlcmwoc3RyZWFtLHN0YXRlKXtcbiAgICAgICAgICAgICAgICBpZihzdHJlYW0uZWF0U3BhY2UoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIGlmKHN0YXRlLmNoYWluKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuQ2hhaW4oc3RyZWFtLHN0YXRlLHN0YXRlLmNoYWluLHN0YXRlLnN0eWxlLHN0YXRlLnRhaWwpO1xuICAgICAgICAgICAgICAgIGlmKHN0cmVhbS5tYXRjaCgvXlxcLT9bXFxkXFwuXS8sZmFsc2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3RyZWFtLm1hdGNoKC9eKFxcLT8oXFxkKlxcLlxcZCsoZVsrLV0/XFxkKyk/fFxcZCtcXC5cXGQqKXwweFtcXGRhLWZBLUZdK3wwYlswMV0rfFxcZCsoZVsrLV0/XFxkKyk/KS8pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ251bWJlcic7XG4gICAgICAgICAgICAgICAgaWYoc3RyZWFtLm1hdGNoKC9ePDwoPz1bX2EtekEtWl0pLykpeyAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IDw8U09NRVRISU5HXFxuLi4uXFxuU09NRVRISU5HXFxuXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1xcdy8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuU09NRVRISU5HKHN0cmVhbSxzdGF0ZSxzdHJlYW0uY3VycmVudCgpLnN1YnN0cigyKSk7fVxuICAgICAgICAgICAgICAgIGlmKHN0cmVhbS5zb2woKSYmc3RyZWFtLm1hdGNoKC9eXFw9aXRlbSg/IVxcdykvKSl7Ly8gTk9URTogXFxuPWl0ZW0uLi5cXG49Y3V0XFxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5TT01FVEhJTkcoc3RyZWFtLHN0YXRlLCc9Y3V0Jyk7fVxuICAgICAgICAgICAgICAgIHZhciBjaD1zdHJlYW0ubmV4dCgpO1xuICAgICAgICAgICAgICAgIGlmKGNoPT0nXCInfHxjaD09XCInXCIpeyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6ICcgb3IgXCIgb3IgPDwnU09NRVRISU5HJ1xcbi4uLlxcblNPTUVUSElOR1xcbiBvciA8PFwiU09NRVRISU5HXCJcXG4uLi5cXG5TT01FVEhJTkdcXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHByZWZpeChzdHJlYW0sIDMpPT1cIjw8XCIrY2gpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcD1zdHJlYW0ucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1xcdy8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbj1zdHJlYW0uY3VycmVudCgpLnN1YnN0cigxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYobiYmc3RyZWFtLmVhdChjaCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuU09NRVRISU5HKHN0cmVhbSxzdGF0ZSxuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnBvcz1wO31cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbkNoYWluKHN0cmVhbSxzdGF0ZSxbY2hdLFwic3RyaW5nXCIpO31cbiAgICAgICAgICAgICAgICBpZihjaD09XCJxXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGM9bG9vayhzdHJlYW0sIC0yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCEoYyYmL1xcdy8udGVzdChjKSkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjPWxvb2soc3RyZWFtLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYz09XCJ4XCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM9bG9vayhzdHJlYW0sIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGM9PVwiKFwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhdFN1ZmZpeChzdHJlYW0sIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuQ2hhaW4oc3RyZWFtLHN0YXRlLFtcIilcIl0sUlhzdHlsZSxSWG1vZGlmaWVycyk7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGM9PVwiW1wiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhdFN1ZmZpeChzdHJlYW0sIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuQ2hhaW4oc3RyZWFtLHN0YXRlLFtcIl1cIl0sUlhzdHlsZSxSWG1vZGlmaWVycyk7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGM9PVwie1wiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhdFN1ZmZpeChzdHJlYW0sIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuQ2hhaW4oc3RyZWFtLHN0YXRlLFtcIn1cIl0sUlhzdHlsZSxSWG1vZGlmaWVycyk7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGM9PVwiPFwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhdFN1ZmZpeChzdHJlYW0sIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuQ2hhaW4oc3RyZWFtLHN0YXRlLFtcIj5cIl0sUlhzdHlsZSxSWG1vZGlmaWVycyk7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKC9bXFxeJ1wiIX5cXC9dLy50ZXN0KGMpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhdFN1ZmZpeChzdHJlYW0sIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuQ2hhaW4oc3RyZWFtLHN0YXRlLFtzdHJlYW0uZWF0KGMpXSxSWHN0eWxlLFJYbW9kaWZpZXJzKTt9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGM9PVwicVwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjPWxvb2soc3RyZWFtLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjPT1cIihcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlYXRTdWZmaXgoc3RyZWFtLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbkNoYWluKHN0cmVhbSxzdGF0ZSxbXCIpXCJdLFwic3RyaW5nXCIpO31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjPT1cIltcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlYXRTdWZmaXgoc3RyZWFtLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbkNoYWluKHN0cmVhbSxzdGF0ZSxbXCJdXCJdLFwic3RyaW5nXCIpO31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjPT1cIntcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlYXRTdWZmaXgoc3RyZWFtLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbkNoYWluKHN0cmVhbSxzdGF0ZSxbXCJ9XCJdLFwic3RyaW5nXCIpO31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjPT1cIjxcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlYXRTdWZmaXgoc3RyZWFtLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbkNoYWluKHN0cmVhbSxzdGF0ZSxbXCI+XCJdLFwic3RyaW5nXCIpO31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZigvW1xcXidcIiF+XFwvXS8udGVzdChjKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlYXRTdWZmaXgoc3RyZWFtLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbkNoYWluKHN0cmVhbSxzdGF0ZSxbc3RyZWFtLmVhdChjKV0sXCJzdHJpbmdcIik7fX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihjPT1cIndcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYz1sb29rKHN0cmVhbSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYz09XCIoXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWF0U3VmZml4KHN0cmVhbSwgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5DaGFpbihzdHJlYW0sc3RhdGUsW1wiKVwiXSxcImJyYWNrZXRcIik7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGM9PVwiW1wiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhdFN1ZmZpeChzdHJlYW0sIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuQ2hhaW4oc3RyZWFtLHN0YXRlLFtcIl1cIl0sXCJicmFja2V0XCIpO31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjPT1cIntcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlYXRTdWZmaXgoc3RyZWFtLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbkNoYWluKHN0cmVhbSxzdGF0ZSxbXCJ9XCJdLFwiYnJhY2tldFwiKTt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYz09XCI8XCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWF0U3VmZml4KHN0cmVhbSwgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5DaGFpbihzdHJlYW0sc3RhdGUsW1wiPlwiXSxcImJyYWNrZXRcIik7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKC9bXFxeJ1wiIX5cXC9dLy50ZXN0KGMpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhdFN1ZmZpeChzdHJlYW0sIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuQ2hhaW4oc3RyZWFtLHN0YXRlLFtzdHJlYW0uZWF0KGMpXSxcImJyYWNrZXRcIik7fX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihjPT1cInJcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYz1sb29rKHN0cmVhbSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYz09XCIoXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWF0U3VmZml4KHN0cmVhbSwgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5DaGFpbihzdHJlYW0sc3RhdGUsW1wiKVwiXSxSWHN0eWxlLFJYbW9kaWZpZXJzKTt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYz09XCJbXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWF0U3VmZml4KHN0cmVhbSwgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5DaGFpbihzdHJlYW0sc3RhdGUsW1wiXVwiXSxSWHN0eWxlLFJYbW9kaWZpZXJzKTt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYz09XCJ7XCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWF0U3VmZml4KHN0cmVhbSwgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5DaGFpbihzdHJlYW0sc3RhdGUsW1wifVwiXSxSWHN0eWxlLFJYbW9kaWZpZXJzKTt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYz09XCI8XCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWF0U3VmZml4KHN0cmVhbSwgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5DaGFpbihzdHJlYW0sc3RhdGUsW1wiPlwiXSxSWHN0eWxlLFJYbW9kaWZpZXJzKTt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoL1tcXF4nXCIhflxcL10vLnRlc3QoYykpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWF0U3VmZml4KHN0cmVhbSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5DaGFpbihzdHJlYW0sc3RhdGUsW3N0cmVhbS5lYXQoYyldLFJYc3R5bGUsUlhtb2RpZmllcnMpO319XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoL1tcXF4nXCIhflxcLyhcXFt7PF0vLnRlc3QoYykpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGM9PVwiKFwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhdFN1ZmZpeChzdHJlYW0sIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuQ2hhaW4oc3RyZWFtLHN0YXRlLFtcIilcIl0sXCJzdHJpbmdcIik7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGM9PVwiW1wiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhdFN1ZmZpeChzdHJlYW0sIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuQ2hhaW4oc3RyZWFtLHN0YXRlLFtcIl1cIl0sXCJzdHJpbmdcIik7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGM9PVwie1wiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhdFN1ZmZpeChzdHJlYW0sIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuQ2hhaW4oc3RyZWFtLHN0YXRlLFtcIn1cIl0sXCJzdHJpbmdcIik7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGM9PVwiPFwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhdFN1ZmZpeChzdHJlYW0sIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuQ2hhaW4oc3RyZWFtLHN0YXRlLFtcIj5cIl0sXCJzdHJpbmdcIik7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKC9bXFxeJ1wiIX5cXC9dLy50ZXN0KGMpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbkNoYWluKHN0cmVhbSxzdGF0ZSxbc3RyZWFtLmVhdChjKV0sXCJzdHJpbmdcIik7fX19fVxuICAgICAgICAgICAgICAgIGlmKGNoPT1cIm1cIil7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYz1sb29rKHN0cmVhbSwgLTIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIShjJiYvXFx3Ly50ZXN0KGMpKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM9c3RyZWFtLmVhdCgvWyhcXFt7PFxcXidcIiF+XFwvXS8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZigvW1xcXidcIiF+XFwvXS8udGVzdChjKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5DaGFpbihzdHJlYW0sc3RhdGUsW2NdLFJYc3R5bGUsUlhtb2RpZmllcnMpO31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjPT1cIihcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5DaGFpbihzdHJlYW0sc3RhdGUsW1wiKVwiXSxSWHN0eWxlLFJYbW9kaWZpZXJzKTt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYz09XCJbXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuQ2hhaW4oc3RyZWFtLHN0YXRlLFtcIl1cIl0sUlhzdHlsZSxSWG1vZGlmaWVycyk7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGM9PVwie1wiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbkNoYWluKHN0cmVhbSxzdGF0ZSxbXCJ9XCJdLFJYc3R5bGUsUlhtb2RpZmllcnMpO31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjPT1cIjxcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5DaGFpbihzdHJlYW0sc3RhdGUsW1wiPlwiXSxSWHN0eWxlLFJYbW9kaWZpZXJzKTt9fX19XG4gICAgICAgICAgICAgICAgaWYoY2g9PVwic1wiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjPS9bXFwvPlxcXX0pXFx3XS8udGVzdChsb29rKHN0cmVhbSwgLTIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFjKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYz1zdHJlYW0uZWF0KC9bKFxcW3s8XFxeJ1wiIX5cXC9dLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGM9PVwiW1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuQ2hhaW4oc3RyZWFtLHN0YXRlLFtcIl1cIixcIl1cIl0sUlhzdHlsZSxSWG1vZGlmaWVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYz09XCJ7XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5DaGFpbihzdHJlYW0sc3RhdGUsW1wifVwiLFwifVwiXSxSWHN0eWxlLFJYbW9kaWZpZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjPT1cIjxcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbkNoYWluKHN0cmVhbSxzdGF0ZSxbXCI+XCIsXCI+XCJdLFJYc3R5bGUsUlhtb2RpZmllcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGM9PVwiKFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuQ2hhaW4oc3RyZWFtLHN0YXRlLFtcIilcIixcIilcIl0sUlhzdHlsZSxSWG1vZGlmaWVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuQ2hhaW4oc3RyZWFtLHN0YXRlLFtjLGNdLFJYc3R5bGUsUlhtb2RpZmllcnMpO319fVxuICAgICAgICAgICAgICAgIGlmKGNoPT1cInlcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYz0vW1xcLz5cXF19KVxcd10vLnRlc3QobG9vayhzdHJlYW0sIC0yKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZighYyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM9c3RyZWFtLmVhdCgvWyhcXFt7PFxcXidcIiF+XFwvXS8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjPT1cIltcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbkNoYWluKHN0cmVhbSxzdGF0ZSxbXCJdXCIsXCJdXCJdLFJYc3R5bGUsUlhtb2RpZmllcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGM9PVwie1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuQ2hhaW4oc3RyZWFtLHN0YXRlLFtcIn1cIixcIn1cIl0sUlhzdHlsZSxSWG1vZGlmaWVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYz09XCI8XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5DaGFpbihzdHJlYW0sc3RhdGUsW1wiPlwiLFwiPlwiXSxSWHN0eWxlLFJYbW9kaWZpZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjPT1cIihcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbkNoYWluKHN0cmVhbSxzdGF0ZSxbXCIpXCIsXCIpXCJdLFJYc3R5bGUsUlhtb2RpZmllcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbkNoYWluKHN0cmVhbSxzdGF0ZSxbYyxjXSxSWHN0eWxlLFJYbW9kaWZpZXJzKTt9fX1cbiAgICAgICAgICAgICAgICBpZihjaD09XCJ0XCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGM9L1tcXC8+XFxdfSlcXHddLy50ZXN0KGxvb2soc3RyZWFtLCAtMikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjPXN0cmVhbS5lYXQoXCJyXCIpO2lmKGMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjPXN0cmVhbS5lYXQoL1soXFxbezxcXF4nXCIhflxcL10vKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYz09XCJbXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5DaGFpbihzdHJlYW0sc3RhdGUsW1wiXVwiLFwiXVwiXSxSWHN0eWxlLFJYbW9kaWZpZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjPT1cIntcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbkNoYWluKHN0cmVhbSxzdGF0ZSxbXCJ9XCIsXCJ9XCJdLFJYc3R5bGUsUlhtb2RpZmllcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGM9PVwiPFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuQ2hhaW4oc3RyZWFtLHN0YXRlLFtcIj5cIixcIj5cIl0sUlhzdHlsZSxSWG1vZGlmaWVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYz09XCIoXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5DaGFpbihzdHJlYW0sc3RhdGUsW1wiKVwiLFwiKVwiXSxSWHN0eWxlLFJYbW9kaWZpZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5DaGFpbihzdHJlYW0sc3RhdGUsW2MsY10sUlhzdHlsZSxSWG1vZGlmaWVycyk7fX19fVxuICAgICAgICAgICAgICAgIGlmKGNoPT1cImBcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5DaGFpbihzdHJlYW0sc3RhdGUsW2NoXSxcInZhcmlhYmxlLTJcIik7fVxuICAgICAgICAgICAgICAgIGlmKGNoPT1cIi9cIil7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZighL35cXHMqJC8udGVzdChwcmVmaXgoc3RyZWFtKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbkNoYWluKHN0cmVhbSxzdGF0ZSxbY2hdLFJYc3R5bGUsUlhtb2RpZmllcnMpO31cbiAgICAgICAgICAgICAgICBpZihjaD09XCIkXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHA9c3RyZWFtLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN0cmVhbS5lYXRXaGlsZSgvXFxkLyl8fHN0cmVhbS5lYXQoXCJ7XCIpJiZzdHJlYW0uZWF0V2hpbGUoL1xcZC8pJiZzdHJlYW0uZWF0KFwifVwiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidmFyaWFibGUtMlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucG9zPXA7fVxuICAgICAgICAgICAgICAgIGlmKC9bJEAlXS8udGVzdChjaCkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHA9c3RyZWFtLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN0cmVhbS5lYXQoXCJeXCIpJiZzdHJlYW0uZWF0KC9bQS1aXS8pfHwhL1tAJCUmXS8udGVzdChsb29rKHN0cmVhbSwgLTIpKSYmc3RyZWFtLmVhdCgvWz18XFxcXFxcLSM/QDs6JmB+XFxeIVxcW1xcXSonXCIkKy4sXFwvPD4oKV0vKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjPXN0cmVhbS5jdXJyZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKFBFUkxbY10pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidmFyaWFibGUtMlwiO31cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5wb3M9cDt9XG4gICAgICAgICAgICAgICAgaWYoL1skQCUmXS8udGVzdChjaCkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3RyZWFtLmVhdFdoaWxlKC9bXFx3JF0vKXx8c3RyZWFtLmVhdChcIntcIikmJnN0cmVhbS5lYXRXaGlsZSgvW1xcdyRdLykmJnN0cmVhbS5lYXQoXCJ9XCIpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGM9c3RyZWFtLmN1cnJlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoUEVSTFtjXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ2YXJpYWJsZS0yXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ2YXJpYWJsZVwiO319XG4gICAgICAgICAgICAgICAgaWYoY2g9PVwiI1wiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGxvb2soc3RyZWFtLCAtMikhPVwiJFwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJjb21tZW50XCI7fX1cbiAgICAgICAgICAgICAgICBpZigvWzorXFwtXFxeKiQmJUA9PD4hP3xcXC9+XFwuXS8udGVzdChjaCkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHA9c3RyZWFtLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvWzorXFwtXFxeKiQmJUA9PD4hP3xcXC9+XFwuXS8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoUEVSTFtzdHJlYW0uY3VycmVudCgpXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnBvcz1wO31cbiAgICAgICAgICAgICAgICBpZihjaD09XCJfXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3RyZWFtLnBvcz09MSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN1ZmZpeChzdHJlYW0sIDYpPT1cIl9FTkRfX1wiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5DaGFpbihzdHJlYW0sc3RhdGUsWydcXDAnXSxcImNvbW1lbnRcIik7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHN1ZmZpeChzdHJlYW0sIDcpPT1cIl9EQVRBX19cIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuQ2hhaW4oc3RyZWFtLHN0YXRlLFsnXFwwJ10sXCJ2YXJpYWJsZS0yXCIpO31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihzdWZmaXgoc3RyZWFtLCA3KT09XCJfQ19fXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbkNoYWluKHN0cmVhbSxzdGF0ZSxbJ1xcMCddLFwic3RyaW5nXCIpO319fVxuICAgICAgICAgICAgICAgIGlmKC9cXHcvLnRlc3QoY2gpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwPXN0cmVhbS5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihsb29rKHN0cmVhbSwgLTIpPT1cIntcIiYmKGxvb2soc3RyZWFtLCAwKT09XCJ9XCJ8fHN0cmVhbS5lYXRXaGlsZSgvXFx3LykmJmxvb2soc3RyZWFtLCAwKT09XCJ9XCIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnBvcz1wO31cbiAgICAgICAgICAgICAgICBpZigvW0EtWl0vLnRlc3QoY2gpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsPWxvb2soc3RyZWFtLCAtMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcD1zdHJlYW0ucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bQS1aX10vKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKC9bXFxkYS16XS8udGVzdChsb29rKHN0cmVhbSwgMCkpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnBvcz1wO31cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjPVBFUkxbc3RyZWFtLmN1cnJlbnQoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFjKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm1ldGFcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY1sxXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjPWNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGwhPVwiOlwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjPT0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoYz09MilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImRlZlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoYz09MylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImF0b21cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGM9PTQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoYz09NSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInZhcmlhYmxlLTJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJtZXRhXCI7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibWV0YVwiO319XG4gICAgICAgICAgICAgICAgaWYoL1thLXpBLVpfXS8udGVzdChjaCkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGw9bG9vayhzdHJlYW0sIC0yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvXFx3Lyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYz1QRVJMW3N0cmVhbS5jdXJyZW50KCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm1ldGFcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM9Y1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGwhPVwiOlwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYz09MSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoYz09MilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJkZWZcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihjPT0zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImF0b21cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihjPT00KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoYz09NSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ2YXJpYWJsZS0yXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJtZXRhXCI7fVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJtZXRhXCI7fVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO31cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5pemU6IHRva2VuUGVybCxcbiAgICAgICAgICAgICAgICAgICAgY2hhaW46IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICB0YWlsOiBudWxsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoc3RhdGUudG9rZW5pemUgfHwgdG9rZW5QZXJsKShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaW5lQ29tbWVudDogJyMnXG4gICAgICAgIH07XG59KTtcblxuQ29kZU1pcnJvci5yZWdpc3RlckhlbHBlcihcIndvcmRDaGFyc1wiLCBcInBlcmxcIiwgL1tcXHckXS8pO1xuXG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3gtcGVybFwiLCBcInBlcmxcIik7XG5cbi8vIGl0J3MgbGlrZSBcInBlZWtcIiwgYnV0IG5lZWQgZm9yIGxvb2stYWhlYWQgb3IgbG9vay1iZWhpbmQgaWYgaW5kZXggPCAwXG5mdW5jdGlvbiBsb29rKHN0cmVhbSwgYyl7XG4gIHJldHVybiBzdHJlYW0uc3RyaW5nLmNoYXJBdChzdHJlYW0ucG9zKyhjfHwwKSk7XG59XG5cbi8vIHJldHVybiBhIHBhcnQgb2YgcHJlZml4IG9mIGN1cnJlbnQgc3RyZWFtIGZyb20gY3VycmVudCBwb3NpdGlvblxuZnVuY3Rpb24gcHJlZml4KHN0cmVhbSwgYyl7XG4gIGlmKGMpe1xuICAgIHZhciB4PXN0cmVhbS5wb3MtYztcbiAgICByZXR1cm4gc3RyZWFtLnN0cmluZy5zdWJzdHIoKHg+PTA/eDowKSxjKTt9XG4gIGVsc2V7XG4gICAgcmV0dXJuIHN0cmVhbS5zdHJpbmcuc3Vic3RyKDAsc3RyZWFtLnBvcy0xKTtcbiAgfVxufVxuXG4vLyByZXR1cm4gYSBwYXJ0IG9mIHN1ZmZpeCBvZiBjdXJyZW50IHN0cmVhbSBmcm9tIGN1cnJlbnQgcG9zaXRpb25cbmZ1bmN0aW9uIHN1ZmZpeChzdHJlYW0sIGMpe1xuICB2YXIgeT1zdHJlYW0uc3RyaW5nLmxlbmd0aDtcbiAgdmFyIHg9eS1zdHJlYW0ucG9zKzE7XG4gIHJldHVybiBzdHJlYW0uc3RyaW5nLnN1YnN0cihzdHJlYW0ucG9zLChjJiZjPHk/Yzp4KSk7XG59XG5cbi8vIGVhdGluZyBhbmQgdm9taXRpbmcgYSBwYXJ0IG9mIHN0cmVhbSBmcm9tIGN1cnJlbnQgcG9zaXRpb25cbmZ1bmN0aW9uIGVhdFN1ZmZpeChzdHJlYW0sIGMpe1xuICB2YXIgeD1zdHJlYW0ucG9zK2M7XG4gIHZhciB5O1xuICBpZih4PD0wKVxuICAgIHN0cmVhbS5wb3M9MDtcbiAgZWxzZSBpZih4Pj0oeT1zdHJlYW0uc3RyaW5nLmxlbmd0aC0xKSlcbiAgICBzdHJlYW0ucG9zPXk7XG4gIGVsc2VcbiAgICBzdHJlYW0ucG9zPXg7XG59XG5cbn0pO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSwgcmVxdWlyZShcIi4uL2h0bWxtaXhlZC9odG1sbWl4ZWRcIiksIHJlcXVpcmUoXCIuLi9jbGlrZS9jbGlrZVwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiLCBcIi4uL2h0bWxtaXhlZC9odG1sbWl4ZWRcIiwgXCIuLi9jbGlrZS9jbGlrZVwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgZnVuY3Rpb24ga2V5d29yZHMoc3RyKSB7XG4gICAgdmFyIG9iaiA9IHt9LCB3b3JkcyA9IHN0ci5zcGxpdChcIiBcIik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7ICsraSkgb2JqW3dvcmRzW2ldXSA9IHRydWU7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIC8vIEhlbHBlciBmb3IgcGhwU3RyaW5nXG4gIGZ1bmN0aW9uIG1hdGNoU2VxdWVuY2UobGlzdCwgZW5kLCBlc2NhcGVzKSB7XG4gICAgaWYgKGxpc3QubGVuZ3RoID09IDApIHJldHVybiBwaHBTdHJpbmcoZW5kKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBwYXR0ZXJucyA9IGxpc3RbMF07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdHRlcm5zLmxlbmd0aDsgaSsrKSBpZiAoc3RyZWFtLm1hdGNoKHBhdHRlcm5zW2ldWzBdKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IG1hdGNoU2VxdWVuY2UobGlzdC5zbGljZSgxKSwgZW5kKTtcbiAgICAgICAgcmV0dXJuIHBhdHRlcm5zW2ldWzFdO1xuICAgICAgfVxuICAgICAgc3RhdGUudG9rZW5pemUgPSBwaHBTdHJpbmcoZW5kLCBlc2NhcGVzKTtcbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gcGhwU3RyaW5nKGNsb3NpbmcsIGVzY2FwZXMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkgeyByZXR1cm4gcGhwU3RyaW5nXyhzdHJlYW0sIHN0YXRlLCBjbG9zaW5nLCBlc2NhcGVzKTsgfTtcbiAgfVxuICBmdW5jdGlvbiBwaHBTdHJpbmdfKHN0cmVhbSwgc3RhdGUsIGNsb3NpbmcsIGVzY2FwZXMpIHtcbiAgICAvLyBcIkNvbXBsZXhcIiBzeW50YXhcbiAgICBpZiAoZXNjYXBlcyAhPT0gZmFsc2UgJiYgc3RyZWFtLm1hdGNoKFwiJHtcIiwgZmFsc2UpIHx8IHN0cmVhbS5tYXRjaChcInskXCIsIGZhbHNlKSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSBudWxsO1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfVxuXG4gICAgLy8gU2ltcGxlIHN5bnRheFxuICAgIGlmIChlc2NhcGVzICE9PSBmYWxzZSAmJiBzdHJlYW0ubWF0Y2goL15cXCRbYS16QS1aX11bYS16QS1aMC05X10qLykpIHtcbiAgICAgIC8vIEFmdGVyIHRoZSB2YXJpYWJsZSBuYW1lIHRoZXJlIG1heSBhcHBlYXIgYXJyYXkgb3Igb2JqZWN0IG9wZXJhdG9yLlxuICAgICAgaWYgKHN0cmVhbS5tYXRjaChcIltcIiwgZmFsc2UpKSB7XG4gICAgICAgIC8vIE1hdGNoIGFycmF5IG9wZXJhdG9yXG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gbWF0Y2hTZXF1ZW5jZShbXG4gICAgICAgICAgW1tcIltcIiwgbnVsbF1dLFxuICAgICAgICAgIFtbL1xcZFtcXHdcXC5dKi8sIFwibnVtYmVyXCJdLFxuICAgICAgICAgICBbL1xcJFthLXpBLVpfXVthLXpBLVowLTlfXSovLCBcInZhcmlhYmxlLTJcIl0sXG4gICAgICAgICAgIFsvW1xcd1xcJF0rLywgXCJ2YXJpYWJsZVwiXV0sXG4gICAgICAgICAgW1tcIl1cIiwgbnVsbF1dXG4gICAgICAgIF0sIGNsb3NpbmcsIGVzY2FwZXMpO1xuICAgICAgfVxuICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXi0+XFx3LywgZmFsc2UpKSB7XG4gICAgICAgIC8vIE1hdGNoIG9iamVjdCBvcGVyYXRvclxuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IG1hdGNoU2VxdWVuY2UoW1xuICAgICAgICAgIFtbXCItPlwiLCBudWxsXV0sXG4gICAgICAgICAgW1svW1xcd10rLywgXCJ2YXJpYWJsZVwiXV1cbiAgICAgICAgXSwgY2xvc2luZywgZXNjYXBlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJ2YXJpYWJsZS0yXCI7XG4gICAgfVxuXG4gICAgdmFyIGVzY2FwZWQgPSBmYWxzZTtcbiAgICAvLyBOb3JtYWwgc3RyaW5nXG4gICAgd2hpbGUgKCFzdHJlYW0uZW9sKCkgJiZcbiAgICAgICAgICAgKGVzY2FwZWQgfHwgZXNjYXBlcyA9PT0gZmFsc2UgfHxcbiAgICAgICAgICAgICghc3RyZWFtLm1hdGNoKFwieyRcIiwgZmFsc2UpICYmXG4gICAgICAgICAgICAgIXN0cmVhbS5tYXRjaCgvXihcXCRbYS16QS1aX11bYS16QS1aMC05X10qfFxcJFxceykvLCBmYWxzZSkpKSkge1xuICAgICAgaWYgKCFlc2NhcGVkICYmIHN0cmVhbS5tYXRjaChjbG9zaW5nKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IG51bGw7XG4gICAgICAgIHN0YXRlLnRva1N0YWNrLnBvcCgpOyBzdGF0ZS50b2tTdGFjay5wb3AoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBlc2NhcGVkID0gc3RyZWFtLm5leHQoKSA9PSBcIlxcXFxcIiAmJiAhZXNjYXBlZDtcbiAgICB9XG4gICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gIH1cblxuICB2YXIgcGhwS2V5d29yZHMgPSBcImFic3RyYWN0IGFuZCBhcnJheSBhcyBicmVhayBjYXNlIGNhdGNoIGNsYXNzIGNsb25lIGNvbnN0IGNvbnRpbnVlIGRlY2xhcmUgZGVmYXVsdCBcIiArXG4gICAgXCJkbyBlbHNlIGVsc2VpZiBlbmRkZWNsYXJlIGVuZGZvciBlbmRmb3JlYWNoIGVuZGlmIGVuZHN3aXRjaCBlbmR3aGlsZSBleHRlbmRzIGZpbmFsIFwiICtcbiAgICBcImZvciBmb3JlYWNoIGZ1bmN0aW9uIGdsb2JhbCBnb3RvIGlmIGltcGxlbWVudHMgaW50ZXJmYWNlIGluc3RhbmNlb2YgbmFtZXNwYWNlIFwiICtcbiAgICBcIm5ldyBvciBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc3RhdGljIHN3aXRjaCB0aHJvdyB0cmFpdCB0cnkgdXNlIHZhciB3aGlsZSB4b3IgXCIgK1xuICAgIFwiZGllIGVjaG8gZW1wdHkgZXhpdCBldmFsIGluY2x1ZGUgaW5jbHVkZV9vbmNlIGlzc2V0IGxpc3QgcmVxdWlyZSByZXF1aXJlX29uY2UgcmV0dXJuIFwiICtcbiAgICBcInByaW50IHVuc2V0IF9faGFsdF9jb21waWxlciBzZWxmIHN0YXRpYyBwYXJlbnQgeWllbGQgaW5zdGVhZG9mIGZpbmFsbHlcIjtcbiAgdmFyIHBocEF0b21zID0gXCJ0cnVlIGZhbHNlIG51bGwgVFJVRSBGQUxTRSBOVUxMIF9fQ0xBU1NfXyBfX0RJUl9fIF9fRklMRV9fIF9fTElORV9fIF9fTUVUSE9EX18gX19GVU5DVElPTl9fIF9fTkFNRVNQQUNFX18gX19UUkFJVF9fXCI7XG4gIHZhciBwaHBCdWlsdGluID0gXCJmdW5jX251bV9hcmdzIGZ1bmNfZ2V0X2FyZyBmdW5jX2dldF9hcmdzIHN0cmxlbiBzdHJjbXAgc3RybmNtcCBzdHJjYXNlY21wIHN0cm5jYXNlY21wIGVhY2ggZXJyb3JfcmVwb3J0aW5nIGRlZmluZSBkZWZpbmVkIHRyaWdnZXJfZXJyb3IgdXNlcl9lcnJvciBzZXRfZXJyb3JfaGFuZGxlciByZXN0b3JlX2Vycm9yX2hhbmRsZXIgZ2V0X2RlY2xhcmVkX2NsYXNzZXMgZ2V0X2xvYWRlZF9leHRlbnNpb25zIGV4dGVuc2lvbl9sb2FkZWQgZ2V0X2V4dGVuc2lvbl9mdW5jcyBkZWJ1Z19iYWNrdHJhY2UgY29uc3RhbnQgYmluMmhleCBoZXgyYmluIHNsZWVwIHVzbGVlcCB0aW1lIG1rdGltZSBnbW1rdGltZSBzdHJmdGltZSBnbXN0cmZ0aW1lIHN0cnRvdGltZSBkYXRlIGdtZGF0ZSBnZXRkYXRlIGxvY2FsdGltZSBjaGVja2RhdGUgZmx1c2ggd29yZHdyYXAgaHRtbHNwZWNpYWxjaGFycyBodG1sZW50aXRpZXMgaHRtbF9lbnRpdHlfZGVjb2RlIG1kNSBtZDVfZmlsZSBjcmMzMiBnZXRpbWFnZXNpemUgaW1hZ2VfdHlwZV90b19taW1lX3R5cGUgcGhwaW5mbyBwaHB2ZXJzaW9uIHBocGNyZWRpdHMgc3RybmF0Y21wIHN0cm5hdGNhc2VjbXAgc3Vic3RyX2NvdW50IHN0cnNwbiBzdHJjc3BuIHN0cnRvayBzdHJ0b3VwcGVyIHN0cnRvbG93ZXIgc3RycG9zIHN0cnJwb3Mgc3RycmV2IGhlYnJldiBoZWJyZXZjIG5sMmJyIGJhc2VuYW1lIGRpcm5hbWUgcGF0aGluZm8gc3RyaXBzbGFzaGVzIHN0cmlwY3NsYXNoZXMgc3Ryc3RyIHN0cmlzdHIgc3RycmNociBzdHJfc2h1ZmZsZSBzdHJfd29yZF9jb3VudCBzdHJjb2xsIHN1YnN0ciBzdWJzdHJfcmVwbGFjZSBxdW90ZW1ldGEgdWNmaXJzdCB1Y3dvcmRzIHN0cnRyIGFkZHNsYXNoZXMgYWRkY3NsYXNoZXMgcnRyaW0gc3RyX3JlcGxhY2Ugc3RyX3JlcGVhdCBjb3VudF9jaGFycyBjaHVua19zcGxpdCB0cmltIGx0cmltIHN0cmlwX3RhZ3Mgc2ltaWxhcl90ZXh0IGV4cGxvZGUgaW1wbG9kZSBzZXRsb2NhbGUgbG9jYWxlY29udiBwYXJzZV9zdHIgc3RyX3BhZCBjaG9wIHN0cmNociBzcHJpbnRmIHByaW50ZiB2cHJpbnRmIHZzcHJpbnRmIHNzY2FuZiBmc2NhbmYgcGFyc2VfdXJsIHVybGVuY29kZSB1cmxkZWNvZGUgcmF3dXJsZW5jb2RlIHJhd3VybGRlY29kZSByZWFkbGluayBsaW5raW5mbyBsaW5rIHVubGluayBleGVjIHN5c3RlbSBlc2NhcGVzaGVsbGNtZCBlc2NhcGVzaGVsbGFyZyBwYXNzdGhydSBzaGVsbF9leGVjIHByb2Nfb3BlbiBwcm9jX2Nsb3NlIHJhbmQgc3JhbmQgZ2V0cmFuZG1heCBtdF9yYW5kIG10X3NyYW5kIG10X2dldHJhbmRtYXggYmFzZTY0X2RlY29kZSBiYXNlNjRfZW5jb2RlIGFicyBjZWlsIGZsb29yIHJvdW5kIGlzX2Zpbml0ZSBpc19uYW4gaXNfaW5maW5pdGUgYmluZGVjIGhleGRlYyBvY3RkZWMgZGVjYmluIGRlY29jdCBkZWNoZXggYmFzZV9jb252ZXJ0IG51bWJlcl9mb3JtYXQgZm1vZCBpcDJsb25nIGxvbmcyaXAgZ2V0ZW52IHB1dGVudiBnZXRvcHQgbWljcm90aW1lIGdldHRpbWVvZmRheSBnZXRydXNhZ2UgdW5pcWlkIHF1b3RlZF9wcmludGFibGVfZGVjb2RlIHNldF90aW1lX2xpbWl0IGdldF9jZmdfdmFyIG1hZ2ljX3F1b3Rlc19ydW50aW1lIHNldF9tYWdpY19xdW90ZXNfcnVudGltZSBnZXRfbWFnaWNfcXVvdGVzX2dwYyBnZXRfbWFnaWNfcXVvdGVzX3J1bnRpbWUgaW1wb3J0X3JlcXVlc3RfdmFyaWFibGVzIGVycm9yX2xvZyBzZXJpYWxpemUgdW5zZXJpYWxpemUgbWVtb3J5X2dldF91c2FnZSBtZW1vcnlfZ2V0X3BlYWtfdXNhZ2UgdmFyX2R1bXAgdmFyX2V4cG9ydCBkZWJ1Z196dmFsX2R1bXAgcHJpbnRfciBoaWdobGlnaHRfZmlsZSBzaG93X3NvdXJjZSBoaWdobGlnaHRfc3RyaW5nIGluaV9nZXQgaW5pX2dldF9hbGwgaW5pX3NldCBpbmlfYWx0ZXIgaW5pX3Jlc3RvcmUgZ2V0X2luY2x1ZGVfcGF0aCBzZXRfaW5jbHVkZV9wYXRoIHJlc3RvcmVfaW5jbHVkZV9wYXRoIHNldGNvb2tpZSBoZWFkZXIgaGVhZGVyc19zZW50IGNvbm5lY3Rpb25fYWJvcnRlZCBjb25uZWN0aW9uX3N0YXR1cyBpZ25vcmVfdXNlcl9hYm9ydCBwYXJzZV9pbmlfZmlsZSBpc191cGxvYWRlZF9maWxlIG1vdmVfdXBsb2FkZWRfZmlsZSBpbnR2YWwgZmxvYXR2YWwgZG91YmxldmFsIHN0cnZhbCBnZXR0eXBlIHNldHR5cGUgaXNfbnVsbCBpc19yZXNvdXJjZSBpc19ib29sIGlzX2xvbmcgaXNfZmxvYXQgaXNfaW50IGlzX2ludGVnZXIgaXNfZG91YmxlIGlzX3JlYWwgaXNfbnVtZXJpYyBpc19zdHJpbmcgaXNfYXJyYXkgaXNfb2JqZWN0IGlzX3NjYWxhciBlcmVnIGVyZWdfcmVwbGFjZSBlcmVnaSBlcmVnaV9yZXBsYWNlIHNwbGl0IHNwbGl0aSBqb2luIHNxbF9yZWdjYXNlIGRsIHBjbG9zZSBwb3BlbiByZWFkZmlsZSByZXdpbmQgcm1kaXIgdW1hc2sgZmNsb3NlIGZlb2YgZmdldGMgZmdldHMgZmdldHNzIGZyZWFkIGZvcGVuIGZwYXNzdGhydSBmdHJ1bmNhdGUgZnN0YXQgZnNlZWsgZnRlbGwgZmZsdXNoIGZ3cml0ZSBmcHV0cyBta2RpciByZW5hbWUgY29weSB0ZW1wbmFtIHRtcGZpbGUgZmlsZSBmaWxlX2dldF9jb250ZW50cyBmaWxlX3B1dF9jb250ZW50cyBzdHJlYW1fc2VsZWN0IHN0cmVhbV9jb250ZXh0X2NyZWF0ZSBzdHJlYW1fY29udGV4dF9zZXRfcGFyYW1zIHN0cmVhbV9jb250ZXh0X3NldF9vcHRpb24gc3RyZWFtX2NvbnRleHRfZ2V0X29wdGlvbnMgc3RyZWFtX2ZpbHRlcl9wcmVwZW5kIHN0cmVhbV9maWx0ZXJfYXBwZW5kIGZnZXRjc3YgZmxvY2sgZ2V0X21ldGFfdGFncyBzdHJlYW1fc2V0X3dyaXRlX2J1ZmZlciBzZXRfZmlsZV9idWZmZXIgc2V0X3NvY2tldF9ibG9ja2luZyBzdHJlYW1fc2V0X2Jsb2NraW5nIHNvY2tldF9zZXRfYmxvY2tpbmcgc3RyZWFtX2dldF9tZXRhX2RhdGEgc3RyZWFtX3JlZ2lzdGVyX3dyYXBwZXIgc3RyZWFtX3dyYXBwZXJfcmVnaXN0ZXIgc3RyZWFtX3NldF90aW1lb3V0IHNvY2tldF9zZXRfdGltZW91dCBzb2NrZXRfZ2V0X3N0YXR1cyByZWFscGF0aCBmbm1hdGNoIGZzb2Nrb3BlbiBwZnNvY2tvcGVuIHBhY2sgdW5wYWNrIGdldF9icm93c2VyIGNyeXB0IG9wZW5kaXIgY2xvc2VkaXIgY2hkaXIgZ2V0Y3dkIHJld2luZGRpciByZWFkZGlyIGRpciBnbG9iIGZpbGVhdGltZSBmaWxlY3RpbWUgZmlsZWdyb3VwIGZpbGVpbm9kZSBmaWxlbXRpbWUgZmlsZW93bmVyIGZpbGVwZXJtcyBmaWxlc2l6ZSBmaWxldHlwZSBmaWxlX2V4aXN0cyBpc193cml0YWJsZSBpc193cml0ZWFibGUgaXNfcmVhZGFibGUgaXNfZXhlY3V0YWJsZSBpc19maWxlIGlzX2RpciBpc19saW5rIHN0YXQgbHN0YXQgY2hvd24gdG91Y2ggY2xlYXJzdGF0Y2FjaGUgbWFpbCBvYl9zdGFydCBvYl9mbHVzaCBvYl9jbGVhbiBvYl9lbmRfZmx1c2ggb2JfZW5kX2NsZWFuIG9iX2dldF9mbHVzaCBvYl9nZXRfY2xlYW4gb2JfZ2V0X2xlbmd0aCBvYl9nZXRfbGV2ZWwgb2JfZ2V0X3N0YXR1cyBvYl9nZXRfY29udGVudHMgb2JfaW1wbGljaXRfZmx1c2ggb2JfbGlzdF9oYW5kbGVycyBrc29ydCBrcnNvcnQgbmF0c29ydCBuYXRjYXNlc29ydCBhc29ydCBhcnNvcnQgc29ydCByc29ydCB1c29ydCB1YXNvcnQgdWtzb3J0IHNodWZmbGUgYXJyYXlfd2FsayBjb3VudCBlbmQgcHJldiBuZXh0IHJlc2V0IGN1cnJlbnQga2V5IG1pbiBtYXggaW5fYXJyYXkgYXJyYXlfc2VhcmNoIGV4dHJhY3QgY29tcGFjdCBhcnJheV9maWxsIHJhbmdlIGFycmF5X211bHRpc29ydCBhcnJheV9wdXNoIGFycmF5X3BvcCBhcnJheV9zaGlmdCBhcnJheV91bnNoaWZ0IGFycmF5X3NwbGljZSBhcnJheV9zbGljZSBhcnJheV9tZXJnZSBhcnJheV9tZXJnZV9yZWN1cnNpdmUgYXJyYXlfa2V5cyBhcnJheV92YWx1ZXMgYXJyYXlfY291bnRfdmFsdWVzIGFycmF5X3JldmVyc2UgYXJyYXlfcmVkdWNlIGFycmF5X3BhZCBhcnJheV9mbGlwIGFycmF5X2NoYW5nZV9rZXlfY2FzZSBhcnJheV9yYW5kIGFycmF5X3VuaXF1ZSBhcnJheV9pbnRlcnNlY3QgYXJyYXlfaW50ZXJzZWN0X2Fzc29jIGFycmF5X2RpZmYgYXJyYXlfZGlmZl9hc3NvYyBhcnJheV9zdW0gYXJyYXlfZmlsdGVyIGFycmF5X21hcCBhcnJheV9jaHVuayBhcnJheV9rZXlfZXhpc3RzIGFycmF5X2ludGVyc2VjdF9rZXkgYXJyYXlfY29tYmluZSBhcnJheV9jb2x1bW4gcG9zIHNpemVvZiBrZXlfZXhpc3RzIGFzc2VydCBhc3NlcnRfb3B0aW9ucyB2ZXJzaW9uX2NvbXBhcmUgZnRvayBzdHJfcm90MTMgYWdncmVnYXRlIHNlc3Npb25fbmFtZSBzZXNzaW9uX21vZHVsZV9uYW1lIHNlc3Npb25fc2F2ZV9wYXRoIHNlc3Npb25faWQgc2Vzc2lvbl9yZWdlbmVyYXRlX2lkIHNlc3Npb25fZGVjb2RlIHNlc3Npb25fcmVnaXN0ZXIgc2Vzc2lvbl91bnJlZ2lzdGVyIHNlc3Npb25faXNfcmVnaXN0ZXJlZCBzZXNzaW9uX2VuY29kZSBzZXNzaW9uX3N0YXJ0IHNlc3Npb25fZGVzdHJveSBzZXNzaW9uX3Vuc2V0IHNlc3Npb25fc2V0X3NhdmVfaGFuZGxlciBzZXNzaW9uX2NhY2hlX2xpbWl0ZXIgc2Vzc2lvbl9jYWNoZV9leHBpcmUgc2Vzc2lvbl9zZXRfY29va2llX3BhcmFtcyBzZXNzaW9uX2dldF9jb29raWVfcGFyYW1zIHNlc3Npb25fd3JpdGVfY2xvc2UgcHJlZ19tYXRjaCBwcmVnX21hdGNoX2FsbCBwcmVnX3JlcGxhY2UgcHJlZ19yZXBsYWNlX2NhbGxiYWNrIHByZWdfc3BsaXQgcHJlZ19xdW90ZSBwcmVnX2dyZXAgb3ZlcmxvYWQgY3R5cGVfYWxudW0gY3R5cGVfYWxwaGEgY3R5cGVfY250cmwgY3R5cGVfZGlnaXQgY3R5cGVfbG93ZXIgY3R5cGVfZ3JhcGggY3R5cGVfcHJpbnQgY3R5cGVfcHVuY3QgY3R5cGVfc3BhY2UgY3R5cGVfdXBwZXIgY3R5cGVfeGRpZ2l0IHZpcnR1YWwgYXBhY2hlX3JlcXVlc3RfaGVhZGVycyBhcGFjaGVfbm90ZSBhcGFjaGVfbG9va3VwX3VyaSBhcGFjaGVfY2hpbGRfdGVybWluYXRlIGFwYWNoZV9zZXRlbnYgYXBhY2hlX3Jlc3BvbnNlX2hlYWRlcnMgYXBhY2hlX2dldF92ZXJzaW9uIGdldGFsbGhlYWRlcnMgbXlzcWxfY29ubmVjdCBteXNxbF9wY29ubmVjdCBteXNxbF9jbG9zZSBteXNxbF9zZWxlY3RfZGIgbXlzcWxfY3JlYXRlX2RiIG15c3FsX2Ryb3BfZGIgbXlzcWxfcXVlcnkgbXlzcWxfdW5idWZmZXJlZF9xdWVyeSBteXNxbF9kYl9xdWVyeSBteXNxbF9saXN0X2RicyBteXNxbF9saXN0X3RhYmxlcyBteXNxbF9saXN0X2ZpZWxkcyBteXNxbF9saXN0X3Byb2Nlc3NlcyBteXNxbF9lcnJvciBteXNxbF9lcnJubyBteXNxbF9hZmZlY3RlZF9yb3dzIG15c3FsX2luc2VydF9pZCBteXNxbF9yZXN1bHQgbXlzcWxfbnVtX3Jvd3MgbXlzcWxfbnVtX2ZpZWxkcyBteXNxbF9mZXRjaF9yb3cgbXlzcWxfZmV0Y2hfYXJyYXkgbXlzcWxfZmV0Y2hfYXNzb2MgbXlzcWxfZmV0Y2hfb2JqZWN0IG15c3FsX2RhdGFfc2VlayBteXNxbF9mZXRjaF9sZW5ndGhzIG15c3FsX2ZldGNoX2ZpZWxkIG15c3FsX2ZpZWxkX3NlZWsgbXlzcWxfZnJlZV9yZXN1bHQgbXlzcWxfZmllbGRfbmFtZSBteXNxbF9maWVsZF90YWJsZSBteXNxbF9maWVsZF9sZW4gbXlzcWxfZmllbGRfdHlwZSBteXNxbF9maWVsZF9mbGFncyBteXNxbF9lc2NhcGVfc3RyaW5nIG15c3FsX3JlYWxfZXNjYXBlX3N0cmluZyBteXNxbF9zdGF0IG15c3FsX3RocmVhZF9pZCBteXNxbF9jbGllbnRfZW5jb2RpbmcgbXlzcWxfZ2V0X2NsaWVudF9pbmZvIG15c3FsX2dldF9ob3N0X2luZm8gbXlzcWxfZ2V0X3Byb3RvX2luZm8gbXlzcWxfZ2V0X3NlcnZlcl9pbmZvIG15c3FsX2luZm8gbXlzcWwgbXlzcWxfZmllbGRuYW1lIG15c3FsX2ZpZWxkdGFibGUgbXlzcWxfZmllbGRsZW4gbXlzcWxfZmllbGR0eXBlIG15c3FsX2ZpZWxkZmxhZ3MgbXlzcWxfc2VsZWN0ZGIgbXlzcWxfY3JlYXRlZGIgbXlzcWxfZHJvcGRiIG15c3FsX2ZyZWVyZXN1bHQgbXlzcWxfbnVtZmllbGRzIG15c3FsX251bXJvd3MgbXlzcWxfbGlzdGRicyBteXNxbF9saXN0dGFibGVzIG15c3FsX2xpc3RmaWVsZHMgbXlzcWxfZGJfbmFtZSBteXNxbF9kYm5hbWUgbXlzcWxfdGFibGVuYW1lIG15c3FsX3RhYmxlX25hbWUgcGdfY29ubmVjdCBwZ19wY29ubmVjdCBwZ19jbG9zZSBwZ19jb25uZWN0aW9uX3N0YXR1cyBwZ19jb25uZWN0aW9uX2J1c3kgcGdfY29ubmVjdGlvbl9yZXNldCBwZ19ob3N0IHBnX2RibmFtZSBwZ19wb3J0IHBnX3R0eSBwZ19vcHRpb25zIHBnX3BpbmcgcGdfcXVlcnkgcGdfc2VuZF9xdWVyeSBwZ19jYW5jZWxfcXVlcnkgcGdfZmV0Y2hfcmVzdWx0IHBnX2ZldGNoX3JvdyBwZ19mZXRjaF9hc3NvYyBwZ19mZXRjaF9hcnJheSBwZ19mZXRjaF9vYmplY3QgcGdfZmV0Y2hfYWxsIHBnX2FmZmVjdGVkX3Jvd3MgcGdfZ2V0X3Jlc3VsdCBwZ19yZXN1bHRfc2VlayBwZ19yZXN1bHRfc3RhdHVzIHBnX2ZyZWVfcmVzdWx0IHBnX2xhc3Rfb2lkIHBnX251bV9yb3dzIHBnX251bV9maWVsZHMgcGdfZmllbGRfbmFtZSBwZ19maWVsZF9udW0gcGdfZmllbGRfc2l6ZSBwZ19maWVsZF90eXBlIHBnX2ZpZWxkX3BydGxlbiBwZ19maWVsZF9pc19udWxsIHBnX2dldF9ub3RpZnkgcGdfZ2V0X3BpZCBwZ19yZXN1bHRfZXJyb3IgcGdfbGFzdF9lcnJvciBwZ19sYXN0X25vdGljZSBwZ19wdXRfbGluZSBwZ19lbmRfY29weSBwZ19jb3B5X3RvIHBnX2NvcHlfZnJvbSBwZ190cmFjZSBwZ191bnRyYWNlIHBnX2xvX2NyZWF0ZSBwZ19sb191bmxpbmsgcGdfbG9fb3BlbiBwZ19sb19jbG9zZSBwZ19sb19yZWFkIHBnX2xvX3dyaXRlIHBnX2xvX3JlYWRfYWxsIHBnX2xvX2ltcG9ydCBwZ19sb19leHBvcnQgcGdfbG9fc2VlayBwZ19sb190ZWxsIHBnX2VzY2FwZV9zdHJpbmcgcGdfZXNjYXBlX2J5dGVhIHBnX3VuZXNjYXBlX2J5dGVhIHBnX2NsaWVudF9lbmNvZGluZyBwZ19zZXRfY2xpZW50X2VuY29kaW5nIHBnX21ldGFfZGF0YSBwZ19jb252ZXJ0IHBnX2luc2VydCBwZ191cGRhdGUgcGdfZGVsZXRlIHBnX3NlbGVjdCBwZ19leGVjIHBnX2dldGxhc3RvaWQgcGdfY21kdHVwbGVzIHBnX2Vycm9ybWVzc2FnZSBwZ19udW1yb3dzIHBnX251bWZpZWxkcyBwZ19maWVsZG5hbWUgcGdfZmllbGRzaXplIHBnX2ZpZWxkdHlwZSBwZ19maWVsZG51bSBwZ19maWVsZHBydGxlbiBwZ19maWVsZGlzbnVsbCBwZ19mcmVlcmVzdWx0IHBnX3Jlc3VsdCBwZ19sb3JlYWRhbGwgcGdfbG9jcmVhdGUgcGdfbG91bmxpbmsgcGdfbG9vcGVuIHBnX2xvY2xvc2UgcGdfbG9yZWFkIHBnX2xvd3JpdGUgcGdfbG9pbXBvcnQgcGdfbG9leHBvcnQgaHR0cF9yZXNwb25zZV9jb2RlIGdldF9kZWNsYXJlZF90cmFpdHMgZ2V0aW1hZ2VzaXplZnJvbXN0cmluZyBzb2NrZXRfaW1wb3J0X3N0cmVhbSBzdHJlYW1fc2V0X2NodW5rX3NpemUgdHJhaXRfZXhpc3RzIGhlYWRlcl9yZWdpc3Rlcl9jYWxsYmFjayBjbGFzc191c2VzIHNlc3Npb25fc3RhdHVzIHNlc3Npb25fcmVnaXN0ZXJfc2h1dGRvd24gZWNobyBwcmludCBnbG9iYWwgc3RhdGljIGV4aXQgYXJyYXkgZW1wdHkgZXZhbCBpc3NldCB1bnNldCBkaWUgaW5jbHVkZSByZXF1aXJlIGluY2x1ZGVfb25jZSByZXF1aXJlX29uY2UganNvbl9kZWNvZGUganNvbl9lbmNvZGUganNvbl9sYXN0X2Vycm9yIGpzb25fbGFzdF9lcnJvcl9tc2cgY3VybF9jbG9zZSBjdXJsX2NvcHlfaGFuZGxlIGN1cmxfZXJybm8gY3VybF9lcnJvciBjdXJsX2VzY2FwZSBjdXJsX2V4ZWMgY3VybF9maWxlX2NyZWF0ZSBjdXJsX2dldGluZm8gY3VybF9pbml0IGN1cmxfbXVsdGlfYWRkX2hhbmRsZSBjdXJsX211bHRpX2Nsb3NlIGN1cmxfbXVsdGlfZXhlYyBjdXJsX211bHRpX2dldGNvbnRlbnQgY3VybF9tdWx0aV9pbmZvX3JlYWQgY3VybF9tdWx0aV9pbml0IGN1cmxfbXVsdGlfcmVtb3ZlX2hhbmRsZSBjdXJsX211bHRpX3NlbGVjdCBjdXJsX211bHRpX3NldG9wdCBjdXJsX211bHRpX3N0cmVycm9yIGN1cmxfcGF1c2UgY3VybF9yZXNldCBjdXJsX3NldG9wdF9hcnJheSBjdXJsX3NldG9wdCBjdXJsX3NoYXJlX2Nsb3NlIGN1cmxfc2hhcmVfaW5pdCBjdXJsX3NoYXJlX3NldG9wdCBjdXJsX3N0cmVycm9yIGN1cmxfdW5lc2NhcGUgY3VybF92ZXJzaW9uIG15c3FsaV9hZmZlY3RlZF9yb3dzIG15c3FsaV9hdXRvY29tbWl0IG15c3FsaV9jaGFuZ2VfdXNlciBteXNxbGlfY2hhcmFjdGVyX3NldF9uYW1lIG15c3FsaV9jbG9zZSBteXNxbGlfY29tbWl0IG15c3FsaV9jb25uZWN0X2Vycm5vIG15c3FsaV9jb25uZWN0X2Vycm9yIG15c3FsaV9jb25uZWN0IG15c3FsaV9kYXRhX3NlZWsgbXlzcWxpX2RlYnVnIG15c3FsaV9kdW1wX2RlYnVnX2luZm8gbXlzcWxpX2Vycm5vIG15c3FsaV9lcnJvcl9saXN0IG15c3FsaV9lcnJvciBteXNxbGlfZmV0Y2hfYWxsIG15c3FsaV9mZXRjaF9hcnJheSBteXNxbGlfZmV0Y2hfYXNzb2MgbXlzcWxpX2ZldGNoX2ZpZWxkX2RpcmVjdCBteXNxbGlfZmV0Y2hfZmllbGQgbXlzcWxpX2ZldGNoX2ZpZWxkcyBteXNxbGlfZmV0Y2hfbGVuZ3RocyBteXNxbGlfZmV0Y2hfb2JqZWN0IG15c3FsaV9mZXRjaF9yb3cgbXlzcWxpX2ZpZWxkX2NvdW50IG15c3FsaV9maWVsZF9zZWVrIG15c3FsaV9maWVsZF90ZWxsIG15c3FsaV9mcmVlX3Jlc3VsdCBteXNxbGlfZ2V0X2NoYXJzZXQgbXlzcWxpX2dldF9jbGllbnRfaW5mbyBteXNxbGlfZ2V0X2NsaWVudF9zdGF0cyBteXNxbGlfZ2V0X2NsaWVudF92ZXJzaW9uIG15c3FsaV9nZXRfY29ubmVjdGlvbl9zdGF0cyBteXNxbGlfZ2V0X2hvc3RfaW5mbyBteXNxbGlfZ2V0X3Byb3RvX2luZm8gbXlzcWxpX2dldF9zZXJ2ZXJfaW5mbyBteXNxbGlfZ2V0X3NlcnZlcl92ZXJzaW9uIG15c3FsaV9pbmZvIG15c3FsaV9pbml0IG15c3FsaV9pbnNlcnRfaWQgbXlzcWxpX2tpbGwgbXlzcWxpX21vcmVfcmVzdWx0cyBteXNxbGlfbXVsdGlfcXVlcnkgbXlzcWxpX25leHRfcmVzdWx0IG15c3FsaV9udW1fZmllbGRzIG15c3FsaV9udW1fcm93cyBteXNxbGlfb3B0aW9ucyBteXNxbGlfcGluZyBteXNxbGlfcHJlcGFyZSBteXNxbGlfcXVlcnkgbXlzcWxpX3JlYWxfY29ubmVjdCBteXNxbGlfcmVhbF9lc2NhcGVfc3RyaW5nIG15c3FsaV9yZWFsX3F1ZXJ5IG15c3FsaV9yZWFwX2FzeW5jX3F1ZXJ5IG15c3FsaV9yZWZyZXNoIG15c3FsaV9yb2xsYmFjayBteXNxbGlfc2VsZWN0X2RiIG15c3FsaV9zZXRfY2hhcnNldCBteXNxbGlfc2V0X2xvY2FsX2luZmlsZV9kZWZhdWx0IG15c3FsaV9zZXRfbG9jYWxfaW5maWxlX2hhbmRsZXIgbXlzcWxpX3NxbHN0YXRlIG15c3FsaV9zc2xfc2V0IG15c3FsaV9zdGF0IG15c3FsaV9zdG10X2luaXQgbXlzcWxpX3N0b3JlX3Jlc3VsdCBteXNxbGlfdGhyZWFkX2lkIG15c3FsaV90aHJlYWRfc2FmZSBteXNxbGlfdXNlX3Jlc3VsdCBteXNxbGlfd2FybmluZ19jb3VudFwiO1xuICBDb2RlTWlycm9yLnJlZ2lzdGVySGVscGVyKFwiaGludFdvcmRzXCIsIFwicGhwXCIsIFtwaHBLZXl3b3JkcywgcGhwQXRvbXMsIHBocEJ1aWx0aW5dLmpvaW4oXCIgXCIpLnNwbGl0KFwiIFwiKSk7XG4gIENvZGVNaXJyb3IucmVnaXN0ZXJIZWxwZXIoXCJ3b3JkQ2hhcnNcIiwgXCJwaHBcIiwgL1tcXHckXS8pO1xuXG4gIHZhciBwaHBDb25maWcgPSB7XG4gICAgbmFtZTogXCJjbGlrZVwiLFxuICAgIGhlbHBlclR5cGU6IFwicGhwXCIsXG4gICAga2V5d29yZHM6IGtleXdvcmRzKHBocEtleXdvcmRzKSxcbiAgICBibG9ja0tleXdvcmRzOiBrZXl3b3JkcyhcImNhdGNoIGRvIGVsc2UgZWxzZWlmIGZvciBmb3JlYWNoIGlmIHN3aXRjaCB0cnkgd2hpbGUgZmluYWxseVwiKSxcbiAgICBkZWZLZXl3b3Jkczoga2V5d29yZHMoXCJjbGFzcyBmdW5jdGlvbiBpbnRlcmZhY2UgbmFtZXNwYWNlIHRyYWl0XCIpLFxuICAgIGF0b21zOiBrZXl3b3JkcyhwaHBBdG9tcyksXG4gICAgYnVpbHRpbjoga2V5d29yZHMocGhwQnVpbHRpbiksXG4gICAgbXVsdGlMaW5lU3RyaW5nczogdHJ1ZSxcbiAgICBob29rczoge1xuICAgICAgXCIkXCI6IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXCRfXS8pO1xuICAgICAgICByZXR1cm4gXCJ2YXJpYWJsZS0yXCI7XG4gICAgICB9LFxuICAgICAgXCI8XCI6IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgdmFyIGJlZm9yZTtcbiAgICAgICAgaWYgKGJlZm9yZSA9IHN0cmVhbS5tYXRjaCgvXjw8XFxzKi8pKSB7XG4gICAgICAgICAgdmFyIHF1b3RlZCA9IHN0cmVhbS5lYXQoL1snXCJdLyk7XG4gICAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwuXS8pO1xuICAgICAgICAgIHZhciBkZWxpbSA9IHN0cmVhbS5jdXJyZW50KCkuc2xpY2UoYmVmb3JlWzBdLmxlbmd0aCArIChxdW90ZWQgPyAyIDogMSkpO1xuICAgICAgICAgIGlmIChxdW90ZWQpIHN0cmVhbS5lYXQocXVvdGVkKTtcbiAgICAgICAgICBpZiAoZGVsaW0pIHtcbiAgICAgICAgICAgIChzdGF0ZS50b2tTdGFjayB8fCAoc3RhdGUudG9rU3RhY2sgPSBbXSkpLnB1c2goZGVsaW0sIDApO1xuICAgICAgICAgICAgc3RhdGUudG9rZW5pemUgPSBwaHBTdHJpbmcoZGVsaW0sIHF1b3RlZCAhPSBcIidcIik7XG4gICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIFwiI1wiOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgd2hpbGUgKCFzdHJlYW0uZW9sKCkgJiYgIXN0cmVhbS5tYXRjaChcIj8+XCIsIGZhbHNlKSkgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgICAgfSxcbiAgICAgIFwiL1wiOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgaWYgKHN0cmVhbS5lYXQoXCIvXCIpKSB7XG4gICAgICAgICAgd2hpbGUgKCFzdHJlYW0uZW9sKCkgJiYgIXN0cmVhbS5tYXRjaChcIj8+XCIsIGZhbHNlKSkgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgICdcIic6IGZ1bmN0aW9uKF9zdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIChzdGF0ZS50b2tTdGFjayB8fCAoc3RhdGUudG9rU3RhY2sgPSBbXSkpLnB1c2goJ1wiJywgMCk7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gcGhwU3RyaW5nKCdcIicpO1xuICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICAgIH0sXG4gICAgICBcIntcIjogZnVuY3Rpb24oX3N0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgaWYgKHN0YXRlLnRva1N0YWNrICYmIHN0YXRlLnRva1N0YWNrLmxlbmd0aClcbiAgICAgICAgICBzdGF0ZS50b2tTdGFja1tzdGF0ZS50b2tTdGFjay5sZW5ndGggLSAxXSsrO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuICAgICAgXCJ9XCI6IGZ1bmN0aW9uKF9zdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIGlmIChzdGF0ZS50b2tTdGFjayAmJiBzdGF0ZS50b2tTdGFjay5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAhLS1zdGF0ZS50b2tTdGFja1tzdGF0ZS50b2tTdGFjay5sZW5ndGggLSAxXSkge1xuICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gcGhwU3RyaW5nKHN0YXRlLnRva1N0YWNrW3N0YXRlLnRva1N0YWNrLmxlbmd0aCAtIDJdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lTW9kZShcInBocFwiLCBmdW5jdGlvbihjb25maWcsIHBhcnNlckNvbmZpZykge1xuICAgIHZhciBodG1sTW9kZSA9IENvZGVNaXJyb3IuZ2V0TW9kZShjb25maWcsIChwYXJzZXJDb25maWcgJiYgcGFyc2VyQ29uZmlnLmh0bWxNb2RlKSB8fCBcInRleHQvaHRtbFwiKTtcbiAgICB2YXIgcGhwTW9kZSA9IENvZGVNaXJyb3IuZ2V0TW9kZShjb25maWcsIHBocENvbmZpZyk7XG5cbiAgICBmdW5jdGlvbiBkaXNwYXRjaChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgaXNQSFAgPSBzdGF0ZS5jdXJNb2RlID09IHBocE1vZGU7XG4gICAgICBpZiAoc3RyZWFtLnNvbCgpICYmIHN0YXRlLnBlbmRpbmcgJiYgc3RhdGUucGVuZGluZyAhPSAnXCInICYmIHN0YXRlLnBlbmRpbmcgIT0gXCInXCIpIHN0YXRlLnBlbmRpbmcgPSBudWxsO1xuICAgICAgaWYgKCFpc1BIUCkge1xuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9ePFxcP1xcdyovKSkge1xuICAgICAgICAgIHN0YXRlLmN1ck1vZGUgPSBwaHBNb2RlO1xuICAgICAgICAgIGlmICghc3RhdGUucGhwKSBzdGF0ZS5waHAgPSBDb2RlTWlycm9yLnN0YXJ0U3RhdGUocGhwTW9kZSwgaHRtbE1vZGUuaW5kZW50KHN0YXRlLmh0bWwsIFwiXCIsIFwiXCIpKVxuICAgICAgICAgIHN0YXRlLmN1clN0YXRlID0gc3RhdGUucGhwO1xuICAgICAgICAgIHJldHVybiBcIm1ldGFcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUucGVuZGluZyA9PSAnXCInIHx8IHN0YXRlLnBlbmRpbmcgPT0gXCInXCIpIHtcbiAgICAgICAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSAmJiBzdHJlYW0ubmV4dCgpICE9IHN0YXRlLnBlbmRpbmcpIHt9XG4gICAgICAgICAgdmFyIHN0eWxlID0gXCJzdHJpbmdcIjtcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5wZW5kaW5nICYmIHN0cmVhbS5wb3MgPCBzdGF0ZS5wZW5kaW5nLmVuZCkge1xuICAgICAgICAgIHN0cmVhbS5wb3MgPSBzdGF0ZS5wZW5kaW5nLmVuZDtcbiAgICAgICAgICB2YXIgc3R5bGUgPSBzdGF0ZS5wZW5kaW5nLnN0eWxlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzdHlsZSA9IGh0bWxNb2RlLnRva2VuKHN0cmVhbSwgc3RhdGUuY3VyU3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5wZW5kaW5nKSBzdGF0ZS5wZW5kaW5nID0gbnVsbDtcbiAgICAgICAgdmFyIGN1ciA9IHN0cmVhbS5jdXJyZW50KCksIG9wZW5QSFAgPSBjdXIuc2VhcmNoKC88XFw/LyksIG07XG4gICAgICAgIGlmIChvcGVuUEhQICE9IC0xKSB7XG4gICAgICAgICAgaWYgKHN0eWxlID09IFwic3RyaW5nXCIgJiYgKG0gPSBjdXIubWF0Y2goL1tcXCdcXFwiXSQvKSkgJiYgIS9cXD8+Ly50ZXN0KGN1cikpIHN0YXRlLnBlbmRpbmcgPSBtWzBdO1xuICAgICAgICAgIGVsc2Ugc3RhdGUucGVuZGluZyA9IHtlbmQ6IHN0cmVhbS5wb3MsIHN0eWxlOiBzdHlsZX07XG4gICAgICAgICAgc3RyZWFtLmJhY2tVcChjdXIubGVuZ3RoIC0gb3BlblBIUCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgfSBlbHNlIGlmIChpc1BIUCAmJiBzdGF0ZS5waHAudG9rZW5pemUgPT0gbnVsbCAmJiBzdHJlYW0ubWF0Y2goXCI/PlwiKSkge1xuICAgICAgICBzdGF0ZS5jdXJNb2RlID0gaHRtbE1vZGU7XG4gICAgICAgIHN0YXRlLmN1clN0YXRlID0gc3RhdGUuaHRtbDtcbiAgICAgICAgaWYgKCFzdGF0ZS5waHAuY29udGV4dC5wcmV2KSBzdGF0ZS5waHAgPSBudWxsO1xuICAgICAgICByZXR1cm4gXCJtZXRhXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcGhwTW9kZS50b2tlbihzdHJlYW0sIHN0YXRlLmN1clN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gQ29kZU1pcnJvci5zdGFydFN0YXRlKGh0bWxNb2RlKVxuICAgICAgICB2YXIgcGhwID0gcGFyc2VyQ29uZmlnLnN0YXJ0T3BlbiA/IENvZGVNaXJyb3Iuc3RhcnRTdGF0ZShwaHBNb2RlKSA6IG51bGxcbiAgICAgICAgcmV0dXJuIHtodG1sOiBodG1sLFxuICAgICAgICAgICAgICAgIHBocDogcGhwLFxuICAgICAgICAgICAgICAgIGN1ck1vZGU6IHBhcnNlckNvbmZpZy5zdGFydE9wZW4gPyBwaHBNb2RlIDogaHRtbE1vZGUsXG4gICAgICAgICAgICAgICAgY3VyU3RhdGU6IHBhcnNlckNvbmZpZy5zdGFydE9wZW4gPyBwaHAgOiBodG1sLFxuICAgICAgICAgICAgICAgIHBlbmRpbmc6IG51bGx9O1xuICAgICAgfSxcblxuICAgICAgY29weVN0YXRlOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICB2YXIgaHRtbCA9IHN0YXRlLmh0bWwsIGh0bWxOZXcgPSBDb2RlTWlycm9yLmNvcHlTdGF0ZShodG1sTW9kZSwgaHRtbCksXG4gICAgICAgICAgICBwaHAgPSBzdGF0ZS5waHAsIHBocE5ldyA9IHBocCAmJiBDb2RlTWlycm9yLmNvcHlTdGF0ZShwaHBNb2RlLCBwaHApLCBjdXI7XG4gICAgICAgIGlmIChzdGF0ZS5jdXJNb2RlID09IGh0bWxNb2RlKSBjdXIgPSBodG1sTmV3O1xuICAgICAgICBlbHNlIGN1ciA9IHBocE5ldztcbiAgICAgICAgcmV0dXJuIHtodG1sOiBodG1sTmV3LCBwaHA6IHBocE5ldywgY3VyTW9kZTogc3RhdGUuY3VyTW9kZSwgY3VyU3RhdGU6IGN1cixcbiAgICAgICAgICAgICAgICBwZW5kaW5nOiBzdGF0ZS5wZW5kaW5nfTtcbiAgICAgIH0sXG5cbiAgICAgIHRva2VuOiBkaXNwYXRjaCxcblxuICAgICAgaW5kZW50OiBmdW5jdGlvbihzdGF0ZSwgdGV4dEFmdGVyLCBsaW5lKSB7XG4gICAgICAgIGlmICgoc3RhdGUuY3VyTW9kZSAhPSBwaHBNb2RlICYmIC9eXFxzKjxcXC8vLnRlc3QodGV4dEFmdGVyKSkgfHxcbiAgICAgICAgICAgIChzdGF0ZS5jdXJNb2RlID09IHBocE1vZGUgJiYgL15cXD8+Ly50ZXN0KHRleHRBZnRlcikpKVxuICAgICAgICAgIHJldHVybiBodG1sTW9kZS5pbmRlbnQoc3RhdGUuaHRtbCwgdGV4dEFmdGVyLCBsaW5lKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmN1ck1vZGUuaW5kZW50KHN0YXRlLmN1clN0YXRlLCB0ZXh0QWZ0ZXIsIGxpbmUpO1xuICAgICAgfSxcblxuICAgICAgYmxvY2tDb21tZW50U3RhcnQ6IFwiLypcIixcbiAgICAgIGJsb2NrQ29tbWVudEVuZDogXCIqL1wiLFxuICAgICAgbGluZUNvbW1lbnQ6IFwiLy9cIixcblxuICAgICAgaW5uZXJNb2RlOiBmdW5jdGlvbihzdGF0ZSkgeyByZXR1cm4ge3N0YXRlOiBzdGF0ZS5jdXJTdGF0ZSwgbW9kZTogc3RhdGUuY3VyTW9kZX07IH1cbiAgICB9O1xuICB9LCBcImh0bWxtaXhlZFwiLCBcImNsaWtlXCIpO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcImFwcGxpY2F0aW9uL3gtaHR0cGQtcGhwXCIsIFwicGhwXCIpO1xuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJhcHBsaWNhdGlvbi94LWh0dHBkLXBocC1vcGVuXCIsIHtuYW1lOiBcInBocFwiLCBzdGFydE9wZW46IHRydWV9KTtcbiAgQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LXBocFwiLCBwaHBDb25maWcpO1xufSk7XG4iLCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4vKlxuICogICAgICBQaWcgTGF0aW4gTW9kZSBmb3IgQ29kZU1pcnJvciAyXG4gKiAgICAgIEBhdXRob3IgUHJhc2FudGggSmF5YWNoYW5kcmFuXG4gKiAgICAgIEBsaW5rICAgaHR0cHM6Ly9naXRodWIuY29tL3ByYXNhbnRoai9waWctY29kZW1pcnJvci0yXG4gKiAgVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBhZGFwdGVkIGZyb20gUEwvU1FMIG1vZGUgaW4gQ29kZU1pcnJvciAyLlxuICovXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTW9kZShcInBpZ1wiLCBmdW5jdGlvbihfY29uZmlnLCBwYXJzZXJDb25maWcpIHtcbiAgdmFyIGtleXdvcmRzID0gcGFyc2VyQ29uZmlnLmtleXdvcmRzLFxuICBidWlsdGlucyA9IHBhcnNlckNvbmZpZy5idWlsdGlucyxcbiAgdHlwZXMgPSBwYXJzZXJDb25maWcudHlwZXMsXG4gIG11bHRpTGluZVN0cmluZ3MgPSBwYXJzZXJDb25maWcubXVsdGlMaW5lU3RyaW5ncztcblxuICB2YXIgaXNPcGVyYXRvckNoYXIgPSAvWyorXFwtJTw+PSY/OlxcLyF8XS87XG5cbiAgZnVuY3Rpb24gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgZikge1xuICAgIHN0YXRlLnRva2VuaXplID0gZjtcbiAgICByZXR1cm4gZihzdHJlYW0sIHN0YXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGlzRW5kID0gZmFsc2U7XG4gICAgdmFyIGNoO1xuICAgIHdoaWxlKGNoID0gc3RyZWFtLm5leHQoKSkge1xuICAgICAgaWYoY2ggPT0gXCIvXCIgJiYgaXNFbmQpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaXNFbmQgPSAoY2ggPT0gXCIqXCIpO1xuICAgIH1cbiAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlblN0cmluZyhxdW90ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgZXNjYXBlZCA9IGZhbHNlLCBuZXh0LCBlbmQgPSBmYWxzZTtcbiAgICAgIHdoaWxlKChuZXh0ID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgICBpZiAobmV4dCA9PSBxdW90ZSAmJiAhZXNjYXBlZCkge1xuICAgICAgICAgIGVuZCA9IHRydWU7IGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZCAmJiBuZXh0ID09IFwiXFxcXFwiO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCB8fCAhKGVzY2FwZWQgfHwgbXVsdGlMaW5lU3RyaW5ncykpXG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgcmV0dXJuIFwiZXJyb3JcIjtcbiAgICB9O1xuICB9XG5cblxuICBmdW5jdGlvbiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG5cbiAgICAvLyBpcyBhIHN0YXJ0IG9mIHN0cmluZz9cbiAgICBpZiAoY2ggPT0gJ1wiJyB8fCBjaCA9PSBcIidcIilcbiAgICAgIHJldHVybiBjaGFpbihzdHJlYW0sIHN0YXRlLCB0b2tlblN0cmluZyhjaCkpO1xuICAgIC8vIGlzIGl0IG9uZSBvZiB0aGUgc3BlY2lhbCBjaGFyc1xuICAgIGVsc2UgaWYoL1tcXFtcXF17fVxcKFxcKSw7XFwuXS8udGVzdChjaCkpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICAvLyBpcyBpdCBhIG51bWJlcj9cbiAgICBlbHNlIGlmKC9cXGQvLnRlc3QoY2gpKSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXC5dLyk7XG4gICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICB9XG4gICAgLy8gbXVsdGkgbGluZSBjb21tZW50IG9yIG9wZXJhdG9yXG4gICAgZWxzZSBpZiAoY2ggPT0gXCIvXCIpIHtcbiAgICAgIGlmIChzdHJlYW0uZWF0KFwiKlwiKSkge1xuICAgICAgICByZXR1cm4gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgdG9rZW5Db21tZW50KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoaXNPcGVyYXRvckNoYXIpO1xuICAgICAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBzaW5nbGUgbGluZSBjb21tZW50IG9yIG9wZXJhdG9yXG4gICAgZWxzZSBpZiAoY2g9PVwiLVwiKSB7XG4gICAgICBpZihzdHJlYW0uZWF0KFwiLVwiKSl7XG4gICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZShpc09wZXJhdG9yQ2hhcik7XG4gICAgICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGlzIGl0IGFuIG9wZXJhdG9yXG4gICAgZWxzZSBpZiAoaXNPcGVyYXRvckNoYXIudGVzdChjaCkpIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZShpc09wZXJhdG9yQ2hhcik7XG4gICAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGdldCB0aGUgd2hpbGUgd29yZFxuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwkX10vKTtcbiAgICAgIC8vIGlzIGl0IG9uZSBvZiB0aGUgbGlzdGVkIGtleXdvcmRzP1xuICAgICAgaWYgKGtleXdvcmRzICYmIGtleXdvcmRzLnByb3BlcnR5SXNFbnVtZXJhYmxlKHN0cmVhbS5jdXJyZW50KCkudG9VcHBlckNhc2UoKSkpIHtcbiAgICAgICAgLy9rZXl3b3JkcyBjYW4gYmUgdXNlZCBhcyB2YXJpYWJsZXMgbGlrZSBmbGF0dGVuKGdyb3VwKSwgZ3JvdXAuJDAgZXRjLi5cbiAgICAgICAgaWYgKCFzdHJlYW0uZWF0KFwiKVwiKSAmJiAhc3RyZWFtLmVhdChcIi5cIikpXG4gICAgICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICAgICAgfVxuICAgICAgLy8gaXMgaXQgb25lIG9mIHRoZSBidWlsdGluIGZ1bmN0aW9ucz9cbiAgICAgIGlmIChidWlsdGlucyAmJiBidWlsdGlucy5wcm9wZXJ0eUlzRW51bWVyYWJsZShzdHJlYW0uY3VycmVudCgpLnRvVXBwZXJDYXNlKCkpKVxuICAgICAgICByZXR1cm4gXCJ2YXJpYWJsZS0yXCI7XG4gICAgICAvLyBpcyBpdCBvbmUgb2YgdGhlIGxpc3RlZCB0eXBlcz9cbiAgICAgIGlmICh0eXBlcyAmJiB0eXBlcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShzdHJlYW0uY3VycmVudCgpLnRvVXBwZXJDYXNlKCkpKVxuICAgICAgICByZXR1cm4gXCJ2YXJpYWJsZS0zXCI7XG4gICAgICAvLyBkZWZhdWx0IGlzIGEgJ3ZhcmlhYmxlJ1xuICAgICAgcmV0dXJuIFwidmFyaWFibGVcIjtcbiAgICB9XG4gIH1cblxuICAvLyBJbnRlcmZhY2VcbiAgcmV0dXJuIHtcbiAgICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRva2VuaXplOiB0b2tlbkJhc2UsXG4gICAgICAgIHN0YXJ0T2ZMaW5lOiB0cnVlXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYoc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xuICAgICAgdmFyIHN0eWxlID0gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfVxuICB9O1xufSk7XG5cbihmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24ga2V5d29yZHMoc3RyKSB7XG4gICAgdmFyIG9iaiA9IHt9LCB3b3JkcyA9IHN0ci5zcGxpdChcIiBcIik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7ICsraSkgb2JqW3dvcmRzW2ldXSA9IHRydWU7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIC8vIGJ1aWx0aW4gZnVuY3MgdGFrZW4gZnJvbSB0cnVuayByZXZpc2lvbiAxMzAzMjM3XG4gIHZhciBwQnVpbHRpbnMgPSBcIkFCUyBBQ09TIEFSSVRZIEFTSU4gQVRBTiBBVkcgQkFHU0laRSBCSU5TVE9SQUdFIEJMT09NIEJVSUxEQkxPT00gQ0JSVCBDRUlMIFwiXG4gICAgKyBcIkNPTkNBVCBDT1IgQ09TIENPU0ggQ09VTlQgQ09VTlRfU1RBUiBDT1YgQ09OU1RBTlRTSVpFIENVQkVESU1FTlNJT05TIERJRkYgRElTVElOQ1QgRE9VQkxFQUJTIFwiXG4gICAgKyBcIkRPVUJMRUFWRyBET1VCTEVCQVNFIERPVUJMRU1BWCBET1VCTEVNSU4gRE9VQkxFUk9VTkQgRE9VQkxFU1VNIEVYUCBGTE9PUiBGTE9BVEFCUyBGTE9BVEFWRyBcIlxuICAgICsgXCJGTE9BVE1BWCBGTE9BVE1JTiBGTE9BVFJPVU5EIEZMT0FUU1VNIEdFTkVSSUNJTlZPS0VSIElOREVYT0YgSU5UQUJTIElOVEFWRyBJTlRNQVggSU5UTUlOIFwiXG4gICAgKyBcIklOVFNVTSBJTlZPS0VGT1JET1VCTEUgSU5WT0tFRk9SRkxPQVQgSU5WT0tFRk9SSU5UIElOVk9LRUZPUkxPTkcgSU5WT0tFRk9SU1RSSU5HIElOVk9LRVIgXCJcbiAgICArIFwiSVNFTVBUWSBKU09OTE9BREVSIEpTT05NRVRBREFUQSBKU09OU1RPUkFHRSBMQVNUX0lOREVYX09GIExDRklSU1QgTE9HIExPRzEwIExPV0VSIExPTkdBQlMgXCJcbiAgICArIFwiTE9OR0FWRyBMT05HTUFYIExPTkdNSU4gTE9OR1NVTSBNQVggTUlOIE1BUFNJWkUgTU9OSVRPUkVEVURGIE5PTkRFVEVSTUlOSVNUSUMgT1VUUFVUU0NIRU1BICBcIlxuICAgICsgXCJQSUdTVE9SQUdFIFBJR1NUUkVBTUlORyBSQU5ET00gUkVHRVhfRVhUUkFDVCBSRUdFWF9FWFRSQUNUX0FMTCBSRVBMQUNFIFJPVU5EIFNJTiBTSU5IIFNJWkUgXCJcbiAgICArIFwiU1FSVCBTVFJTUExJVCBTVUJTVFJJTkcgU1VNIFNUUklOR0NPTkNBVCBTVFJJTkdNQVggU1RSSU5HTUlOIFNUUklOR1NJWkUgVEFOIFRBTkggVE9CQUcgXCJcbiAgICArIFwiVE9LRU5JWkUgVE9NQVAgVE9QIFRPVFVQTEUgVFJJTSBURVhUTE9BREVSIFRVUExFU0laRSBVQ0ZJUlNUIFVQUEVSIFVURjhTVE9SQUdFQ09OVkVSVEVSIFwiO1xuXG4gIC8vIHRha2VuIGZyb20gUXVlcnlMZXhlci5nXG4gIHZhciBwS2V5d29yZHMgPSBcIlZPSUQgSU1QT1JUIFJFVFVSTlMgREVGSU5FIExPQUQgRklMVEVSIEZPUkVBQ0ggT1JERVIgQ1VCRSBESVNUSU5DVCBDT0dST1VQIFwiXG4gICAgKyBcIkpPSU4gQ1JPU1MgVU5JT04gU1BMSVQgSU5UTyBJRiBPVEhFUldJU0UgQUxMIEFTIEJZIFVTSU5HIElOTkVSIE9VVEVSIE9OU0NIRU1BIFBBUkFMTEVMIFwiXG4gICAgKyBcIlBBUlRJVElPTiBHUk9VUCBBTkQgT1IgTk9UIEdFTkVSQVRFIEZMQVRURU4gQVNDIERFU0MgSVMgU1RSRUFNIFRIUk9VR0ggU1RPUkUgTUFQUkVEVUNFIFwiXG4gICAgKyBcIlNISVAgQ0FDSEUgSU5QVVQgT1VUUFVUIFNUREVSUk9SIFNURElOIFNURE9VVCBMSU1JVCBTQU1QTEUgTEVGVCBSSUdIVCBGVUxMIEVRIEdUIExUIEdURSBMVEUgXCJcbiAgICArIFwiTkVRIE1BVENIRVMgVFJVRSBGQUxTRSBEVU1QXCI7XG5cbiAgLy8gZGF0YSB0eXBlc1xuICB2YXIgcFR5cGVzID0gXCJCT09MRUFOIElOVCBMT05HIEZMT0FUIERPVUJMRSBDSEFSQVJSQVkgQllURUFSUkFZIEJBRyBUVVBMRSBNQVAgXCI7XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LXBpZ1wiLCB7XG4gICAgbmFtZTogXCJwaWdcIixcbiAgICBidWlsdGluczoga2V5d29yZHMocEJ1aWx0aW5zKSxcbiAgICBrZXl3b3Jkczoga2V5d29yZHMocEtleXdvcmRzKSxcbiAgICB0eXBlczoga2V5d29yZHMocFR5cGVzKVxuICB9KTtcblxuICBDb2RlTWlycm9yLnJlZ2lzdGVySGVscGVyKFwiaGludFdvcmRzXCIsIFwicGlnXCIsIChwQnVpbHRpbnMgKyBwVHlwZXMgKyBwS2V5d29yZHMpLnNwbGl0KFwiIFwiKSk7XG59KCkpO1xuXG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JykgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZSgnLi4vLi4vbGliL2NvZGVtaXJyb3InKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoWycuLi8uLi9saWIvY29kZW1pcnJvciddLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKHdpbmRvdy5Db2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcbid1c2Ugc3RyaWN0JztcblxuQ29kZU1pcnJvci5kZWZpbmVNb2RlKCdwb3dlcnNoZWxsJywgZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIGJ1aWxkUmVnZXhwKHBhdHRlcm5zLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIHByZWZpeCA9IG9wdGlvbnMucHJlZml4ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnByZWZpeCA6ICdeJztcbiAgICB2YXIgc3VmZml4ID0gb3B0aW9ucy5zdWZmaXggIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3VmZml4IDogJ1xcXFxiJztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0dGVybnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChwYXR0ZXJuc1tpXSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICBwYXR0ZXJuc1tpXSA9IHBhdHRlcm5zW2ldLnNvdXJjZTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBwYXR0ZXJuc1tpXSA9IHBhdHRlcm5zW2ldLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUmVnRXhwKHByZWZpeCArICcoJyArIHBhdHRlcm5zLmpvaW4oJ3wnKSArICcpJyArIHN1ZmZpeCwgJ2knKTtcbiAgfVxuXG4gIHZhciBub3RDaGFyYWN0ZXJPckRhc2ggPSAnKD89W15BLVphLXpcXFxcZFxcXFwtX118JCknO1xuICB2YXIgdmFyTmFtZXMgPSAvW1xcd1xcLTpdL1xuICB2YXIga2V5d29yZHMgPSBidWlsZFJlZ2V4cChbXG4gICAgL2JlZ2lufGJyZWFrfGNhdGNofGNvbnRpbnVlfGRhdGF8ZGVmYXVsdHxkb3xkeW5hbWljcGFyYW0vLFxuICAgIC9lbHNlfGVsc2VpZnxlbmR8ZXhpdHxmaWx0ZXJ8ZmluYWxseXxmb3J8Zm9yZWFjaHxmcm9tfGZ1bmN0aW9ufGlmfGluLyxcbiAgICAvcGFyYW18cHJvY2Vzc3xyZXR1cm58c3dpdGNofHRocm93fHRyYXB8dHJ5fHVudGlsfHdoZXJlfHdoaWxlL1xuICBdLCB7IHN1ZmZpeDogbm90Q2hhcmFjdGVyT3JEYXNoIH0pO1xuXG4gIHZhciBwdW5jdHVhdGlvbiA9IC9bXFxbXFxde30sO2BcXFxcXFwuXXxAWyh7XS87XG4gIHZhciB3b3JkT3BlcmF0b3JzID0gYnVpbGRSZWdleHAoW1xuICAgICdmJyxcbiAgICAvYj9ub3QvLFxuICAgIC9baWNdP3NwbGl0LywgJ2pvaW4nLFxuICAgIC9pcyhub3QpPy8sICdhcycsXG4gICAgL1tpY10/KGVxfG5lfFtnbF1bdGVdKS8sXG4gICAgL1tpY10/KG5vdCk/KGxpa2V8bWF0Y2h8Y29udGFpbnMpLyxcbiAgICAvW2ljXT9yZXBsYWNlLyxcbiAgICAvYj8oYW5kfG9yfHhvcikvXG4gIF0sIHsgcHJlZml4OiAnLScgfSk7XG4gIHZhciBzeW1ib2xPcGVyYXRvcnMgPSAvWytcXC0qXFwvJV09fFxcK1xcK3wtLXxcXC5cXC58WytcXC0qJl4lOj0hfFxcL118PCg/ISMpfCg/ISMpPi87XG4gIHZhciBvcGVyYXRvcnMgPSBidWlsZFJlZ2V4cChbd29yZE9wZXJhdG9ycywgc3ltYm9sT3BlcmF0b3JzXSwgeyBzdWZmaXg6ICcnIH0pO1xuXG4gIHZhciBudW1iZXJzID0gL14oKDB4W1xcZGEtZl0rKXwoKFxcZCtcXC5cXGQrfFxcZFxcLnxcXC5cXGQrfFxcZCspKGVbXFwrXFwtXT9cXGQrKT8pKVtsZF0/KFtrbWd0cF1iKT8vaTtcblxuICB2YXIgaWRlbnRpZmllcnMgPSAvXltBLVphLXpcXF9dW0EtWmEtelxcLVxcX1xcZF0qXFxiLztcblxuICB2YXIgc3ltYm9sQnVpbHRpbnMgPSAvW0EtWl06fCV8XFw/L2k7XG4gIHZhciBuYW1lZEJ1aWx0aW5zID0gYnVpbGRSZWdleHAoW1xuICAgIC9BZGQtKENvbXB1dGVyfENvbnRlbnR8SGlzdG9yeXxNZW1iZXJ8UFNTbmFwaW58VHlwZSkvLFxuICAgIC9DaGVja3BvaW50LUNvbXB1dGVyLyxcbiAgICAvQ2xlYXItKENvbnRlbnR8RXZlbnRMb2d8SGlzdG9yeXxIb3N0fEl0ZW0oUHJvcGVydHkpP3xWYXJpYWJsZSkvLFxuICAgIC9Db21wYXJlLU9iamVjdC8sXG4gICAgL0NvbXBsZXRlLVRyYW5zYWN0aW9uLyxcbiAgICAvQ29ubmVjdC1QU1Nlc3Npb24vLFxuICAgIC9Db252ZXJ0RnJvbS0oQ3N2fEpzb258U2VjdXJlU3RyaW5nfFN0cmluZ0RhdGEpLyxcbiAgICAvQ29udmVydC1QYXRoLyxcbiAgICAvQ29udmVydFRvLShDc3Z8SHRtbHxKc29ufFNlY3VyZVN0cmluZ3xYbWwpLyxcbiAgICAvQ29weS1JdGVtKFByb3BlcnR5KT8vLFxuICAgIC9EZWJ1Zy1Qcm9jZXNzLyxcbiAgICAvRGlzYWJsZS0oQ29tcHV0ZXJSZXN0b3JlfFBTQnJlYWtwb2ludHxQU1JlbW90aW5nfFBTU2Vzc2lvbkNvbmZpZ3VyYXRpb24pLyxcbiAgICAvRGlzY29ubmVjdC1QU1Nlc3Npb24vLFxuICAgIC9FbmFibGUtKENvbXB1dGVyUmVzdG9yZXxQU0JyZWFrcG9pbnR8UFNSZW1vdGluZ3xQU1Nlc3Npb25Db25maWd1cmF0aW9uKS8sXG4gICAgLyhFbnRlcnxFeGl0KS1QU1Nlc3Npb24vLFxuICAgIC9FeHBvcnQtKEFsaWFzfENsaXhtbHxDb25zb2xlfENvdW50ZXJ8Q3N2fEZvcm1hdERhdGF8TW9kdWxlTWVtYmVyfFBTU2Vzc2lvbikvLFxuICAgIC9Gb3JFYWNoLU9iamVjdC8sXG4gICAgL0Zvcm1hdC0oQ3VzdG9tfExpc3R8VGFibGV8V2lkZSkvLFxuICAgIG5ldyBSZWdFeHAoJ0dldC0oQWNsfEFsaWFzfEF1dGhlbnRpY29kZVNpZ25hdHVyZXxDaGlsZEl0ZW18Q29tbWFuZHxDb21wdXRlclJlc3RvcmVQb2ludHxDb250ZW50fENvbnRyb2xQYW5lbEl0ZW18Q291bnRlcnxDcmVkZW50aWFsJ1xuICAgICAgKyAnfEN1bHR1cmV8RGF0ZXxFdmVudHxFdmVudExvZ3xFdmVudFN1YnNjcmliZXJ8RXhlY3V0aW9uUG9saWN5fEZvcm1hdERhdGF8SGVscHxIaXN0b3J5fEhvc3R8SG90Rml4fEl0ZW18SXRlbVByb3BlcnR5fEpvYidcbiAgICAgICsgJ3xMb2NhdGlvbnxNZW1iZXJ8TW9kdWxlfFBmeENlcnRpZmljYXRlfFByb2Nlc3N8UFNCcmVha3BvaW50fFBTQ2FsbFN0YWNrfFBTRHJpdmV8UFNQcm92aWRlcnxQU1Nlc3Npb258UFNTZXNzaW9uQ29uZmlndXJhdGlvbidcbiAgICAgICsgJ3xQU1NuYXBpbnxSYW5kb218U2VydmljZXxUcmFjZVNvdXJjZXxUcmFuc2FjdGlvbnxUeXBlRGF0YXxVSUN1bHR1cmV8VW5pcXVlfFZhcmlhYmxlfFZlcmJ8V2luRXZlbnR8V21pT2JqZWN0KScpLFxuICAgIC9Hcm91cC1PYmplY3QvLFxuICAgIC9JbXBvcnQtKEFsaWFzfENsaXhtbHxDb3VudGVyfENzdnxMb2NhbGl6ZWREYXRhfE1vZHVsZXxQU1Nlc3Npb24pLyxcbiAgICAvSW1wb3J0U3lzdGVtTW9kdWxlcy8sXG4gICAgL0ludm9rZS0oQ29tbWFuZHxFeHByZXNzaW9ufEhpc3Rvcnl8SXRlbXxSZXN0TWV0aG9kfFdlYlJlcXVlc3R8V21pTWV0aG9kKS8sXG4gICAgL0pvaW4tUGF0aC8sXG4gICAgL0xpbWl0LUV2ZW50TG9nLyxcbiAgICAvTWVhc3VyZS0oQ29tbWFuZHxPYmplY3QpLyxcbiAgICAvTW92ZS1JdGVtKFByb3BlcnR5KT8vLFxuICAgIG5ldyBSZWdFeHAoJ05ldy0oQWxpYXN8RXZlbnR8RXZlbnRMb2d8SXRlbShQcm9wZXJ0eSk/fE1vZHVsZXxNb2R1bGVNYW5pZmVzdHxPYmplY3R8UFNEcml2ZXxQU1Nlc3Npb258UFNTZXNzaW9uQ29uZmlndXJhdGlvbkZpbGUnXG4gICAgICArICd8UFNTZXNzaW9uT3B0aW9ufFBTVHJhbnNwb3J0T3B0aW9ufFNlcnZpY2V8VGltZVNwYW58VmFyaWFibGV8V2ViU2VydmljZVByb3h5fFdpbkV2ZW50KScpLFxuICAgIC9PdXQtKERlZmF1bHR8RmlsZXxHcmlkVmlld3xIb3N0fE51bGx8UHJpbnRlcnxTdHJpbmcpLyxcbiAgICAvUGF1c2UvLFxuICAgIC8oUG9wfFB1c2gpLUxvY2F0aW9uLyxcbiAgICAvUmVhZC1Ib3N0LyxcbiAgICAvUmVjZWl2ZS0oSm9ifFBTU2Vzc2lvbikvLFxuICAgIC9SZWdpc3Rlci0oRW5naW5lRXZlbnR8T2JqZWN0RXZlbnR8UFNTZXNzaW9uQ29uZmlndXJhdGlvbnxXbWlFdmVudCkvLFxuICAgIC9SZW1vdmUtKENvbXB1dGVyfEV2ZW50fEV2ZW50TG9nfEl0ZW0oUHJvcGVydHkpP3xKb2J8TW9kdWxlfFBTQnJlYWtwb2ludHxQU0RyaXZlfFBTU2Vzc2lvbnxQU1NuYXBpbnxUeXBlRGF0YXxWYXJpYWJsZXxXbWlPYmplY3QpLyxcbiAgICAvUmVuYW1lLShDb21wdXRlcnxJdGVtKFByb3BlcnR5KT8pLyxcbiAgICAvUmVzZXQtQ29tcHV0ZXJNYWNoaW5lUGFzc3dvcmQvLFxuICAgIC9SZXNvbHZlLVBhdGgvLFxuICAgIC9SZXN0YXJ0LShDb21wdXRlcnxTZXJ2aWNlKS8sXG4gICAgL1Jlc3RvcmUtQ29tcHV0ZXIvLFxuICAgIC9SZXN1bWUtKEpvYnxTZXJ2aWNlKS8sXG4gICAgL1NhdmUtSGVscC8sXG4gICAgL1NlbGVjdC0oT2JqZWN0fFN0cmluZ3xYbWwpLyxcbiAgICAvU2VuZC1NYWlsTWVzc2FnZS8sXG4gICAgbmV3IFJlZ0V4cCgnU2V0LShBY2x8QWxpYXN8QXV0aGVudGljb2RlU2lnbmF0dXJlfENvbnRlbnR8RGF0ZXxFeGVjdXRpb25Qb2xpY3l8SXRlbShQcm9wZXJ0eSk/fExvY2F0aW9ufFBTQnJlYWtwb2ludHxQU0RlYnVnJyArXG4gICAgICAgICAgICAgICAnfFBTU2Vzc2lvbkNvbmZpZ3VyYXRpb258U2VydmljZXxTdHJpY3RNb2RlfFRyYWNlU291cmNlfFZhcmlhYmxlfFdtaUluc3RhbmNlKScpLFxuICAgIC9TaG93LShDb21tYW5kfENvbnRyb2xQYW5lbEl0ZW18RXZlbnRMb2cpLyxcbiAgICAvU29ydC1PYmplY3QvLFxuICAgIC9TcGxpdC1QYXRoLyxcbiAgICAvU3RhcnQtKEpvYnxQcm9jZXNzfFNlcnZpY2V8U2xlZXB8VHJhbnNhY3Rpb258VHJhbnNjcmlwdCkvLFxuICAgIC9TdG9wLShDb21wdXRlcnxKb2J8UHJvY2Vzc3xTZXJ2aWNlfFRyYW5zY3JpcHQpLyxcbiAgICAvU3VzcGVuZC0oSm9ifFNlcnZpY2UpLyxcbiAgICAvVGFiRXhwYW5zaW9uMi8sXG4gICAgL1RlZS1PYmplY3QvLFxuICAgIC9UZXN0LShDb21wdXRlclNlY3VyZUNoYW5uZWx8Q29ubmVjdGlvbnxNb2R1bGVNYW5pZmVzdHxQYXRofFBTU2Vzc2lvbkNvbmZpZ3VyYXRpb25GaWxlKS8sXG4gICAgL1RyYWNlLUNvbW1hbmQvLFxuICAgIC9VbmJsb2NrLUZpbGUvLFxuICAgIC9VbmRvLVRyYW5zYWN0aW9uLyxcbiAgICAvVW5yZWdpc3Rlci0oRXZlbnR8UFNTZXNzaW9uQ29uZmlndXJhdGlvbikvLFxuICAgIC9VcGRhdGUtKEZvcm1hdERhdGF8SGVscHxMaXN0fFR5cGVEYXRhKS8sXG4gICAgL1VzZS1UcmFuc2FjdGlvbi8sXG4gICAgL1dhaXQtKEV2ZW50fEpvYnxQcm9jZXNzKS8sXG4gICAgL1doZXJlLU9iamVjdC8sXG4gICAgL1dyaXRlLShEZWJ1Z3xFcnJvcnxFdmVudExvZ3xIb3N0fE91dHB1dHxQcm9ncmVzc3xWZXJib3NlfFdhcm5pbmcpLyxcbiAgICAvY2R8aGVscHxta2Rpcnxtb3JlfG9zc3xwcm9tcHQvLFxuICAgIC9hY3xhc25wfGNhdHxjZHxjaGRpcnxjbGN8Y2xlYXJ8Y2xoeXxjbGl8Y2xwfGNsc3xjbHZ8Y25zbnxjb21wYXJlfGNvcHl8Y3B8Y3BpfGNwcHxjdnBhfGRicHxkZWx8ZGlmZnxkaXJ8ZG5zbnxlYnAvLFxuICAgIC9lY2hvfGVwYWx8ZXBjc3Z8ZXBzbnxlcmFzZXxldHNufGV4c258ZmN8Zmx8Zm9yZWFjaHxmdHxmd3xnYWx8Z2JwfGdjfGdjaXxnY218Z2NzfGdkcnxnaHl8Z2l8Z2pifGdsfGdtfGdtb3xncHxncHMvLFxuICAgIC9ncm91cHxnc258Z3NucHxnc3Z8Z3V8Z3Z8Z3dtaXxofGhpc3Rvcnl8aWNtfGlleHxpaHl8aWl8aXBhbHxpcGNzdnxpcG1vfGlwc258aXJtfGlzZXxpd21pfGl3cnxraWxsfGxwfGxzfG1hbnxtZC8sXG4gICAgL21lYXN1cmV8bWl8bW91bnR8bW92ZXxtcHxtdnxuYWx8bmRyfG5pfG5tb3xucHNzY3xuc258bnZ8b2d2fG9ofHBvcGR8cHN8cHVzaGR8cHdkfHJ8cmJwfHJjamJ8cmNzbnxyZHxyZHJ8cmVufHJpLyxcbiAgICAvcmpifHJtfHJtZGlyfHJtb3xybml8cm5wfHJwfHJzbnxyc25wfHJ1amJ8cnZ8cnZwYXxyd21pfHNhamJ8c2FsfHNhcHN8c2FzdnxzYnB8c2N8c2VsZWN0fHNldHxzaGNtfHNpfHNsfHNsZWVwfHNscy8sXG4gICAgL3NvcnR8c3B8c3BqYnxzcHBzfHNwc3Z8c3RhcnR8c3VqYnxzdnxzd21pfHRlZXx0cmNtfHR5cGV8d2hlcmV8d2pifHdyaXRlL1xuICBdLCB7IHByZWZpeDogJycsIHN1ZmZpeDogJycgfSk7XG4gIHZhciB2YXJpYWJsZUJ1aWx0aW5zID0gYnVpbGRSZWdleHAoW1xuICAgIC9bJD9eX118QXJnc3xDb25maXJtUHJlZmVyZW5jZXxDb25zb2xlRmlsZU5hbWV8RGVidWdQcmVmZXJlbmNlfEVycm9yfEVycm9yQWN0aW9uUHJlZmVyZW5jZXxFcnJvclZpZXd8RXhlY3V0aW9uQ29udGV4dC8sXG4gICAgL0Zvcm1hdEVudW1lcmF0aW9uTGltaXR8SG9tZXxIb3N0fElucHV0fE1heGltdW1BbGlhc0NvdW50fE1heGltdW1Ecml2ZUNvdW50fE1heGltdW1FcnJvckNvdW50fE1heGltdW1GdW5jdGlvbkNvdW50LyxcbiAgICAvTWF4aW11bUhpc3RvcnlDb3VudHxNYXhpbXVtVmFyaWFibGVDb3VudHxNeUludm9jYXRpb258TmVzdGVkUHJvbXB0TGV2ZWx8T3V0cHV0RW5jb2Rpbmd8UGlkfFByb2ZpbGV8UHJvZ3Jlc3NQcmVmZXJlbmNlLyxcbiAgICAvUFNCb3VuZFBhcmFtZXRlcnN8UFNDb21tYW5kUGF0aHxQU0N1bHR1cmV8UFNEZWZhdWx0UGFyYW1ldGVyVmFsdWVzfFBTRW1haWxTZXJ2ZXJ8UFNIb21lfFBTU2NyaXB0Um9vdHxQU1Nlc3Npb25BcHBsaWNhdGlvbk5hbWUvLFxuICAgIC9QU1Nlc3Npb25Db25maWd1cmF0aW9uTmFtZXxQU1Nlc3Npb25PcHRpb258UFNVSUN1bHR1cmV8UFNWZXJzaW9uVGFibGV8UHdkfFNoZWxsSWR8U3RhY2tUcmFjZXxWZXJib3NlUHJlZmVyZW5jZS8sXG4gICAgL1dhcm5pbmdQcmVmZXJlbmNlfFdoYXRJZlByZWZlcmVuY2UvLFxuXG4gICAgL0V2ZW50fEV2ZW50QXJnc3xFdmVudFN1YnNjcmliZXJ8U2VuZGVyLyxcbiAgICAvTWF0Y2hlc3xPZnN8Rm9yRWFjaHxMYXN0RXhpdENvZGV8UFNDbWRsZXR8UFNJdGVtfFBTU2VuZGVySW5mb3xUaGlzLyxcbiAgICAvdHJ1ZXxmYWxzZXxudWxsL1xuICBdLCB7IHByZWZpeDogJ1xcXFwkJywgc3VmZml4OiAnJyB9KTtcblxuICB2YXIgYnVpbHRpbnMgPSBidWlsZFJlZ2V4cChbc3ltYm9sQnVpbHRpbnMsIG5hbWVkQnVpbHRpbnMsIHZhcmlhYmxlQnVpbHRpbnNdLCB7IHN1ZmZpeDogbm90Q2hhcmFjdGVyT3JEYXNoIH0pO1xuXG4gIHZhciBncmFtbWFyID0ge1xuICAgIGtleXdvcmQ6IGtleXdvcmRzLFxuICAgIG51bWJlcjogbnVtYmVycyxcbiAgICBvcGVyYXRvcjogb3BlcmF0b3JzLFxuICAgIGJ1aWx0aW46IGJ1aWx0aW5zLFxuICAgIHB1bmN0dWF0aW9uOiBwdW5jdHVhdGlvbixcbiAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyc1xuICB9O1xuXG4gIC8vIHRva2VuaXplcnNcbiAgZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAvLyBIYW5kbGUgQ29tbWVudHNcbiAgICAvL3ZhciBjaCA9IHN0cmVhbS5wZWVrKCk7XG5cbiAgICB2YXIgcGFyZW50ID0gc3RhdGUucmV0dXJuU3RhY2tbc3RhdGUucmV0dXJuU3RhY2subGVuZ3RoIC0gMV07XG4gICAgaWYgKHBhcmVudCAmJiBwYXJlbnQuc2hvdWxkUmV0dXJuRnJvbShzdGF0ZSkpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gcGFyZW50LnRva2VuaXplO1xuICAgICAgc3RhdGUucmV0dXJuU3RhY2sucG9wKCk7XG4gICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoc3RyZWFtLmVhdCgnKCcpKSB7XG4gICAgICBzdGF0ZS5icmFja2V0TmVzdGluZyArPSAxO1xuICAgICAgcmV0dXJuICdwdW5jdHVhdGlvbic7XG4gICAgfVxuXG4gICAgaWYgKHN0cmVhbS5lYXQoJyknKSkge1xuICAgICAgc3RhdGUuYnJhY2tldE5lc3RpbmcgLT0gMTtcbiAgICAgIHJldHVybiAncHVuY3R1YXRpb24nO1xuICAgIH1cblxuICAgIGZvciAodmFyIGtleSBpbiBncmFtbWFyKSB7XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKGdyYW1tYXJba2V5XSkpIHtcbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuXG4gICAgLy8gc2luZ2xlLXF1b3RlIHN0cmluZ1xuICAgIGlmIChjaCA9PT0gXCInXCIpIHtcbiAgICAgIHJldHVybiB0b2tlblNpbmdsZVF1b3RlU3RyaW5nKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChjaCA9PT0gJyQnKSB7XG4gICAgICByZXR1cm4gdG9rZW5WYXJpYWJsZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICAvLyBkb3VibGUtcXVvdGUgc3RyaW5nXG4gICAgaWYgKGNoID09PSAnXCInKSB7XG4gICAgICByZXR1cm4gdG9rZW5Eb3VibGVRdW90ZVN0cmluZyhzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoY2ggPT09ICc8JyAmJiBzdHJlYW0uZWF0KCcjJykpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5Db21tZW50O1xuICAgICAgcmV0dXJuIHRva2VuQ29tbWVudChzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoY2ggPT09ICcjJykge1xuICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgcmV0dXJuICdjb21tZW50JztcbiAgICB9XG5cbiAgICBpZiAoY2ggPT09ICdAJykge1xuICAgICAgdmFyIHF1b3RlTWF0Y2ggPSBzdHJlYW0uZWF0KC9bXCInXS8pO1xuICAgICAgaWYgKHF1b3RlTWF0Y2ggJiYgc3RyZWFtLmVvbCgpKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5NdWx0aVN0cmluZztcbiAgICAgICAgc3RhdGUuc3RhcnRRdW90ZSA9IHF1b3RlTWF0Y2hbMF07XG4gICAgICAgIHJldHVybiB0b2tlbk11bHRpU3RyaW5nKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgfSBlbHNlIGlmIChzdHJlYW0uZW9sKCkpIHtcbiAgICAgICAgcmV0dXJuICdlcnJvcic7XG4gICAgICB9IGVsc2UgaWYgKHN0cmVhbS5wZWVrKCkubWF0Y2goL1soe10vKSkge1xuICAgICAgICByZXR1cm4gJ3B1bmN0dWF0aW9uJztcbiAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLnBlZWsoKS5tYXRjaCh2YXJOYW1lcykpIHtcbiAgICAgICAgLy8gc3BsYXR0ZWQgdmFyaWFibGVcbiAgICAgICAgcmV0dXJuIHRva2VuVmFyaWFibGUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAnZXJyb3InO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5TaW5nbGVRdW90ZVN0cmluZyhzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGNoO1xuICAgIHdoaWxlICgoY2ggPSBzdHJlYW0ucGVlaygpKSAhPSBudWxsKSB7XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuXG4gICAgICBpZiAoY2ggPT09IFwiJ1wiICYmICFzdHJlYW0uZWF0KFwiJ1wiKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgICAgcmV0dXJuICdzdHJpbmcnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnZXJyb3InO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5Eb3VibGVRdW90ZVN0cmluZyhzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGNoO1xuICAgIHdoaWxlICgoY2ggPSBzdHJlYW0ucGVlaygpKSAhPSBudWxsKSB7XG4gICAgICBpZiAoY2ggPT09ICckJykge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuU3RyaW5nSW50ZXJwb2xhdGlvbjtcbiAgICAgICAgcmV0dXJuICdzdHJpbmcnO1xuICAgICAgfVxuXG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgaWYgKGNoID09PSAnYCcpIHtcbiAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaCA9PT0gJ1wiJyAmJiAhc3RyZWFtLmVhdCgnXCInKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgICAgcmV0dXJuICdzdHJpbmcnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnZXJyb3InO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5TdHJpbmdJbnRlcnBvbGF0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICByZXR1cm4gdG9rZW5JbnRlcnBvbGF0aW9uKHN0cmVhbSwgc3RhdGUsIHRva2VuRG91YmxlUXVvdGVTdHJpbmcpO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5NdWx0aVN0cmluZ1JldHVybihzdHJlYW0sIHN0YXRlKSB7XG4gICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbk11bHRpU3RyaW5nO1xuICAgIHN0YXRlLnN0YXJ0UXVvdGUgPSAnXCInXG4gICAgcmV0dXJuIHRva2VuTXVsdGlTdHJpbmcoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlbkhlcmVTdHJpbmdJbnRlcnBvbGF0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICByZXR1cm4gdG9rZW5JbnRlcnBvbGF0aW9uKHN0cmVhbSwgc3RhdGUsIHRva2VuTXVsdGlTdHJpbmdSZXR1cm4pO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5JbnRlcnBvbGF0aW9uKHN0cmVhbSwgc3RhdGUsIHBhcmVudFRva2VuaXplKSB7XG4gICAgaWYgKHN0cmVhbS5tYXRjaCgnJCgnKSkge1xuICAgICAgdmFyIHNhdmVkQnJhY2tldE5lc3RpbmcgPSBzdGF0ZS5icmFja2V0TmVzdGluZztcbiAgICAgIHN0YXRlLnJldHVyblN0YWNrLnB1c2goe1xuICAgICAgICAvKmpzaGludCBsb29wZnVuYzp0cnVlICovXG4gICAgICAgIHNob3VsZFJldHVybkZyb206IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlLmJyYWNrZXROZXN0aW5nID09PSBzYXZlZEJyYWNrZXROZXN0aW5nO1xuICAgICAgICB9LFxuICAgICAgICB0b2tlbml6ZTogcGFyZW50VG9rZW5pemVcbiAgICAgIH0pO1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICBzdGF0ZS5icmFja2V0TmVzdGluZyArPSAxO1xuICAgICAgcmV0dXJuICdwdW5jdHVhdGlvbic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICBzdGF0ZS5yZXR1cm5TdGFjay5wdXNoKHtcbiAgICAgICAgc2hvdWxkUmV0dXJuRnJvbTogZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAgICB0b2tlbml6ZTogcGFyZW50VG9rZW5pemVcbiAgICAgIH0pO1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlblZhcmlhYmxlO1xuICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIG1heWJlRW5kID0gZmFsc2UsIGNoO1xuICAgIHdoaWxlICgoY2ggPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICBpZiAobWF5YmVFbmQgJiYgY2ggPT0gJz4nKSB7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBtYXliZUVuZCA9IChjaCA9PT0gJyMnKTtcbiAgICB9XG4gICAgcmV0dXJuICdjb21tZW50JztcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuVmFyaWFibGUoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0cmVhbS5wZWVrKCk7XG4gICAgaWYgKHN0cmVhbS5lYXQoJ3snKSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlblZhcmlhYmxlV2l0aEJyYWNlcztcbiAgICAgIHJldHVybiB0b2tlblZhcmlhYmxlV2l0aEJyYWNlcyhzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2UgaWYgKGNoICE9IHVuZGVmaW5lZCAmJiBjaC5tYXRjaCh2YXJOYW1lcykpIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSh2YXJOYW1lcyk7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgIHJldHVybiAndmFyaWFibGUtMic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgcmV0dXJuICdlcnJvcic7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5WYXJpYWJsZVdpdGhCcmFjZXMoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBjaDtcbiAgICB3aGlsZSAoKGNoID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgaWYgKGNoID09PSAnfScpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJ3ZhcmlhYmxlLTInO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5NdWx0aVN0cmluZyhzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIHF1b3RlID0gc3RhdGUuc3RhcnRRdW90ZTtcbiAgICBpZiAoc3RyZWFtLnNvbCgpICYmIHN0cmVhbS5tYXRjaChuZXcgUmVnRXhwKHF1b3RlICsgJ0AnKSkpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgIH1cbiAgICBlbHNlIGlmIChxdW90ZSA9PT0gJ1wiJykge1xuICAgICAgd2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcbiAgICAgICAgdmFyIGNoID0gc3RyZWFtLnBlZWsoKTtcbiAgICAgICAgaWYgKGNoID09PSAnJCcpIHtcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuSGVyZVN0cmluZ0ludGVycG9sYXRpb247XG4gICAgICAgICAgcmV0dXJuICdzdHJpbmcnO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgaWYgKGNoID09PSAnYCcpIHtcbiAgICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgIH1cblxuICAgIHJldHVybiAnc3RyaW5nJztcbiAgfVxuXG4gIHZhciBleHRlcm5hbCA9IHtcbiAgICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJldHVyblN0YWNrOiBbXSxcbiAgICAgICAgYnJhY2tldE5lc3Rpbmc6IDAsXG4gICAgICAgIHRva2VuaXplOiB0b2tlbkJhc2VcbiAgICAgIH07XG4gICAgfSxcblxuICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSxcblxuICAgIGJsb2NrQ29tbWVudFN0YXJ0OiAnPCMnLFxuICAgIGJsb2NrQ29tbWVudEVuZDogJyM+JyxcbiAgICBsaW5lQ29tbWVudDogJyMnLFxuICAgIGZvbGQ6ICdicmFjZSdcbiAgfTtcbiAgcmV0dXJuIGV4dGVybmFsO1xufSk7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTUlNRSgnYXBwbGljYXRpb24veC1wb3dlcnNoZWxsJywgJ3Bvd2Vyc2hlbGwnKTtcbn0pO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcblwidXNlIHN0cmljdFwiO1xuXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoXCJwcm9wZXJ0aWVzXCIsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgc29sID0gc3RyZWFtLnNvbCgpIHx8IHN0YXRlLmFmdGVyU2VjdGlvbjtcbiAgICAgIHZhciBlb2wgPSBzdHJlYW0uZW9sKCk7XG5cbiAgICAgIHN0YXRlLmFmdGVyU2VjdGlvbiA9IGZhbHNlO1xuXG4gICAgICBpZiAoc29sKSB7XG4gICAgICAgIGlmIChzdGF0ZS5uZXh0TXVsdGlsaW5lKSB7XG4gICAgICAgICAgc3RhdGUuaW5NdWx0aWxpbmUgPSB0cnVlO1xuICAgICAgICAgIHN0YXRlLm5leHRNdWx0aWxpbmUgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS5wb3NpdGlvbiA9IFwiZGVmXCI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGVvbCAmJiAhIHN0YXRlLm5leHRNdWx0aWxpbmUpIHtcbiAgICAgICAgc3RhdGUuaW5NdWx0aWxpbmUgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUucG9zaXRpb24gPSBcImRlZlwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoc29sKSB7XG4gICAgICAgIHdoaWxlKHN0cmVhbS5lYXRTcGFjZSgpKSB7fVxuICAgICAgfVxuXG4gICAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuXG4gICAgICBpZiAoc29sICYmIChjaCA9PT0gXCIjXCIgfHwgY2ggPT09IFwiIVwiIHx8IGNoID09PSBcIjtcIikpIHtcbiAgICAgICAgc3RhdGUucG9zaXRpb24gPSBcImNvbW1lbnRcIjtcbiAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgICB9IGVsc2UgaWYgKHNvbCAmJiBjaCA9PT0gXCJbXCIpIHtcbiAgICAgICAgc3RhdGUuYWZ0ZXJTZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgc3RyZWFtLnNraXBUbyhcIl1cIik7IHN0cmVhbS5lYXQoXCJdXCIpO1xuICAgICAgICByZXR1cm4gXCJoZWFkZXJcIjtcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT09IFwiPVwiIHx8IGNoID09PSBcIjpcIikge1xuICAgICAgICBzdGF0ZS5wb3NpdGlvbiA9IFwicXVvdGVcIjtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2UgaWYgKGNoID09PSBcIlxcXFxcIiAmJiBzdGF0ZS5wb3NpdGlvbiA9PT0gXCJxdW90ZVwiKSB7XG4gICAgICAgIGlmIChzdHJlYW0uZW9sKCkpIHsgIC8vIGVuZCBvZiBsaW5lP1xuICAgICAgICAgIC8vIE11bHRpbGluZSB2YWx1ZVxuICAgICAgICAgIHN0YXRlLm5leHRNdWx0aWxpbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGF0ZS5wb3NpdGlvbjtcbiAgICB9LFxuXG4gICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb3NpdGlvbiA6IFwiZGVmXCIsICAgICAgIC8vIEN1cnJlbnQgcG9zaXRpb24sIFwiZGVmXCIsIFwicXVvdGVcIiBvciBcImNvbW1lbnRcIlxuICAgICAgICBuZXh0TXVsdGlsaW5lIDogZmFsc2UsICAvLyBJcyB0aGUgbmV4dCBsaW5lIG11bHRpbGluZSB2YWx1ZVxuICAgICAgICBpbk11bHRpbGluZSA6IGZhbHNlLCAgICAvLyBJcyB0aGUgY3VycmVudCBsaW5lIGEgbXVsdGlsaW5lIHZhbHVlXG4gICAgICAgIGFmdGVyU2VjdGlvbiA6IGZhbHNlICAgIC8vIERpZCB3ZSBqdXN0IG9wZW4gYSBzZWN0aW9uXG4gICAgICB9O1xuICAgIH1cblxuICB9O1xufSk7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQveC1wcm9wZXJ0aWVzXCIsIFwicHJvcGVydGllc1wiKTtcbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQveC1pbmlcIiwgXCJwcm9wZXJ0aWVzXCIpO1xuXG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGZ1bmN0aW9uIHdvcmRSZWdleHAod29yZHMpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChcIl4oKFwiICsgd29yZHMuam9pbihcIil8KFwiKSArIFwiKSlcXFxcYlwiLCBcImlcIik7XG4gIH07XG5cbiAgdmFyIGtleXdvcmRBcnJheSA9IFtcbiAgICBcInBhY2thZ2VcIiwgXCJtZXNzYWdlXCIsIFwiaW1wb3J0XCIsIFwic3ludGF4XCIsXG4gICAgXCJyZXF1aXJlZFwiLCBcIm9wdGlvbmFsXCIsIFwicmVwZWF0ZWRcIiwgXCJyZXNlcnZlZFwiLCBcImRlZmF1bHRcIiwgXCJleHRlbnNpb25zXCIsIFwicGFja2VkXCIsXG4gICAgXCJib29sXCIsIFwiYnl0ZXNcIiwgXCJkb3VibGVcIiwgXCJlbnVtXCIsIFwiZmxvYXRcIiwgXCJzdHJpbmdcIixcbiAgICBcImludDMyXCIsIFwiaW50NjRcIiwgXCJ1aW50MzJcIiwgXCJ1aW50NjRcIiwgXCJzaW50MzJcIiwgXCJzaW50NjRcIiwgXCJmaXhlZDMyXCIsIFwiZml4ZWQ2NFwiLCBcInNmaXhlZDMyXCIsIFwic2ZpeGVkNjRcIixcbiAgICBcIm9wdGlvblwiLCBcInNlcnZpY2VcIiwgXCJycGNcIiwgXCJyZXR1cm5zXCJcbiAgXTtcbiAgdmFyIGtleXdvcmRzID0gd29yZFJlZ2V4cChrZXl3b3JkQXJyYXkpO1xuXG4gIENvZGVNaXJyb3IucmVnaXN0ZXJIZWxwZXIoXCJoaW50V29yZHNcIiwgXCJwcm90b2J1ZlwiLCBrZXl3b3JkQXJyYXkpO1xuXG4gIHZhciBpZGVudGlmaWVycyA9IG5ldyBSZWdFeHAoXCJeW19BLVphLXpcXHhhMS1cXHVmZmZmXVtfQS1aYS16MC05XFx4YTEtXFx1ZmZmZl0qXCIpO1xuXG4gIGZ1bmN0aW9uIHRva2VuQmFzZShzdHJlYW0pIHtcbiAgICAvLyB3aGl0ZXNwYWNlc1xuICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkgcmV0dXJuIG51bGw7XG5cbiAgICAvLyBIYW5kbGUgb25lIGxpbmUgQ29tbWVudHNcbiAgICBpZiAoc3RyZWFtLm1hdGNoKFwiLy9cIikpIHtcbiAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgTnVtYmVyIExpdGVyYWxzXG4gICAgaWYgKHN0cmVhbS5tYXRjaCgvXlswLTlcXC4rLV0vLCBmYWxzZSkpIHtcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goL15bKy1dPzB4WzAtOWEtZkEtRl0rLykpXG4gICAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXlsrLV0/XFxkKlxcLlxcZCsoW0VlRGRdWystXT9cXGQrKT8vKSlcbiAgICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eWystXT9cXGQrKFtFZURkXVsrLV0/XFxkKyk/LykpXG4gICAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBTdHJpbmdzXG4gICAgaWYgKHN0cmVhbS5tYXRjaCgvXlwiKFteXCJdfChcIlwiKSkqXCIvKSkgeyByZXR1cm4gXCJzdHJpbmdcIjsgfVxuICAgIGlmIChzdHJlYW0ubWF0Y2goL14nKFteJ118KCcnKSkqJy8pKSB7IHJldHVybiBcInN0cmluZ1wiOyB9XG5cbiAgICAvLyBIYW5kbGUgd29yZHNcbiAgICBpZiAoc3RyZWFtLm1hdGNoKGtleXdvcmRzKSkgeyByZXR1cm4gXCJrZXl3b3JkXCI7IH1cbiAgICBpZiAoc3RyZWFtLm1hdGNoKGlkZW50aWZpZXJzKSkgeyByZXR1cm4gXCJ2YXJpYWJsZVwiOyB9IDtcblxuICAgIC8vIEhhbmRsZSBub24tZGV0ZWN0ZWQgaXRlbXNcbiAgICBzdHJlYW0ubmV4dCgpO1xuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lTW9kZShcInByb3RvYnVmXCIsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0b2tlbjogdG9rZW5CYXNlLFxuICAgICAgZm9sZDogXCJicmFjZVwiXG4gICAgfTtcbiAgfSk7XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LXByb3RvYnVmXCIsIFwicHJvdG9idWZcIik7XG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIiksIHJlcXVpcmUoXCIuLi9qYXZhc2NyaXB0L2phdmFzY3JpcHRcIiksIHJlcXVpcmUoXCIuLi9jc3MvY3NzXCIpLCByZXF1aXJlKFwiLi4vaHRtbG1peGVkL2h0bWxtaXhlZFwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiLCBcIi4uL2phdmFzY3JpcHQvamF2YXNjcmlwdFwiLCBcIi4uL2Nzcy9jc3NcIiwgXCIuLi9odG1sbWl4ZWQvaHRtbG1peGVkXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTW9kZShcInB1Z1wiLCBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIC8vIHRva2VuIHR5cGVzXG4gIHZhciBLRVlXT1JEID0gJ2tleXdvcmQnO1xuICB2YXIgRE9DVFlQRSA9ICdtZXRhJztcbiAgdmFyIElEID0gJ2J1aWx0aW4nO1xuICB2YXIgQ0xBU1MgPSAncXVhbGlmaWVyJztcblxuICB2YXIgQVRUUlNfTkVTVCA9IHtcbiAgICAneyc6ICd9JyxcbiAgICAnKCc6ICcpJyxcbiAgICAnWyc6ICddJ1xuICB9O1xuXG4gIHZhciBqc01vZGUgPSBDb2RlTWlycm9yLmdldE1vZGUoY29uZmlnLCAnamF2YXNjcmlwdCcpO1xuXG4gIGZ1bmN0aW9uIFN0YXRlKCkge1xuICAgIHRoaXMuamF2YVNjcmlwdExpbmUgPSBmYWxzZTtcbiAgICB0aGlzLmphdmFTY3JpcHRMaW5lRXhjbHVkZXNDb2xvbiA9IGZhbHNlO1xuXG4gICAgdGhpcy5qYXZhU2NyaXB0QXJndW1lbnRzID0gZmFsc2U7XG4gICAgdGhpcy5qYXZhU2NyaXB0QXJndW1lbnRzRGVwdGggPSAwO1xuXG4gICAgdGhpcy5pc0ludGVycG9sYXRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmludGVycG9sYXRpb25OZXN0aW5nID0gMDtcblxuICAgIHRoaXMuanNTdGF0ZSA9IENvZGVNaXJyb3Iuc3RhcnRTdGF0ZShqc01vZGUpO1xuXG4gICAgdGhpcy5yZXN0T2ZMaW5lID0gJyc7XG5cbiAgICB0aGlzLmlzSW5jbHVkZUZpbHRlcmVkID0gZmFsc2U7XG4gICAgdGhpcy5pc0VhY2ggPSBmYWxzZTtcblxuICAgIHRoaXMubGFzdFRhZyA9ICcnO1xuICAgIHRoaXMuc2NyaXB0VHlwZSA9ICcnO1xuXG4gICAgLy8gQXR0cmlidXRlcyBNb2RlXG4gICAgdGhpcy5pc0F0dHJzID0gZmFsc2U7XG4gICAgdGhpcy5hdHRyc05lc3QgPSBbXTtcbiAgICB0aGlzLmluQXR0cmlidXRlTmFtZSA9IHRydWU7XG4gICAgdGhpcy5hdHRyaWJ1dGVJc1R5cGUgPSBmYWxzZTtcbiAgICB0aGlzLmF0dHJWYWx1ZSA9ICcnO1xuXG4gICAgLy8gSW5kZW50ZWQgTW9kZVxuICAgIHRoaXMuaW5kZW50T2YgPSBJbmZpbml0eTtcbiAgICB0aGlzLmluZGVudFRva2VuID0gJyc7XG5cbiAgICB0aGlzLmlubmVyTW9kZSA9IG51bGw7XG4gICAgdGhpcy5pbm5lclN0YXRlID0gbnVsbDtcblxuICAgIHRoaXMuaW5uZXJNb2RlRm9yTGluZSA9IGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBTYWZlbHkgY29weSBhIHN0YXRlXG4gICAqXG4gICAqIEByZXR1cm4ge1N0YXRlfVxuICAgKi9cbiAgU3RhdGUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlcyA9IG5ldyBTdGF0ZSgpO1xuICAgIHJlcy5qYXZhU2NyaXB0TGluZSA9IHRoaXMuamF2YVNjcmlwdExpbmU7XG4gICAgcmVzLmphdmFTY3JpcHRMaW5lRXhjbHVkZXNDb2xvbiA9IHRoaXMuamF2YVNjcmlwdExpbmVFeGNsdWRlc0NvbG9uO1xuICAgIHJlcy5qYXZhU2NyaXB0QXJndW1lbnRzID0gdGhpcy5qYXZhU2NyaXB0QXJndW1lbnRzO1xuICAgIHJlcy5qYXZhU2NyaXB0QXJndW1lbnRzRGVwdGggPSB0aGlzLmphdmFTY3JpcHRBcmd1bWVudHNEZXB0aDtcbiAgICByZXMuaXNJbnRlcnBvbGF0aW5nID0gdGhpcy5pc0ludGVycG9sYXRpbmc7XG4gICAgcmVzLmludGVycG9sYXRpb25OZXN0aW5nID0gdGhpcy5pbnRlcnBvbGF0aW9uTmVzdGluZztcblxuICAgIHJlcy5qc1N0YXRlID0gQ29kZU1pcnJvci5jb3B5U3RhdGUoanNNb2RlLCB0aGlzLmpzU3RhdGUpO1xuXG4gICAgcmVzLmlubmVyTW9kZSA9IHRoaXMuaW5uZXJNb2RlO1xuICAgIGlmICh0aGlzLmlubmVyTW9kZSAmJiB0aGlzLmlubmVyU3RhdGUpIHtcbiAgICAgIHJlcy5pbm5lclN0YXRlID0gQ29kZU1pcnJvci5jb3B5U3RhdGUodGhpcy5pbm5lck1vZGUsIHRoaXMuaW5uZXJTdGF0ZSk7XG4gICAgfVxuXG4gICAgcmVzLnJlc3RPZkxpbmUgPSB0aGlzLnJlc3RPZkxpbmU7XG5cbiAgICByZXMuaXNJbmNsdWRlRmlsdGVyZWQgPSB0aGlzLmlzSW5jbHVkZUZpbHRlcmVkO1xuICAgIHJlcy5pc0VhY2ggPSB0aGlzLmlzRWFjaDtcbiAgICByZXMubGFzdFRhZyA9IHRoaXMubGFzdFRhZztcbiAgICByZXMuc2NyaXB0VHlwZSA9IHRoaXMuc2NyaXB0VHlwZTtcbiAgICByZXMuaXNBdHRycyA9IHRoaXMuaXNBdHRycztcbiAgICByZXMuYXR0cnNOZXN0ID0gdGhpcy5hdHRyc05lc3Quc2xpY2UoKTtcbiAgICByZXMuaW5BdHRyaWJ1dGVOYW1lID0gdGhpcy5pbkF0dHJpYnV0ZU5hbWU7XG4gICAgcmVzLmF0dHJpYnV0ZUlzVHlwZSA9IHRoaXMuYXR0cmlidXRlSXNUeXBlO1xuICAgIHJlcy5hdHRyVmFsdWUgPSB0aGlzLmF0dHJWYWx1ZTtcbiAgICByZXMuaW5kZW50T2YgPSB0aGlzLmluZGVudE9mO1xuICAgIHJlcy5pbmRlbnRUb2tlbiA9IHRoaXMuaW5kZW50VG9rZW47XG5cbiAgICByZXMuaW5uZXJNb2RlRm9yTGluZSA9IHRoaXMuaW5uZXJNb2RlRm9yTGluZTtcblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgZnVuY3Rpb24gamF2YVNjcmlwdChzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHN0cmVhbS5zb2woKSkge1xuICAgICAgLy8gaWYgamF2YVNjcmlwdExpbmUgd2FzIHNldCBhdCBlbmQgb2YgbGluZSwgaWdub3JlIGl0XG4gICAgICBzdGF0ZS5qYXZhU2NyaXB0TGluZSA9IGZhbHNlO1xuICAgICAgc3RhdGUuamF2YVNjcmlwdExpbmVFeGNsdWRlc0NvbG9uID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5qYXZhU2NyaXB0TGluZSkge1xuICAgICAgaWYgKHN0YXRlLmphdmFTY3JpcHRMaW5lRXhjbHVkZXNDb2xvbiAmJiBzdHJlYW0ucGVlaygpID09PSAnOicpIHtcbiAgICAgICAgc3RhdGUuamF2YVNjcmlwdExpbmUgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUuamF2YVNjcmlwdExpbmVFeGNsdWRlc0NvbG9uID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB0b2sgPSBqc01vZGUudG9rZW4oc3RyZWFtLCBzdGF0ZS5qc1N0YXRlKTtcbiAgICAgIGlmIChzdHJlYW0uZW9sKCkpIHN0YXRlLmphdmFTY3JpcHRMaW5lID0gZmFsc2U7XG4gICAgICByZXR1cm4gdG9rIHx8IHRydWU7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGphdmFTY3JpcHRBcmd1bWVudHMoc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5qYXZhU2NyaXB0QXJndW1lbnRzKSB7XG4gICAgICBpZiAoc3RhdGUuamF2YVNjcmlwdEFyZ3VtZW50c0RlcHRoID09PSAwICYmIHN0cmVhbS5wZWVrKCkgIT09ICcoJykge1xuICAgICAgICBzdGF0ZS5qYXZhU2NyaXB0QXJndW1lbnRzID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChzdHJlYW0ucGVlaygpID09PSAnKCcpIHtcbiAgICAgICAgc3RhdGUuamF2YVNjcmlwdEFyZ3VtZW50c0RlcHRoKys7XG4gICAgICB9IGVsc2UgaWYgKHN0cmVhbS5wZWVrKCkgPT09ICcpJykge1xuICAgICAgICBzdGF0ZS5qYXZhU2NyaXB0QXJndW1lbnRzRGVwdGgtLTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5qYXZhU2NyaXB0QXJndW1lbnRzRGVwdGggPT09IDApIHtcbiAgICAgICAgc3RhdGUuamF2YVNjcmlwdEFyZ3VtZW50cyA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0b2sgPSBqc01vZGUudG9rZW4oc3RyZWFtLCBzdGF0ZS5qc1N0YXRlKTtcbiAgICAgIHJldHVybiB0b2sgfHwgdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB5aWVsZFN0YXRlbWVudChzdHJlYW0pIHtcbiAgICBpZiAoc3RyZWFtLm1hdGNoKC9eeWllbGRcXGIvKSkge1xuICAgICAgICByZXR1cm4gJ2tleXdvcmQnO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRvY3R5cGUoc3RyZWFtKSB7XG4gICAgaWYgKHN0cmVhbS5tYXRjaCgvXig/OmRvY3R5cGUpICooW15cXG5dKyk/LykpIHtcbiAgICAgICAgcmV0dXJuIERPQ1RZUEU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW50ZXJwb2xhdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHN0cmVhbS5tYXRjaCgnI3snKSkge1xuICAgICAgc3RhdGUuaXNJbnRlcnBvbGF0aW5nID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmludGVycG9sYXRpb25OZXN0aW5nID0gMDtcbiAgICAgIHJldHVybiAncHVuY3R1YXRpb24nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludGVycG9sYXRpb25Db250aW51ZWQoc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5pc0ludGVycG9sYXRpbmcpIHtcbiAgICAgIGlmIChzdHJlYW0ucGVlaygpID09PSAnfScpIHtcbiAgICAgICAgc3RhdGUuaW50ZXJwb2xhdGlvbk5lc3RpbmctLTtcbiAgICAgICAgaWYgKHN0YXRlLmludGVycG9sYXRpb25OZXN0aW5nIDwgMCkge1xuICAgICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgICAgc3RhdGUuaXNJbnRlcnBvbGF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuICdwdW5jdHVhdGlvbic7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLnBlZWsoKSA9PT0gJ3snKSB7XG4gICAgICAgIHN0YXRlLmludGVycG9sYXRpb25OZXN0aW5nKys7XG4gICAgICB9XG4gICAgICByZXR1cm4ganNNb2RlLnRva2VuKHN0cmVhbSwgc3RhdGUuanNTdGF0ZSkgfHwgdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjYXNlU3RhdGVtZW50KHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RyZWFtLm1hdGNoKC9eY2FzZVxcYi8pKSB7XG4gICAgICBzdGF0ZS5qYXZhU2NyaXB0TGluZSA9IHRydWU7XG4gICAgICByZXR1cm4gS0VZV09SRDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB3aGVuKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RyZWFtLm1hdGNoKC9ed2hlblxcYi8pKSB7XG4gICAgICBzdGF0ZS5qYXZhU2NyaXB0TGluZSA9IHRydWU7XG4gICAgICBzdGF0ZS5qYXZhU2NyaXB0TGluZUV4Y2x1ZGVzQ29sb24gPSB0cnVlO1xuICAgICAgcmV0dXJuIEtFWVdPUkQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVmYXVsdFN0YXRlbWVudChzdHJlYW0pIHtcbiAgICBpZiAoc3RyZWFtLm1hdGNoKC9eZGVmYXVsdFxcYi8pKSB7XG4gICAgICByZXR1cm4gS0VZV09SRDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBleHRlbmRzU3RhdGVtZW50KHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RyZWFtLm1hdGNoKC9eZXh0ZW5kcz9cXGIvKSkge1xuICAgICAgc3RhdGUucmVzdE9mTGluZSA9ICdzdHJpbmcnO1xuICAgICAgcmV0dXJuIEtFWVdPUkQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYXBwZW5kKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RyZWFtLm1hdGNoKC9eYXBwZW5kXFxiLykpIHtcbiAgICAgIHN0YXRlLnJlc3RPZkxpbmUgPSAndmFyaWFibGUnO1xuICAgICAgcmV0dXJuIEtFWVdPUkQ7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHByZXBlbmQoc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmIChzdHJlYW0ubWF0Y2goL15wcmVwZW5kXFxiLykpIHtcbiAgICAgIHN0YXRlLnJlc3RPZkxpbmUgPSAndmFyaWFibGUnO1xuICAgICAgcmV0dXJuIEtFWVdPUkQ7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGJsb2NrKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RyZWFtLm1hdGNoKC9eYmxvY2tcXGIgKig/OihwcmVwZW5kfGFwcGVuZClcXGIpPy8pKSB7XG4gICAgICBzdGF0ZS5yZXN0T2ZMaW5lID0gJ3ZhcmlhYmxlJztcbiAgICAgIHJldHVybiBLRVlXT1JEO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluY2x1ZGUoc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmIChzdHJlYW0ubWF0Y2goL15pbmNsdWRlXFxiLykpIHtcbiAgICAgIHN0YXRlLnJlc3RPZkxpbmUgPSAnc3RyaW5nJztcbiAgICAgIHJldHVybiBLRVlXT1JEO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluY2x1ZGVGaWx0ZXJlZChzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHN0cmVhbS5tYXRjaCgvXmluY2x1ZGU6KFthLXpBLVowLTlcXC1dKykvLCBmYWxzZSkgJiYgc3RyZWFtLm1hdGNoKCdpbmNsdWRlJykpIHtcbiAgICAgIHN0YXRlLmlzSW5jbHVkZUZpbHRlcmVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBLRVlXT1JEO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluY2x1ZGVGaWx0ZXJlZENvbnRpbnVlZChzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmlzSW5jbHVkZUZpbHRlcmVkKSB7XG4gICAgICB2YXIgdG9rID0gZmlsdGVyKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgc3RhdGUuaXNJbmNsdWRlRmlsdGVyZWQgPSBmYWxzZTtcbiAgICAgIHN0YXRlLnJlc3RPZkxpbmUgPSAnc3RyaW5nJztcbiAgICAgIHJldHVybiB0b2s7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWl4aW4oc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmIChzdHJlYW0ubWF0Y2goL15taXhpblxcYi8pKSB7XG4gICAgICBzdGF0ZS5qYXZhU2NyaXB0TGluZSA9IHRydWU7XG4gICAgICByZXR1cm4gS0VZV09SRDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjYWxsKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RyZWFtLm1hdGNoKC9eXFwrKFstXFx3XSspLykpIHtcbiAgICAgIGlmICghc3RyZWFtLm1hdGNoKC9eXFwoICpbLVxcd10rICo9LywgZmFsc2UpKSB7XG4gICAgICAgIHN0YXRlLmphdmFTY3JpcHRBcmd1bWVudHMgPSB0cnVlO1xuICAgICAgICBzdGF0ZS5qYXZhU2NyaXB0QXJndW1lbnRzRGVwdGggPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuICd2YXJpYWJsZSc7XG4gICAgfVxuICAgIGlmIChzdHJlYW0ubWF0Y2goJysjeycsIGZhbHNlKSkge1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHN0YXRlLm1peGluQ2FsbEFmdGVyID0gdHJ1ZTtcbiAgICAgIHJldHVybiBpbnRlcnBvbGF0aW9uKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjYWxsQXJndW1lbnRzKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUubWl4aW5DYWxsQWZ0ZXIpIHtcbiAgICAgIHN0YXRlLm1peGluQ2FsbEFmdGVyID0gZmFsc2U7XG4gICAgICBpZiAoIXN0cmVhbS5tYXRjaCgvXlxcKCAqWy1cXHddKyAqPS8sIGZhbHNlKSkge1xuICAgICAgICBzdGF0ZS5qYXZhU2NyaXB0QXJndW1lbnRzID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUuamF2YVNjcmlwdEFyZ3VtZW50c0RlcHRoID0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbmRpdGlvbmFsKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RyZWFtLm1hdGNoKC9eKGlmfHVubGVzc3xlbHNlIGlmfGVsc2UpXFxiLykpIHtcbiAgICAgIHN0YXRlLmphdmFTY3JpcHRMaW5lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBLRVlXT1JEO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVhY2goc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmIChzdHJlYW0ubWF0Y2goL14oLSAqKT8oZWFjaHxmb3IpXFxiLykpIHtcbiAgICAgIHN0YXRlLmlzRWFjaCA9IHRydWU7XG4gICAgICByZXR1cm4gS0VZV09SRDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZWFjaENvbnRpbnVlZChzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmlzRWFjaCkge1xuICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXiBpblxcYi8pKSB7XG4gICAgICAgIHN0YXRlLmphdmFTY3JpcHRMaW5lID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUuaXNFYWNoID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBLRVlXT1JEO1xuICAgICAgfSBlbHNlIGlmIChzdHJlYW0uc29sKCkgfHwgc3RyZWFtLmVvbCgpKSB7XG4gICAgICAgIHN0YXRlLmlzRWFjaCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubmV4dCgpKSB7XG4gICAgICAgIHdoaWxlICghc3RyZWFtLm1hdGNoKC9eIGluXFxiLywgZmFsc2UpICYmIHN0cmVhbS5uZXh0KCkpO1xuICAgICAgICByZXR1cm4gJ3ZhcmlhYmxlJztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB3aGlsZVN0YXRlbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHN0cmVhbS5tYXRjaCgvXndoaWxlXFxiLykpIHtcbiAgICAgIHN0YXRlLmphdmFTY3JpcHRMaW5lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBLRVlXT1JEO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRhZyhzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGNhcHR1cmVzO1xuICAgIGlmIChjYXB0dXJlcyA9IHN0cmVhbS5tYXRjaCgvXihcXHcoPzpbLTpcXHddKlxcdyk/KVxcLz8vKSkge1xuICAgICAgc3RhdGUubGFzdFRhZyA9IGNhcHR1cmVzWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoc3RhdGUubGFzdFRhZyA9PT0gJ3NjcmlwdCcpIHtcbiAgICAgICAgc3RhdGUuc2NyaXB0VHlwZSA9ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JztcbiAgICAgIH1cbiAgICAgIHJldHVybiAndGFnJztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaWx0ZXIoc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmIChzdHJlYW0ubWF0Y2goL146KFtcXHdcXC1dKykvKSkge1xuICAgICAgdmFyIGlubmVyTW9kZTtcbiAgICAgIGlmIChjb25maWcgJiYgY29uZmlnLmlubmVyTW9kZXMpIHtcbiAgICAgICAgaW5uZXJNb2RlID0gY29uZmlnLmlubmVyTW9kZXMoc3RyZWFtLmN1cnJlbnQoKS5zdWJzdHJpbmcoMSkpO1xuICAgICAgfVxuICAgICAgaWYgKCFpbm5lck1vZGUpIHtcbiAgICAgICAgaW5uZXJNb2RlID0gc3RyZWFtLmN1cnJlbnQoKS5zdWJzdHJpbmcoMSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGlubmVyTW9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaW5uZXJNb2RlID0gQ29kZU1pcnJvci5nZXRNb2RlKGNvbmZpZywgaW5uZXJNb2RlKTtcbiAgICAgIH1cbiAgICAgIHNldElubmVyTW9kZShzdHJlYW0sIHN0YXRlLCBpbm5lck1vZGUpO1xuICAgICAgcmV0dXJuICdhdG9tJztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb2RlKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RyZWFtLm1hdGNoKC9eKCE/PXwtKS8pKSB7XG4gICAgICBzdGF0ZS5qYXZhU2NyaXB0TGluZSA9IHRydWU7XG4gICAgICByZXR1cm4gJ3B1bmN0dWF0aW9uJztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpZChzdHJlYW0pIHtcbiAgICBpZiAoc3RyZWFtLm1hdGNoKC9eIyhbXFx3LV0rKS8pKSB7XG4gICAgICByZXR1cm4gSUQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xhc3NOYW1lKHN0cmVhbSkge1xuICAgIGlmIChzdHJlYW0ubWF0Y2goL15cXC4oW1xcdy1dKykvKSkge1xuICAgICAgcmV0dXJuIENMQVNTO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGF0dHJzKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RyZWFtLnBlZWsoKSA9PSAnKCcpIHtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICBzdGF0ZS5pc0F0dHJzID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmF0dHJzTmVzdCA9IFtdO1xuICAgICAgc3RhdGUuaW5BdHRyaWJ1dGVOYW1lID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmF0dHJWYWx1ZSA9ICcnO1xuICAgICAgc3RhdGUuYXR0cmlidXRlSXNUeXBlID0gZmFsc2U7XG4gICAgICByZXR1cm4gJ3B1bmN0dWF0aW9uJztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhdHRyc0NvbnRpbnVlZChzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmlzQXR0cnMpIHtcbiAgICAgIGlmIChBVFRSU19ORVNUW3N0cmVhbS5wZWVrKCldKSB7XG4gICAgICAgIHN0YXRlLmF0dHJzTmVzdC5wdXNoKEFUVFJTX05FU1Rbc3RyZWFtLnBlZWsoKV0pO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmF0dHJzTmVzdFtzdGF0ZS5hdHRyc05lc3QubGVuZ3RoIC0gMV0gPT09IHN0cmVhbS5wZWVrKCkpIHtcbiAgICAgICAgc3RhdGUuYXR0cnNOZXN0LnBvcCgpO1xuICAgICAgfSBlbHNlICBpZiAoc3RyZWFtLmVhdCgnKScpKSB7XG4gICAgICAgIHN0YXRlLmlzQXR0cnMgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuICdwdW5jdHVhdGlvbic7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuaW5BdHRyaWJ1dGVOYW1lICYmIHN0cmVhbS5tYXRjaCgvXltePSxcXCkhXSsvKSkge1xuICAgICAgICBpZiAoc3RyZWFtLnBlZWsoKSA9PT0gJz0nIHx8IHN0cmVhbS5wZWVrKCkgPT09ICchJykge1xuICAgICAgICAgIHN0YXRlLmluQXR0cmlidXRlTmFtZSA9IGZhbHNlO1xuICAgICAgICAgIHN0YXRlLmpzU3RhdGUgPSBDb2RlTWlycm9yLnN0YXJ0U3RhdGUoanNNb2RlKTtcbiAgICAgICAgICBpZiAoc3RhdGUubGFzdFRhZyA9PT0gJ3NjcmlwdCcgJiYgc3RyZWFtLmN1cnJlbnQoKS50cmltKCkudG9Mb3dlckNhc2UoKSA9PT0gJ3R5cGUnKSB7XG4gICAgICAgICAgICBzdGF0ZS5hdHRyaWJ1dGVJc1R5cGUgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5hdHRyaWJ1dGVJc1R5cGUgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdhdHRyaWJ1dGUnO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG9rID0ganNNb2RlLnRva2VuKHN0cmVhbSwgc3RhdGUuanNTdGF0ZSk7XG4gICAgICBpZiAoc3RhdGUuYXR0cmlidXRlSXNUeXBlICYmIHRvayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgc3RhdGUuc2NyaXB0VHlwZSA9IHN0cmVhbS5jdXJyZW50KCkudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5hdHRyc05lc3QubGVuZ3RoID09PSAwICYmICh0b2sgPT09ICdzdHJpbmcnIHx8IHRvayA9PT0gJ3ZhcmlhYmxlJyB8fCB0b2sgPT09ICdrZXl3b3JkJykpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBGdW5jdGlvbignJywgJ3ZhciB4ICcgKyBzdGF0ZS5hdHRyVmFsdWUucmVwbGFjZSgvLFxccyokLywgJycpLnJlcGxhY2UoL14hLywgJycpKTtcbiAgICAgICAgICBzdGF0ZS5pbkF0dHJpYnV0ZU5hbWUgPSB0cnVlO1xuICAgICAgICAgIHN0YXRlLmF0dHJWYWx1ZSA9ICcnO1xuICAgICAgICAgIHN0cmVhbS5iYWNrVXAoc3RyZWFtLmN1cnJlbnQoKS5sZW5ndGgpO1xuICAgICAgICAgIHJldHVybiBhdHRyc0NvbnRpbnVlZChzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAvL25vdCB0aGUgZW5kIG9mIGFuIGF0dHJpYnV0ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGF0ZS5hdHRyVmFsdWUgKz0gc3RyZWFtLmN1cnJlbnQoKTtcbiAgICAgIHJldHVybiB0b2sgfHwgdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhdHRyaWJ1dGVzQmxvY2soc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmIChzdHJlYW0ubWF0Y2goL14mYXR0cmlidXRlc1xcYi8pKSB7XG4gICAgICBzdGF0ZS5qYXZhU2NyaXB0QXJndW1lbnRzID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmphdmFTY3JpcHRBcmd1bWVudHNEZXB0aCA9IDA7XG4gICAgICByZXR1cm4gJ2tleXdvcmQnO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluZGVudChzdHJlYW0pIHtcbiAgICBpZiAoc3RyZWFtLnNvbCgpICYmIHN0cmVhbS5lYXRTcGFjZSgpKSB7XG4gICAgICByZXR1cm4gJ2luZGVudCc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHN0cmVhbS5tYXRjaCgvXiAqXFwvXFwvKC0pPyhbXlxcbl0qKS8pKSB7XG4gICAgICBzdGF0ZS5pbmRlbnRPZiA9IHN0cmVhbS5pbmRlbnRhdGlvbigpO1xuICAgICAgc3RhdGUuaW5kZW50VG9rZW4gPSAnY29tbWVudCc7XG4gICAgICByZXR1cm4gJ2NvbW1lbnQnO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbG9uKHN0cmVhbSkge1xuICAgIGlmIChzdHJlYW0ubWF0Y2goL146ICovKSkge1xuICAgICAgcmV0dXJuICdjb2xvbic7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdGV4dChzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHN0cmVhbS5tYXRjaCgvXig/OlxcfCA/fCApKFteXFxuXSspLykpIHtcbiAgICAgIHJldHVybiAnc3RyaW5nJztcbiAgICB9XG4gICAgaWYgKHN0cmVhbS5tYXRjaCgvXig8W15cXG5dKikvLCBmYWxzZSkpIHtcbiAgICAgIC8vIGh0bWwgc3RyaW5nXG4gICAgICBzZXRJbm5lck1vZGUoc3RyZWFtLCBzdGF0ZSwgJ2h0bWxtaXhlZCcpO1xuICAgICAgc3RhdGUuaW5uZXJNb2RlRm9yTGluZSA9IHRydWU7XG4gICAgICByZXR1cm4gaW5uZXJNb2RlKHN0cmVhbSwgc3RhdGUsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRvdChzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHN0cmVhbS5lYXQoJy4nKSkge1xuICAgICAgdmFyIGlubmVyTW9kZSA9IG51bGw7XG4gICAgICBpZiAoc3RhdGUubGFzdFRhZyA9PT0gJ3NjcmlwdCcgJiYgc3RhdGUuc2NyaXB0VHlwZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2phdmFzY3JpcHQnKSAhPSAtMSkge1xuICAgICAgICBpbm5lck1vZGUgPSBzdGF0ZS5zY3JpcHRUeXBlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXCJ8Jy9nLCAnJyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxhc3RUYWcgPT09ICdzdHlsZScpIHtcbiAgICAgICAgaW5uZXJNb2RlID0gJ2Nzcyc7XG4gICAgICB9XG4gICAgICBzZXRJbm5lck1vZGUoc3RyZWFtLCBzdGF0ZSwgaW5uZXJNb2RlKTtcbiAgICAgIHJldHVybiAnZG90JztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmYWlsKHN0cmVhbSkge1xuICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIHNldElubmVyTW9kZShzdHJlYW0sIHN0YXRlLCBtb2RlKSB7XG4gICAgbW9kZSA9IENvZGVNaXJyb3IubWltZU1vZGVzW21vZGVdIHx8IG1vZGU7XG4gICAgbW9kZSA9IGNvbmZpZy5pbm5lck1vZGVzID8gY29uZmlnLmlubmVyTW9kZXMobW9kZSkgfHwgbW9kZSA6IG1vZGU7XG4gICAgbW9kZSA9IENvZGVNaXJyb3IubWltZU1vZGVzW21vZGVdIHx8IG1vZGU7XG4gICAgbW9kZSA9IENvZGVNaXJyb3IuZ2V0TW9kZShjb25maWcsIG1vZGUpO1xuICAgIHN0YXRlLmluZGVudE9mID0gc3RyZWFtLmluZGVudGF0aW9uKCk7XG5cbiAgICBpZiAobW9kZSAmJiBtb2RlLm5hbWUgIT09ICdudWxsJykge1xuICAgICAgc3RhdGUuaW5uZXJNb2RlID0gbW9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuaW5kZW50VG9rZW4gPSAnc3RyaW5nJztcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaW5uZXJNb2RlKHN0cmVhbSwgc3RhdGUsIGZvcmNlKSB7XG4gICAgaWYgKHN0cmVhbS5pbmRlbnRhdGlvbigpID4gc3RhdGUuaW5kZW50T2YgfHwgKHN0YXRlLmlubmVyTW9kZUZvckxpbmUgJiYgIXN0cmVhbS5zb2woKSkgfHwgZm9yY2UpIHtcbiAgICAgIGlmIChzdGF0ZS5pbm5lck1vZGUpIHtcbiAgICAgICAgaWYgKCFzdGF0ZS5pbm5lclN0YXRlKSB7XG4gICAgICAgICAgc3RhdGUuaW5uZXJTdGF0ZSA9IHN0YXRlLmlubmVyTW9kZS5zdGFydFN0YXRlID8gQ29kZU1pcnJvci5zdGFydFN0YXRlKHN0YXRlLmlubmVyTW9kZSwgc3RyZWFtLmluZGVudGF0aW9uKCkpIDoge307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmVhbS5oaWRlRmlyc3RDaGFycyhzdGF0ZS5pbmRlbnRPZiArIDIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGUuaW5uZXJNb2RlLnRva2VuKHN0cmVhbSwgc3RhdGUuaW5uZXJTdGF0ZSkgfHwgdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgIHJldHVybiBzdGF0ZS5pbmRlbnRUb2tlbjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHN0cmVhbS5zb2woKSkge1xuICAgICAgc3RhdGUuaW5kZW50T2YgPSBJbmZpbml0eTtcbiAgICAgIHN0YXRlLmluZGVudFRva2VuID0gbnVsbDtcbiAgICAgIHN0YXRlLmlubmVyTW9kZSA9IG51bGw7XG4gICAgICBzdGF0ZS5pbm5lclN0YXRlID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcmVzdE9mTGluZShzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHN0cmVhbS5zb2woKSkge1xuICAgICAgLy8gaWYgcmVzdE9mTGluZSB3YXMgc2V0IGF0IGVuZCBvZiBsaW5lLCBpZ25vcmUgaXRcbiAgICAgIHN0YXRlLnJlc3RPZkxpbmUgPSAnJztcbiAgICB9XG4gICAgaWYgKHN0YXRlLnJlc3RPZkxpbmUpIHtcbiAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgIHZhciB0b2sgPSBzdGF0ZS5yZXN0T2ZMaW5lO1xuICAgICAgc3RhdGUucmVzdE9mTGluZSA9ICcnO1xuICAgICAgcmV0dXJuIHRvaztcbiAgICB9XG4gIH1cblxuXG4gIGZ1bmN0aW9uIHN0YXJ0U3RhdGUoKSB7XG4gICAgcmV0dXJuIG5ldyBTdGF0ZSgpO1xuICB9XG4gIGZ1bmN0aW9uIGNvcHlTdGF0ZShzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZS5jb3B5KCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgbmV4dCB0b2tlbiBpbiB0aGUgc3RyZWFtXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyZWFtfSBzdHJlYW1cbiAgICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAgICovXG4gIGZ1bmN0aW9uIG5leHRUb2tlbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIHRvayA9IGlubmVyTW9kZShzdHJlYW0sIHN0YXRlKVxuICAgICAgfHwgcmVzdE9mTGluZShzdHJlYW0sIHN0YXRlKVxuICAgICAgfHwgaW50ZXJwb2xhdGlvbkNvbnRpbnVlZChzdHJlYW0sIHN0YXRlKVxuICAgICAgfHwgaW5jbHVkZUZpbHRlcmVkQ29udGludWVkKHN0cmVhbSwgc3RhdGUpXG4gICAgICB8fCBlYWNoQ29udGludWVkKHN0cmVhbSwgc3RhdGUpXG4gICAgICB8fCBhdHRyc0NvbnRpbnVlZChzdHJlYW0sIHN0YXRlKVxuICAgICAgfHwgamF2YVNjcmlwdChzdHJlYW0sIHN0YXRlKVxuICAgICAgfHwgamF2YVNjcmlwdEFyZ3VtZW50cyhzdHJlYW0sIHN0YXRlKVxuICAgICAgfHwgY2FsbEFyZ3VtZW50cyhzdHJlYW0sIHN0YXRlKVxuXG4gICAgICB8fCB5aWVsZFN0YXRlbWVudChzdHJlYW0pXG4gICAgICB8fCBkb2N0eXBlKHN0cmVhbSlcbiAgICAgIHx8IGludGVycG9sYXRpb24oc3RyZWFtLCBzdGF0ZSlcbiAgICAgIHx8IGNhc2VTdGF0ZW1lbnQoc3RyZWFtLCBzdGF0ZSlcbiAgICAgIHx8IHdoZW4oc3RyZWFtLCBzdGF0ZSlcbiAgICAgIHx8IGRlZmF1bHRTdGF0ZW1lbnQoc3RyZWFtKVxuICAgICAgfHwgZXh0ZW5kc1N0YXRlbWVudChzdHJlYW0sIHN0YXRlKVxuICAgICAgfHwgYXBwZW5kKHN0cmVhbSwgc3RhdGUpXG4gICAgICB8fCBwcmVwZW5kKHN0cmVhbSwgc3RhdGUpXG4gICAgICB8fCBibG9jayhzdHJlYW0sIHN0YXRlKVxuICAgICAgfHwgaW5jbHVkZShzdHJlYW0sIHN0YXRlKVxuICAgICAgfHwgaW5jbHVkZUZpbHRlcmVkKHN0cmVhbSwgc3RhdGUpXG4gICAgICB8fCBtaXhpbihzdHJlYW0sIHN0YXRlKVxuICAgICAgfHwgY2FsbChzdHJlYW0sIHN0YXRlKVxuICAgICAgfHwgY29uZGl0aW9uYWwoc3RyZWFtLCBzdGF0ZSlcbiAgICAgIHx8IGVhY2goc3RyZWFtLCBzdGF0ZSlcbiAgICAgIHx8IHdoaWxlU3RhdGVtZW50KHN0cmVhbSwgc3RhdGUpXG4gICAgICB8fCB0YWcoc3RyZWFtLCBzdGF0ZSlcbiAgICAgIHx8IGZpbHRlcihzdHJlYW0sIHN0YXRlKVxuICAgICAgfHwgY29kZShzdHJlYW0sIHN0YXRlKVxuICAgICAgfHwgaWQoc3RyZWFtKVxuICAgICAgfHwgY2xhc3NOYW1lKHN0cmVhbSlcbiAgICAgIHx8IGF0dHJzKHN0cmVhbSwgc3RhdGUpXG4gICAgICB8fCBhdHRyaWJ1dGVzQmxvY2soc3RyZWFtLCBzdGF0ZSlcbiAgICAgIHx8IGluZGVudChzdHJlYW0pXG4gICAgICB8fCB0ZXh0KHN0cmVhbSwgc3RhdGUpXG4gICAgICB8fCBjb21tZW50KHN0cmVhbSwgc3RhdGUpXG4gICAgICB8fCBjb2xvbihzdHJlYW0pXG4gICAgICB8fCBkb3Qoc3RyZWFtLCBzdGF0ZSlcbiAgICAgIHx8IGZhaWwoc3RyZWFtKTtcblxuICAgIHJldHVybiB0b2sgPT09IHRydWUgPyBudWxsIDogdG9rO1xuICB9XG4gIHJldHVybiB7XG4gICAgc3RhcnRTdGF0ZTogc3RhcnRTdGF0ZSxcbiAgICBjb3B5U3RhdGU6IGNvcHlTdGF0ZSxcbiAgICB0b2tlbjogbmV4dFRva2VuXG4gIH07XG59LCAnamF2YXNjcmlwdCcsICdjc3MnLCAnaHRtbG1peGVkJyk7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTUlNRSgndGV4dC94LXB1ZycsICdwdWcnKTtcbkNvZGVNaXJyb3IuZGVmaW5lTUlNRSgndGV4dC94LWphZGUnLCAncHVnJyk7XG5cbn0pO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcblwidXNlIHN0cmljdFwiO1xuXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoXCJwdXBwZXRcIiwgZnVuY3Rpb24gKCkge1xuICAvLyBTdG9yZXMgdGhlIHdvcmRzIGZyb20gdGhlIGRlZmluZSBtZXRob2RcbiAgdmFyIHdvcmRzID0ge307XG4gIC8vIFRha2VuLCBtb3N0bHksIGZyb20gdGhlIFB1cHBldCBvZmZpY2lhbCB2YXJpYWJsZSBzdGFuZGFyZHMgcmVnZXhcbiAgdmFyIHZhcmlhYmxlX3JlZ2V4ID0gLyh7KT8oW2Etel1bYS16MC05X10qKT8oKDo6W2Etel1bYS16MC05X10qKSo6Oik/W2EtekEtWjAtOV9dKyh9KT8vO1xuXG4gIC8vIFRha2VzIGEgc3RyaW5nIG9mIHdvcmRzIHNlcGFyYXRlZCBieSBzcGFjZXMgYW5kIGFkZHMgdGhlbSBhc1xuICAvLyBrZXlzIHdpdGggdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBhcmd1bWVudCAnc3R5bGUnXG4gIGZ1bmN0aW9uIGRlZmluZShzdHlsZSwgc3RyaW5nKSB7XG4gICAgdmFyIHNwbGl0ID0gc3RyaW5nLnNwbGl0KCcgJyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGxpdC5sZW5ndGg7IGkrKykge1xuICAgICAgd29yZHNbc3BsaXRbaV1dID0gc3R5bGU7XG4gICAgfVxuICB9XG5cbiAgLy8gVGFrZXMgY29tbW9ubHkga25vd24gcHVwcGV0IHR5cGVzL3dvcmRzIGFuZCBjbGFzc2lmaWVzIHRoZW0gdG8gYSBzdHlsZVxuICBkZWZpbmUoJ2tleXdvcmQnLCAnY2xhc3MgZGVmaW5lIHNpdGUgbm9kZSBpbmNsdWRlIGltcG9ydCBpbmhlcml0cycpO1xuICBkZWZpbmUoJ2tleXdvcmQnLCAnY2FzZSBpZiBlbHNlIGluIGFuZCBlbHNpZiBkZWZhdWx0IG9yJyk7XG4gIGRlZmluZSgnYXRvbScsICdmYWxzZSB0cnVlIHJ1bm5pbmcgcHJlc2VudCBhYnNlbnQgZmlsZSBkaXJlY3RvcnkgdW5kZWYnKTtcbiAgZGVmaW5lKCdidWlsdGluJywgJ2FjdGlvbiBhdWdlYXMgYnVyc3QgY2hhaW4gY29tcHV0ZXIgY3JvbiBkZXN0aW5hdGlvbiBkcG9ydCBleGVjICcgK1xuICAgICdmaWxlIGZpbGVidWNrZXQgZ3JvdXAgaG9zdCBpY21wIGluaWZhY2UgaW50ZXJmYWNlIGp1bXAgazVsb2dpbiBsaW1pdCBsb2dfbGV2ZWwgJyArXG4gICAgJ2xvZ19wcmVmaXggbWFjYXV0aG9yaXphdGlvbiBtYWlsYWxpYXMgbWFpbGxpc3QgbWN4IG1vdW50IG5hZ2lvc19jb21tYW5kICcgK1xuICAgICduYWdpb3NfY29udGFjdCBuYWdpb3NfY29udGFjdGdyb3VwIG5hZ2lvc19ob3N0IG5hZ2lvc19ob3N0ZGVwZW5kZW5jeSAnICtcbiAgICAnbmFnaW9zX2hvc3Rlc2NhbGF0aW9uIG5hZ2lvc19ob3N0ZXh0aW5mbyBuYWdpb3NfaG9zdGdyb3VwIG5hZ2lvc19zZXJ2aWNlICcgK1xuICAgICduYWdpb3Nfc2VydmljZWRlcGVuZGVuY3kgbmFnaW9zX3NlcnZpY2Vlc2NhbGF0aW9uIG5hZ2lvc19zZXJ2aWNlZXh0aW5mbyAnICtcbiAgICAnbmFnaW9zX3NlcnZpY2Vncm91cCBuYWdpb3NfdGltZXBlcmlvZCBuYW1lIG5vdGlmeSBvdXRpZmFjZSBwYWNrYWdlIHByb3RvIHJlamVjdCAnICtcbiAgICAncmVzb3VyY2VzIHJvdXRlciBzY2hlZHVsZSBzY2hlZHVsZWRfdGFzayBzZWxib29sZWFuIHNlbG1vZHVsZSBzZXJ2aWNlIHNvdXJjZSAnICtcbiAgICAnc3BvcnQgc3NoX2F1dGhvcml6ZWRfa2V5IHNzaGtleSBzdGFnZSBzdGF0ZSB0YWJsZSB0aWR5IHRvZGVzdCB0b3BvcnRzIHRvc291cmNlICcgK1xuICAgICd1c2VyIHZsYW4geXVtcmVwbyB6ZnMgem9uZSB6cG9vbCcpO1xuXG4gIC8vIEFmdGVyIGZpbmRpbmcgYSBzdGFydCBvZiBhIHN0cmluZyAoJ3xcIikgdGhpcyBmdW5jdGlvbiBhdHRlbXB0cyB0byBmaW5kIHRoZSBlbmQ7XG4gIC8vIElmIGEgdmFyaWFibGUgaXMgZW5jb3VudGVyZWQgYWxvbmcgdGhlIHdheSwgd2UgZGlzcGxheSBpdCBkaWZmZXJlbnRseSB3aGVuIGl0XG4gIC8vIGlzIGVuY2Fwc3VsYXRlZCBpbiBhIGRvdWJsZS1xdW90ZWQgc3RyaW5nLlxuICBmdW5jdGlvbiB0b2tlblN0cmluZyhzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGN1cnJlbnQsIHByZXYsIGZvdW5kX3ZhciA9IGZhbHNlO1xuICAgIHdoaWxlICghc3RyZWFtLmVvbCgpICYmIChjdXJyZW50ID0gc3RyZWFtLm5leHQoKSkgIT0gc3RhdGUucGVuZGluZykge1xuICAgICAgaWYgKGN1cnJlbnQgPT09ICckJyAmJiBwcmV2ICE9ICdcXFxcJyAmJiBzdGF0ZS5wZW5kaW5nID09ICdcIicpIHtcbiAgICAgICAgZm91bmRfdmFyID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBwcmV2ID0gY3VycmVudDtcbiAgICB9XG4gICAgaWYgKGZvdW5kX3Zhcikge1xuICAgICAgc3RyZWFtLmJhY2tVcCgxKTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnQgPT0gc3RhdGUucGVuZGluZykge1xuICAgICAgc3RhdGUuY29udGludWVTdHJpbmcgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29udGludWVTdHJpbmcgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgfVxuXG4gIC8vIE1haW4gZnVuY3Rpb25cbiAgZnVuY3Rpb24gdG9rZW5pemUoc3RyZWFtLCBzdGF0ZSkge1xuICAgIC8vIE1hdGNoZXMgb25lIHdob2xlIHdvcmRcbiAgICB2YXIgd29yZCA9IHN0cmVhbS5tYXRjaCgvW1xcd10rLywgZmFsc2UpO1xuICAgIC8vIE1hdGNoZXMgYXR0cmlidXRlcyAoaS5lLiBlbnN1cmUgPT4gcHJlc2VudCA7ICdlbnN1cmUnIHdvdWxkIGJlIG1hdGNoZWQpXG4gICAgdmFyIGF0dHJpYnV0ZSA9IHN0cmVhbS5tYXRjaCgvKFxccyspP1xcdytcXHMrPT4uKi8sIGZhbHNlKTtcbiAgICAvLyBNYXRjaGVzIG5vbi1idWlsdGluIHJlc291cmNlIGRlY2xhcmF0aW9uc1xuICAgIC8vIChpLmUuIFwiYXBhY2hlOjp2aG9zdCB7XCIgb3IgXCJteWN1c3RvbWNsYXNzcyB7XCIgd291bGQgYmUgbWF0Y2hlZClcbiAgICB2YXIgcmVzb3VyY2UgPSBzdHJlYW0ubWF0Y2goLyhcXHMrKT9bXFx3Ol9dKyhcXHMrKT97LywgZmFsc2UpO1xuICAgIC8vIE1hdGNoZXMgdmlydHVhbCBhbmQgZXhwb3J0ZWQgcmVzb3VyY2VzIChpLmUuIEBAdXNlciB7IDsgYW5kIHRoZSBsaWtlKVxuICAgIHZhciBzcGVjaWFsX3Jlc291cmNlID0gc3RyZWFtLm1hdGNoKC8oXFxzKyk/W0BdezEsMn1bXFx3Ol9dKyhcXHMrKT97LywgZmFsc2UpO1xuXG4gICAgLy8gRmluYWxseSBhZHZhbmNlIHRoZSBzdHJlYW1cbiAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuXG4gICAgLy8gSGF2ZSB3ZSBmb3VuZCBhIHZhcmlhYmxlP1xuICAgIGlmIChjaCA9PT0gJyQnKSB7XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKHZhcmlhYmxlX3JlZ2V4KSkge1xuICAgICAgICAvLyBJZiBzbywgYW5kIGl0cyBpbiBhIHN0cmluZywgYXNzaWduIGl0IGEgZGlmZmVyZW50IGNvbG9yXG4gICAgICAgIHJldHVybiBzdGF0ZS5jb250aW51ZVN0cmluZyA/ICd2YXJpYWJsZS0yJyA6ICd2YXJpYWJsZSc7XG4gICAgICB9XG4gICAgICAvLyBPdGhlcndpc2UgcmV0dXJuIGFuIGludmFsaWQgdmFyaWFibGVcbiAgICAgIHJldHVybiBcImVycm9yXCI7XG4gICAgfVxuICAgIC8vIFNob3VsZCB3ZSBzdGlsbCBiZSBsb29raW5nIGZvciB0aGUgZW5kIG9mIGEgc3RyaW5nP1xuICAgIGlmIChzdGF0ZS5jb250aW51ZVN0cmluZykge1xuICAgICAgLy8gSWYgc28sIGdvIHRocm91Z2ggdGhlIGxvb3AgYWdhaW5cbiAgICAgIHN0cmVhbS5iYWNrVXAoMSk7XG4gICAgICByZXR1cm4gdG9rZW5TdHJpbmcoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICAgIC8vIEFyZSB3ZSBpbiBhIGRlZmluaXRpb24gKGNsYXNzLCBub2RlLCBkZWZpbmUpP1xuICAgIGlmIChzdGF0ZS5pbkRlZmluaXRpb24pIHtcbiAgICAgIC8vIElmIHNvLCByZXR1cm4gZGVmIChpLmUuIGZvciAnY2xhc3MgbXljbGFzcyB7JyA7ICdteWNsYXNzJyB3b3VsZCBiZSBtYXRjaGVkKVxuICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvKFxccyspP1tcXHc6X10rKFxccyspPy8pKSB7XG4gICAgICAgIHJldHVybiAnZGVmJztcbiAgICAgIH1cbiAgICAgIC8vIE1hdGNoIHRoZSByZXN0IGl0IHRoZSBuZXh0IHRpbWUgYXJvdW5kXG4gICAgICBzdHJlYW0ubWF0Y2goL1xccyt7Lyk7XG4gICAgICBzdGF0ZS5pbkRlZmluaXRpb24gPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gQXJlIHdlIGluIGFuICdpbmNsdWRlJyBzdGF0ZW1lbnQ/XG4gICAgaWYgKHN0YXRlLmluSW5jbHVkZSkge1xuICAgICAgLy8gTWF0Y2ggYW5kIHJldHVybiB0aGUgaW5jbHVkZWQgY2xhc3NcbiAgICAgIHN0cmVhbS5tYXRjaCgvKFxccyspP1xcUysoXFxzKyk/Lyk7XG4gICAgICBzdGF0ZS5pbkluY2x1ZGUgPSBmYWxzZTtcbiAgICAgIHJldHVybiAnZGVmJztcbiAgICB9XG4gICAgLy8gRG8gd2UganVzdCBoYXZlIGEgZnVuY3Rpb24gb24gb3VyIGhhbmRzP1xuICAgIC8vIEluICdlbnN1cmVfcmVzb3VyY2UoXCJteWNsYXNzXCIpJywgJ2Vuc3VyZV9yZXNvdXJjZScgaXMgbWF0Y2hlZFxuICAgIGlmIChzdHJlYW0ubWF0Y2goLyhcXHMrKT9cXHcrXFwoLykpIHtcbiAgICAgIHN0cmVhbS5iYWNrVXAoMSk7XG4gICAgICByZXR1cm4gJ2RlZic7XG4gICAgfVxuICAgIC8vIEhhdmUgd2UgbWF0Y2hlZCB0aGUgcHJpb3IgYXR0cmlidXRlIHJlZ2V4P1xuICAgIGlmIChhdHRyaWJ1dGUpIHtcbiAgICAgIHN0cmVhbS5tYXRjaCgvKFxccyspP1xcdysvKTtcbiAgICAgIHJldHVybiAndGFnJztcbiAgICB9XG4gICAgLy8gRG8gd2UgaGF2ZSBQdXBwZXQgc3BlY2lmaWMgd29yZHM/XG4gICAgaWYgKHdvcmQgJiYgd29yZHMuaGFzT3duUHJvcGVydHkod29yZCkpIHtcbiAgICAgIC8vIE5lZ2F0ZXMgdGhlIGluaXRpYWwgbmV4dCgpXG4gICAgICBzdHJlYW0uYmFja1VwKDEpO1xuICAgICAgLy8gcnMgbW92ZSB0aGUgc3RyZWFtXG4gICAgICBzdHJlYW0ubWF0Y2goL1tcXHddKy8pO1xuICAgICAgLy8gV2Ugd2FudCB0byBwcm9jZXNzIHRoZXNlIHdvcmRzIGRpZmZlcmVudGx5XG4gICAgICAvLyBkbyB0byB0aGUgaW1wb3J0YW5jZSB0aGV5IGhhdmUgaW4gUHVwcGV0XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC9cXHMrXFxTK1xccyt7LywgZmFsc2UpKSB7XG4gICAgICAgIHN0YXRlLmluRGVmaW5pdGlvbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAod29yZCA9PSAnaW5jbHVkZScpIHtcbiAgICAgICAgc3RhdGUuaW5JbmNsdWRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vIFJldHVybnMgdGhlaXIgdmFsdWUgYXMgc3RhdGUgaW4gdGhlIHByaW9yIGRlZmluZSBtZXRob2RzXG4gICAgICByZXR1cm4gd29yZHNbd29yZF07XG4gICAgfVxuICAgIC8vIElzIHRoZXJlIGEgbWF0Y2ggb24gYSByZWZlcmVuY2U/XG4gICAgaWYgKC8oXnxcXHMrKVtBLVpdW1xcdzpfXSsvLnRlc3Qod29yZCkpIHtcbiAgICAgIC8vIE5lZ2F0ZSB0aGUgbmV4dCgpXG4gICAgICBzdHJlYW0uYmFja1VwKDEpO1xuICAgICAgLy8gTWF0Y2ggdGhlIGZ1bGwgcmVmZXJlbmNlXG4gICAgICBzdHJlYW0ubWF0Y2goLyhefFxccyspW0EtWl1bXFx3Ol9dKy8pO1xuICAgICAgcmV0dXJuICdkZWYnO1xuICAgIH1cbiAgICAvLyBIYXZlIHdlIG1hdGNoZWQgdGhlIHByaW9yIHJlc291cmNlIHJlZ2V4P1xuICAgIGlmIChyZXNvdXJjZSkge1xuICAgICAgc3RyZWFtLm1hdGNoKC8oXFxzKyk/W1xcdzpfXSsvKTtcbiAgICAgIHJldHVybiAnZGVmJztcbiAgICB9XG4gICAgLy8gSGF2ZSB3ZSBtYXRjaGVkIHRoZSBwcmlvciBzcGVjaWFsX3Jlc291cmNlIHJlZ2V4P1xuICAgIGlmIChzcGVjaWFsX3Jlc291cmNlKSB7XG4gICAgICBzdHJlYW0ubWF0Y2goLyhcXHMrKT9bQF17MSwyfS8pO1xuICAgICAgcmV0dXJuICdzcGVjaWFsJztcbiAgICB9XG4gICAgLy8gTWF0Y2ggYWxsIHRoZSBjb21tZW50cy4gQWxsIG9mIHRoZW0uXG4gICAgaWYgKGNoID09IFwiI1wiKSB7XG4gICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgfVxuICAgIC8vIEhhdmUgd2UgZm91bmQgYSBzdHJpbmc/XG4gICAgaWYgKGNoID09IFwiJ1wiIHx8IGNoID09ICdcIicpIHtcbiAgICAgIC8vIFN0b3JlIHRoZSB0eXBlIChzaW5nbGUgb3IgZG91YmxlKVxuICAgICAgc3RhdGUucGVuZGluZyA9IGNoO1xuICAgICAgLy8gUGVyZm9ybSB0aGUgbG9vcGluZyBmdW5jdGlvbiB0byBmaW5kIHRoZSBlbmRcbiAgICAgIHJldHVybiB0b2tlblN0cmluZyhzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gICAgLy8gTWF0Y2ggYWxsIHRoZSBicmFja2V0c1xuICAgIGlmIChjaCA9PSAneycgfHwgY2ggPT0gJ30nKSB7XG4gICAgICByZXR1cm4gJ2JyYWNrZXQnO1xuICAgIH1cbiAgICAvLyBNYXRjaCBjaGFyYWN0ZXJzIHRoYXQgd2UgYXJlIGdvaW5nIHRvIGFzc3VtZVxuICAgIC8vIGFyZSB0cnlpbmcgdG8gYmUgcmVnZXhcbiAgICBpZiAoY2ggPT0gJy8nKSB7XG4gICAgICBzdHJlYW0ubWF0Y2goL15bXlxcL10qXFwvLyk7XG4gICAgICByZXR1cm4gJ3ZhcmlhYmxlLTMnO1xuICAgIH1cbiAgICAvLyBNYXRjaCBhbGwgdGhlIG51bWJlcnNcbiAgICBpZiAoY2gubWF0Y2goL1swLTldLykpIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvWzAtOV0rLyk7XG4gICAgICByZXR1cm4gJ251bWJlcic7XG4gICAgfVxuICAgIC8vIE1hdGNoIHRoZSAnPScgYW5kICc9Picgb3BlcmF0b3JzXG4gICAgaWYgKGNoID09ICc9Jykge1xuICAgICAgaWYgKHN0cmVhbS5wZWVrKCkgPT0gJz4nKSB7XG4gICAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gICAgfVxuICAgIC8vIEtlZXAgYWR2YW5jaW5nIHRocm91Z2ggYWxsIHRoZSByZXN0XG4gICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3LV0vKTtcbiAgICAvLyBSZXR1cm4gYSBibGFuayBsaW5lIGZvciBldmVyeXRoaW5nIGVsc2VcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvLyBTdGFydCBpdCBhbGxcbiAgcmV0dXJuIHtcbiAgICBzdGFydFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RhdGUgPSB7fTtcbiAgICAgIHN0YXRlLmluRGVmaW5pdGlvbiA9IGZhbHNlO1xuICAgICAgc3RhdGUuaW5JbmNsdWRlID0gZmFsc2U7XG4gICAgICBzdGF0ZS5jb250aW51ZVN0cmluZyA9IGZhbHNlO1xuICAgICAgc3RhdGUucGVuZGluZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG4gICAgdG9rZW46IGZ1bmN0aW9uIChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAvLyBTdHJpcCB0aGUgc3BhY2VzLCBidXQgcmVnZXggd2lsbCBhY2NvdW50IGZvciB0aGVtIGVpdGhlcndheVxuICAgICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSByZXR1cm4gbnVsbDtcbiAgICAgIC8vIEdvIHRocm91Z2ggdGhlIG1haW4gcHJvY2Vzc1xuICAgICAgcmV0dXJuIHRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfTtcbn0pO1xuXG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3gtcHVwcGV0XCIsIFwicHVwcGV0XCIpO1xuXG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwicVwiLGZ1bmN0aW9uKGNvbmZpZyl7XG4gIHZhciBpbmRlbnRVbml0PWNvbmZpZy5pbmRlbnRVbml0LFxuICAgICAgY3VyUHVuYyxcbiAgICAgIGtleXdvcmRzPWJ1aWxkUkUoW1wiYWJzXCIsXCJhY29zXCIsXCJhalwiLFwiYWowXCIsXCJhbGxcIixcImFuZFwiLFwiYW55XCIsXCJhc2NcIixcImFzaW5cIixcImFzb2ZcIixcImF0YW5cIixcImF0dHJcIixcImF2Z1wiLFwiYXZnc1wiLFwiYmluXCIsXCJieVwiLFwiY2VpbGluZ1wiLFwiY29sc1wiLFwiY29yXCIsXCJjb3NcIixcImNvdW50XCIsXCJjb3ZcIixcImNyb3NzXCIsXCJjc3ZcIixcImN1dFwiLFwiZGVsZXRlXCIsXCJkZWx0YXNcIixcImRlc2NcIixcImRldlwiLFwiZGlmZmVyXCIsXCJkaXN0aW5jdFwiLFwiZGl2XCIsXCJkb1wiLFwiZWFjaFwiLFwiZWpcIixcImVubGlzdFwiLFwiZXZhbFwiLFwiZXhjZXB0XCIsXCJleGVjXCIsXCJleGl0XCIsXCJleHBcIixcImZieVwiLFwiZmlsbHNcIixcImZpcnN0XCIsXCJma2V5c1wiLFwiZmxpcFwiLFwiZmxvb3JcIixcImZyb21cIixcImdldFwiLFwiZ2V0ZW52XCIsXCJncm91cFwiLFwiZ3RpbWVcIixcImhjbG9zZVwiLFwiaGNvdW50XCIsXCJoZGVsXCIsXCJob3BlblwiLFwiaHN5bVwiLFwiaWFzY1wiLFwiaWRlc2NcIixcImlmXCIsXCJpalwiLFwiaW5cIixcImluc2VydFwiLFwiaW50ZXJcIixcImludlwiLFwia2V5XCIsXCJrZXlzXCIsXCJsYXN0XCIsXCJsaWtlXCIsXCJsaXN0XCIsXCJsalwiLFwibG9hZFwiLFwibG9nXCIsXCJsb3dlclwiLFwibHNxXCIsXCJsdGltZVwiLFwibHRyaW1cIixcIm1hdmdcIixcIm1heFwiLFwibWF4c1wiLFwibWNvdW50XCIsXCJtZDVcIixcIm1kZXZcIixcIm1lZFwiLFwibWV0YVwiLFwibWluXCIsXCJtaW5zXCIsXCJtbWF4XCIsXCJtbWluXCIsXCJtbXVcIixcIm1vZFwiLFwibXN1bVwiLFwibmVnXCIsXCJuZXh0XCIsXCJub3RcIixcIm51bGxcIixcIm9yXCIsXCJvdmVyXCIsXCJwYXJzZVwiLFwicGVhY2hcIixcInBqXCIsXCJwbGlzdFwiLFwicHJkXCIsXCJwcmRzXCIsXCJwcmV2XCIsXCJwcmlvclwiLFwicmFuZFwiLFwicmFua1wiLFwicmF0aW9zXCIsXCJyYXplXCIsXCJyZWFkMFwiLFwicmVhZDFcIixcInJlY2lwcm9jYWxcIixcInJldmVyc2VcIixcInJsb2FkXCIsXCJyb3RhdGVcIixcInJzYXZlXCIsXCJydHJpbVwiLFwic2F2ZVwiLFwic2NhblwiLFwic2VsZWN0XCIsXCJzZXRcIixcInNldGVudlwiLFwic2hvd1wiLFwic2lnbnVtXCIsXCJzaW5cIixcInNxcnRcIixcInNzXCIsXCJzc3JcIixcInN0cmluZ1wiLFwic3VibGlzdFwiLFwic3VtXCIsXCJzdW1zXCIsXCJzdlwiLFwic3lzdGVtXCIsXCJ0YWJsZXNcIixcInRhblwiLFwidGlsXCIsXCJ0cmltXCIsXCJ0eGZcIixcInR5cGVcIixcInVqXCIsXCJ1bmdyb3VwXCIsXCJ1bmlvblwiLFwidXBkYXRlXCIsXCJ1cHBlclwiLFwidXBzZXJ0XCIsXCJ2YWx1ZVwiLFwidmFyXCIsXCJ2aWV3XCIsXCJ2aWV3c1wiLFwidnNcIixcIndhdmdcIixcIndoZXJlXCIsXCJ3aGVyZVwiLFwid2hpbGVcIixcIndpdGhpblwiLFwid2pcIixcIndqMVwiLFwid3N1bVwiLFwieGFzY1wiLFwieGJhclwiLFwieGNvbFwiLFwieGNvbHNcIixcInhkZXNjXCIsXCJ4ZXhwXCIsXCJ4Z3JvdXBcIixcInhrZXlcIixcInhsb2dcIixcInhwcmV2XCIsXCJ4cmFua1wiXSksXG4gICAgICBFPS9bfC8mXiErOlxcXFxcXC0qJSQ9fiM7QD48LD9fXFwnXFxcIlxcW1xcKFxcXVxcKVxcc3t9XS87XG4gIGZ1bmN0aW9uIGJ1aWxkUkUodyl7cmV0dXJuIG5ldyBSZWdFeHAoXCJeKFwiK3cuam9pbihcInxcIikrXCIpJFwiKTt9XG4gIGZ1bmN0aW9uIHRva2VuQmFzZShzdHJlYW0sc3RhdGUpe1xuICAgIHZhciBzb2w9c3RyZWFtLnNvbCgpLGM9c3RyZWFtLm5leHQoKTtcbiAgICBjdXJQdW5jPW51bGw7XG4gICAgaWYoc29sKVxuICAgICAgaWYoYz09XCIvXCIpXG4gICAgICAgIHJldHVybihzdGF0ZS50b2tlbml6ZT10b2tlbkxpbmVDb21tZW50KShzdHJlYW0sc3RhdGUpO1xuICAgICAgZWxzZSBpZihjPT1cIlxcXFxcIil7XG4gICAgICAgIGlmKHN0cmVhbS5lb2woKXx8L1xccy8udGVzdChzdHJlYW0ucGVlaygpKSlcbiAgICAgICAgICByZXR1cm4gc3RyZWFtLnNraXBUb0VuZCgpLC9eXFxcXFxccyokLy50ZXN0KHN0cmVhbS5jdXJyZW50KCkpPyhzdGF0ZS50b2tlbml6ZT10b2tlbkNvbW1lbnRUb0VPRikoc3RyZWFtKTpzdGF0ZS50b2tlbml6ZT10b2tlbkJhc2UsXCJjb21tZW50XCI7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXR1cm4gc3RhdGUudG9rZW5pemU9dG9rZW5CYXNlLFwiYnVpbHRpblwiO1xuICAgICAgfVxuICAgIGlmKC9cXHMvLnRlc3QoYykpXG4gICAgICByZXR1cm4gc3RyZWFtLnBlZWsoKT09XCIvXCI/KHN0cmVhbS5za2lwVG9FbmQoKSxcImNvbW1lbnRcIik6XCJ3aGl0ZXNwYWNlXCI7XG4gICAgaWYoYz09J1wiJylcbiAgICAgIHJldHVybihzdGF0ZS50b2tlbml6ZT10b2tlblN0cmluZykoc3RyZWFtLHN0YXRlKTtcbiAgICBpZihjPT0nYCcpXG4gICAgICByZXR1cm4gc3RyZWFtLmVhdFdoaWxlKC9bQS1aYS16XFxkXzpcXC8uXS8pLFwic3ltYm9sXCI7XG4gICAgaWYoKFwiLlwiPT1jJiYvXFxkLy50ZXN0KHN0cmVhbS5wZWVrKCkpKXx8L1xcZC8udGVzdChjKSl7XG4gICAgICB2YXIgdD1udWxsO1xuICAgICAgc3RyZWFtLmJhY2tVcCgxKTtcbiAgICAgIGlmKHN0cmVhbS5tYXRjaCgvXlxcZHs0fVxcLlxcZHsyfShtfFxcLlxcZHsyfShbRFRdKFxcZHsyfSg6XFxkezJ9KDpcXGR7Mn0oXFwuXFxkezEsOX0pPyk/KT8pPyk/KS8pXG4gICAgICB8fCBzdHJlYW0ubWF0Y2goL15cXGQrRChcXGR7Mn0oOlxcZHsyfSg6XFxkezJ9KFxcLlxcZHsxLDl9KT8pPyk/KS8pXG4gICAgICB8fCBzdHJlYW0ubWF0Y2goL15cXGR7Mn06XFxkezJ9KDpcXGR7Mn0oXFwuXFxkezEsOX0pPyk/LylcbiAgICAgIHx8IHN0cmVhbS5tYXRjaCgvXlxcZCtbcHR1dl17MX0vKSlcbiAgICAgICAgdD1cInRlbXBvcmFsXCI7XG4gICAgICBlbHNlIGlmKHN0cmVhbS5tYXRjaCgvXjBbTndXXXsxfS8pXG4gICAgICB8fCBzdHJlYW0ubWF0Y2goL14weFtcXGRhLWZBLUZdKi8pXG4gICAgICB8fCBzdHJlYW0ubWF0Y2goL15bMDFdK1tiXXsxfS8pXG4gICAgICB8fCBzdHJlYW0ubWF0Y2goL15cXGQrW2NoaWpuXXsxfS8pXG4gICAgICB8fCBzdHJlYW0ubWF0Y2goLy0/XFxkKihcXC5cXGQqKT8oZVsrXFwtXT9cXGQrKT8oZXxmKT8vKSlcbiAgICAgICAgdD1cIm51bWJlclwiO1xuICAgICAgcmV0dXJuKHQmJighKGM9c3RyZWFtLnBlZWsoKSl8fEUudGVzdChjKSkpP3Q6KHN0cmVhbS5uZXh0KCksXCJlcnJvclwiKTtcbiAgICB9XG4gICAgaWYoL1tBLVphLXpdfFxcLi8udGVzdChjKSlcbiAgICAgIHJldHVybiBzdHJlYW0uZWF0V2hpbGUoL1tBLVphLXouX1xcZF0vKSxrZXl3b3Jkcy50ZXN0KHN0cmVhbS5jdXJyZW50KCkpP1wia2V5d29yZFwiOlwidmFyaWFibGVcIjtcbiAgICBpZigvW3wvJl4hKzpcXFxcXFwtKiUkPX4jO0A+PFxcLiw/X1xcJ10vLnRlc3QoYykpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBpZigvW3t9XFwoXFxbXFxdXFwpXS8udGVzdChjKSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVyblwiZXJyb3JcIjtcbiAgfVxuICBmdW5jdGlvbiB0b2tlbkxpbmVDb21tZW50KHN0cmVhbSxzdGF0ZSl7XG4gICAgcmV0dXJuIHN0cmVhbS5za2lwVG9FbmQoKSwvXFwvXFxzKiQvLnRlc3Qoc3RyZWFtLmN1cnJlbnQoKSk/KHN0YXRlLnRva2VuaXplPXRva2VuQmxvY2tDb21tZW50KShzdHJlYW0sc3RhdGUpOihzdGF0ZS50b2tlbml6ZT10b2tlbkJhc2UpLFwiY29tbWVudFwiO1xuICB9XG4gIGZ1bmN0aW9uIHRva2VuQmxvY2tDb21tZW50KHN0cmVhbSxzdGF0ZSl7XG4gICAgdmFyIGY9c3RyZWFtLnNvbCgpJiZzdHJlYW0ucGVlaygpPT1cIlxcXFxcIjtcbiAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgaWYoZiYmL15cXFxcXFxzKiQvLnRlc3Qoc3RyZWFtLmN1cnJlbnQoKSkpXG4gICAgICBzdGF0ZS50b2tlbml6ZT10b2tlbkJhc2U7XG4gICAgcmV0dXJuXCJjb21tZW50XCI7XG4gIH1cbiAgZnVuY3Rpb24gdG9rZW5Db21tZW50VG9FT0Yoc3RyZWFtKXtyZXR1cm4gc3RyZWFtLnNraXBUb0VuZCgpLFwiY29tbWVudFwiO31cbiAgZnVuY3Rpb24gdG9rZW5TdHJpbmcoc3RyZWFtLHN0YXRlKXtcbiAgICB2YXIgZXNjYXBlZD1mYWxzZSxuZXh0LGVuZD1mYWxzZTtcbiAgICB3aGlsZSgobmV4dD1zdHJlYW0ubmV4dCgpKSl7XG4gICAgICBpZihuZXh0PT1cIlxcXCJcIiYmIWVzY2FwZWQpe2VuZD10cnVlO2JyZWFrO31cbiAgICAgIGVzY2FwZWQ9IWVzY2FwZWQmJm5leHQ9PVwiXFxcXFwiO1xuICAgIH1cbiAgICBpZihlbmQpc3RhdGUudG9rZW5pemU9dG9rZW5CYXNlO1xuICAgIHJldHVyblwic3RyaW5nXCI7XG4gIH1cbiAgZnVuY3Rpb24gcHVzaENvbnRleHQoc3RhdGUsdHlwZSxjb2wpe3N0YXRlLmNvbnRleHQ9e3ByZXY6c3RhdGUuY29udGV4dCxpbmRlbnQ6c3RhdGUuaW5kZW50LGNvbDpjb2wsdHlwZTp0eXBlfTt9XG4gIGZ1bmN0aW9uIHBvcENvbnRleHQoc3RhdGUpe3N0YXRlLmluZGVudD1zdGF0ZS5jb250ZXh0LmluZGVudDtzdGF0ZS5jb250ZXh0PXN0YXRlLmNvbnRleHQucHJldjt9XG4gIHJldHVybntcbiAgICBzdGFydFN0YXRlOmZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm57dG9rZW5pemU6dG9rZW5CYXNlLFxuICAgICAgICAgICAgIGNvbnRleHQ6bnVsbCxcbiAgICAgICAgICAgICBpbmRlbnQ6MCxcbiAgICAgICAgICAgICBjb2w6MH07XG4gICAgfSxcbiAgICB0b2tlbjpmdW5jdGlvbihzdHJlYW0sc3RhdGUpe1xuICAgICAgaWYoc3RyZWFtLnNvbCgpKXtcbiAgICAgICAgaWYoc3RhdGUuY29udGV4dCYmc3RhdGUuY29udGV4dC5hbGlnbj09bnVsbClcbiAgICAgICAgICBzdGF0ZS5jb250ZXh0LmFsaWduPWZhbHNlO1xuICAgICAgICBzdGF0ZS5pbmRlbnQ9c3RyZWFtLmluZGVudGF0aW9uKCk7XG4gICAgICB9XG4gICAgICAvL2lmIChzdHJlYW0uZWF0U3BhY2UoKSkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgc3R5bGU9c3RhdGUudG9rZW5pemUoc3RyZWFtLHN0YXRlKTtcbiAgICAgIGlmKHN0eWxlIT1cImNvbW1lbnRcIiYmc3RhdGUuY29udGV4dCYmc3RhdGUuY29udGV4dC5hbGlnbj09bnVsbCYmc3RhdGUuY29udGV4dC50eXBlIT1cInBhdHRlcm5cIil7XG4gICAgICAgIHN0YXRlLmNvbnRleHQuYWxpZ249dHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmKGN1clB1bmM9PVwiKFwiKXB1c2hDb250ZXh0KHN0YXRlLFwiKVwiLHN0cmVhbS5jb2x1bW4oKSk7XG4gICAgICBlbHNlIGlmKGN1clB1bmM9PVwiW1wiKXB1c2hDb250ZXh0KHN0YXRlLFwiXVwiLHN0cmVhbS5jb2x1bW4oKSk7XG4gICAgICBlbHNlIGlmKGN1clB1bmM9PVwie1wiKXB1c2hDb250ZXh0KHN0YXRlLFwifVwiLHN0cmVhbS5jb2x1bW4oKSk7XG4gICAgICBlbHNlIGlmKC9bXFxdXFx9XFwpXS8udGVzdChjdXJQdW5jKSl7XG4gICAgICAgIHdoaWxlKHN0YXRlLmNvbnRleHQmJnN0YXRlLmNvbnRleHQudHlwZT09XCJwYXR0ZXJuXCIpcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICAgIGlmKHN0YXRlLmNvbnRleHQmJmN1clB1bmM9PXN0YXRlLmNvbnRleHQudHlwZSlwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYoY3VyUHVuYz09XCIuXCImJnN0YXRlLmNvbnRleHQmJnN0YXRlLmNvbnRleHQudHlwZT09XCJwYXR0ZXJuXCIpcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICBlbHNlIGlmKC9hdG9tfHN0cmluZ3x2YXJpYWJsZS8udGVzdChzdHlsZSkmJnN0YXRlLmNvbnRleHQpe1xuICAgICAgICBpZigvW1xcfVxcXV0vLnRlc3Qoc3RhdGUuY29udGV4dC50eXBlKSlcbiAgICAgICAgICBwdXNoQ29udGV4dChzdGF0ZSxcInBhdHRlcm5cIixzdHJlYW0uY29sdW1uKCkpO1xuICAgICAgICBlbHNlIGlmKHN0YXRlLmNvbnRleHQudHlwZT09XCJwYXR0ZXJuXCImJiFzdGF0ZS5jb250ZXh0LmFsaWduKXtcbiAgICAgICAgICBzdGF0ZS5jb250ZXh0LmFsaWduPXRydWU7XG4gICAgICAgICAgc3RhdGUuY29udGV4dC5jb2w9c3RyZWFtLmNvbHVtbigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfSxcbiAgICBpbmRlbnQ6ZnVuY3Rpb24oc3RhdGUsdGV4dEFmdGVyKXtcbiAgICAgIHZhciBmaXJzdENoYXI9dGV4dEFmdGVyJiZ0ZXh0QWZ0ZXIuY2hhckF0KDApO1xuICAgICAgdmFyIGNvbnRleHQ9c3RhdGUuY29udGV4dDtcbiAgICAgIGlmKC9bXFxdXFx9XS8udGVzdChmaXJzdENoYXIpKVxuICAgICAgICB3aGlsZSAoY29udGV4dCYmY29udGV4dC50eXBlPT1cInBhdHRlcm5cIiljb250ZXh0PWNvbnRleHQucHJldjtcbiAgICAgIHZhciBjbG9zaW5nPWNvbnRleHQmJmZpcnN0Q2hhcj09Y29udGV4dC50eXBlO1xuICAgICAgaWYoIWNvbnRleHQpXG4gICAgICAgIHJldHVybiAwO1xuICAgICAgZWxzZSBpZihjb250ZXh0LnR5cGU9PVwicGF0dGVyblwiKVxuICAgICAgICByZXR1cm4gY29udGV4dC5jb2w7XG4gICAgICBlbHNlIGlmKGNvbnRleHQuYWxpZ24pXG4gICAgICAgIHJldHVybiBjb250ZXh0LmNvbCsoY2xvc2luZz8wOjEpO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gY29udGV4dC5pbmRlbnQrKGNsb3Npbmc/MDppbmRlbnRVbml0KTtcbiAgICB9XG4gIH07XG59KTtcbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQveC1xXCIsXCJxXCIpO1xuXG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwicnBtLWNoYW5nZXNcIiwgZnVuY3Rpb24oKSB7XG4gIHZhciBoZWFkZXJTZXBhcmF0b3IgPSAvXi0rJC87XG4gIHZhciBoZWFkZXJMaW5lID0gL14oTW9ufFR1ZXxXZWR8VGh1fEZyaXxTYXR8U3VuKSAoSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpICA/XFxkezEsMn0gXFxkezJ9OlxcZHsyfSg6XFxkezJ9KT8gW0EtWl17Myw0fSBcXGR7NH0gLSAvO1xuICB2YXIgc2ltcGxlRW1haWwgPSAvXltcXHcrLi1dK0BbXFx3Li1dKy87XG5cbiAgcmV0dXJuIHtcbiAgICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICBpZiAoc3RyZWFtLnNvbCgpKSB7XG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2goaGVhZGVyU2VwYXJhdG9yKSkgeyByZXR1cm4gJ3RhZyc7IH1cbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaChoZWFkZXJMaW5lKSkgeyByZXR1cm4gJ3RhZyc7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goc2ltcGxlRW1haWwpKSB7IHJldHVybiAnc3RyaW5nJzsgfVxuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcbn0pO1xuXG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3gtcnBtLWNoYW5nZXNcIiwgXCJycG0tY2hhbmdlc1wiKTtcblxuLy8gUXVpY2sgYW5kIGRpcnR5IHNwZWMgZmlsZSBoaWdobGlnaHRpbmdcblxuQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwicnBtLXNwZWNcIiwgZnVuY3Rpb24oKSB7XG4gIHZhciBhcmNoID0gL14oaTM4NnxpNTg2fGk2ODZ8eDg2XzY0fHBwYzY0bGV8cHBjNjR8cHBjfGlhNjR8czM5MHh8czM5MHxzcGFyYzY0fHNwYXJjdjl8c3BhcmN8bm9hcmNofGFscGhhZXY2fGFscGhhfGhwcGF8bWlwc2VsKS87XG5cbiAgdmFyIHByZWFtYmxlID0gL15bYS16QS1aMC05KCldKzovO1xuICB2YXIgc2VjdGlvbiA9IC9eJShkZWJ1Z19wYWNrYWdlfHBhY2thZ2V8ZGVzY3JpcHRpb258cHJlcHxidWlsZHxpbnN0YWxsfGZpbGVzfGNsZWFufGNoYW5nZWxvZ3xwcmVpbnN0YWxsfHByZXVufHBvc3RpbnN0YWxsfHBvc3R1bnxwcmV0cmFuc3xwb3N0dHJhbnN8cHJlfHBvc3R8dHJpZ2dlcmlufHRyaWdnZXJ1bnx2ZXJpZnlzY3JpcHR8Y2hlY2t8dHJpZ2dlcnBvc3R1bnx0cmlnZ2VycHJlaW58dHJpZ2dlcikvO1xuICB2YXIgY29udHJvbF9mbG93X2NvbXBsZXggPSAvXiUoaWZuYXJjaHxpZmFyY2h8aWYpLzsgLy8gcnBtIGNvbnRyb2wgZmxvdyBtYWNyb3NcbiAgdmFyIGNvbnRyb2xfZmxvd19zaW1wbGUgPSAvXiUoZWxzZXxlbmRpZikvOyAvLyBycG0gY29udHJvbCBmbG93IG1hY3Jvc1xuICB2YXIgb3BlcmF0b3JzID0gL14oXFwhfFxcP3xcXDxcXD18XFw8fFxcPlxcPXxcXD58XFw9XFw9fFxcJlxcJnxcXHxcXHwpLzsgLy8gb3BlcmF0b3JzIGluIGNvbnRyb2wgZmxvdyBtYWNyb3NcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb250cm9sRmxvdzogZmFsc2UsXG4gICAgICAgICAgbWFjcm9QYXJhbWV0ZXJzOiBmYWxzZSxcbiAgICAgICAgICBzZWN0aW9uOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9rZW46IGZ1bmN0aW9uIChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgY2ggPSBzdHJlYW0ucGVlaygpO1xuICAgICAgaWYgKGNoID09IFwiI1wiKSB7IHN0cmVhbS5za2lwVG9FbmQoKTsgcmV0dXJuIFwiY29tbWVudFwiOyB9XG5cbiAgICAgIGlmIChzdHJlYW0uc29sKCkpIHtcbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaChwcmVhbWJsZSkpIHsgcmV0dXJuIFwiaGVhZGVyXCI7IH1cbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaChzZWN0aW9uKSkgeyByZXR1cm4gXCJhdG9tXCI7IH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXlxcJFxcdysvKSkgeyByZXR1cm4gXCJkZWZcIjsgfSAvLyBWYXJpYWJsZXMgbGlrZSAnJFJQTV9CVUlMRF9ST09UJ1xuICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXlxcJFxce1xcdytcXH0vKSkgeyByZXR1cm4gXCJkZWZcIjsgfSAvLyBWYXJpYWJsZXMgbGlrZSAnJHtSUE1fQlVJTERfUk9PVH0nXG5cbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goY29udHJvbF9mbG93X3NpbXBsZSkpIHsgcmV0dXJuIFwia2V5d29yZFwiOyB9XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKGNvbnRyb2xfZmxvd19jb21wbGV4KSkge1xuICAgICAgICBzdGF0ZS5jb250cm9sRmxvdyA9IHRydWU7XG4gICAgICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5jb250cm9sRmxvdykge1xuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKG9wZXJhdG9ycykpIHsgcmV0dXJuIFwib3BlcmF0b3JcIjsgfVxuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eKFxcZCspLykpIHsgcmV0dXJuIFwibnVtYmVyXCI7IH1cbiAgICAgICAgaWYgKHN0cmVhbS5lb2woKSkgeyBzdGF0ZS5jb250cm9sRmxvdyA9IGZhbHNlOyB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goYXJjaCkpIHtcbiAgICAgICAgaWYgKHN0cmVhbS5lb2woKSkgeyBzdGF0ZS5jb250cm9sRmxvdyA9IGZhbHNlOyB9XG4gICAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgICAgfVxuXG4gICAgICAvLyBNYWNyb3MgbGlrZSAnJW1ha2VfaW5zdGFsbCcgb3IgJyVhdHRyKDA3NzUscm9vdCxyb290KSdcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goL14lW1xcd10rLykpIHtcbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgnKCcpKSB7IHN0YXRlLm1hY3JvUGFyYW1ldGVycyA9IHRydWU7IH1cbiAgICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLm1hY3JvUGFyYW1ldGVycykge1xuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eXFxkKy8pKSB7IHJldHVybiBcIm51bWJlclwiO31cbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgnKScpKSB7XG4gICAgICAgICAgc3RhdGUubWFjcm9QYXJhbWV0ZXJzID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE1hY3JvcyBsaWtlICcle2RlZmluZWQgZmVkb3JhfSdcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goL14lXFx7XFw/P1tcXHcgXFwtXFw6XFwhXStcXH0vKSkge1xuICAgICAgICBpZiAoc3RyZWFtLmVvbCgpKSB7IHN0YXRlLmNvbnRyb2xGbG93ID0gZmFsc2U7IH1cbiAgICAgICAgcmV0dXJuIFwiZGVmXCI7XG4gICAgICB9XG5cbiAgICAgIC8vVE9ETzogSW5jbHVkZSBiYXNoIHNjcmlwdCBzdWItcGFyc2VyIChDb2RlTWlycm9yIHN1cHBvcnRzIHRoYXQpXG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xufSk7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQveC1ycG0tc3BlY1wiLCBcInJwbS1zcGVjXCIpO1xuXG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIiksIHJlcXVpcmUoXCIuLi9weXRob24vcHl0aG9uXCIpLCByZXF1aXJlKFwiLi4vc3RleC9zdGV4XCIpLCByZXF1aXJlKFwiLi4vLi4vYWRkb24vbW9kZS9vdmVybGF5XCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIsIFwiLi4vcHl0aG9uL3B5dGhvblwiLCBcIi4uL3N0ZXgvc3RleFwiLCBcIi4uLy4uL2FkZG9uL21vZGUvb3ZlcmxheVwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcblwidXNlIHN0cmljdFwiO1xuXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoJ3JzdCcsIGZ1bmN0aW9uIChjb25maWcsIG9wdGlvbnMpIHtcblxuICB2YXIgcnhfc3Ryb25nID0gL15cXCpcXCpbXlxcKlxcc10oPzpbXlxcKl0qW15cXCpcXHNdKT9cXCpcXCovO1xuICB2YXIgcnhfZW1waGFzaXMgPSAvXlxcKlteXFwqXFxzXSg/OlteXFwqXSpbXlxcKlxcc10pP1xcKi87XG4gIHZhciByeF9saXRlcmFsID0gL15gYFteYFxcc10oPzpbXmBdKlteYFxcc10pYGAvO1xuXG4gIHZhciByeF9udW1iZXIgPSAvXig/OltcXGRdKyg/OltcXC4sXVxcZCspKikvO1xuICB2YXIgcnhfcG9zaXRpdmUgPSAvXig/Olxcc1xcK1tcXGRdKyg/OltcXC4sXVxcZCspKikvO1xuICB2YXIgcnhfbmVnYXRpdmUgPSAvXig/Olxcc1xcLVtcXGRdKyg/OltcXC4sXVxcZCspKikvO1xuXG4gIHZhciByeF91cmlfcHJvdG9jb2wgPSBcIltIaF1bVHRdW1R0XVtQcF1bU3NdPzovL1wiO1xuICB2YXIgcnhfdXJpX2RvbWFpbiA9IFwiKD86W1xcXFxkXFxcXHcuLV0rKVxcXFwuKD86XFxcXHd7Miw2fSlcIjtcbiAgdmFyIHJ4X3VyaV9wYXRoID0gXCIoPzovW1xcXFxkXFxcXHdcXFxcI1xcXFwlXFxcXCZcXFxcLVxcXFwuXFxcXCxcXFxcL1xcXFw6XFxcXD1cXFxcP1xcXFx+XSspKlwiO1xuICB2YXIgcnhfdXJpID0gbmV3IFJlZ0V4cChcIl5cIiArIHJ4X3VyaV9wcm90b2NvbCArIHJ4X3VyaV9kb21haW4gKyByeF91cmlfcGF0aCk7XG5cbiAgdmFyIG92ZXJsYXkgPSB7XG4gICAgdG9rZW46IGZ1bmN0aW9uIChzdHJlYW0pIHtcblxuICAgICAgaWYgKHN0cmVhbS5tYXRjaChyeF9zdHJvbmcpICYmIHN0cmVhbS5tYXRjaCAoL1xcVyt8JC8sIGZhbHNlKSlcbiAgICAgICAgcmV0dXJuICdzdHJvbmcnO1xuICAgICAgaWYgKHN0cmVhbS5tYXRjaChyeF9lbXBoYXNpcykgJiYgc3RyZWFtLm1hdGNoICgvXFxXK3wkLywgZmFsc2UpKVxuICAgICAgICByZXR1cm4gJ2VtJztcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2gocnhfbGl0ZXJhbCkgJiYgc3RyZWFtLm1hdGNoICgvXFxXK3wkLywgZmFsc2UpKVxuICAgICAgICByZXR1cm4gJ3N0cmluZy0yJztcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2gocnhfbnVtYmVyKSlcbiAgICAgICAgcmV0dXJuICdudW1iZXInO1xuICAgICAgaWYgKHN0cmVhbS5tYXRjaChyeF9wb3NpdGl2ZSkpXG4gICAgICAgIHJldHVybiAncG9zaXRpdmUnO1xuICAgICAgaWYgKHN0cmVhbS5tYXRjaChyeF9uZWdhdGl2ZSkpXG4gICAgICAgIHJldHVybiAnbmVnYXRpdmUnO1xuICAgICAgaWYgKHN0cmVhbS5tYXRjaChyeF91cmkpKVxuICAgICAgICByZXR1cm4gJ2xpbmsnO1xuXG4gICAgICB3aGlsZSAoc3RyZWFtLm5leHQoKSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2gocnhfc3Ryb25nLCBmYWxzZSkpIGJyZWFrO1xuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKHJ4X2VtcGhhc2lzLCBmYWxzZSkpIGJyZWFrO1xuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKHJ4X2xpdGVyYWwsIGZhbHNlKSkgYnJlYWs7XG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2gocnhfbnVtYmVyLCBmYWxzZSkpIGJyZWFrO1xuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKHJ4X3Bvc2l0aXZlLCBmYWxzZSkpIGJyZWFrO1xuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKHJ4X25lZ2F0aXZlLCBmYWxzZSkpIGJyZWFrO1xuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKHJ4X3VyaSwgZmFsc2UpKSBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuXG4gIHZhciBtb2RlID0gQ29kZU1pcnJvci5nZXRNb2RlKFxuICAgIGNvbmZpZywgb3B0aW9ucy5iYWNrZHJvcCB8fCAncnN0LWJhc2UnXG4gICk7XG5cbiAgcmV0dXJuIENvZGVNaXJyb3Iub3ZlcmxheU1vZGUobW9kZSwgb3ZlcmxheSwgdHJ1ZSk7IC8vIGNvbWJpbmVcbn0sICdweXRob24nLCAnc3RleCcpO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbkNvZGVNaXJyb3IuZGVmaW5lTW9kZSgncnN0LWJhc2UnLCBmdW5jdGlvbiAoY29uZmlnKSB7XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIGZ1bmN0aW9uIGZvcm1hdChzdHJpbmcpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC97KFxcZCspfS9nLCBmdW5jdGlvbiAobWF0Y2gsIG4pIHtcbiAgICAgIHJldHVybiB0eXBlb2YgYXJnc1tuXSAhPSAndW5kZWZpbmVkJyA/IGFyZ3Nbbl0gOiBtYXRjaDtcbiAgICB9KTtcbiAgfVxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICB2YXIgbW9kZV9weXRob24gPSBDb2RlTWlycm9yLmdldE1vZGUoY29uZmlnLCAncHl0aG9uJyk7XG4gIHZhciBtb2RlX3N0ZXggPSBDb2RlTWlycm9yLmdldE1vZGUoY29uZmlnLCAnc3RleCcpO1xuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICB2YXIgU0VQQSA9IFwiXFxcXHMrXCI7XG4gIHZhciBUQUlMID0gXCIoPzpcXFxccyp8XFxcXFd8JClcIixcbiAgcnhfVEFJTCA9IG5ldyBSZWdFeHAoZm9ybWF0KCdeezB9JywgVEFJTCkpO1xuXG4gIHZhciBOQU1FID1cbiAgICBcIig/OlteXFxcXFdcXFxcZF9dKD86W1xcXFx3IVxcXCIjJCUmJygpXFxcXCpcXFxcKyxcXFxcLVxcXFwuXFwvOjs8PT5cXFxcP10qW15cXFxcV19dKT8pXCIsXG4gIHJ4X05BTUUgPSBuZXcgUmVnRXhwKGZvcm1hdCgnXnswfScsIE5BTUUpKTtcbiAgdmFyIE5BTUVfV1dTID1cbiAgICBcIig/OlteXFxcXFdcXFxcZF9dKD86W1xcXFx3XFxcXHMhXFxcIiMkJSYnKClcXFxcKlxcXFwrLFxcXFwtXFxcXC5cXC86Ozw9PlxcXFw/XSpbXlxcXFxXX10pPylcIjtcbiAgdmFyIFJFRl9OQU1FID0gZm9ybWF0KCcoPzp7MH18YHsxfWApJywgTkFNRSwgTkFNRV9XV1MpO1xuXG4gIHZhciBURVhUMSA9IFwiKD86W15cXFxcc1xcXFx8XSg/OlteXFxcXHxdKlteXFxcXHNcXFxcfF0pPylcIjtcbiAgdmFyIFRFWFQyID0gXCIoPzpbXlxcXFxgXSspXCIsXG4gIHJ4X1RFWFQyID0gbmV3IFJlZ0V4cChmb3JtYXQoJ157MH0nLCBURVhUMikpO1xuXG4gIHZhciByeF9zZWN0aW9uID0gbmV3IFJlZ0V4cChcbiAgICBcIl4oWyEnIyQlJlxcXCIoKSorLC0uLzo7PD0+P0BcXFxcW1xcXFxcXFxcXFxcXF1eX2B7fH1+XSlcXFxcMXszLH1cXFxccyokXCIpO1xuICB2YXIgcnhfZXhwbGljaXQgPSBuZXcgUmVnRXhwKFxuICAgIGZvcm1hdCgnXlxcXFwuXFxcXC57MH0nLCBTRVBBKSk7XG4gIHZhciByeF9saW5rID0gbmV3IFJlZ0V4cChcbiAgICBmb3JtYXQoJ15fezB9OnsxfXxeX186ezF9JywgUkVGX05BTUUsIFRBSUwpKTtcbiAgdmFyIHJ4X2RpcmVjdGl2ZSA9IG5ldyBSZWdFeHAoXG4gICAgZm9ybWF0KCdeezB9Ojp7MX0nLCBSRUZfTkFNRSwgVEFJTCkpO1xuICB2YXIgcnhfc3Vic3RpdHV0aW9uID0gbmV3IFJlZ0V4cChcbiAgICBmb3JtYXQoJ15cXFxcfHswfVxcXFx8ezF9ezJ9Ojp7M30nLCBURVhUMSwgU0VQQSwgUkVGX05BTUUsIFRBSUwpKTtcbiAgdmFyIHJ4X2Zvb3Rub3RlID0gbmV3IFJlZ0V4cChcbiAgICBmb3JtYXQoJ15cXFxcWyg/OlxcXFxkK3wjezB9P3xcXFxcKildezF9JywgUkVGX05BTUUsIFRBSUwpKTtcbiAgdmFyIHJ4X2NpdGF0aW9uID0gbmV3IFJlZ0V4cChcbiAgICBmb3JtYXQoJ15cXFxcW3swfVxcXFxdezF9JywgUkVGX05BTUUsIFRBSUwpKTtcblxuICB2YXIgcnhfc3Vic3RpdHV0aW9uX3JlZiA9IG5ldyBSZWdFeHAoXG4gICAgZm9ybWF0KCdeXFxcXHx7MH1cXFxcfCcsIFRFWFQxKSk7XG4gIHZhciByeF9mb290bm90ZV9yZWYgPSBuZXcgUmVnRXhwKFxuICAgIGZvcm1hdCgnXlxcXFxbKD86XFxcXGQrfCN7MH0/fFxcXFwqKV1fJywgUkVGX05BTUUpKTtcbiAgdmFyIHJ4X2NpdGF0aW9uX3JlZiA9IG5ldyBSZWdFeHAoXG4gICAgZm9ybWF0KCdeXFxcXFt7MH1cXFxcXV8nLCBSRUZfTkFNRSkpO1xuICB2YXIgcnhfbGlua19yZWYxID0gbmV3IFJlZ0V4cChcbiAgICBmb3JtYXQoJ157MH1fXz8nLCBSRUZfTkFNRSkpO1xuICB2YXIgcnhfbGlua19yZWYyID0gbmV3IFJlZ0V4cChcbiAgICBmb3JtYXQoJ15gezB9YF8nLCBURVhUMikpO1xuXG4gIHZhciByeF9yb2xlX3ByZSA9IG5ldyBSZWdFeHAoXG4gICAgZm9ybWF0KCdeOnswfTpgezF9YHsyfScsIE5BTUUsIFRFWFQyLCBUQUlMKSk7XG4gIHZhciByeF9yb2xlX3N1ZiA9IG5ldyBSZWdFeHAoXG4gICAgZm9ybWF0KCdeYHsxfWA6ezB9OnsyfScsIE5BTUUsIFRFWFQyLCBUQUlMKSk7XG4gIHZhciByeF9yb2xlID0gbmV3IFJlZ0V4cChcbiAgICBmb3JtYXQoJ146ezB9OnsxfScsIE5BTUUsIFRBSUwpKTtcblxuICB2YXIgcnhfZGlyZWN0aXZlX25hbWUgPSBuZXcgUmVnRXhwKGZvcm1hdCgnXnswfScsIFJFRl9OQU1FKSk7XG4gIHZhciByeF9kaXJlY3RpdmVfdGFpbCA9IG5ldyBSZWdFeHAoZm9ybWF0KCdeOjp7MH0nLCBUQUlMKSk7XG4gIHZhciByeF9zdWJzdGl0dXRpb25fdGV4dCA9IG5ldyBSZWdFeHAoZm9ybWF0KCdeXFxcXHx7MH1cXFxcfCcsIFRFWFQxKSk7XG4gIHZhciByeF9zdWJzdGl0dXRpb25fc2VwYSA9IG5ldyBSZWdFeHAoZm9ybWF0KCdeezB9JywgU0VQQSkpO1xuICB2YXIgcnhfc3Vic3RpdHV0aW9uX25hbWUgPSBuZXcgUmVnRXhwKGZvcm1hdCgnXnswfScsIFJFRl9OQU1FKSk7XG4gIHZhciByeF9zdWJzdGl0dXRpb25fdGFpbCA9IG5ldyBSZWdFeHAoZm9ybWF0KCdeOjp7MH0nLCBUQUlMKSk7XG4gIHZhciByeF9saW5rX2hlYWQgPSBuZXcgUmVnRXhwKFwiXl9cIik7XG4gIHZhciByeF9saW5rX25hbWUgPSBuZXcgUmVnRXhwKGZvcm1hdCgnXnswfXxfJywgUkVGX05BTUUpKTtcbiAgdmFyIHJ4X2xpbmtfdGFpbCA9IG5ldyBSZWdFeHAoZm9ybWF0KCdeOnswfScsIFRBSUwpKTtcblxuICB2YXIgcnhfdmVyYmF0aW0gPSBuZXcgUmVnRXhwKCdeOjpcXFxccyokJyk7XG4gIHZhciByeF9leGFtcGxlcyA9IG5ldyBSZWdFeHAoJ15cXFxccysoPzo+Pj58SW4gXFxcXFtcXFxcZCtcXFxcXTopXFxcXHMnKTtcblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgZnVuY3Rpb24gdG9fbm9ybWFsKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgdG9rZW4gPSBudWxsO1xuXG4gICAgaWYgKHN0cmVhbS5zb2woKSAmJiBzdHJlYW0ubWF0Y2gocnhfZXhhbXBsZXMsIGZhbHNlKSkge1xuICAgICAgY2hhbmdlKHN0YXRlLCB0b19tb2RlLCB7XG4gICAgICAgIG1vZGU6IG1vZGVfcHl0aG9uLCBsb2NhbDogQ29kZU1pcnJvci5zdGFydFN0YXRlKG1vZGVfcHl0aG9uKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChzdHJlYW0uc29sKCkgJiYgc3RyZWFtLm1hdGNoKHJ4X2V4cGxpY2l0KSkge1xuICAgICAgY2hhbmdlKHN0YXRlLCB0b19leHBsaWNpdCk7XG4gICAgICB0b2tlbiA9ICdtZXRhJztcbiAgICB9IGVsc2UgaWYgKHN0cmVhbS5zb2woKSAmJiBzdHJlYW0ubWF0Y2gocnhfc2VjdGlvbikpIHtcbiAgICAgIGNoYW5nZShzdGF0ZSwgdG9fbm9ybWFsKTtcbiAgICAgIHRva2VuID0gJ2hlYWRlcic7XG4gICAgfSBlbHNlIGlmIChwaGFzZShzdGF0ZSkgPT0gcnhfcm9sZV9wcmUgfHxcbiAgICAgICAgICAgICAgIHN0cmVhbS5tYXRjaChyeF9yb2xlX3ByZSwgZmFsc2UpKSB7XG5cbiAgICAgIHN3aXRjaCAoc3RhZ2Uoc3RhdGUpKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIGNoYW5nZShzdGF0ZSwgdG9fbm9ybWFsLCBjb250ZXh0KHJ4X3JvbGVfcHJlLCAxKSk7XG4gICAgICAgIHN0cmVhbS5tYXRjaCgvXjovKTtcbiAgICAgICAgdG9rZW4gPSAnbWV0YSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICBjaGFuZ2Uoc3RhdGUsIHRvX25vcm1hbCwgY29udGV4dChyeF9yb2xlX3ByZSwgMikpO1xuICAgICAgICBzdHJlYW0ubWF0Y2gocnhfTkFNRSk7XG4gICAgICAgIHRva2VuID0gJ2tleXdvcmQnO1xuXG4gICAgICAgIGlmIChzdHJlYW0uY3VycmVudCgpLm1hdGNoKC9eKD86bWF0aHxsYXRleCkvKSkge1xuICAgICAgICAgIHN0YXRlLnRtcF9zdGV4ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgY2hhbmdlKHN0YXRlLCB0b19ub3JtYWwsIGNvbnRleHQocnhfcm9sZV9wcmUsIDMpKTtcbiAgICAgICAgc3RyZWFtLm1hdGNoKC9eOmAvKTtcbiAgICAgICAgdG9rZW4gPSAnbWV0YSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBpZiAoc3RhdGUudG1wX3N0ZXgpIHtcbiAgICAgICAgICBzdGF0ZS50bXBfc3RleCA9IHVuZGVmaW5lZDsgc3RhdGUudG1wID0ge1xuICAgICAgICAgICAgbW9kZTogbW9kZV9zdGV4LCBsb2NhbDogQ29kZU1pcnJvci5zdGFydFN0YXRlKG1vZGVfc3RleClcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXRlLnRtcCkge1xuICAgICAgICAgIGlmIChzdHJlYW0ucGVlaygpID09ICdgJykge1xuICAgICAgICAgICAgY2hhbmdlKHN0YXRlLCB0b19ub3JtYWwsIGNvbnRleHQocnhfcm9sZV9wcmUsIDQpKTtcbiAgICAgICAgICAgIHN0YXRlLnRtcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRva2VuID0gc3RhdGUudG1wLm1vZGUudG9rZW4oc3RyZWFtLCBzdGF0ZS50bXAubG9jYWwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hhbmdlKHN0YXRlLCB0b19ub3JtYWwsIGNvbnRleHQocnhfcm9sZV9wcmUsIDQpKTtcbiAgICAgICAgc3RyZWFtLm1hdGNoKHJ4X1RFWFQyKTtcbiAgICAgICAgdG9rZW4gPSAnc3RyaW5nJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIGNoYW5nZShzdGF0ZSwgdG9fbm9ybWFsLCBjb250ZXh0KHJ4X3JvbGVfcHJlLCA1KSk7XG4gICAgICAgIHN0cmVhbS5tYXRjaCgvXmAvKTtcbiAgICAgICAgdG9rZW4gPSAnbWV0YSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA1OlxuICAgICAgICBjaGFuZ2Uoc3RhdGUsIHRvX25vcm1hbCwgY29udGV4dChyeF9yb2xlX3ByZSwgNikpO1xuICAgICAgICBzdHJlYW0ubWF0Y2gocnhfVEFJTCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY2hhbmdlKHN0YXRlLCB0b19ub3JtYWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGhhc2Uoc3RhdGUpID09IHJ4X3JvbGVfc3VmIHx8XG4gICAgICAgICAgICAgICBzdHJlYW0ubWF0Y2gocnhfcm9sZV9zdWYsIGZhbHNlKSkge1xuXG4gICAgICBzd2l0Y2ggKHN0YWdlKHN0YXRlKSkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICBjaGFuZ2Uoc3RhdGUsIHRvX25vcm1hbCwgY29udGV4dChyeF9yb2xlX3N1ZiwgMSkpO1xuICAgICAgICBzdHJlYW0ubWF0Y2goL15gLyk7XG4gICAgICAgIHRva2VuID0gJ21ldGEnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgY2hhbmdlKHN0YXRlLCB0b19ub3JtYWwsIGNvbnRleHQocnhfcm9sZV9zdWYsIDIpKTtcbiAgICAgICAgc3RyZWFtLm1hdGNoKHJ4X1RFWFQyKTtcbiAgICAgICAgdG9rZW4gPSAnc3RyaW5nJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGNoYW5nZShzdGF0ZSwgdG9fbm9ybWFsLCBjb250ZXh0KHJ4X3JvbGVfc3VmLCAzKSk7XG4gICAgICAgIHN0cmVhbS5tYXRjaCgvXmA6Lyk7XG4gICAgICAgIHRva2VuID0gJ21ldGEnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgY2hhbmdlKHN0YXRlLCB0b19ub3JtYWwsIGNvbnRleHQocnhfcm9sZV9zdWYsIDQpKTtcbiAgICAgICAgc3RyZWFtLm1hdGNoKHJ4X05BTUUpO1xuICAgICAgICB0b2tlbiA9ICdrZXl3b3JkJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIGNoYW5nZShzdGF0ZSwgdG9fbm9ybWFsLCBjb250ZXh0KHJ4X3JvbGVfc3VmLCA1KSk7XG4gICAgICAgIHN0cmVhbS5tYXRjaCgvXjovKTtcbiAgICAgICAgdG9rZW4gPSAnbWV0YSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA1OlxuICAgICAgICBjaGFuZ2Uoc3RhdGUsIHRvX25vcm1hbCwgY29udGV4dChyeF9yb2xlX3N1ZiwgNikpO1xuICAgICAgICBzdHJlYW0ubWF0Y2gocnhfVEFJTCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY2hhbmdlKHN0YXRlLCB0b19ub3JtYWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGhhc2Uoc3RhdGUpID09IHJ4X3JvbGUgfHwgc3RyZWFtLm1hdGNoKHJ4X3JvbGUsIGZhbHNlKSkge1xuXG4gICAgICBzd2l0Y2ggKHN0YWdlKHN0YXRlKSkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICBjaGFuZ2Uoc3RhdGUsIHRvX25vcm1hbCwgY29udGV4dChyeF9yb2xlLCAxKSk7XG4gICAgICAgIHN0cmVhbS5tYXRjaCgvXjovKTtcbiAgICAgICAgdG9rZW4gPSAnbWV0YSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICBjaGFuZ2Uoc3RhdGUsIHRvX25vcm1hbCwgY29udGV4dChyeF9yb2xlLCAyKSk7XG4gICAgICAgIHN0cmVhbS5tYXRjaChyeF9OQU1FKTtcbiAgICAgICAgdG9rZW4gPSAna2V5d29yZCc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBjaGFuZ2Uoc3RhdGUsIHRvX25vcm1hbCwgY29udGV4dChyeF9yb2xlLCAzKSk7XG4gICAgICAgIHN0cmVhbS5tYXRjaCgvXjovKTtcbiAgICAgICAgdG9rZW4gPSAnbWV0YSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBjaGFuZ2Uoc3RhdGUsIHRvX25vcm1hbCwgY29udGV4dChyeF9yb2xlLCA0KSk7XG4gICAgICAgIHN0cmVhbS5tYXRjaChyeF9UQUlMKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjaGFuZ2Uoc3RhdGUsIHRvX25vcm1hbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwaGFzZShzdGF0ZSkgPT0gcnhfc3Vic3RpdHV0aW9uX3JlZiB8fFxuICAgICAgICAgICAgICAgc3RyZWFtLm1hdGNoKHJ4X3N1YnN0aXR1dGlvbl9yZWYsIGZhbHNlKSkge1xuXG4gICAgICBzd2l0Y2ggKHN0YWdlKHN0YXRlKSkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICBjaGFuZ2Uoc3RhdGUsIHRvX25vcm1hbCwgY29udGV4dChyeF9zdWJzdGl0dXRpb25fcmVmLCAxKSk7XG4gICAgICAgIHN0cmVhbS5tYXRjaChyeF9zdWJzdGl0dXRpb25fdGV4dCk7XG4gICAgICAgIHRva2VuID0gJ3ZhcmlhYmxlLTInO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgY2hhbmdlKHN0YXRlLCB0b19ub3JtYWwsIGNvbnRleHQocnhfc3Vic3RpdHV0aW9uX3JlZiwgMikpO1xuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eXz9fPy8pKSB0b2tlbiA9ICdsaW5rJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjaGFuZ2Uoc3RhdGUsIHRvX25vcm1hbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2gocnhfZm9vdG5vdGVfcmVmKSkge1xuICAgICAgY2hhbmdlKHN0YXRlLCB0b19ub3JtYWwpO1xuICAgICAgdG9rZW4gPSAncXVvdGUnO1xuICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKHJ4X2NpdGF0aW9uX3JlZikpIHtcbiAgICAgIGNoYW5nZShzdGF0ZSwgdG9fbm9ybWFsKTtcbiAgICAgIHRva2VuID0gJ3F1b3RlJztcbiAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaChyeF9saW5rX3JlZjEpKSB7XG4gICAgICBjaGFuZ2Uoc3RhdGUsIHRvX25vcm1hbCk7XG4gICAgICBpZiAoIXN0cmVhbS5wZWVrKCkgfHwgc3RyZWFtLnBlZWsoKS5tYXRjaCgvXlxcVyQvKSkge1xuICAgICAgICB0b2tlbiA9ICdsaW5rJztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBoYXNlKHN0YXRlKSA9PSByeF9saW5rX3JlZjIgfHxcbiAgICAgICAgICAgICAgIHN0cmVhbS5tYXRjaChyeF9saW5rX3JlZjIsIGZhbHNlKSkge1xuXG4gICAgICBzd2l0Y2ggKHN0YWdlKHN0YXRlKSkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICBpZiAoIXN0cmVhbS5wZWVrKCkgfHwgc3RyZWFtLnBlZWsoKS5tYXRjaCgvXlxcVyQvKSkge1xuICAgICAgICAgIGNoYW5nZShzdGF0ZSwgdG9fbm9ybWFsLCBjb250ZXh0KHJ4X2xpbmtfcmVmMiwgMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmVhbS5tYXRjaChyeF9saW5rX3JlZjIpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICBjaGFuZ2Uoc3RhdGUsIHRvX25vcm1hbCwgY29udGV4dChyeF9saW5rX3JlZjIsIDIpKTtcbiAgICAgICAgc3RyZWFtLm1hdGNoKC9eYC8pO1xuICAgICAgICB0b2tlbiA9ICdsaW5rJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGNoYW5nZShzdGF0ZSwgdG9fbm9ybWFsLCBjb250ZXh0KHJ4X2xpbmtfcmVmMiwgMykpO1xuICAgICAgICBzdHJlYW0ubWF0Y2gocnhfVEVYVDIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgY2hhbmdlKHN0YXRlLCB0b19ub3JtYWwsIGNvbnRleHQocnhfbGlua19yZWYyLCA0KSk7XG4gICAgICAgIHN0cmVhbS5tYXRjaCgvXmBfLyk7XG4gICAgICAgIHRva2VuID0gJ2xpbmsnO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNoYW5nZShzdGF0ZSwgdG9fbm9ybWFsKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaChyeF92ZXJiYXRpbSkpIHtcbiAgICAgIGNoYW5nZShzdGF0ZSwgdG9fdmVyYmF0aW0pO1xuICAgIH1cblxuICAgIGVsc2Uge1xuICAgICAgaWYgKHN0cmVhbS5uZXh0KCkpIGNoYW5nZShzdGF0ZSwgdG9fbm9ybWFsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9rZW47XG4gIH1cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgZnVuY3Rpb24gdG9fZXhwbGljaXQoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciB0b2tlbiA9IG51bGw7XG5cbiAgICBpZiAocGhhc2Uoc3RhdGUpID09IHJ4X3N1YnN0aXR1dGlvbiB8fFxuICAgICAgICBzdHJlYW0ubWF0Y2gocnhfc3Vic3RpdHV0aW9uLCBmYWxzZSkpIHtcblxuICAgICAgc3dpdGNoIChzdGFnZShzdGF0ZSkpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgY2hhbmdlKHN0YXRlLCB0b19leHBsaWNpdCwgY29udGV4dChyeF9zdWJzdGl0dXRpb24sIDEpKTtcbiAgICAgICAgc3RyZWFtLm1hdGNoKHJ4X3N1YnN0aXR1dGlvbl90ZXh0KTtcbiAgICAgICAgdG9rZW4gPSAndmFyaWFibGUtMic7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICBjaGFuZ2Uoc3RhdGUsIHRvX2V4cGxpY2l0LCBjb250ZXh0KHJ4X3N1YnN0aXR1dGlvbiwgMikpO1xuICAgICAgICBzdHJlYW0ubWF0Y2gocnhfc3Vic3RpdHV0aW9uX3NlcGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgY2hhbmdlKHN0YXRlLCB0b19leHBsaWNpdCwgY29udGV4dChyeF9zdWJzdGl0dXRpb24sIDMpKTtcbiAgICAgICAgc3RyZWFtLm1hdGNoKHJ4X3N1YnN0aXR1dGlvbl9uYW1lKTtcbiAgICAgICAgdG9rZW4gPSAna2V5d29yZCc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBjaGFuZ2Uoc3RhdGUsIHRvX2V4cGxpY2l0LCBjb250ZXh0KHJ4X3N1YnN0aXR1dGlvbiwgNCkpO1xuICAgICAgICBzdHJlYW0ubWF0Y2gocnhfc3Vic3RpdHV0aW9uX3RhaWwpO1xuICAgICAgICB0b2tlbiA9ICdtZXRhJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjaGFuZ2Uoc3RhdGUsIHRvX25vcm1hbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwaGFzZShzdGF0ZSkgPT0gcnhfZGlyZWN0aXZlIHx8XG4gICAgICAgICAgICAgICBzdHJlYW0ubWF0Y2gocnhfZGlyZWN0aXZlLCBmYWxzZSkpIHtcblxuICAgICAgc3dpdGNoIChzdGFnZShzdGF0ZSkpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgY2hhbmdlKHN0YXRlLCB0b19leHBsaWNpdCwgY29udGV4dChyeF9kaXJlY3RpdmUsIDEpKTtcbiAgICAgICAgc3RyZWFtLm1hdGNoKHJ4X2RpcmVjdGl2ZV9uYW1lKTtcbiAgICAgICAgdG9rZW4gPSAna2V5d29yZCc7XG5cbiAgICAgICAgaWYgKHN0cmVhbS5jdXJyZW50KCkubWF0Y2goL14oPzptYXRofGxhdGV4KS8pKVxuICAgICAgICAgIHN0YXRlLnRtcF9zdGV4ID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoc3RyZWFtLmN1cnJlbnQoKS5tYXRjaCgvXnB5dGhvbi8pKVxuICAgICAgICAgIHN0YXRlLnRtcF9weSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICBjaGFuZ2Uoc3RhdGUsIHRvX2V4cGxpY2l0LCBjb250ZXh0KHJ4X2RpcmVjdGl2ZSwgMikpO1xuICAgICAgICBzdHJlYW0ubWF0Y2gocnhfZGlyZWN0aXZlX3RhaWwpO1xuICAgICAgICB0b2tlbiA9ICdtZXRhJztcblxuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9ebGF0ZXhcXHMqJC8pIHx8IHN0YXRlLnRtcF9zdGV4KSB7XG4gICAgICAgICAgc3RhdGUudG1wX3N0ZXggPSB1bmRlZmluZWQ7IGNoYW5nZShzdGF0ZSwgdG9fbW9kZSwge1xuICAgICAgICAgICAgbW9kZTogbW9kZV9zdGV4LCBsb2NhbDogQ29kZU1pcnJvci5zdGFydFN0YXRlKG1vZGVfc3RleClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgY2hhbmdlKHN0YXRlLCB0b19leHBsaWNpdCwgY29udGV4dChyeF9kaXJlY3RpdmUsIDMpKTtcbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXnB5dGhvblxccyokLykgfHwgc3RhdGUudG1wX3B5KSB7XG4gICAgICAgICAgc3RhdGUudG1wX3B5ID0gdW5kZWZpbmVkOyBjaGFuZ2Uoc3RhdGUsIHRvX21vZGUsIHtcbiAgICAgICAgICAgIG1vZGU6IG1vZGVfcHl0aG9uLCBsb2NhbDogQ29kZU1pcnJvci5zdGFydFN0YXRlKG1vZGVfcHl0aG9uKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY2hhbmdlKHN0YXRlLCB0b19ub3JtYWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGhhc2Uoc3RhdGUpID09IHJ4X2xpbmsgfHwgc3RyZWFtLm1hdGNoKHJ4X2xpbmssIGZhbHNlKSkge1xuXG4gICAgICBzd2l0Y2ggKHN0YWdlKHN0YXRlKSkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICBjaGFuZ2Uoc3RhdGUsIHRvX2V4cGxpY2l0LCBjb250ZXh0KHJ4X2xpbmssIDEpKTtcbiAgICAgICAgc3RyZWFtLm1hdGNoKHJ4X2xpbmtfaGVhZCk7XG4gICAgICAgIHN0cmVhbS5tYXRjaChyeF9saW5rX25hbWUpO1xuICAgICAgICB0b2tlbiA9ICdsaW5rJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGNoYW5nZShzdGF0ZSwgdG9fZXhwbGljaXQsIGNvbnRleHQocnhfbGluaywgMikpO1xuICAgICAgICBzdHJlYW0ubWF0Y2gocnhfbGlua190YWlsKTtcbiAgICAgICAgdG9rZW4gPSAnbWV0YSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY2hhbmdlKHN0YXRlLCB0b19ub3JtYWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKHJ4X2Zvb3Rub3RlKSkge1xuICAgICAgY2hhbmdlKHN0YXRlLCB0b19ub3JtYWwpO1xuICAgICAgdG9rZW4gPSAncXVvdGUnO1xuICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKHJ4X2NpdGF0aW9uKSkge1xuICAgICAgY2hhbmdlKHN0YXRlLCB0b19ub3JtYWwpO1xuICAgICAgdG9rZW4gPSAncXVvdGUnO1xuICAgIH1cblxuICAgIGVsc2Uge1xuICAgICAgc3RyZWFtLmVhdFNwYWNlKCk7XG4gICAgICBpZiAoc3RyZWFtLmVvbCgpKSB7XG4gICAgICAgIGNoYW5nZShzdGF0ZSwgdG9fbm9ybWFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgY2hhbmdlKHN0YXRlLCB0b19jb21tZW50KTtcbiAgICAgICAgdG9rZW4gPSAnY29tbWVudCc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIGZ1bmN0aW9uIHRvX2NvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHJldHVybiBhc19ibG9jayhzdHJlYW0sIHN0YXRlLCAnY29tbWVudCcpO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9fdmVyYmF0aW0oc3RyZWFtLCBzdGF0ZSkge1xuICAgIHJldHVybiBhc19ibG9jayhzdHJlYW0sIHN0YXRlLCAnbWV0YScpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXNfYmxvY2soc3RyZWFtLCBzdGF0ZSwgdG9rZW4pIHtcbiAgICBpZiAoc3RyZWFtLmVvbCgpIHx8IHN0cmVhbS5lYXRTcGFjZSgpKSB7XG4gICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICByZXR1cm4gdG9rZW47XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoYW5nZShzdGF0ZSwgdG9fbm9ybWFsKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICBmdW5jdGlvbiB0b19tb2RlKHN0cmVhbSwgc3RhdGUpIHtcblxuICAgIGlmIChzdGF0ZS5jdHgubW9kZSAmJiBzdGF0ZS5jdHgubG9jYWwpIHtcblxuICAgICAgaWYgKHN0cmVhbS5zb2woKSkge1xuICAgICAgICBpZiAoIXN0cmVhbS5lYXRTcGFjZSgpKSBjaGFuZ2Uoc3RhdGUsIHRvX25vcm1hbCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RhdGUuY3R4Lm1vZGUudG9rZW4oc3RyZWFtLCBzdGF0ZS5jdHgubG9jYWwpO1xuICAgIH1cblxuICAgIGNoYW5nZShzdGF0ZSwgdG9fbm9ybWFsKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICBmdW5jdGlvbiBjb250ZXh0KHBoYXNlLCBzdGFnZSwgbW9kZSwgbG9jYWwpIHtcbiAgICByZXR1cm4ge3BoYXNlOiBwaGFzZSwgc3RhZ2U6IHN0YWdlLCBtb2RlOiBtb2RlLCBsb2NhbDogbG9jYWx9O1xuICB9XG5cbiAgZnVuY3Rpb24gY2hhbmdlKHN0YXRlLCB0b2ssIGN0eCkge1xuICAgIHN0YXRlLnRvayA9IHRvaztcbiAgICBzdGF0ZS5jdHggPSBjdHggfHwge307XG4gIH1cblxuICBmdW5jdGlvbiBzdGFnZShzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZS5jdHguc3RhZ2UgfHwgMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBoYXNlKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLmN0eC5waGFzZTtcbiAgfVxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICByZXR1cm4ge1xuICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7dG9rOiB0b19ub3JtYWwsIGN0eDogY29udGV4dCh1bmRlZmluZWQsIDApfTtcbiAgICB9LFxuXG4gICAgY29weVN0YXRlOiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIHZhciBjdHggPSBzdGF0ZS5jdHgsIHRtcCA9IHN0YXRlLnRtcDtcbiAgICAgIGlmIChjdHgubG9jYWwpXG4gICAgICAgIGN0eCA9IHttb2RlOiBjdHgubW9kZSwgbG9jYWw6IENvZGVNaXJyb3IuY29weVN0YXRlKGN0eC5tb2RlLCBjdHgubG9jYWwpfTtcbiAgICAgIGlmICh0bXApXG4gICAgICAgIHRtcCA9IHttb2RlOiB0bXAubW9kZSwgbG9jYWw6IENvZGVNaXJyb3IuY29weVN0YXRlKHRtcC5tb2RlLCB0bXAubG9jYWwpfTtcbiAgICAgIHJldHVybiB7dG9rOiBzdGF0ZS50b2ssIGN0eDogY3R4LCB0bXA6IHRtcH07XG4gICAgfSxcblxuICAgIGlubmVyTW9kZTogZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICByZXR1cm4gc3RhdGUudG1wICAgICAgPyB7c3RhdGU6IHN0YXRlLnRtcC5sb2NhbCwgbW9kZTogc3RhdGUudG1wLm1vZGV9XG4gICAgICA6IHN0YXRlLmN0eC5tb2RlID8ge3N0YXRlOiBzdGF0ZS5jdHgubG9jYWwsIG1vZGU6IHN0YXRlLmN0eC5tb2RlfVxuICAgICAgOiBudWxsO1xuICAgIH0sXG5cbiAgICB0b2tlbjogZnVuY3Rpb24gKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHJldHVybiBzdGF0ZS50b2soc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9O1xufSwgJ3B5dGhvbicsICdzdGV4Jyk7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuQ29kZU1pcnJvci5kZWZpbmVNSU1FKCd0ZXh0L3gtcnN0JywgJ3JzdCcpO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbn0pO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcblwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiB3b3JkT2JqKHdvcmRzKSB7XG4gIHZhciBvID0ge307XG4gIGZvciAodmFyIGkgPSAwLCBlID0gd29yZHMubGVuZ3RoOyBpIDwgZTsgKytpKSBvW3dvcmRzW2ldXSA9IHRydWU7XG4gIHJldHVybiBvO1xufVxuXG52YXIga2V5d29yZExpc3QgPSBbXG4gIFwiYWxpYXNcIiwgXCJhbmRcIiwgXCJCRUdJTlwiLCBcImJlZ2luXCIsIFwiYnJlYWtcIiwgXCJjYXNlXCIsIFwiY2xhc3NcIiwgXCJkZWZcIiwgXCJkZWZpbmVkP1wiLCBcImRvXCIsIFwiZWxzZVwiLFxuICBcImVsc2lmXCIsIFwiRU5EXCIsIFwiZW5kXCIsIFwiZW5zdXJlXCIsIFwiZmFsc2VcIiwgXCJmb3JcIiwgXCJpZlwiLCBcImluXCIsIFwibW9kdWxlXCIsIFwibmV4dFwiLCBcIm5vdFwiLCBcIm9yXCIsXG4gIFwicmVkb1wiLCBcInJlc2N1ZVwiLCBcInJldHJ5XCIsIFwicmV0dXJuXCIsIFwic2VsZlwiLCBcInN1cGVyXCIsIFwidGhlblwiLCBcInRydWVcIiwgXCJ1bmRlZlwiLCBcInVubGVzc1wiLFxuICBcInVudGlsXCIsIFwid2hlblwiLCBcIndoaWxlXCIsIFwieWllbGRcIiwgXCJuaWxcIiwgXCJyYWlzZVwiLCBcInRocm93XCIsIFwiY2F0Y2hcIiwgXCJmYWlsXCIsIFwibG9vcFwiLCBcImNhbGxjY1wiLFxuICBcImNhbGxlclwiLCBcImxhbWJkYVwiLCBcInByb2NcIiwgXCJwdWJsaWNcIiwgXCJwcm90ZWN0ZWRcIiwgXCJwcml2YXRlXCIsIFwicmVxdWlyZVwiLCBcImxvYWRcIixcbiAgXCJyZXF1aXJlX3JlbGF0aXZlXCIsIFwiZXh0ZW5kXCIsIFwiYXV0b2xvYWRcIiwgXCJfX0VORF9fXCIsIFwiX19GSUxFX19cIiwgXCJfX0xJTkVfX1wiLCBcIl9fZGlyX19cIlxuXSwga2V5d29yZHMgPSB3b3JkT2JqKGtleXdvcmRMaXN0KTtcblxudmFyIGluZGVudFdvcmRzID0gd29yZE9iaihbXCJkZWZcIiwgXCJjbGFzc1wiLCBcImNhc2VcIiwgXCJmb3JcIiwgXCJ3aGlsZVwiLCBcInVudGlsXCIsIFwibW9kdWxlXCIsIFwidGhlblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjYXRjaFwiLCBcImxvb3BcIiwgXCJwcm9jXCIsIFwiYmVnaW5cIl0pO1xudmFyIGRlZGVudFdvcmRzID0gd29yZE9iaihbXCJlbmRcIiwgXCJ1bnRpbFwiXSk7XG52YXIgb3BlbmluZyA9IHtcIltcIjogXCJdXCIsIFwie1wiOiBcIn1cIiwgXCIoXCI6IFwiKVwifTtcbnZhciBjbG9zaW5nID0ge1wiXVwiOiBcIltcIiwgXCJ9XCI6IFwie1wiLCBcIilcIjogXCIoXCJ9O1xuXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoXCJydWJ5XCIsIGZ1bmN0aW9uKGNvbmZpZykge1xuICB2YXIgY3VyUHVuYztcblxuICBmdW5jdGlvbiBjaGFpbihuZXd0b2ssIHN0cmVhbSwgc3RhdGUpIHtcbiAgICBzdGF0ZS50b2tlbml6ZS5wdXNoKG5ld3Rvayk7XG4gICAgcmV0dXJuIG5ld3RvayhzdHJlYW0sIHN0YXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHN0cmVhbS5zb2woKSAmJiBzdHJlYW0ubWF0Y2goXCI9YmVnaW5cIikgJiYgc3RyZWFtLmVvbCgpKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZS5wdXNoKHJlYWRCbG9ja0NvbW1lbnQpO1xuICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgIH1cbiAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xuICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCksIG07XG4gICAgaWYgKGNoID09IFwiYFwiIHx8IGNoID09IFwiJ1wiIHx8IGNoID09ICdcIicpIHtcbiAgICAgIHJldHVybiBjaGFpbihyZWFkUXVvdGVkKGNoLCBcInN0cmluZ1wiLCBjaCA9PSAnXCInIHx8IGNoID09IFwiYFwiKSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIGlmIChjaCA9PSBcIi9cIikge1xuICAgICAgaWYgKHJlZ2V4cEFoZWFkKHN0cmVhbSkpXG4gICAgICAgIHJldHVybiBjaGFpbihyZWFkUXVvdGVkKGNoLCBcInN0cmluZy0yXCIsIHRydWUpLCBzdHJlYW0sIHN0YXRlKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgICB9IGVsc2UgaWYgKGNoID09IFwiJVwiKSB7XG4gICAgICB2YXIgc3R5bGUgPSBcInN0cmluZ1wiLCBlbWJlZCA9IHRydWU7XG4gICAgICBpZiAoc3RyZWFtLmVhdChcInNcIikpIHN0eWxlID0gXCJhdG9tXCI7XG4gICAgICBlbHNlIGlmIChzdHJlYW0uZWF0KC9bV1FdLykpIHN0eWxlID0gXCJzdHJpbmdcIjtcbiAgICAgIGVsc2UgaWYgKHN0cmVhbS5lYXQoL1tyXS8pKSBzdHlsZSA9IFwic3RyaW5nLTJcIjtcbiAgICAgIGVsc2UgaWYgKHN0cmVhbS5lYXQoL1t3eHFdLykpIHsgc3R5bGUgPSBcInN0cmluZ1wiOyBlbWJlZCA9IGZhbHNlOyB9XG4gICAgICB2YXIgZGVsaW0gPSBzdHJlYW0uZWF0KC9bXlxcd1xccz1dLyk7XG4gICAgICBpZiAoIWRlbGltKSByZXR1cm4gXCJvcGVyYXRvclwiO1xuICAgICAgaWYgKG9wZW5pbmcucHJvcGVydHlJc0VudW1lcmFibGUoZGVsaW0pKSBkZWxpbSA9IG9wZW5pbmdbZGVsaW1dO1xuICAgICAgcmV0dXJuIGNoYWluKHJlYWRRdW90ZWQoZGVsaW0sIHN0eWxlLCBlbWJlZCwgdHJ1ZSksIHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSBpZiAoY2ggPT0gXCIjXCIpIHtcbiAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICB9IGVsc2UgaWYgKGNoID09IFwiPFwiICYmIChtID0gc3RyZWFtLm1hdGNoKC9ePChbLX5dKVtcXGBcXFwiXFwnXT8oW2EtekEtWl8/XVxcdyopW1xcYFxcXCJcXCddPyg/Ojt8JCkvKSkpIHtcbiAgICAgIHJldHVybiBjaGFpbihyZWFkSGVyZURvYyhtWzJdLCBtWzFdKSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIGlmIChjaCA9PSBcIjBcIikge1xuICAgICAgaWYgKHN0cmVhbS5lYXQoXCJ4XCIpKSBzdHJlYW0uZWF0V2hpbGUoL1tcXGRhLWZBLUZdLyk7XG4gICAgICBlbHNlIGlmIChzdHJlYW0uZWF0KFwiYlwiKSkgc3RyZWFtLmVhdFdoaWxlKC9bMDFdLyk7XG4gICAgICBlbHNlIHN0cmVhbS5lYXRXaGlsZSgvWzAtN10vKTtcbiAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgIH0gZWxzZSBpZiAoL1xcZC8udGVzdChjaCkpIHtcbiAgICAgIHN0cmVhbS5tYXRjaCgvXltcXGRfXSooPzpcXC5bXFxkX10rKT8oPzpbZUVdWytcXC1dP1tcXGRfXSspPy8pO1xuICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgfSBlbHNlIGlmIChjaCA9PSBcIj9cIikge1xuICAgICAgd2hpbGUgKHN0cmVhbS5tYXRjaCgvXlxcXFxbQ01dLS8pKSB7fVxuICAgICAgaWYgKHN0cmVhbS5lYXQoXCJcXFxcXCIpKSBzdHJlYW0uZWF0V2hpbGUoL1xcdy8pO1xuICAgICAgZWxzZSBzdHJlYW0ubmV4dCgpO1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfSBlbHNlIGlmIChjaCA9PSBcIjpcIikge1xuICAgICAgaWYgKHN0cmVhbS5lYXQoXCInXCIpKSByZXR1cm4gY2hhaW4ocmVhZFF1b3RlZChcIidcIiwgXCJhdG9tXCIsIGZhbHNlKSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBpZiAoc3RyZWFtLmVhdCgnXCInKSkgcmV0dXJuIGNoYWluKHJlYWRRdW90ZWQoJ1wiJywgXCJhdG9tXCIsIHRydWUpLCBzdHJlYW0sIHN0YXRlKTtcblxuICAgICAgLy8gOj4gOj4+IDo8IDo8PCBhcmUgdmFsaWQgc3ltYm9sc1xuICAgICAgaWYgKHN0cmVhbS5lYXQoL1tcXDxcXD5dLykpIHtcbiAgICAgICAgc3RyZWFtLmVhdCgvW1xcPFxcPl0vKTtcbiAgICAgICAgcmV0dXJuIFwiYXRvbVwiO1xuICAgICAgfVxuXG4gICAgICAvLyA6KyA6LSA6LyA6KiA6fCA6JiA6ISBhcmUgdmFsaWQgc3ltYm9sc1xuICAgICAgaWYgKHN0cmVhbS5lYXQoL1tcXCtcXC1cXCpcXC9cXCZcXHxcXDpcXCFdLykpIHtcbiAgICAgICAgcmV0dXJuIFwiYXRvbVwiO1xuICAgICAgfVxuXG4gICAgICAvLyBTeW1ib2xzIGNhbid0IHN0YXJ0IGJ5IGEgZGlnaXRcbiAgICAgIGlmIChzdHJlYW0uZWF0KC9bYS16QS1aJEBfXFx4YTEtXFx1ZmZmZl0vKSkge1xuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHckXFx4YTEtXFx1ZmZmZl0vKTtcbiAgICAgICAgLy8gT25seSBvbmUgPyAhID0gaXMgYWxsb3dlZCBhbmQgb25seSBhcyB0aGUgbGFzdCBjaGFyYWN0ZXJcbiAgICAgICAgc3RyZWFtLmVhdCgvW1xcP1xcIVxcPV0vKTtcbiAgICAgICAgcmV0dXJuIFwiYXRvbVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgICB9IGVsc2UgaWYgKGNoID09IFwiQFwiICYmIHN0cmVhbS5tYXRjaCgvXkA/W2EtekEtWl9cXHhhMS1cXHVmZmZmXS8pKSB7XG4gICAgICBzdHJlYW0uZWF0KFwiQFwiKTtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xceGExLVxcdWZmZmZdLyk7XG4gICAgICByZXR1cm4gXCJ2YXJpYWJsZS0yXCI7XG4gICAgfSBlbHNlIGlmIChjaCA9PSBcIiRcIikge1xuICAgICAgaWYgKHN0cmVhbS5lYXQoL1thLXpBLVpfXS8pKSB7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd10vKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLmVhdCgvXFxkLykpIHtcbiAgICAgICAgc3RyZWFtLmVhdCgvXFxkLyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJlYW0ubmV4dCgpOyAvLyBNdXN0IGJlIGEgc3BlY2lhbCBnbG9iYWwgbGlrZSAkOiBvciAkIVxuICAgICAgfVxuICAgICAgcmV0dXJuIFwidmFyaWFibGUtM1wiO1xuICAgIH0gZWxzZSBpZiAoL1thLXpBLVpfXFx4YTEtXFx1ZmZmZl0vLnRlc3QoY2gpKSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXHhhMS1cXHVmZmZmXS8pO1xuICAgICAgc3RyZWFtLmVhdCgvW1xcP1xcIV0vKTtcbiAgICAgIGlmIChzdHJlYW0uZWF0KFwiOlwiKSkgcmV0dXJuIFwiYXRvbVwiO1xuICAgICAgcmV0dXJuIFwiaWRlbnRcIjtcbiAgICB9IGVsc2UgaWYgKGNoID09IFwifFwiICYmIChzdGF0ZS52YXJMaXN0IHx8IHN0YXRlLmxhc3RUb2sgPT0gXCJ7XCIgfHwgc3RhdGUubGFzdFRvayA9PSBcImRvXCIpKSB7XG4gICAgICBjdXJQdW5jID0gXCJ8XCI7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKC9bXFwoXFwpXFxbXFxde31cXFxcO10vLnRlc3QoY2gpKSB7XG4gICAgICBjdXJQdW5jID0gY2g7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGNoID09IFwiLVwiICYmIHN0cmVhbS5lYXQoXCI+XCIpKSB7XG4gICAgICByZXR1cm4gXCJhcnJvd1wiO1xuICAgIH0gZWxzZSBpZiAoL1s9K1xcLVxcLyo6XFwuXiU8Pn58XS8udGVzdChjaCkpIHtcbiAgICAgIHZhciBtb3JlID0gc3RyZWFtLmVhdFdoaWxlKC9bPStcXC1cXC8qOlxcLl4lPD5+fF0vKTtcbiAgICAgIGlmIChjaCA9PSBcIi5cIiAmJiAhbW9yZSkgY3VyUHVuYyA9IFwiLlwiO1xuICAgICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVnZXhwQWhlYWQoc3RyZWFtKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RyZWFtLnBvcywgZGVwdGggPSAwLCBuZXh0LCBmb3VuZCA9IGZhbHNlLCBlc2NhcGVkID0gZmFsc2VcbiAgICB3aGlsZSAoKG5leHQgPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICBpZiAoIWVzY2FwZWQpIHtcbiAgICAgICAgaWYgKFwiW3soXCIuaW5kZXhPZihuZXh0KSA+IC0xKSB7XG4gICAgICAgICAgZGVwdGgrK1xuICAgICAgICB9IGVsc2UgaWYgKFwiXX0pXCIuaW5kZXhPZihuZXh0KSA+IC0xKSB7XG4gICAgICAgICAgZGVwdGgtLVxuICAgICAgICAgIGlmIChkZXB0aCA8IDApIGJyZWFrXG4gICAgICAgIH0gZWxzZSBpZiAobmV4dCA9PSBcIi9cIiAmJiBkZXB0aCA9PSAwKSB7XG4gICAgICAgICAgZm91bmQgPSB0cnVlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBlc2NhcGVkID0gbmV4dCA9PSBcIlxcXFxcIlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXNjYXBlZCA9IGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIHN0cmVhbS5iYWNrVXAoc3RyZWFtLnBvcyAtIHN0YXJ0KVxuICAgIHJldHVybiBmb3VuZFxuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5CYXNlVW50aWxCcmFjZShkZXB0aCkge1xuICAgIGlmICghZGVwdGgpIGRlcHRoID0gMTtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKHN0cmVhbS5wZWVrKCkgPT0gXCJ9XCIpIHtcbiAgICAgICAgaWYgKGRlcHRoID09IDEpIHtcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZS5wb3AoKTtcbiAgICAgICAgICByZXR1cm4gc3RhdGUudG9rZW5pemVbc3RhdGUudG9rZW5pemUubGVuZ3RoLTFdKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLnRva2VuaXplW3N0YXRlLnRva2VuaXplLmxlbmd0aCAtIDFdID0gdG9rZW5CYXNlVW50aWxCcmFjZShkZXB0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHN0cmVhbS5wZWVrKCkgPT0gXCJ7XCIpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemVbc3RhdGUudG9rZW5pemUubGVuZ3RoIC0gMV0gPSB0b2tlbkJhc2VVbnRpbEJyYWNlKGRlcHRoICsgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gdG9rZW5CYXNlT25jZSgpIHtcbiAgICB2YXIgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAoYWxyZWFkeUNhbGxlZCkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZS5wb3AoKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplW3N0YXRlLnRva2VuaXplLmxlbmd0aC0xXShzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIGFscmVhZHlDYWxsZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHJlYWRRdW90ZWQocXVvdGUsIHN0eWxlLCBlbWJlZCwgdW5lc2NhcGVkKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBlc2NhcGVkID0gZmFsc2UsIGNoO1xuXG4gICAgICBpZiAoc3RhdGUuY29udGV4dC50eXBlID09PSAncmVhZC1xdW90ZWQtcGF1c2VkJykge1xuICAgICAgICBzdGF0ZS5jb250ZXh0ID0gc3RhdGUuY29udGV4dC5wcmV2O1xuICAgICAgICBzdHJlYW0uZWF0KFwifVwiKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKChjaCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGNoID09IHF1b3RlICYmICh1bmVzY2FwZWQgfHwgIWVzY2FwZWQpKSB7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemUucG9wKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVtYmVkICYmIGNoID09IFwiI1wiICYmICFlc2NhcGVkKSB7XG4gICAgICAgICAgaWYgKHN0cmVhbS5lYXQoXCJ7XCIpKSB7XG4gICAgICAgICAgICBpZiAocXVvdGUgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgc3RhdGUuY29udGV4dCA9IHtwcmV2OiBzdGF0ZS5jb250ZXh0LCB0eXBlOiAncmVhZC1xdW90ZWQtcGF1c2VkJ307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZS50b2tlbml6ZS5wdXNoKHRva2VuQmFzZVVudGlsQnJhY2UoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2UgaWYgKC9bQFxcJF0vLnRlc3Qoc3RyZWFtLnBlZWsoKSkpIHtcbiAgICAgICAgICAgIHN0YXRlLnRva2VuaXplLnB1c2godG9rZW5CYXNlT25jZSgpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQgJiYgY2ggPT0gXCJcXFxcXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiByZWFkSGVyZURvYyhwaHJhc2UsIG1heUluZGVudCkge1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAobWF5SW5kZW50KSBzdHJlYW0uZWF0U3BhY2UoKVxuICAgICAgaWYgKHN0cmVhbS5tYXRjaChwaHJhc2UpKSBzdGF0ZS50b2tlbml6ZS5wb3AoKTtcbiAgICAgIGVsc2Ugc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiByZWFkQmxvY2tDb21tZW50KHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RyZWFtLnNvbCgpICYmIHN0cmVhbS5tYXRjaChcIj1lbmRcIikgJiYgc3RyZWFtLmVvbCgpKVxuICAgICAgc3RhdGUudG9rZW5pemUucG9wKCk7XG4gICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge3Rva2VuaXplOiBbdG9rZW5CYXNlXSxcbiAgICAgICAgICAgICAgaW5kZW50ZWQ6IDAsXG4gICAgICAgICAgICAgIGNvbnRleHQ6IHt0eXBlOiBcInRvcFwiLCBpbmRlbnRlZDogLWNvbmZpZy5pbmRlbnRVbml0fSxcbiAgICAgICAgICAgICAgY29udGludWVkTGluZTogZmFsc2UsXG4gICAgICAgICAgICAgIGxhc3RUb2s6IG51bGwsXG4gICAgICAgICAgICAgIHZhckxpc3Q6IGZhbHNlfTtcbiAgICB9LFxuXG4gICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGN1clB1bmMgPSBudWxsO1xuICAgICAgaWYgKHN0cmVhbS5zb2woKSkgc3RhdGUuaW5kZW50ZWQgPSBzdHJlYW0uaW5kZW50YXRpb24oKTtcbiAgICAgIHZhciBzdHlsZSA9IHN0YXRlLnRva2VuaXplW3N0YXRlLnRva2VuaXplLmxlbmd0aC0xXShzdHJlYW0sIHN0YXRlKSwga3d0eXBlO1xuICAgICAgdmFyIHRoaXNUb2sgPSBjdXJQdW5jO1xuICAgICAgaWYgKHN0eWxlID09IFwiaWRlbnRcIikge1xuICAgICAgICB2YXIgd29yZCA9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAgICAgIHN0eWxlID0gc3RhdGUubGFzdFRvayA9PSBcIi5cIiA/IFwicHJvcGVydHlcIlxuICAgICAgICAgIDoga2V5d29yZHMucHJvcGVydHlJc0VudW1lcmFibGUoc3RyZWFtLmN1cnJlbnQoKSkgPyBcImtleXdvcmRcIlxuICAgICAgICAgIDogL15bQS1aXS8udGVzdCh3b3JkKSA/IFwidGFnXCJcbiAgICAgICAgICA6IChzdGF0ZS5sYXN0VG9rID09IFwiZGVmXCIgfHwgc3RhdGUubGFzdFRvayA9PSBcImNsYXNzXCIgfHwgc3RhdGUudmFyTGlzdCkgPyBcImRlZlwiXG4gICAgICAgICAgOiBcInZhcmlhYmxlXCI7XG4gICAgICAgIGlmIChzdHlsZSA9PSBcImtleXdvcmRcIikge1xuICAgICAgICAgIHRoaXNUb2sgPSB3b3JkO1xuICAgICAgICAgIGlmIChpbmRlbnRXb3Jkcy5wcm9wZXJ0eUlzRW51bWVyYWJsZSh3b3JkKSkga3d0eXBlID0gXCJpbmRlbnRcIjtcbiAgICAgICAgICBlbHNlIGlmIChkZWRlbnRXb3Jkcy5wcm9wZXJ0eUlzRW51bWVyYWJsZSh3b3JkKSkga3d0eXBlID0gXCJkZWRlbnRcIjtcbiAgICAgICAgICBlbHNlIGlmICgod29yZCA9PSBcImlmXCIgfHwgd29yZCA9PSBcInVubGVzc1wiKSAmJiBzdHJlYW0uY29sdW1uKCkgPT0gc3RyZWFtLmluZGVudGF0aW9uKCkpXG4gICAgICAgICAgICBrd3R5cGUgPSBcImluZGVudFwiO1xuICAgICAgICAgIGVsc2UgaWYgKHdvcmQgPT0gXCJkb1wiICYmIHN0YXRlLmNvbnRleHQuaW5kZW50ZWQgPCBzdGF0ZS5pbmRlbnRlZClcbiAgICAgICAgICAgIGt3dHlwZSA9IFwiaW5kZW50XCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjdXJQdW5jIHx8IChzdHlsZSAmJiBzdHlsZSAhPSBcImNvbW1lbnRcIikpIHN0YXRlLmxhc3RUb2sgPSB0aGlzVG9rO1xuICAgICAgaWYgKGN1clB1bmMgPT0gXCJ8XCIpIHN0YXRlLnZhckxpc3QgPSAhc3RhdGUudmFyTGlzdDtcblxuICAgICAgaWYgKGt3dHlwZSA9PSBcImluZGVudFwiIHx8IC9bXFwoXFxbXFx7XS8udGVzdChjdXJQdW5jKSlcbiAgICAgICAgc3RhdGUuY29udGV4dCA9IHtwcmV2OiBzdGF0ZS5jb250ZXh0LCB0eXBlOiBjdXJQdW5jIHx8IHN0eWxlLCBpbmRlbnRlZDogc3RhdGUuaW5kZW50ZWR9O1xuICAgICAgZWxzZSBpZiAoKGt3dHlwZSA9PSBcImRlZGVudFwiIHx8IC9bXFwpXFxdXFx9XS8udGVzdChjdXJQdW5jKSkgJiYgc3RhdGUuY29udGV4dC5wcmV2KVxuICAgICAgICBzdGF0ZS5jb250ZXh0ID0gc3RhdGUuY29udGV4dC5wcmV2O1xuXG4gICAgICBpZiAoc3RyZWFtLmVvbCgpKVxuICAgICAgICBzdGF0ZS5jb250aW51ZWRMaW5lID0gKGN1clB1bmMgPT0gXCJcXFxcXCIgfHwgc3R5bGUgPT0gXCJvcGVyYXRvclwiKTtcbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9LFxuXG4gICAgaW5kZW50OiBmdW5jdGlvbihzdGF0ZSwgdGV4dEFmdGVyKSB7XG4gICAgICBpZiAoc3RhdGUudG9rZW5pemVbc3RhdGUudG9rZW5pemUubGVuZ3RoLTFdICE9IHRva2VuQmFzZSkgcmV0dXJuIENvZGVNaXJyb3IuUGFzcztcbiAgICAgIHZhciBmaXJzdENoYXIgPSB0ZXh0QWZ0ZXIgJiYgdGV4dEFmdGVyLmNoYXJBdCgwKTtcbiAgICAgIHZhciBjdCA9IHN0YXRlLmNvbnRleHQ7XG4gICAgICB2YXIgY2xvc2VkID0gY3QudHlwZSA9PSBjbG9zaW5nW2ZpcnN0Q2hhcl0gfHxcbiAgICAgICAgY3QudHlwZSA9PSBcImtleXdvcmRcIiAmJiAvXig/OmVuZHx1bnRpbHxlbHNlfGVsc2lmfHdoZW58cmVzY3VlKVxcYi8udGVzdCh0ZXh0QWZ0ZXIpO1xuICAgICAgcmV0dXJuIGN0LmluZGVudGVkICsgKGNsb3NlZCA/IDAgOiBjb25maWcuaW5kZW50VW5pdCkgK1xuICAgICAgICAoc3RhdGUuY29udGludWVkTGluZSA/IGNvbmZpZy5pbmRlbnRVbml0IDogMCk7XG4gICAgfSxcblxuICAgIGVsZWN0cmljSW5wdXQ6IC9eXFxzKig/OmVuZHxyZXNjdWV8ZWxzaWZ8ZWxzZXxcXH0pJC8sXG4gICAgbGluZUNvbW1lbnQ6IFwiI1wiLFxuICAgIGZvbGQ6IFwiaW5kZW50XCJcbiAgfTtcbn0pO1xuXG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3gtcnVieVwiLCBcInJ1YnlcIik7XG5cbkNvZGVNaXJyb3IucmVnaXN0ZXJIZWxwZXIoXCJoaW50V29yZHNcIiwgXCJydWJ5XCIsIGtleXdvcmRMaXN0KTtcblxufSk7XG4iLCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpLCByZXF1aXJlKFwiLi4vLi4vYWRkb24vbW9kZS9zaW1wbGVcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIiwgXCIuLi8uLi9hZGRvbi9tb2RlL3NpbXBsZVwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcblwidXNlIHN0cmljdFwiO1xuXG5Db2RlTWlycm9yLmRlZmluZVNpbXBsZU1vZGUoXCJydXN0XCIse1xuICBzdGFydDogW1xuICAgIC8vIHN0cmluZyBhbmQgYnl0ZSBzdHJpbmdcbiAgICB7cmVnZXg6IC9iP1wiLywgdG9rZW46IFwic3RyaW5nXCIsIG5leHQ6IFwic3RyaW5nXCJ9LFxuICAgIC8vIHJhdyBzdHJpbmcgYW5kIHJhdyBieXRlIHN0cmluZ1xuICAgIHtyZWdleDogL2I/clwiLywgdG9rZW46IFwic3RyaW5nXCIsIG5leHQ6IFwic3RyaW5nX3Jhd1wifSxcbiAgICB7cmVnZXg6IC9iP3IjK1wiLywgdG9rZW46IFwic3RyaW5nXCIsIG5leHQ6IFwic3RyaW5nX3Jhd19oYXNoXCJ9LFxuICAgIC8vIGNoYXJhY3RlclxuICAgIHtyZWdleDogLycoPzpbXidcXFxcXXxcXFxcKD86W25ydDAnXCJdfHhbXFxkYS1mQS1GXXsyfXx1XFx7W1xcZGEtZkEtRl17Nn1cXH0pKScvLCB0b2tlbjogXCJzdHJpbmctMlwifSxcbiAgICAvLyBieXRlXG4gICAge3JlZ2V4OiAvYicoPzpbXiddfFxcXFwoPzpbJ1xcXFxucnQwXXx4W1xcZGEtZkEtRl17Mn0pKScvLCB0b2tlbjogXCJzdHJpbmctMlwifSxcblxuICAgIHtyZWdleDogLyg/Oig/OlswLTldWzAtOV9dKikoPzooPzpbRWVdWystXT9bMC05X10rKXxcXC5bMC05X10rKD86W0VlXVsrLV0/WzAtOV9dKyk/KSg/OmYzMnxmNjQpPyl8KD86MCg/OmJbMDFfXSt8KD86b1swLTdfXSspfCg/OnhbMC05YS1mQS1GX10rKSl8KD86WzAtOV1bMC05X10qKSkoPzp1OHx1MTZ8dTMyfHU2NHxpOHxpMTZ8aTMyfGk2NHxpc2l6ZXx1c2l6ZSk/LyxcbiAgICAgdG9rZW46IFwibnVtYmVyXCJ9LFxuICAgIHtyZWdleDogLyhsZXQoPzpcXHMrbXV0KT98Zm58ZW51bXxtb2R8c3RydWN0fHR5cGV8dW5pb24pKFxccyspKFthLXpBLVpfXVthLXpBLVowLTlfXSopLywgdG9rZW46IFtcImtleXdvcmRcIiwgbnVsbCwgXCJkZWZcIl19LFxuICAgIHtyZWdleDogLyg/OmFic3RyYWN0fGFsaWdub2Z8YXN8YXN5bmN8YXdhaXR8Ym94fGJyZWFrfGNvbnRpbnVlfGNvbnN0fGNyYXRlfGRvfGR5bnxlbHNlfGVudW18ZXh0ZXJufGZufGZvcnxmaW5hbHxpZnxpbXBsfGlufGxvb3B8bWFjcm98bWF0Y2h8bW9kfG1vdmV8b2Zmc2V0b2Z8b3ZlcnJpZGV8cHJpdnxwcm9jfHB1YnxwdXJlfHJlZnxyZXR1cm58c2VsZnxzaXplb2Z8c3RhdGljfHN0cnVjdHxzdXBlcnx0cmFpdHx0eXBlfHR5cGVvZnx1bmlvbnx1bnNhZmV8dW5zaXplZHx1c2V8dmlydHVhbHx3aGVyZXx3aGlsZXx5aWVsZClcXGIvLCB0b2tlbjogXCJrZXl3b3JkXCJ9LFxuICAgIHtyZWdleDogL1xcYig/OlNlbGZ8aXNpemV8dXNpemV8Y2hhcnxib29sfHU4fHUxNnx1MzJ8dTY0fGYxNnxmMzJ8ZjY0fGk4fGkxNnxpMzJ8aTY0fHN0cnxPcHRpb24pXFxiLywgdG9rZW46IFwiYXRvbVwifSxcbiAgICB7cmVnZXg6IC9cXGIoPzp0cnVlfGZhbHNlfFNvbWV8Tm9uZXxPa3xFcnIpXFxiLywgdG9rZW46IFwiYnVpbHRpblwifSxcbiAgICB7cmVnZXg6IC9cXGIoZm4pKFxccyspKFthLXpBLVpfXVthLXpBLVowLTlfXSopLyxcbiAgICAgdG9rZW46IFtcImtleXdvcmRcIiwgbnVsbCAsXCJkZWZcIl19LFxuICAgIHtyZWdleDogLyMhP1xcWy4qXFxdLywgdG9rZW46IFwibWV0YVwifSxcbiAgICB7cmVnZXg6IC9cXC9cXC8uKi8sIHRva2VuOiBcImNvbW1lbnRcIn0sXG4gICAge3JlZ2V4OiAvXFwvXFwqLywgdG9rZW46IFwiY29tbWVudFwiLCBuZXh0OiBcImNvbW1lbnRcIn0sXG4gICAge3JlZ2V4OiAvWy0rXFwvKj08PiFdKy8sIHRva2VuOiBcIm9wZXJhdG9yXCJ9LFxuICAgIHtyZWdleDogL1thLXpBLVpfXVxcdyohLyx0b2tlbjogXCJ2YXJpYWJsZS0zXCJ9LFxuICAgIHtyZWdleDogL1thLXpBLVpfXVxcdyovLCB0b2tlbjogXCJ2YXJpYWJsZVwifSxcbiAgICB7cmVnZXg6IC9bXFx7XFxbXFwoXS8sIGluZGVudDogdHJ1ZX0sXG4gICAge3JlZ2V4OiAvW1xcfVxcXVxcKV0vLCBkZWRlbnQ6IHRydWV9XG4gIF0sXG4gIHN0cmluZzogW1xuICAgIHtyZWdleDogL1wiLywgdG9rZW46IFwic3RyaW5nXCIsIG5leHQ6IFwic3RhcnRcIn0sXG4gICAge3JlZ2V4OiAvKD86W15cXFxcXCJdfFxcXFwoPzoufCQpKSovLCB0b2tlbjogXCJzdHJpbmdcIn1cbiAgXSxcbiAgc3RyaW5nX3JhdzogW1xuICAgIHtyZWdleDogL1wiLywgdG9rZW46IFwic3RyaW5nXCIsIG5leHQ6IFwic3RhcnRcIn0sXG4gICAge3JlZ2V4OiAvW15cIl0qLywgdG9rZW46IFwic3RyaW5nXCJ9XG4gIF0sXG4gIHN0cmluZ19yYXdfaGFzaDogW1xuICAgIHtyZWdleDogL1wiIysvLCB0b2tlbjogXCJzdHJpbmdcIiwgbmV4dDogXCJzdGFydFwifSxcbiAgICB7cmVnZXg6IC8oPzpbXlwiXXxcIig/ISMpKSovLCB0b2tlbjogXCJzdHJpbmdcIn1cbiAgXSxcbiAgY29tbWVudDogW1xuICAgIHtyZWdleDogLy4qP1xcKlxcLy8sIHRva2VuOiBcImNvbW1lbnRcIiwgbmV4dDogXCJzdGFydFwifSxcbiAgICB7cmVnZXg6IC8uKi8sIHRva2VuOiBcImNvbW1lbnRcIn1cbiAgXSxcbiAgbWV0YToge1xuICAgIGRvbnRJbmRlbnRTdGF0ZXM6IFtcImNvbW1lbnRcIl0sXG4gICAgZWxlY3RyaWNJbnB1dDogL15cXHMqXFx9JC8sXG4gICAgYmxvY2tDb21tZW50U3RhcnQ6IFwiLypcIixcbiAgICBibG9ja0NvbW1lbnRFbmQ6IFwiKi9cIixcbiAgICBsaW5lQ29tbWVudDogXCIvL1wiLFxuICAgIGZvbGQ6IFwiYnJhY2VcIlxuICB9XG59KTtcblxuXG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3gtcnVzdHNyY1wiLCBcInJ1c3RcIik7XG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3J1c3RcIiwgXCJydXN0XCIpO1xufSk7XG4iLCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG5cbi8vIFNBUyBtb2RlIGNvcHlyaWdodCAoYykgMjAxNiBKYXJlZCBEZWFuLCBTQVMgSW5zdGl0dXRlXG4vLyBDcmVhdGVkIGJ5IEphcmVkIERlYW5cblxuLy8gVE9ET1xuLy8gaW5kZW50IGFuZCBkZS1pbmRlbnRcbi8vIGlkZW50aWZ5IG1hY3JvIHZhcmlhYmxlc1xuXG5cbi8vRGVmaW5pdGlvbnNcbi8vICBjb21tZW50IC0tIHRleHQgd2l0aGluICogOyBvciAvKiAqL1xuLy8gIGtleXdvcmQgLS0gU0FTIGxhbmd1YWdlIHZhcmlhYmxlXG4vLyAgdmFyaWFibGUgLS0gbWFjcm8gdmFyaWFibGVzIHN0YXJ0cyB3aXRoICcmJyBvciB2YXJpYWJsZSBmb3JtYXRzXG4vLyAgdmFyaWFibGUtMiAtLSBEQVRBIFN0ZXAsIHByb2MsIG9yIG1hY3JvIG5hbWVzXG4vLyAgc3RyaW5nIC0tIHRleHQgd2l0aGluICcgJyBvciBcIiBcIlxuLy8gIG9wZXJhdG9yIC0tIG51bWVyaWMgb3BlcmF0b3IgKyAvIC0gKiAqKiBsZSBlcSBnZSAuLi4gYW5kIHNvIG9uXG4vLyAgYnVpbHRpbiAtLSBwcm9jICVtYWNybyBkYXRhIHJ1biBtZW5kXG4vLyAgYXRvbVxuLy8gIGRlZlxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBDb2RlTWlycm9yLmRlZmluZU1vZGUoXCJzYXNcIiwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB3b3JkcyA9IHt9O1xuICAgIHZhciBpc0RvdWJsZU9wZXJhdG9yU3ltID0ge1xuICAgICAgZXE6ICdvcGVyYXRvcicsXG4gICAgICBsdDogJ29wZXJhdG9yJyxcbiAgICAgIGxlOiAnb3BlcmF0b3InLFxuICAgICAgZ3Q6ICdvcGVyYXRvcicsXG4gICAgICBnZTogJ29wZXJhdG9yJyxcbiAgICAgIFwiaW5cIjogJ29wZXJhdG9yJyxcbiAgICAgIG5lOiAnb3BlcmF0b3InLFxuICAgICAgb3I6ICdvcGVyYXRvcidcbiAgICB9O1xuICAgIHZhciBpc0RvdWJsZU9wZXJhdG9yQ2hhciA9IC8oPD18Pj18IT18PD4pLztcbiAgICB2YXIgaXNTaW5nbGVPcGVyYXRvckNoYXIgPSAvWz1cXCg6XFwpLHt9Lio8PitcXC1cXC9eXFxbXFxdXS87XG5cbiAgICAvLyBUYWtlcyBhIHN0cmluZyBvZiB3b3JkcyBzZXBhcmF0ZWQgYnkgc3BhY2VzIGFuZCBhZGRzIHRoZW0gYXNcbiAgICAvLyBrZXlzIHdpdGggdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBhcmd1bWVudCAnc3R5bGUnXG4gICAgZnVuY3Rpb24gZGVmaW5lKHN0eWxlLCBzdHJpbmcsIGNvbnRleHQpIHtcbiAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgIHZhciBzcGxpdCA9IHN0cmluZy5zcGxpdCgnICcpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwbGl0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgd29yZHNbc3BsaXRbaV1dID0ge3N0eWxlOiBzdHlsZSwgc3RhdGU6IGNvbnRleHR9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vZGF0YXN0ZXBcbiAgICBkZWZpbmUoJ2RlZicsICdzdGFjayBwZ20gdmlldyBzb3VyY2UgZGVidWcgbmVzdGluZyBub2xpc3QnLCBbJ2luRGF0YVN0ZXAnXSk7XG4gICAgZGVmaW5lKCdkZWYnLCAnaWYgd2hpbGUgdW50aWwgZm9yIGRvIGRvOyBlbmQgZW5kOyB0aGVuIGVsc2UgY2FuY2VsJywgWydpbkRhdGFTdGVwJ10pO1xuICAgIGRlZmluZSgnZGVmJywgJ2xhYmVsIGZvcm1hdCBfbl8gX2Vycm9yXycsIFsnaW5EYXRhU3RlcCddKTtcbiAgICBkZWZpbmUoJ2RlZicsICdBTFRFUiBCVUZOTyBCVUZTSVpFIENOVExMRVYgQ09NUFJFU1MgRExETUdBQ1RJT04gRU5DUllQVCBFTkNSWVBUS0VZIEVYVEVORE9CU0NPVU5URVIgR0VOTUFYIEdFTk5VTSBJTkRFWCBMQUJFTCBPQlNCVUYgT1VUUkVQIFBXIFBXUkVRIFJFQUQgUkVQRU1QVFkgUkVQTEFDRSBSRVVTRSBST0xFIFNPUlRFREJZIFNQSUxMIFRPQlNOTyBUWVBFIFdSSVRFIEZJTEVDTE9TRSBGSVJTVE9CUyBJTiBPQlMgUE9JTlRPQlMgV0hFUkUgV0hFUkVVUCBJRFhOQU1FIElEWFdIRVJFIERST1AgS0VFUCBSRU5BTUUnLCBbJ2luRGF0YVN0ZXAnXSk7XG4gICAgZGVmaW5lKCdkZWYnLCAnZmlsZXZhciBmaW5mbyBmaW52IGZpcG5hbWUgZmlwbmFtZWwgZmlwc3RhdGUgZmlyc3QgZmlyc3RvYnMgZmxvb3InLCBbJ2luRGF0YVN0ZXAnXSk7XG4gICAgZGVmaW5lKCdkZWYnLCAndmFyZm10IHZhcmluZm10IHZhcmxhYmVsIHZhcmxlbiB2YXJuYW1lIHZhcm51bSB2YXJyYXkgdmFycmF5eCB2YXJ0eXBlIHZlcmlmeSB2Zm9ybWF0IHZmb3JtYXRkIHZmb3JtYXRkeCB2Zm9ybWF0biB2Zm9ybWF0bnggdmZvcm1hdHcgdmZvcm1hdHd4IHZmb3JtYXR4IHZpbmFycmF5IHZpbmFycmF5eCB2aW5mb3JtYXQgdmluZm9ybWF0ZCB2aW5mb3JtYXRkeCB2aW5mb3JtYXRuIHZpbmZvcm1hdG54IHZpbmZvcm1hdHcgdmluZm9ybWF0d3ggdmluZm9ybWF0eCB2bGFiZWwgdmxhYmVseCB2bGVuZ3RoIHZsZW5ndGh4IHZuYW1lIHZuYW1leCB2bmZlcnIgdnR5cGUgdnR5cGV4IHdlZWtkYXknLCBbJ2luRGF0YVN0ZXAnXSk7XG4gICAgZGVmaW5lKCdkZWYnLCAnemlwZmlwcyB6aXBuYW1lIHppcG5hbWVsIHppcHN0YXRlJywgWydpbkRhdGFTdGVwJ10pO1xuICAgIGRlZmluZSgnZGVmJywgJ3B1dCBwdXRjIHB1dG4nLCBbJ2luRGF0YVN0ZXAnXSk7XG4gICAgZGVmaW5lKCdidWlsdGluJywgJ2RhdGEgcnVuJywgWydpbkRhdGFTdGVwJ10pO1xuXG5cbiAgICAvL3Byb2NcbiAgICBkZWZpbmUoJ2RlZicsICdkYXRhJywgWydpblByb2MnXSk7XG5cbiAgICAvLyBmbG93IGNvbnRyb2wgZm9yIG1hY3Jvc1xuICAgIGRlZmluZSgnZGVmJywgJyVpZiAlZW5kICVlbmQ7ICVlbHNlICVlbHNlOyAlZG8gJWRvOyAldGhlbicsIFsnaW5NYWNybyddKTtcblxuICAgIC8vZXZlcnl3aGVyZVxuICAgIGRlZmluZSgnYnVpbHRpbicsICdwcm9jIHJ1bjsgcXVpdDsgbGlibmFtZSBmaWxlbmFtZSAlbWFjcm8gJW1lbmQgb3B0aW9uIG9wdGlvbnMnLCBbJ0FMTCddKTtcblxuICAgIGRlZmluZSgnZGVmJywgJ2Zvb3Rub3RlIHRpdGxlIGxpYm5hbWUgb2RzJywgWydBTEwnXSk7XG4gICAgZGVmaW5lKCdkZWYnLCAnJWxldCAlcHV0ICVnbG9iYWwgJXN5c2Z1bmMgJWV2YWwgJywgWydBTEwnXSk7XG4gICAgLy8gYXV0b21hdGljIG1hY3JvIHZhcmlhYmxlcyBodHRwOi8vc3VwcG9ydC5zYXMuY29tL2RvY3VtZW50YXRpb24vY2RsL2VuL21jcm9scmVmLzYxODg1L0hUTUwvZGVmYXVsdC92aWV3ZXIuaHRtI2EwMDMxNjcwMjMuaHRtXG4gICAgZGVmaW5lKCd2YXJpYWJsZScsICcmc3lzYnVmZnIgJnN5c2NjICZzeXNjaGFyd2lkdGggJnN5c2NtZCAmc3lzZGF0ZSAmc3lzZGF0ZTkgJnN5c2RheSAmc3lzZGV2aWMgJnN5c2RtZyAmc3lzZHNuICZzeXNlbmNvZGluZyAmc3lzZW52ICZzeXNlcnIgJnN5c2Vycm9ydGV4dCAmc3lzZmlscmMgJnN5c2hvc3RuYW1lICZzeXNpbmRleCAmc3lzaW5mbyAmc3lzam9iaWQgJnN5c2xhc3QgJnN5c2xja3JjICZzeXNsaWJyYyAmc3lzbG9nYXBwbG5hbWUgJnN5c21hY3JvbmFtZSAmc3lzbWVudiAmc3lzbXNnICZzeXNuY3B1ICZzeXNvZHNwYXRoICZzeXNwYXJtICZzeXNwYnVmZiAmc3lzcHJvY2Vzc2lkICZzeXNwcm9jZXNzbmFtZSAmc3lzcHJvY25hbWUgJnN5c3JjICZzeXNzY3AgJnN5c3NjcGwgJnN5c3NjcGwgJnN5c3NpdGUgJnN5c3N0YXJ0aWQgJnN5c3N0YXJ0bmFtZSAmc3lzdGNwaXBob3N0bmFtZSAmc3lzdGltZSAmc3lzdXNlcmlkICZzeXN2ZXIgJnN5c3Zsb25nICZzeXN2bG9uZzQgJnN5c3dhcm5pbmd0ZXh0JywgWydBTEwnXSk7XG5cbiAgICAvL2Zvb3Rub3RlWzEtOV0/IHRpdGxlWzEtOV0/XG5cbiAgICAvL29wdGlvbnMgc3RhdGVtZW50XG4gICAgZGVmaW5lKCdkZWYnLCAnc291cmNlMiBub3NvdXJjZTIgcGFnZSBwYWdlbm8gcGFnZXNpemUnLCBbJ0FMTCddKTtcblxuICAgIC8vcHJvYyBhbmQgZGF0YXN0ZXBcbiAgICBkZWZpbmUoJ2RlZicsICdfYWxsXyBfY2hhcmFjdGVyXyBfY21kXyBfZnJlcV8gX2lfIF9pbmZpbGVfIF9sYXN0XyBfbXNnXyBfbnVsbF8gX251bWVyaWNfIF90ZW1wb3JhcnlfIF90eXBlXyBhYm9ydCBhYnMgYWRkciBhZGpyc3EgYWlyeSBhbHBoYSBhbHRlciBhbHRsb2cgYWx0cHJpbnQgYW5kIGFyY29zIGFycmF5IGFyc2luIGFzIGF0YW4gYXR0cmMgYXR0cmliIGF0dHJuIGF1dGhzZXJ2ZXIgYXV0b2V4ZWMgYXdzY29udHJvbCBhd3NkZWYgYXdzbWVudSBhd3NtZW51bWVyZ2UgYXdzdGl0bGUgYmFja3dhcmQgYmFuZCBiYXNlIGJldGFpbnYgYmV0d2VlbiBibG9ja3NpemUgYmxzaGlmdCBibm90IGJvciBicnNoaWZ0IGJ1Zm5vIGJ1ZnNpemUgYnhvciBieSBieWVyciBieWxpbmUgYnl0ZSBjYWxjdWxhdGVkIGNhbGwgY2FyZHMgY2FyZHM0IGNhdGNhY2hlIGNidWZubyBjZGYgY2VpbCBjZW50ZXIgY2V4aXN0IGNoYW5nZSBjaGlzcSBjaW52IGNsYXNzIGNsZWFudXAgY2xvc2UgY25vbmN0IGNudGxsZXYgY29hbGVzY2UgY29kZWdlbiBjb2wgY29sbGF0ZSBjb2xsaW4gY29sdW1uIGNvbWFtaWQgY29tYXV4MSBjb21hdXgyIGNvbWRlZiBjb21wYmwgY29tcG91bmQgY29tcHJlc3MgY29uZmlnIGNvbnRpbnVlIGNvbnZlcnQgY29zIGNvc2ggY3B1aWQgY3JlYXRlIGNyb3NzIGNyb3NzdGFiIGNzcyBjdXJvYnMgY3YgZGFjY2RiIGRhY2NkYnNsIGRhY2NzbCBkYWNjc3lkIGRhY2N0YWIgZGFpcnkgZGF0YWxpbmVzIGRhdGFsaW5lczQgZGF0ZWp1bCBkYXRlcGFydCBkYXRldGltZSBkYXkgZGJjc2xhbmcgZGJjc3R5cGUgZGNsb3NlIGRkZm0gZGRtIGRlbGV0ZSBkZWxpbWl0ZXIgZGVwZGIgZGVwZGJzbCBkZXBzbCBkZXBzeWQgZGVwdGFiIGRlcXVvdGUgZGVzY2VuZGluZyBkZXNjcmlwdCBkZXNpZ249IGRldmljZSBkZmxhbmcgZGhtcyBkaWYgZGlnYW1tYSBkaW0gZGluZm8gZGlzcGxheSBkaXN0aW5jdCBka3JpY29uZCBka3JvY29uZCBkbG0gZG51bSBkbyBkb3BlbiBkb3B0bmFtZSBkb3B0bnVtIGRyZWFkIGRyb3AgZHJvcG5vdGUgZHNuYW1lIGRzbmZlcnIgZWNobyBlbHNlIGVtYWlsZGxnIGVtYWlsaWQgZW1haWxwdyBlbWFpbHNlcnZlciBlbWFpbHN5cyBlbmNyeXB0IGVuZCBlbmRzYXMgZW5naW5lIGVvZiBlb3YgZXJmIGVyZmMgZXJyb3IgZXJyb3JjaGVjayBlcnJvcnMgZXhpc3QgZXhwIGZhcHBlbmQgZmNsb3NlIGZjb2wgZmRlbGV0ZSBmZWVkYmFjayBmZXRjaCBmZXRjaG9icyBmZXhpc3QgZmdldCBmaWxlIGZpbGVjbG9zZSBmaWxlZXhpc3QgZmlsZWZtdCBmaWxlbmFtZSBmaWxlcmVmICBmbXRlcnIgZm10c2VhcmNoIGZub25jdCBmbm90ZSBmb250IGZvbnRhbGlhcyAgZm9wZW4gZm9wdG5hbWUgZm9wdG51bSBmb3JjZSBmb3JtYXR0ZWQgZm9ybWNoYXIgZm9ybWRlbGltIGZvcm1kbGltIGZvcndhcmQgZnBvaW50IGZwb3MgZnB1dCBmcmVhZCBmcmV3aW5kIGZybGVuIGZyb20gZnNlcCBmdXp6IGZ3cml0ZSBnYW1pbnYgZ2FtbWEgZ2V0b3B0aW9uIGdldHZhcmMgZ2V0dmFybiBnbyBnb3RvIGdyb3VwIGd3aW5kb3cgaGJhciBoYm91bmQgaGVscGVudiBoZWxwbG9jIGhtcyBob25vcmFwcGVhcmFuY2UgaG9zdGhlbHAgaG9zdHByaW50IGhvdXIgaHBjdCBodG1sIGh2YXIgaWJlc3NlbCBpYnIgaWQgaWYgaW5kZXggaW5kZXhjIGluZGV4dyBpbml0Y21kIGluaXRzdG10IGlubmVyIGlucHV0IGlucHV0YyBpbnB1dG4gaW5yIGluc2VydCBpbnQgaW50Y2sgaW50bnggaW50byBpbnRyciBpbnZhbGlkZGF0YSBpcnIgaXMgamJlc3NlbCBqb2luIGp1bGRhdGUga2VlcCBrZW50YiBrdXJ0b3NpcyBsYWJlbCBsYWcgbGFzdCBsYm91bmQgbGVhdmUgbGVmdCBsZW5ndGggbGV2ZWxzIGxnYW1tYSBsaWIgIGxpYnJhcnkgbGlicmVmIGxpbmUgbGluZXNpemUgbGluayBsaXN0IGxvZyBsb2cxMCBsb2cyIGxvZ3BkZiBsb2dwbWYgbG9nc2RmIGxvc3RjYXJkIGxvd2Nhc2UgbHJlY2wgbHMgbWFjcm8gbWFjcm9nZW4gbWFwcyBtYXV0b3NvdXJjZSBtYXggbWF4ZGVjIG1heHIgbWR5IG1lYW4gbWVhc3VyZXMgbWVkaWFuIG1lbXR5cGUgbWVyZ2UgbWVycm9yIG1pbiBtaW51dGUgbWlzc2luZyBtaXNzb3ZlciBtbG9naWMgbW9kIG1vZGUgbW9kZWwgbW9kaWZ5IG1vbnRoIG1vcGVuIG1vcnQgbXByaW50IG1yZWNhbGwgbXNnbGV2ZWwgbXN5bXRhYm1heCBtdmFyc2l6ZSBteXkgbiBuZXN0IG5ldHB2IG5ldyBuZXdzIG5taXNzIG5vIG5vYmF0Y2ggbm9icyBub2NhcHMgbm9jYXJkaW1hZ2Ugbm9jZW50ZXIgbm9jaGFyY29kZSBub2NtZG1hYyBub2NvbCBub2N1bSBub2RhdGUgbm9kYmNzIG5vZGV0YWlscyBub2RtciBub2RtcyBub2Rtc2JhdGNoIG5vZHVwIG5vZHVwa2V5IG5vZHVwbGljYXRlcyBub2VjaG9hdXRvIG5vZXF1YWxzIG5vZXJyb3JhYmVuZCBub2V4aXR3aW5kb3dzIG5vZnVsbHN0aW1lciBub2ljb24gbm9pbXBsbWFjIG5vaW50IG5vbGlzdCBub2xvYWRsaXN0IG5vbWlzcyBub21sb2dpYyBub21wcmludCBub21yZWNhbGwgbm9tc2djYXNlIG5vbXN0b3JlZCBub211bHRlbnZhcHBsIG5vbm90ZXMgbm9udW1iZXIgbm9vYnMgbm9vdnAgbm9wYWQgbm9wZXJjZW50IG5vcHJpbnQgbm9wcmludGluaXQgbm9ybWFsIG5vcm93IG5vcnNhc3VzZXIgbm9zZXRpbml0ICBub3NwbGFzaCBub3N5bWJvbGdlbiBub3RlIG5vdGVzIG5vdGl0bGUgbm90aXRsZXMgbm90c29ydGVkIG5vdmVyYm9zZSBub3hzeW5jIG5veHdhaXQgbnB2IG51bGwgbnVtYmVyIG51bWtleXMgbnVtbW91c2VrZXlzIG53YXkgb2JzICBvbiBvcGVuICAgICBvcmRlciBvcmRpbmFsIG90aGVyd2lzZSBvdXQgb3V0ZXIgb3V0cD0gb3V0cHV0IG92ZXIgb3ZwIHAoMSA1IDEwIDI1IDUwIDc1IDkwIDk1IDk5KSBwYWQgcGFkMiAgcGFpcmVkIHBhcm0gcGFybWNhcmRzIHBhdGggcGF0aGRsbCBwYXRobmFtZSBwZGYgcGVlayBwZWVrYyBwZmtleSBwbWYgcG9pbnQgcG9pc3NvbiBwb2tlIHBvc2l0aW9uIHByaW50ZXIgcHJvYmJldGEgcHJvYmJubWwgcHJvYmNoaSBwcm9iZiBwcm9iZ2FtIHByb2JoeXByIHByb2JpdCBwcm9ibmVnYiBwcm9ibm9ybSBwcm9ic2lnIHByb2J0IHByb2NsZWF2ZSBwcnQgcHMgIHB3IHB3cmVxIHF0ciBxdW90ZSByIHJhbmJpbiByYW5jYXUgcmFuZG9tIHJhbmV4cCByYW5nYW0gcmFuZ2UgcmFua3MgcmFubm9yIHJhbnBvaSByYW50YmwgcmFudHJpIHJhbnVuaSByY29yciByZWFkIHJlY2ZtIHJlZ2lzdGVyIHJlZ3IgcmVtb3RlIHJlbW92ZSByZW5hbWUgcmVwZWF0IHJlcGVhdGVkIHJlcGxhY2UgcmVzb2x2ZSByZXRhaW4gcmV0dXJuIHJldXNlIHJldmVyc2UgcmV3aW5kIHJpZ2h0IHJvdW5kIHJzcXVhcmUgcnRmIHJ0cmFjZSBydHJhY2Vsb2MgcyBzMiBzYW1wbG9jIHNhc2F1dG9zIHNhc2NvbnRyb2wgc2FzZnJzY3Igc2FzbXNnIHNhc21zdG9yZSBzYXNzY3JpcHQgc2FzdXNlciBzYXZpbmcgc2NhbiBzZGYgc2Vjb25kIHNlbGVjdCBzZWxlY3Rpb24gc2VwYXJhdGVkIHNlcSBzZXJyb3Igc2V0IHNldGNvbW0gc2V0b3Qgc2lnbiBzaW1wbGUgc2luIHNpbmggc2l0ZWluZm8gc2tld25lc3Mgc2tpcCBzbGUgc2xzIHNvcnRlZGJ5IHNvcnRwZ20gc29ydHNlcSBzb3J0c2l6ZSBzb3VuZGV4ICBzcGVkaXMgc3BsYXNobG9jYXRpb24gc3BsaXQgc3Bvb2wgc3FydCBzdGFydCBzdGQgc3RkZXJyIHN0ZGluIHN0ZmlwcyBzdGltZXIgc3RuYW1lIHN0bmFtZWwgc3RvcCBzdG9wb3ZlciBzdWIgc3ViZ3JvdXAgc3VicG9wbiBzdWJzdHIgc3VtIHN1bXdndCBzeW1ib2wgc3ltYm9sZ2VuIHN5bWdldCBzeW1wdXQgc3lzZ2V0IHN5c2luIHN5c2xlYXZlIHN5c21zZyBzeXNwYXJtIHN5c3ByaW50IHN5c3ByaW50Zm9udCBzeXNwcm9kIHN5c3JjIHN5c3RlbSB0IHRhYmxlIHRhYmxlcyB0YW4gdGFuaCB0YXBlY2xvc2UgdGJ1ZnNpemUgdGVybWluYWwgdGVzdCB0aGVuIHRpbWVwYXJ0IHRpbnYgIHRub25jdCB0byB0b2RheSB0b2wgdG9vbGRlZiB0b3RwZXIgdHJhbnNmb3Jtb3V0IHRyYW5zbGF0ZSB0cmFudGFiIHRyYW53cmQgdHJpZ2FtbWEgdHJpbSB0cmltbiB0cnVuYyB0cnVuY292ZXIgdHlwZSB1bmZvcm1hdHRlZCB1bmlmb3JtIHVuaW9uIHVudGlsIHVwY2FzZSB1cGRhdGUgdXNlciB1c2VyaWNvbiB1c3MgdmFsaWRhdGUgdmFsdWUgdmFyICB3ZWlnaHQgd2hlbiB3aGVyZSB3aGlsZSB3aW5jaGFyc2V0IHdpbmRvdyB3b3JrIHdvcmtpbml0IHdvcmt0ZXJtIHdyaXRlIHdzdW0geHN5bmMgeHdhaXQgeWVhcmN1dG9mZiB5ZXMgeXlxICBtaW4gbWF4JywgWydpbkRhdGFTdGVwJywgJ2luUHJvYyddKTtcbiAgICBkZWZpbmUoJ29wZXJhdG9yJywgJ2FuZCBub3QgJywgWydpbkRhdGFTdGVwJywgJ2luUHJvYyddKTtcblxuICAgIC8vIE1haW4gZnVuY3Rpb25cbiAgICBmdW5jdGlvbiB0b2tlbml6ZShzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAvLyBGaW5hbGx5IGFkdmFuY2UgdGhlIHN0cmVhbVxuICAgICAgdmFyIGNoID0gc3RyZWFtLm5leHQoKTtcblxuICAgICAgLy8gQkxPQ0tDT01NRU5UXG4gICAgICBpZiAoY2ggPT09ICcvJyAmJiBzdHJlYW0uZWF0KCcqJykpIHtcbiAgICAgICAgc3RhdGUuY29udGludWVDb21tZW50ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5jb250aW51ZUNvbW1lbnQgPT09IHRydWUpIHsgLy8gaW4gY29tbWVudCBibG9ja1xuICAgICAgICAvL2NvbW1lbnQgZW5kcyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaW5lXG4gICAgICAgIGlmIChjaCA9PT0gJyonICYmIHN0cmVhbS5wZWVrKCkgPT09ICcvJykge1xuICAgICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgICAgc3RhdGUuY29udGludWVDb21tZW50ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLnNraXBUbygnKicpKSB7IC8vY29tbWVudCBpcyBwb3RlbnRpYWxseSBsYXRlciBpbiBsaW5lXG4gICAgICAgICAgc3RyZWFtLnNraXBUbygnKicpO1xuICAgICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgICAgaWYgKHN0cmVhbS5lYXQoJy8nKSlcbiAgICAgICAgICAgIHN0YXRlLmNvbnRpbnVlQ29tbWVudCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaCA9PSBcIipcIiAmJiBzdHJlYW0uY29sdW1uKCkgPT0gc3RyZWFtLmluZGVudGF0aW9uKCkpIHtcbiAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpXG4gICAgICAgIHJldHVybiBcImNvbW1lbnRcIlxuICAgICAgfVxuXG4gICAgICAvLyBEb3VibGVPcGVyYXRvciBtYXRjaFxuICAgICAgdmFyIGRvdWJsZU9wZXJhdG9yID0gY2ggKyBzdHJlYW0ucGVlaygpO1xuXG4gICAgICBpZiAoKGNoID09PSAnXCInIHx8IGNoID09PSBcIidcIikgJiYgIXN0YXRlLmNvbnRpbnVlU3RyaW5nKSB7XG4gICAgICAgIHN0YXRlLmNvbnRpbnVlU3RyaW5nID0gY2hcbiAgICAgICAgcmV0dXJuIFwic3RyaW5nXCJcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuY29udGludWVTdHJpbmcpIHtcbiAgICAgICAgaWYgKHN0YXRlLmNvbnRpbnVlU3RyaW5nID09IGNoKSB7XG4gICAgICAgICAgc3RhdGUuY29udGludWVTdHJpbmcgPSBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5za2lwVG8oc3RhdGUuY29udGludWVTdHJpbmcpKSB7XG4gICAgICAgICAgLy8gcXVvdGUgZm91bmQgb24gdGhpcyBsaW5lXG4gICAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgICBzdGF0ZS5jb250aW51ZVN0cmluZyA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5jb250aW51ZVN0cmluZyAhPT0gbnVsbCAmJiBzdHJlYW0uZW9sKCkpIHtcbiAgICAgICAgc3RyZWFtLnNraXBUbyhzdGF0ZS5jb250aW51ZVN0cmluZykgfHwgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICAgIH0gZWxzZSBpZiAoL1tcXGRcXC5dLy50ZXN0KGNoKSkgeyAvL2ZpbmQgbnVtYmVyc1xuICAgICAgICBpZiAoY2ggPT09IFwiLlwiKVxuICAgICAgICAgIHN0cmVhbS5tYXRjaCgvXlswLTldKyhbZUVdW1xcLStdP1swLTldKyk/Lyk7XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSBcIjBcIilcbiAgICAgICAgICBzdHJlYW0ubWF0Y2goL15beFhdWzAtOWEtZkEtRl0rLykgfHwgc3RyZWFtLm1hdGNoKC9eMFswLTddKy8pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgc3RyZWFtLm1hdGNoKC9eWzAtOV0qXFwuP1swLTldKihbZUVdW1xcLStdP1swLTldKyk/Lyk7XG4gICAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgICAgfSBlbHNlIGlmIChpc0RvdWJsZU9wZXJhdG9yQ2hhci50ZXN0KGNoICsgc3RyZWFtLnBlZWsoKSkpIHsgLy8gVFdPIFNZTUJPTCBUT0tFTlNcbiAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgICAgIH0gZWxzZSBpZiAoaXNEb3VibGVPcGVyYXRvclN5bS5oYXNPd25Qcm9wZXJ0eShkb3VibGVPcGVyYXRvcikpIHtcbiAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgaWYgKHN0cmVhbS5wZWVrKCkgPT09ICcgJylcbiAgICAgICAgICByZXR1cm4gaXNEb3VibGVPcGVyYXRvclN5bVtkb3VibGVPcGVyYXRvci50b0xvd2VyQ2FzZSgpXTtcbiAgICAgIH0gZWxzZSBpZiAoaXNTaW5nbGVPcGVyYXRvckNoYXIudGVzdChjaCkpIHsgLy8gU0lOR0xFIFNZTUJPTCBUT0tFTlNcbiAgICAgICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgICAgIH1cblxuICAgICAgLy8gTWF0Y2hlcyBvbmUgd2hvbGUgd29yZCAtLSBldmVuIGlmIHRoZSB3b3JkIGlzIGEgY2hhcmFjdGVyXG4gICAgICB2YXIgd29yZDtcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goL1slJjtcXHddKy8sIGZhbHNlKSAhPSBudWxsKSB7XG4gICAgICAgIHdvcmQgPSBjaCArIHN0cmVhbS5tYXRjaCgvWyUmO1xcd10rLywgdHJ1ZSk7XG4gICAgICAgIGlmICgvJi8udGVzdCh3b3JkKSkgcmV0dXJuICd2YXJpYWJsZSdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdvcmQgPSBjaDtcbiAgICAgIH1cbiAgICAgIC8vIHRoZSB3b3JkIGFmdGVyIERBVEEgUFJPQyBvciBNQUNST1xuICAgICAgaWYgKHN0YXRlLm5leHR3b3JkKSB7XG4gICAgICAgIHN0cmVhbS5tYXRjaCgvW1xcd10rLyk7XG4gICAgICAgIC8vIG1hdGNoIG1lbW5hbWUubGlibmFtZVxuICAgICAgICBpZiAoc3RyZWFtLnBlZWsoKSA9PT0gJy4nKSBzdHJlYW0uc2tpcFRvKCcgJyk7XG4gICAgICAgIHN0YXRlLm5leHR3b3JkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiAndmFyaWFibGUtMic7XG4gICAgICB9XG5cbiAgICAgIHdvcmQgPSB3b3JkLnRvTG93ZXJDYXNlKClcbiAgICAgIC8vIEFyZSB3ZSBpbiBhIERBVEEgU3RlcD9cbiAgICAgIGlmIChzdGF0ZS5pbkRhdGFTdGVwKSB7XG4gICAgICAgIGlmICh3b3JkID09PSAncnVuOycgfHwgc3RyZWFtLm1hdGNoKC9ydW5cXHM7LykpIHtcbiAgICAgICAgICBzdGF0ZS5pbkRhdGFTdGVwID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuICdidWlsdGluJztcbiAgICAgICAgfVxuICAgICAgICAvLyB2YXJpYWJsZSBmb3JtYXRzXG4gICAgICAgIGlmICgod29yZCkgJiYgc3RyZWFtLm5leHQoKSA9PT0gJy4nKSB7XG4gICAgICAgICAgLy9laXRoZXIgYSBmb3JtYXQgb3IgbGlibmFtZS5tZW1uYW1lXG4gICAgICAgICAgaWYgKC9cXHcvLnRlc3Qoc3RyZWFtLnBlZWsoKSkpIHJldHVybiAndmFyaWFibGUtMic7XG4gICAgICAgICAgZWxzZSByZXR1cm4gJ3ZhcmlhYmxlJztcbiAgICAgICAgfVxuICAgICAgICAvLyBkbyB3ZSBoYXZlIGEgREFUQSBTdGVwIGtleXdvcmRcbiAgICAgICAgaWYgKHdvcmQgJiYgd29yZHMuaGFzT3duUHJvcGVydHkod29yZCkgJiZcbiAgICAgICAgICAgICh3b3Jkc1t3b3JkXS5zdGF0ZS5pbmRleE9mKFwiaW5EYXRhU3RlcFwiKSAhPT0gLTEgfHxcbiAgICAgICAgICAgICB3b3Jkc1t3b3JkXS5zdGF0ZS5pbmRleE9mKFwiQUxMXCIpICE9PSAtMSkpIHtcbiAgICAgICAgICAvL2JhY2t1cCB0byB0aGUgc3RhcnQgb2YgdGhlIHdvcmRcbiAgICAgICAgICBpZiAoc3RyZWFtLnN0YXJ0IDwgc3RyZWFtLnBvcylcbiAgICAgICAgICAgIHN0cmVhbS5iYWNrVXAoc3RyZWFtLnBvcyAtIHN0cmVhbS5zdGFydCk7XG4gICAgICAgICAgLy9hZHZhbmNlIHRoZSBsZW5ndGggb2YgdGhlIHdvcmQgYW5kIHJldHVyblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZC5sZW5ndGg7ICsraSkgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgICByZXR1cm4gd29yZHNbd29yZF0uc3R5bGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEFyZSB3ZSBpbiBhbiBQcm9jIHN0YXRlbWVudD9cbiAgICAgIGlmIChzdGF0ZS5pblByb2MpIHtcbiAgICAgICAgaWYgKHdvcmQgPT09ICdydW47JyB8fCB3b3JkID09PSAncXVpdDsnKSB7XG4gICAgICAgICAgc3RhdGUuaW5Qcm9jID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuICdidWlsdGluJztcbiAgICAgICAgfVxuICAgICAgICAvLyBkbyB3ZSBoYXZlIGEgcHJvYyBrZXl3b3JkXG4gICAgICAgIGlmICh3b3JkICYmIHdvcmRzLmhhc093blByb3BlcnR5KHdvcmQpICYmXG4gICAgICAgICAgICAod29yZHNbd29yZF0uc3RhdGUuaW5kZXhPZihcImluUHJvY1wiKSAhPT0gLTEgfHxcbiAgICAgICAgICAgICB3b3Jkc1t3b3JkXS5zdGF0ZS5pbmRleE9mKFwiQUxMXCIpICE9PSAtMSkpIHtcbiAgICAgICAgICBzdHJlYW0ubWF0Y2goL1tcXHddKy8pO1xuICAgICAgICAgIHJldHVybiB3b3Jkc1t3b3JkXS5zdHlsZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQXJlIHdlIGluIGEgTWFjcm8gc3RhdGVtZW50P1xuICAgICAgaWYgKHN0YXRlLmluTWFjcm8pIHtcbiAgICAgICAgaWYgKHdvcmQgPT09ICclbWVuZCcpIHtcbiAgICAgICAgICBpZiAoc3RyZWFtLnBlZWsoKSA9PT0gJzsnKSBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAgIHN0YXRlLmluTWFjcm8gPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gJ2J1aWx0aW4nO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3b3JkICYmIHdvcmRzLmhhc093blByb3BlcnR5KHdvcmQpICYmXG4gICAgICAgICAgICAod29yZHNbd29yZF0uc3RhdGUuaW5kZXhPZihcImluTWFjcm9cIikgIT09IC0xIHx8XG4gICAgICAgICAgICAgd29yZHNbd29yZF0uc3RhdGUuaW5kZXhPZihcIkFMTFwiKSAhPT0gLTEpKSB7XG4gICAgICAgICAgc3RyZWFtLm1hdGNoKC9bXFx3XSsvKTtcbiAgICAgICAgICByZXR1cm4gd29yZHNbd29yZF0uc3R5bGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJ2F0b20nO1xuICAgICAgfVxuICAgICAgLy8gRG8gd2UgaGF2ZSBLZXl3b3JkcyBzcGVjaWZpYyB3b3Jkcz9cbiAgICAgIGlmICh3b3JkICYmIHdvcmRzLmhhc093blByb3BlcnR5KHdvcmQpKSB7XG4gICAgICAgIC8vIE5lZ2F0ZXMgdGhlIGluaXRpYWwgbmV4dCgpXG4gICAgICAgIHN0cmVhbS5iYWNrVXAoMSk7XG4gICAgICAgIC8vIEFjdHVhbGx5IG1vdmUgdGhlIHN0cmVhbVxuICAgICAgICBzdHJlYW0ubWF0Y2goL1tcXHddKy8pO1xuICAgICAgICBpZiAod29yZCA9PT0gJ2RhdGEnICYmIC89Ly50ZXN0KHN0cmVhbS5wZWVrKCkpID09PSBmYWxzZSkge1xuICAgICAgICAgIHN0YXRlLmluRGF0YVN0ZXAgPSB0cnVlO1xuICAgICAgICAgIHN0YXRlLm5leHR3b3JkID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gJ2J1aWx0aW4nO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3b3JkID09PSAncHJvYycpIHtcbiAgICAgICAgICBzdGF0ZS5pblByb2MgPSB0cnVlO1xuICAgICAgICAgIHN0YXRlLm5leHR3b3JkID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gJ2J1aWx0aW4nO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3b3JkID09PSAnJW1hY3JvJykge1xuICAgICAgICAgIHN0YXRlLmluTWFjcm8gPSB0cnVlO1xuICAgICAgICAgIHN0YXRlLm5leHR3b3JkID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gJ2J1aWx0aW4nO1xuICAgICAgICB9XG4gICAgICAgIGlmICgvdGl0bGVbMS05XS8udGVzdCh3b3JkKSkgcmV0dXJuICdkZWYnO1xuXG4gICAgICAgIGlmICh3b3JkID09PSAnZm9vdG5vdGUnKSB7XG4gICAgICAgICAgc3RyZWFtLmVhdCgvWzEtOV0vKTtcbiAgICAgICAgICByZXR1cm4gJ2RlZic7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXR1cm5zIHRoZWlyIHZhbHVlIGFzIHN0YXRlIGluIHRoZSBwcmlvciBkZWZpbmUgbWV0aG9kc1xuICAgICAgICBpZiAoc3RhdGUuaW5EYXRhU3RlcCA9PT0gdHJ1ZSAmJiB3b3Jkc1t3b3JkXS5zdGF0ZS5pbmRleE9mKFwiaW5EYXRhU3RlcFwiKSAhPT0gLTEpXG4gICAgICAgICAgcmV0dXJuIHdvcmRzW3dvcmRdLnN0eWxlO1xuICAgICAgICBpZiAoc3RhdGUuaW5Qcm9jID09PSB0cnVlICYmIHdvcmRzW3dvcmRdLnN0YXRlLmluZGV4T2YoXCJpblByb2NcIikgIT09IC0xKVxuICAgICAgICAgIHJldHVybiB3b3Jkc1t3b3JkXS5zdHlsZTtcbiAgICAgICAgaWYgKHN0YXRlLmluTWFjcm8gPT09IHRydWUgJiYgd29yZHNbd29yZF0uc3RhdGUuaW5kZXhPZihcImluTWFjcm9cIikgIT09IC0xKVxuICAgICAgICAgIHJldHVybiB3b3Jkc1t3b3JkXS5zdHlsZTtcbiAgICAgICAgaWYgKHdvcmRzW3dvcmRdLnN0YXRlLmluZGV4T2YoXCJBTExcIikgIT09IC0xKVxuICAgICAgICAgIHJldHVybiB3b3Jkc1t3b3JkXS5zdHlsZTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICAvLyBVbnJlY29nbml6ZWQgc3ludGF4XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGluRGF0YVN0ZXA6IGZhbHNlLFxuICAgICAgICAgIGluUHJvYzogZmFsc2UsXG4gICAgICAgICAgaW5NYWNybzogZmFsc2UsXG4gICAgICAgICAgbmV4dHdvcmQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRpbnVlU3RyaW5nOiBudWxsLFxuICAgICAgICAgIGNvbnRpbnVlQ29tbWVudDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB0b2tlbjogZnVuY3Rpb24gKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgLy8gU3RyaXAgdGhlIHNwYWNlcywgYnV0IHJlZ2V4IHdpbGwgYWNjb3VudCBmb3IgdGhlbSBlaXRoZXIgd2F5XG4gICAgICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkgcmV0dXJuIG51bGw7XG4gICAgICAgIC8vIEdvIHRocm91Z2ggdGhlIG1haW4gcHJvY2Vzc1xuICAgICAgICByZXR1cm4gdG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICB9LFxuXG4gICAgICBibG9ja0NvbW1lbnRTdGFydDogXCIvKlwiLFxuICAgICAgYmxvY2tDb21tZW50RW5kOiBcIiovXCJcbiAgICB9O1xuXG4gIH0pO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQveC1zYXNcIiwgXCJzYXNcIik7XG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIiksIHJlcXVpcmUoXCIuLi9jc3MvY3NzXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIsIFwiLi4vY3NzL2Nzc1wiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcblwidXNlIHN0cmljdFwiO1xuXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoXCJzYXNzXCIsIGZ1bmN0aW9uKGNvbmZpZykge1xuICB2YXIgY3NzTW9kZSA9IENvZGVNaXJyb3IubWltZU1vZGVzW1widGV4dC9jc3NcIl07XG4gIHZhciBwcm9wZXJ0eUtleXdvcmRzID0gY3NzTW9kZS5wcm9wZXJ0eUtleXdvcmRzIHx8IHt9LFxuICAgICAgY29sb3JLZXl3b3JkcyA9IGNzc01vZGUuY29sb3JLZXl3b3JkcyB8fCB7fSxcbiAgICAgIHZhbHVlS2V5d29yZHMgPSBjc3NNb2RlLnZhbHVlS2V5d29yZHMgfHwge30sXG4gICAgICBmb250UHJvcGVydGllcyA9IGNzc01vZGUuZm9udFByb3BlcnRpZXMgfHwge307XG5cbiAgZnVuY3Rpb24gdG9rZW5SZWdleHAod29yZHMpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChcIl5cIiArIHdvcmRzLmpvaW4oXCJ8XCIpKTtcbiAgfVxuXG4gIHZhciBrZXl3b3JkcyA9IFtcInRydWVcIiwgXCJmYWxzZVwiLCBcIm51bGxcIiwgXCJhdXRvXCJdO1xuICB2YXIga2V5d29yZHNSZWdleHAgPSBuZXcgUmVnRXhwKFwiXlwiICsga2V5d29yZHMuam9pbihcInxcIikpO1xuXG4gIHZhciBvcGVyYXRvcnMgPSBbXCJcXFxcKFwiLCBcIlxcXFwpXCIsIFwiPVwiLCBcIj5cIiwgXCI8XCIsIFwiPT1cIiwgXCI+PVwiLCBcIjw9XCIsIFwiXFxcXCtcIiwgXCItXCIsXG4gICAgICAgICAgICAgICAgICAgXCJcXFxcIT1cIiwgXCIvXCIsIFwiXFxcXCpcIiwgXCIlXCIsIFwiYW5kXCIsIFwib3JcIiwgXCJub3RcIiwgXCI7XCIsXCJcXFxce1wiLFwiXFxcXH1cIixcIjpcIl07XG4gIHZhciBvcFJlZ2V4cCA9IHRva2VuUmVnZXhwKG9wZXJhdG9ycyk7XG5cbiAgdmFyIHBzZXVkb0VsZW1lbnRzUmVnZXhwID0gL146Oj9bYS16QS1aX11bXFx3XFwtXSovO1xuXG4gIHZhciB3b3JkO1xuXG4gIGZ1bmN0aW9uIGlzRW5kTGluZShzdHJlYW0pIHtcbiAgICByZXR1cm4gIXN0cmVhbS5wZWVrKCkgfHwgc3RyZWFtLm1hdGNoKC9cXHMrJC8sIGZhbHNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVybFRva2VucyhzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGNoID0gc3RyZWFtLnBlZWsoKTtcblxuICAgIGlmIChjaCA9PT0gXCIpXCIpIHtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICBzdGF0ZS50b2tlbml6ZXIgPSB0b2tlbkJhc2U7XG4gICAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IFwiKFwiKSB7XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgc3RyZWFtLmVhdFNwYWNlKCk7XG5cbiAgICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gXCInXCIgfHwgY2ggPT09ICdcIicpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplciA9IGJ1aWxkU3RyaW5nVG9rZW5pemVyKHN0cmVhbS5uZXh0KCkpO1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnRva2VuaXplciA9IGJ1aWxkU3RyaW5nVG9rZW5pemVyKFwiKVwiLCBmYWxzZSk7XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY29tbWVudChpbmRlbnRhdGlvbiwgbXVsdGlMaW5lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmIChzdHJlYW0uc29sKCkgJiYgc3RyZWFtLmluZGVudGF0aW9uKCkgPD0gaW5kZW50YXRpb24pIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemVyID0gdG9rZW5CYXNlO1xuICAgICAgICByZXR1cm4gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAobXVsdGlMaW5lICYmIHN0cmVhbS5za2lwVG8oXCIqL1wiKSkge1xuICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICBzdGF0ZS50b2tlbml6ZXIgPSB0b2tlbkJhc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gYnVpbGRTdHJpbmdUb2tlbml6ZXIocXVvdGUsIGdyZWVkeSkge1xuICAgIGlmIChncmVlZHkgPT0gbnVsbCkgeyBncmVlZHkgPSB0cnVlOyB9XG5cbiAgICBmdW5jdGlvbiBzdHJpbmdUb2tlbml6ZXIoc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIG5leHRDaGFyID0gc3RyZWFtLm5leHQoKTtcbiAgICAgIHZhciBwZWVrQ2hhciA9IHN0cmVhbS5wZWVrKCk7XG4gICAgICB2YXIgcHJldmlvdXNDaGFyID0gc3RyZWFtLnN0cmluZy5jaGFyQXQoc3RyZWFtLnBvcy0yKTtcblxuICAgICAgdmFyIGVuZGluZ1N0cmluZyA9ICgobmV4dENoYXIgIT09IFwiXFxcXFwiICYmIHBlZWtDaGFyID09PSBxdW90ZSkgfHwgKG5leHRDaGFyID09PSBxdW90ZSAmJiBwcmV2aW91c0NoYXIgIT09IFwiXFxcXFwiKSk7XG5cbiAgICAgIGlmIChlbmRpbmdTdHJpbmcpIHtcbiAgICAgICAgaWYgKG5leHRDaGFyICE9PSBxdW90ZSAmJiBncmVlZHkpIHsgc3RyZWFtLm5leHQoKTsgfVxuICAgICAgICBpZiAoaXNFbmRMaW5lKHN0cmVhbSkpIHtcbiAgICAgICAgICBzdGF0ZS5jdXJzb3JIYWxmID0gMDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS50b2tlbml6ZXIgPSB0b2tlbkJhc2U7XG4gICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgfSBlbHNlIGlmIChuZXh0Q2hhciA9PT0gXCIjXCIgJiYgcGVla0NoYXIgPT09IFwie1wiKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplciA9IGJ1aWxkSW50ZXJwb2xhdGlvblRva2VuaXplcihzdHJpbmdUb2tlbml6ZXIpO1xuICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZ1Rva2VuaXplcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkSW50ZXJwb2xhdGlvblRva2VuaXplcihjdXJyZW50VG9rZW5pemVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmIChzdHJlYW0ucGVlaygpID09PSBcIn1cIikge1xuICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICBzdGF0ZS50b2tlbml6ZXIgPSBjdXJyZW50VG9rZW5pemVyO1xuICAgICAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaW5kZW50KHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmluZGVudENvdW50ID09IDApIHtcbiAgICAgIHN0YXRlLmluZGVudENvdW50Kys7XG4gICAgICB2YXIgbGFzdFNjb3BlT2Zmc2V0ID0gc3RhdGUuc2NvcGVzWzBdLm9mZnNldDtcbiAgICAgIHZhciBjdXJyZW50T2Zmc2V0ID0gbGFzdFNjb3BlT2Zmc2V0ICsgY29uZmlnLmluZGVudFVuaXQ7XG4gICAgICBzdGF0ZS5zY29wZXMudW5zaGlmdCh7IG9mZnNldDpjdXJyZW50T2Zmc2V0IH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZGVudChzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5zY29wZXMubGVuZ3RoID09IDEpIHJldHVybjtcblxuICAgIHN0YXRlLnNjb3Blcy5zaGlmdCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdHJlYW0ucGVlaygpO1xuXG4gICAgLy8gQ29tbWVudFxuICAgIGlmIChzdHJlYW0ubWF0Y2goXCIvKlwiKSkge1xuICAgICAgc3RhdGUudG9rZW5pemVyID0gY29tbWVudChzdHJlYW0uaW5kZW50YXRpb24oKSwgdHJ1ZSk7XG4gICAgICByZXR1cm4gc3RhdGUudG9rZW5pemVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgICBpZiAoc3RyZWFtLm1hdGNoKFwiLy9cIikpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplciA9IGNvbW1lbnQoc3RyZWFtLmluZGVudGF0aW9uKCksIGZhbHNlKTtcbiAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgLy8gSW50ZXJwb2xhdGlvblxuICAgIGlmIChzdHJlYW0ubWF0Y2goXCIje1wiKSkge1xuICAgICAgc3RhdGUudG9rZW5pemVyID0gYnVpbGRJbnRlcnBvbGF0aW9uVG9rZW5pemVyKHRva2VuQmFzZSk7XG4gICAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICAgIH1cblxuICAgIC8vIFN0cmluZ3NcbiAgICBpZiAoY2ggPT09ICdcIicgfHwgY2ggPT09IFwiJ1wiKSB7XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgc3RhdGUudG9rZW5pemVyID0gYnVpbGRTdHJpbmdUb2tlbml6ZXIoY2gpO1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfVxuXG4gICAgaWYoIXN0YXRlLmN1cnNvckhhbGYpey8vIHN0YXRlLmN1cnNvckhhbGYgPT09IDBcbiAgICAvLyBmaXJzdCBoYWxmIGkuZS4gYmVmb3JlIDogZm9yIGtleS12YWx1ZSBwYWlyc1xuICAgIC8vIGluY2x1ZGluZyBzZWxlY3RvcnNcblxuICAgICAgaWYgKGNoID09PSBcIi1cIikge1xuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eLVxcdystLykpIHtcbiAgICAgICAgICByZXR1cm4gXCJtZXRhXCI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNoID09PSBcIi5cIikge1xuICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eW1xcdy1dKy8pKSB7XG4gICAgICAgICAgaW5kZW50KHN0YXRlKTtcbiAgICAgICAgICByZXR1cm4gXCJxdWFsaWZpZXJcIjtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0ucGVlaygpID09PSBcIiNcIikge1xuICAgICAgICAgIGluZGVudChzdGF0ZSk7XG4gICAgICAgICAgcmV0dXJuIFwidGFnXCI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNoID09PSBcIiNcIikge1xuICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAvLyBJRCBzZWxlY3RvcnNcbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXltcXHctXSsvKSkge1xuICAgICAgICAgIGluZGVudChzdGF0ZSk7XG4gICAgICAgICAgcmV0dXJuIFwiYnVpbHRpblwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJlYW0ucGVlaygpID09PSBcIiNcIikge1xuICAgICAgICAgIGluZGVudChzdGF0ZSk7XG4gICAgICAgICAgcmV0dXJuIFwidGFnXCI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVmFyaWFibGVzXG4gICAgICBpZiAoY2ggPT09IFwiJFwiKSB7XG4gICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcdy1dLyk7XG4gICAgICAgIHJldHVybiBcInZhcmlhYmxlLTJcIjtcbiAgICAgIH1cblxuICAgICAgLy8gTnVtYmVyc1xuICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXi0/WzAtOVxcLl0rLykpXG4gICAgICAgIHJldHVybiBcIm51bWJlclwiO1xuXG4gICAgICAvLyBVbml0c1xuICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXihweHxlbXxpbilcXGIvKSlcbiAgICAgICAgcmV0dXJuIFwidW5pdFwiO1xuXG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKGtleXdvcmRzUmVnZXhwKSlcbiAgICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuXG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC9edXJsLykgJiYgc3RyZWFtLnBlZWsoKSA9PT0gXCIoXCIpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemVyID0gdXJsVG9rZW5zO1xuICAgICAgICByZXR1cm4gXCJhdG9tXCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaCA9PT0gXCI9XCIpIHtcbiAgICAgICAgLy8gTWF0Y2ggc2hvcnRjdXQgbWl4aW4gZGVmaW5pdGlvblxuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9ePVtcXHctXSsvKSkge1xuICAgICAgICAgIGluZGVudChzdGF0ZSk7XG4gICAgICAgICAgcmV0dXJuIFwibWV0YVwiO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjaCA9PT0gXCIrXCIpIHtcbiAgICAgICAgLy8gTWF0Y2ggc2hvcnRjdXQgbWl4aW4gZGVmaW5pdGlvblxuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eXFwrW1xcdy1dKy8pKXtcbiAgICAgICAgICByZXR1cm4gXCJ2YXJpYWJsZS0zXCI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoY2ggPT09IFwiQFwiKXtcbiAgICAgICAgaWYoc3RyZWFtLm1hdGNoKCdAZXh0ZW5kJykpe1xuICAgICAgICAgIGlmKCFzdHJlYW0ubWF0Y2goL1xccypbXFx3XS8pKVxuICAgICAgICAgICAgZGVkZW50KHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG5cbiAgICAgIC8vIEluZGVudCBEaXJlY3RpdmVzXG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eQChlbHNlIGlmfGlmfG1lZGlhfGVsc2V8Zm9yfGVhY2h8d2hpbGV8bWl4aW58ZnVuY3Rpb24pLykpIHtcbiAgICAgICAgaW5kZW50KHN0YXRlKTtcbiAgICAgICAgcmV0dXJuIFwiZGVmXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIE90aGVyIERpcmVjdGl2ZXNcbiAgICAgIGlmIChjaCA9PT0gXCJAXCIpIHtcbiAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3LV0vKTtcbiAgICAgICAgcmV0dXJuIFwiZGVmXCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHJlYW0uZWF0V2hpbGUoL1tcXHctXS8pKXtcbiAgICAgICAgaWYoc3RyZWFtLm1hdGNoKC8gKjogKltcXHctXFwrXFwkIyFcXChcIiddLyxmYWxzZSkpe1xuICAgICAgICAgIHdvcmQgPSBzdHJlYW0uY3VycmVudCgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgdmFyIHByb3AgPSBzdGF0ZS5wcmV2UHJvcCArIFwiLVwiICsgd29yZDtcbiAgICAgICAgICBpZiAocHJvcGVydHlLZXl3b3Jkcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwicHJvcGVydHlcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnR5S2V5d29yZHMuaGFzT3duUHJvcGVydHkod29yZCkpIHtcbiAgICAgICAgICAgIHN0YXRlLnByZXZQcm9wID0gd29yZDtcbiAgICAgICAgICAgIHJldHVybiBcInByb3BlcnR5XCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChmb250UHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eSh3b3JkKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwicHJvcGVydHlcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFwidGFnXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihzdHJlYW0ubWF0Y2goLyAqOi8sZmFsc2UpKXtcbiAgICAgICAgICBpbmRlbnQoc3RhdGUpO1xuICAgICAgICAgIHN0YXRlLmN1cnNvckhhbGYgPSAxO1xuICAgICAgICAgIHN0YXRlLnByZXZQcm9wID0gc3RyZWFtLmN1cnJlbnQoKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIHJldHVybiBcInByb3BlcnR5XCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihzdHJlYW0ubWF0Y2goLyAqLC8sZmFsc2UpKXtcbiAgICAgICAgICByZXR1cm4gXCJ0YWdcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgIGluZGVudChzdGF0ZSk7XG4gICAgICAgICAgcmV0dXJuIFwidGFnXCI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoY2ggPT09IFwiOlwiKXtcbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaChwc2V1ZG9FbGVtZW50c1JlZ2V4cCkpeyAvLyBjb3VsZCBiZSBhIHBzZXVkby1lbGVtZW50XG4gICAgICAgICAgcmV0dXJuIFwidmFyaWFibGUtM1wiO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIHN0YXRlLmN1cnNvckhhbGY9MTtcbiAgICAgICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgICAgIH1cblxuICAgIH0gLy8gY3Vyc29ySGFsZj09PTAgZW5kcyBoZXJlXG4gICAgZWxzZXtcblxuICAgICAgaWYgKGNoID09PSBcIiNcIikge1xuICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAvLyBIZXggbnVtYmVyc1xuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9bMC05YS1mQS1GXXs2fXxbMC05YS1mQS1GXXszfS8pKXtcbiAgICAgICAgICBpZiAoaXNFbmRMaW5lKHN0cmVhbSkpIHtcbiAgICAgICAgICAgIHN0YXRlLmN1cnNvckhhbGYgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBOdW1iZXJzXG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eLT9bMC05XFwuXSsvKSl7XG4gICAgICAgIGlmIChpc0VuZExpbmUoc3RyZWFtKSkge1xuICAgICAgICAgIHN0YXRlLmN1cnNvckhhbGYgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgICAgfVxuXG4gICAgICAvLyBVbml0c1xuICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXihweHxlbXxpbilcXGIvKSl7XG4gICAgICAgIGlmIChpc0VuZExpbmUoc3RyZWFtKSkge1xuICAgICAgICAgIHN0YXRlLmN1cnNvckhhbGYgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcInVuaXRcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0cmVhbS5tYXRjaChrZXl3b3Jkc1JlZ2V4cCkpe1xuICAgICAgICBpZiAoaXNFbmRMaW5lKHN0cmVhbSkpIHtcbiAgICAgICAgICBzdGF0ZS5jdXJzb3JIYWxmID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goL151cmwvKSAmJiBzdHJlYW0ucGVlaygpID09PSBcIihcIikge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZXIgPSB1cmxUb2tlbnM7XG4gICAgICAgIGlmIChpc0VuZExpbmUoc3RyZWFtKSkge1xuICAgICAgICAgIHN0YXRlLmN1cnNvckhhbGYgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcImF0b21cIjtcbiAgICAgIH1cblxuICAgICAgLy8gVmFyaWFibGVzXG4gICAgICBpZiAoY2ggPT09IFwiJFwiKSB7XG4gICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcdy1dLyk7XG4gICAgICAgIGlmIChpc0VuZExpbmUoc3RyZWFtKSkge1xuICAgICAgICAgIHN0YXRlLmN1cnNvckhhbGYgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcInZhcmlhYmxlLTJcIjtcbiAgICAgIH1cblxuICAgICAgLy8gYmFuZyBjaGFyYWN0ZXIgZm9yICFpbXBvcnRhbnQsICFkZWZhdWx0LCBldGMuXG4gICAgICBpZiAoY2ggPT09IFwiIVwiKSB7XG4gICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIHN0YXRlLmN1cnNvckhhbGYgPSAwO1xuICAgICAgICByZXR1cm4gc3RyZWFtLm1hdGNoKC9eW1xcd10rLykgPyBcImtleXdvcmRcIjogXCJvcGVyYXRvclwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKG9wUmVnZXhwKSl7XG4gICAgICAgIGlmIChpc0VuZExpbmUoc3RyZWFtKSkge1xuICAgICAgICAgIHN0YXRlLmN1cnNvckhhbGYgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIGF0dHJpYnV0ZXNcbiAgICAgIGlmIChzdHJlYW0uZWF0V2hpbGUoL1tcXHctXS8pKSB7XG4gICAgICAgIGlmIChpc0VuZExpbmUoc3RyZWFtKSkge1xuICAgICAgICAgIHN0YXRlLmN1cnNvckhhbGYgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHdvcmQgPSBzdHJlYW0uY3VycmVudCgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICh2YWx1ZUtleXdvcmRzLmhhc093blByb3BlcnR5KHdvcmQpKSB7XG4gICAgICAgICAgcmV0dXJuIFwiYXRvbVwiO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbG9yS2V5d29yZHMuaGFzT3duUHJvcGVydHkod29yZCkpIHtcbiAgICAgICAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlLZXl3b3Jkcy5oYXNPd25Qcm9wZXJ0eSh3b3JkKSkge1xuICAgICAgICAgIHN0YXRlLnByZXZQcm9wID0gc3RyZWFtLmN1cnJlbnQoKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIHJldHVybiBcInByb3BlcnR5XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFwidGFnXCI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy9zdHJlYW0uZWF0U3BhY2UoKTtcbiAgICAgIGlmIChpc0VuZExpbmUoc3RyZWFtKSkge1xuICAgICAgICBzdGF0ZS5jdXJzb3JIYWxmID0gMDtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICB9IC8vIGVsc2UgZW5kcyBoZXJlXG5cbiAgICBpZiAoc3RyZWFtLm1hdGNoKG9wUmVnZXhwKSlcbiAgICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG5cbiAgICAvLyBJZiB3ZSBoYXZlbid0IHJldHVybmVkIGJ5IG5vdywgd2UgbW92ZSAxIGNoYXJhY3RlclxuICAgIC8vIGFuZCByZXR1cm4gYW4gZXJyb3JcbiAgICBzdHJlYW0ubmV4dCgpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5MZXhlcihzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHN0cmVhbS5zb2woKSkgc3RhdGUuaW5kZW50Q291bnQgPSAwO1xuICAgIHZhciBzdHlsZSA9IHN0YXRlLnRva2VuaXplcihzdHJlYW0sIHN0YXRlKTtcbiAgICB2YXIgY3VycmVudCA9IHN0cmVhbS5jdXJyZW50KCk7XG5cbiAgICBpZiAoY3VycmVudCA9PT0gXCJAcmV0dXJuXCIgfHwgY3VycmVudCA9PT0gXCJ9XCIpe1xuICAgICAgZGVkZW50KHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3R5bGUgIT09IG51bGwpIHtcbiAgICAgIHZhciBzdGFydE9mVG9rZW4gPSBzdHJlYW0ucG9zIC0gY3VycmVudC5sZW5ndGg7XG5cbiAgICAgIHZhciB3aXRoQ3VycmVudEluZGVudCA9IHN0YXJ0T2ZUb2tlbiArIChjb25maWcuaW5kZW50VW5pdCAqIHN0YXRlLmluZGVudENvdW50KTtcblxuICAgICAgdmFyIG5ld1Njb3BlcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLnNjb3Blcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc2NvcGUgPSBzdGF0ZS5zY29wZXNbaV07XG5cbiAgICAgICAgaWYgKHNjb3BlLm9mZnNldCA8PSB3aXRoQ3VycmVudEluZGVudClcbiAgICAgICAgICBuZXdTY29wZXMucHVzaChzY29wZSk7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLnNjb3BlcyA9IG5ld1Njb3BlcztcbiAgICB9XG5cblxuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b2tlbml6ZXI6IHRva2VuQmFzZSxcbiAgICAgICAgc2NvcGVzOiBbe29mZnNldDogMCwgdHlwZTogXCJzYXNzXCJ9XSxcbiAgICAgICAgaW5kZW50Q291bnQ6IDAsXG4gICAgICAgIGN1cnNvckhhbGY6IDAsICAvLyBjdXJzb3IgaGFsZiB0ZWxscyB1cyBpZiBjdXJzb3IgbGllcyBhZnRlciAoMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yIGJlZm9yZSAoMCkgY29sb24gKHdlbGwuLi4gbW9yZSBvciBsZXNzKVxuICAgICAgICBkZWZpbmVkVmFyczogW10sXG4gICAgICAgIGRlZmluZWRNaXhpbnM6IFtdXG4gICAgICB9O1xuICAgIH0sXG4gICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBzdHlsZSA9IHRva2VuTGV4ZXIoc3RyZWFtLCBzdGF0ZSk7XG5cbiAgICAgIHN0YXRlLmxhc3RUb2tlbiA9IHsgc3R5bGU6IHN0eWxlLCBjb250ZW50OiBzdHJlYW0uY3VycmVudCgpIH07XG5cbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9LFxuXG4gICAgaW5kZW50OiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgcmV0dXJuIHN0YXRlLnNjb3Blc1swXS5vZmZzZXQ7XG4gICAgfSxcblxuICAgIGJsb2NrQ29tbWVudFN0YXJ0OiBcIi8qXCIsXG4gICAgYmxvY2tDb21tZW50RW5kOiBcIiovXCIsXG4gICAgbGluZUNvbW1lbnQ6IFwiLy9cIixcbiAgICBmb2xkOiBcImluZGVudFwiXG4gIH07XG59LCBcImNzc1wiKTtcblxuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LXNhc3NcIiwgXCJzYXNzXCIpO1xuXG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbi8qKlxuICogQXV0aG9yOiBLb2ggWmkgSGFuLCBiYXNlZCBvbiBpbXBsZW1lbnRhdGlvbiBieSBLb2ggWmkgQ2h1blxuICovXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwic2NoZW1lXCIsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgQlVJTFRJTiA9IFwiYnVpbHRpblwiLCBDT01NRU5UID0gXCJjb21tZW50XCIsIFNUUklORyA9IFwic3RyaW5nXCIsXG4gICAgICAgIEFUT00gPSBcImF0b21cIiwgTlVNQkVSID0gXCJudW1iZXJcIiwgQlJBQ0tFVCA9IFwiYnJhY2tldFwiO1xuICAgIHZhciBJTkRFTlRfV09SRF9TS0lQID0gMjtcblxuICAgIGZ1bmN0aW9uIG1ha2VLZXl3b3JkcyhzdHIpIHtcbiAgICAgICAgdmFyIG9iaiA9IHt9LCB3b3JkcyA9IHN0ci5zcGxpdChcIiBcIik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyArK2kpIG9ialt3b3Jkc1tpXV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHZhciBrZXl3b3JkcyA9IG1ha2VLZXl3b3JkcyhcIs67IGNhc2UtbGFtYmRhIGNhbGwvY2MgY2xhc3MgY29uZC1leHBhbmQgZGVmaW5lLWNsYXNzIGRlZmluZS12YWx1ZXMgZXhpdC1oYW5kbGVyIGZpZWxkIGltcG9ydCBpbmhlcml0IGluaXQtZmllbGQgaW50ZXJmYWNlIGxldCotdmFsdWVzIGxldC12YWx1ZXMgbGV0L2VjIG1peGluIG9wdC1sYW1iZGEgb3ZlcnJpZGUgcHJvdGVjdCBwcm92aWRlIHB1YmxpYyByZW5hbWUgcmVxdWlyZSByZXF1aXJlLWZvci1zeW50YXggc3ludGF4IHN5bnRheC1jYXNlIHN5bnRheC1lcnJvciB1bml0L3NpZyB1bmxlc3Mgd2hlbiB3aXRoLXN5bnRheCBhbmQgYmVnaW4gY2FsbC13aXRoLWN1cnJlbnQtY29udGludWF0aW9uIGNhbGwtd2l0aC1pbnB1dC1maWxlIGNhbGwtd2l0aC1vdXRwdXQtZmlsZSBjYXNlIGNvbmQgZGVmaW5lIGRlZmluZS1zeW50YXggZGVmaW5lLW1hY3JvIGRlZm1hY3JvIGRlbGF5IGRvIGR5bmFtaWMtd2luZCBlbHNlIGZvci1lYWNoIGlmIGxhbWJkYSBsZXQgbGV0KiBsZXQtc3ludGF4IGxldHJlYyBsZXRyZWMtc3ludGF4IG1hcCBvciBzeW50YXgtcnVsZXMgYWJzIGFjb3MgYW5nbGUgYXBwZW5kIGFwcGx5IGFzaW4gYXNzb2MgYXNzcSBhc3N2IGF0YW4gYm9vbGVhbj8gY2FhciBjYWRyIGNhbGwtd2l0aC1pbnB1dC1maWxlIGNhbGwtd2l0aC1vdXRwdXQtZmlsZSBjYWxsLXdpdGgtdmFsdWVzIGNhciBjZGRkYXIgY2RkZGRyIGNkciBjZWlsaW5nIGNoYXItPmludGVnZXIgY2hhci1hbHBoYWJldGljPyBjaGFyLWNpPD0/IGNoYXItY2k8PyBjaGFyLWNpPT8gY2hhci1jaT49PyBjaGFyLWNpPj8gY2hhci1kb3duY2FzZSBjaGFyLWxvd2VyLWNhc2U/IGNoYXItbnVtZXJpYz8gY2hhci1yZWFkeT8gY2hhci11cGNhc2UgY2hhci11cHBlci1jYXNlPyBjaGFyLXdoaXRlc3BhY2U/IGNoYXI8PT8gY2hhcjw/IGNoYXI9PyBjaGFyPj0/IGNoYXI+PyBjaGFyPyBjbG9zZS1pbnB1dC1wb3J0IGNsb3NlLW91dHB1dC1wb3J0IGNvbXBsZXg/IGNvbnMgY29zIGN1cnJlbnQtaW5wdXQtcG9ydCBjdXJyZW50LW91dHB1dC1wb3J0IGRlbm9taW5hdG9yIGRpc3BsYXkgZW9mLW9iamVjdD8gZXE/IGVxdWFsPyBlcXY/IGV2YWwgZXZlbj8gZXhhY3QtPmluZXhhY3QgZXhhY3Q/IGV4cCBleHB0ICNmIGZsb29yIGZvcmNlIGdjZCBpbWFnLXBhcnQgaW5leGFjdC0+ZXhhY3QgaW5leGFjdD8gaW5wdXQtcG9ydD8gaW50ZWdlci0+Y2hhciBpbnRlZ2VyPyBpbnRlcmFjdGlvbi1lbnZpcm9ubWVudCBsY20gbGVuZ3RoIGxpc3QgbGlzdC0+c3RyaW5nIGxpc3QtPnZlY3RvciBsaXN0LXJlZiBsaXN0LXRhaWwgbGlzdD8gbG9hZCBsb2cgbWFnbml0dWRlIG1ha2UtcG9sYXIgbWFrZS1yZWN0YW5ndWxhciBtYWtlLXN0cmluZyBtYWtlLXZlY3RvciBtYXggbWVtYmVyIG1lbXEgbWVtdiBtaW4gbW9kdWxvIG5lZ2F0aXZlPyBuZXdsaW5lIG5vdCBudWxsLWVudmlyb25tZW50IG51bGw/IG51bWJlci0+c3RyaW5nIG51bWJlcj8gbnVtZXJhdG9yIG9kZD8gb3Blbi1pbnB1dC1maWxlIG9wZW4tb3V0cHV0LWZpbGUgb3V0cHV0LXBvcnQ/IHBhaXI/IHBlZWstY2hhciBwb3J0PyBwb3NpdGl2ZT8gcHJvY2VkdXJlPyBxdWFzaXF1b3RlIHF1b3RlIHF1b3RpZW50IHJhdGlvbmFsPyByYXRpb25hbGl6ZSByZWFkIHJlYWQtY2hhciByZWFsLXBhcnQgcmVhbD8gcmVtYWluZGVyIHJldmVyc2Ugcm91bmQgc2NoZW1lLXJlcG9ydC1lbnZpcm9ubWVudCBzZXQhIHNldC1jYXIhIHNldC1jZHIhIHNpbiBzcXJ0IHN0cmluZyBzdHJpbmctPmxpc3Qgc3RyaW5nLT5udW1iZXIgc3RyaW5nLT5zeW1ib2wgc3RyaW5nLWFwcGVuZCBzdHJpbmctY2k8PT8gc3RyaW5nLWNpPD8gc3RyaW5nLWNpPT8gc3RyaW5nLWNpPj0/IHN0cmluZy1jaT4/IHN0cmluZy1jb3B5IHN0cmluZy1maWxsISBzdHJpbmctbGVuZ3RoIHN0cmluZy1yZWYgc3RyaW5nLXNldCEgc3RyaW5nPD0/IHN0cmluZzw/IHN0cmluZz0/IHN0cmluZz49PyBzdHJpbmc+PyBzdHJpbmc/IHN1YnN0cmluZyBzeW1ib2wtPnN0cmluZyBzeW1ib2w/ICN0IHRhbiB0cmFuc2NyaXB0LW9mZiB0cmFuc2NyaXB0LW9uIHRydW5jYXRlIHZhbHVlcyB2ZWN0b3IgdmVjdG9yLT5saXN0IHZlY3Rvci1maWxsISB2ZWN0b3ItbGVuZ3RoIHZlY3Rvci1yZWYgdmVjdG9yLXNldCEgd2l0aC1pbnB1dC1mcm9tLWZpbGUgd2l0aC1vdXRwdXQtdG8tZmlsZSB3cml0ZSB3cml0ZS1jaGFyIHplcm8/XCIpO1xuICAgIHZhciBpbmRlbnRLZXlzID0gbWFrZUtleXdvcmRzKFwiZGVmaW5lIGxldCBsZXRyZWMgbGV0KiBsYW1iZGEgZGVmaW5lLW1hY3JvIGRlZm1hY3JvIGxldC1zeW50YXggbGV0cmVjLXN5bnRheCBsZXQtdmFsdWVzIGxldCotdmFsdWVzIGRlZmluZS1zeW50YXggc3ludGF4LXJ1bGVzIGRlZmluZS12YWx1ZXMgd2hlbiB1bmxlc3NcIik7XG5cbiAgICBmdW5jdGlvbiBzdGF0ZVN0YWNrKGluZGVudCwgdHlwZSwgcHJldikgeyAvLyByZXByZXNlbnRzIGEgc3RhdGUgc3RhY2sgb2JqZWN0XG4gICAgICAgIHRoaXMuaW5kZW50ID0gaW5kZW50O1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnByZXYgPSBwcmV2O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHB1c2hTdGFjayhzdGF0ZSwgaW5kZW50LCB0eXBlKSB7XG4gICAgICAgIHN0YXRlLmluZGVudFN0YWNrID0gbmV3IHN0YXRlU3RhY2soaW5kZW50LCB0eXBlLCBzdGF0ZS5pbmRlbnRTdGFjayk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9wU3RhY2soc3RhdGUpIHtcbiAgICAgICAgc3RhdGUuaW5kZW50U3RhY2sgPSBzdGF0ZS5pbmRlbnRTdGFjay5wcmV2O1xuICAgIH1cblxuICAgIHZhciBiaW5hcnlNYXRjaGVyID0gbmV3IFJlZ0V4cCgvXig/OlstK11pfFstK11bMDFdKyMqKD86XFwvWzAxXSsjKik/aXxbLStdP1swMV0rIyooPzpcXC9bMDFdKyMqKT9AWy0rXT9bMDFdKyMqKD86XFwvWzAxXSsjKik/fFstK10/WzAxXSsjKig/OlxcL1swMV0rIyopP1stK10oPzpbMDFdKyMqKD86XFwvWzAxXSsjKik/KT9pfFstK10/WzAxXSsjKig/OlxcL1swMV0rIyopPykoPz1bKClcXHM7XCJdfCQpL2kpO1xuICAgIHZhciBvY3RhbE1hdGNoZXIgPSBuZXcgUmVnRXhwKC9eKD86Wy0rXWl8Wy0rXVswLTddKyMqKD86XFwvWzAtN10rIyopP2l8Wy0rXT9bMC03XSsjKig/OlxcL1swLTddKyMqKT9AWy0rXT9bMC03XSsjKig/OlxcL1swLTddKyMqKT98Wy0rXT9bMC03XSsjKig/OlxcL1swLTddKyMqKT9bLStdKD86WzAtN10rIyooPzpcXC9bMC03XSsjKik/KT9pfFstK10/WzAtN10rIyooPzpcXC9bMC03XSsjKik/KSg/PVsoKVxccztcIl18JCkvaSk7XG4gICAgdmFyIGhleE1hdGNoZXIgPSBuZXcgUmVnRXhwKC9eKD86Wy0rXWl8Wy0rXVtcXGRhLWZdKyMqKD86XFwvW1xcZGEtZl0rIyopP2l8Wy0rXT9bXFxkYS1mXSsjKig/OlxcL1tcXGRhLWZdKyMqKT9AWy0rXT9bXFxkYS1mXSsjKig/OlxcL1tcXGRhLWZdKyMqKT98Wy0rXT9bXFxkYS1mXSsjKig/OlxcL1tcXGRhLWZdKyMqKT9bLStdKD86W1xcZGEtZl0rIyooPzpcXC9bXFxkYS1mXSsjKik/KT9pfFstK10/W1xcZGEtZl0rIyooPzpcXC9bXFxkYS1mXSsjKik/KSg/PVsoKVxccztcIl18JCkvaSk7XG4gICAgdmFyIGRlY2ltYWxNYXRjaGVyID0gbmV3IFJlZ0V4cCgvXig/OlstK11pfFstK10oPzooPzooPzpcXGQrIytcXC4/Iyp8XFxkK1xcLlxcZCojKnxcXC5cXGQrIyp8XFxkKykoPzpbZXNmZGxdWy0rXT9cXGQrKT8pfFxcZCsjKlxcL1xcZCsjKilpfFstK10/KD86KD86KD86XFxkKyMrXFwuPyMqfFxcZCtcXC5cXGQqIyp8XFwuXFxkKyMqfFxcZCspKD86W2VzZmRsXVstK10/XFxkKyk/KXxcXGQrIypcXC9cXGQrIyopQFstK10/KD86KD86KD86XFxkKyMrXFwuPyMqfFxcZCtcXC5cXGQqIyp8XFwuXFxkKyMqfFxcZCspKD86W2VzZmRsXVstK10/XFxkKyk/KXxcXGQrIypcXC9cXGQrIyopfFstK10/KD86KD86KD86XFxkKyMrXFwuPyMqfFxcZCtcXC5cXGQqIyp8XFwuXFxkKyMqfFxcZCspKD86W2VzZmRsXVstK10/XFxkKyk/KXxcXGQrIypcXC9cXGQrIyopWy0rXSg/Oig/Oig/OlxcZCsjK1xcLj8jKnxcXGQrXFwuXFxkKiMqfFxcLlxcZCsjKnxcXGQrKSg/Oltlc2ZkbF1bLStdP1xcZCspPyl8XFxkKyMqXFwvXFxkKyMqKT9pfCg/Oig/Oig/OlxcZCsjK1xcLj8jKnxcXGQrXFwuXFxkKiMqfFxcLlxcZCsjKnxcXGQrKSg/Oltlc2ZkbF1bLStdP1xcZCspPyl8XFxkKyMqXFwvXFxkKyMqKSkoPz1bKClcXHM7XCJdfCQpL2kpO1xuXG4gICAgZnVuY3Rpb24gaXNCaW5hcnlOdW1iZXIgKHN0cmVhbSkge1xuICAgICAgICByZXR1cm4gc3RyZWFtLm1hdGNoKGJpbmFyeU1hdGNoZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzT2N0YWxOdW1iZXIgKHN0cmVhbSkge1xuICAgICAgICByZXR1cm4gc3RyZWFtLm1hdGNoKG9jdGFsTWF0Y2hlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEZWNpbWFsTnVtYmVyIChzdHJlYW0sIGJhY2t1cCkge1xuICAgICAgICBpZiAoYmFja3VwID09PSB0cnVlKSB7XG4gICAgICAgICAgICBzdHJlYW0uYmFja1VwKDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJlYW0ubWF0Y2goZGVjaW1hbE1hdGNoZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSGV4TnVtYmVyIChzdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5tYXRjaChoZXhNYXRjaGVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGluZGVudFN0YWNrOiBudWxsLFxuICAgICAgICAgICAgICAgIGluZGVudGF0aW9uOiAwLFxuICAgICAgICAgICAgICAgIG1vZGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNFeHByQ29tbWVudDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc0V4cHJRdW90ZTogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9rZW46IGZ1bmN0aW9uIChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuaW5kZW50U3RhY2sgPT0gbnVsbCAmJiBzdHJlYW0uc29sKCkpIHtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgaW5kZW50YXRpb24sIGJ1dCBvbmx5IGlmIGluZGVudFN0YWNrIGlzIGVtcHR5XG4gICAgICAgICAgICAgICAgc3RhdGUuaW5kZW50YXRpb24gPSBzdHJlYW0uaW5kZW50YXRpb24oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2tpcCBzcGFjZXNcbiAgICAgICAgICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJldHVyblR5cGUgPSBudWxsO1xuXG4gICAgICAgICAgICBzd2l0Y2goc3RhdGUubW9kZSl7XG4gICAgICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOiAvLyBtdWx0aS1saW5lIHN0cmluZyBwYXJzaW5nIG1vZGVcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQsIGVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChuZXh0ID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPT0gXCJcXFwiXCIgJiYgIWVzY2FwZWQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZCAmJiBuZXh0ID09IFwiXFxcXFwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGUgPSBTVFJJTkc7IC8vIGNvbnRpbnVlIG9uIGluIHNjaGVtZS1zdHJpbmcgbW9kZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29tbWVudFwiOiAvLyBjb21tZW50IHBhcnNpbmcgbW9kZVxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCwgbWF5YmVFbmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChuZXh0ID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPT0gXCIjXCIgJiYgbWF5YmVFbmQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlRW5kID0gKG5leHQgPT0gXCJ8XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGUgPSBDT01NRU5UO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwicy1leHByLWNvbW1lbnRcIjogLy8gcy1leHByIGNvbW1lbnRpbmcgbW9kZVxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmKHN0cmVhbS5wZWVrKCkgPT0gXCIoXCIgfHwgc3RyZWFtLnBlZWsoKSA9PSBcIltcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhY3R1YWxseSBzdGFydCBzY2hlbWUgcy1leHByIGNvbW1lbnRpbmcgbW9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuc0V4cHJDb21tZW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBub3Qgd2UganVzdCBjb21tZW50IHRoZSBlbnRpcmUgb2YgdGhlIG5leHQgdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW15cXHNcXChcXClcXFtcXF1dLyk7IC8vIGVhdCBzeW1ib2wgYXRvbVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVHlwZSA9IENPTU1FTlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IC8vIGRlZmF1bHQgcGFyc2luZyBtb2RlXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09IFwiXFxcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gXCJzdHJpbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGUgPSBTVFJJTkc7XG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PSBcIidcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmVhbS5wZWVrKCkgPT0gXCIoXCIgfHwgc3RyZWFtLnBlZWsoKSA9PSBcIltcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZS5zRXhwclF1b3RlICE9IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuc0V4cHJRdW90ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSAvLyBlbHNlIGFscmVhZHkgaW4gYSBxdW90ZWQgZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGUgPSBBVE9NO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdfXFwtISQlJiorXFwuXFwvOjw9Pj9AXFxefl0vKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlID0gQVRPTTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PSAnIycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHJlYW0uZWF0KFwifFwiKSkgeyAgICAgICAgICAgICAgICAgICAgLy8gTXVsdGktbGluZSBjb21tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IFwiY29tbWVudFwiOyAvLyB0b2dnbGUgdG8gY29tbWVudCBtb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVHlwZSA9IENPTU1FTlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5lYXQoL1t0Zl0vaSkpIHsgICAgICAgICAgICAvLyAjdC8jZiAoYXRvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlID0gQVRPTTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLmVhdCgnOycpKSB7ICAgICAgICAgICAgICAgIC8vIFMtRXhwciBjb21tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IFwicy1leHByLWNvbW1lbnRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlID0gQ09NTUVOVDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG51bVRlc3QgPSBudWxsLCBoYXNFeGFjdG5lc3MgPSBmYWxzZSwgaGFzUmFkaXggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHJlYW0uZWF0KC9bZWldL2kpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc0V4YWN0bmVzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmJhY2tVcCgxKTsgICAgICAgLy8gbXVzdCBiZSByYWRpeCBzcGVjaWZpZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXiNiL2kpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bVRlc3QgPSBpc0JpbmFyeU51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaCgvXiNvL2kpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bVRlc3QgPSBpc09jdGFsTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKC9eI3gvaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtVGVzdCA9IGlzSGV4TnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKC9eI2QvaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtVGVzdCA9IGlzRGVjaW1hbE51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaCgvXlstKzAtOS5dLywgZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc1JhZGl4ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bVRlc3QgPSBpc0RlY2ltYWxOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmUtY29uc3VtZSB0aGUgaW5pdGlhbCAjIGlmIGFsbCBtYXRjaGVzIGZhaWxlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWhhc0V4YWN0bmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0uZWF0KCcjJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudW1UZXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1JhZGl4ICYmICFoYXNFeGFjdG5lc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnN1bWUgb3B0aW9uYWwgZXhhY3RuZXNzIGFmdGVyIHJhZGl4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0ubWF0Y2goL14jW2VpXS9pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVtVGVzdChzdHJlYW0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVHlwZSA9IE5VTUJFUjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoL15bLSswLTkuXS8udGVzdChjaCkgJiYgaXNEZWNpbWFsTnVtYmVyKHN0cmVhbSwgdHJ1ZSkpIHsgLy8gbWF0Y2ggbm9uLXByZWZpeGVkIG51bWJlciwgbXVzdCBiZSBkZWNpbWFsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlID0gTlVNQkVSO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09IFwiO1wiKSB7IC8vIGNvbW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTsgLy8gcmVzdCBvZiB0aGUgbGluZSBpcyBhIGNvbW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGUgPSBDT01NRU5UO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09IFwiKFwiIHx8IGNoID09IFwiW1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGtleVdvcmQgPSAnJzsgdmFyIGluZGVudFRlbXAgPSBzdHJlYW0uY29sdW1uKCksIGxldHRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgRWl0aGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAoaW5kZW50LXdvcmQgLi5cbiAgICAgICAgICAgICAgICAgICAgICAgIChub24taW5kZW50LXdvcmQgLi5cbiAgICAgICAgICAgICAgICAgICAgICAgICg7c29tZXRoaW5nIGVsc2UsIGJyYWNrZXQsIGV0Yy5cbiAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgobGV0dGVyID0gc3RyZWFtLmVhdCgvW15cXHNcXChcXFtcXDtcXClcXF1dLykpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlXb3JkICs9IGxldHRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleVdvcmQubGVuZ3RoID4gMCAmJiBpbmRlbnRLZXlzLnByb3BlcnR5SXNFbnVtZXJhYmxlKGtleVdvcmQpKSB7IC8vIGluZGVudC13b3JkXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXNoU3RhY2soc3RhdGUsIGluZGVudFRlbXAgKyBJTkRFTlRfV09SRF9TS0lQLCBjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBub24taW5kZW50IHdvcmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjb250aW51ZSBlYXRpbmcgdGhlIHNwYWNlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5lYXRTcGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHJlYW0uZW9sKCkgfHwgc3RyZWFtLnBlZWsoKSA9PSBcIjtcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3RoaW5nIHNpZ25pZmljYW50IGFmdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHJlc3RhcnQgaW5kZW50YXRpb24gMSBzcGFjZSBhZnRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXNoU3RhY2soc3RhdGUsIGluZGVudFRlbXAgKyAxLCBjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVzaFN0YWNrKHN0YXRlLCBpbmRlbnRUZW1wICsgc3RyZWFtLmN1cnJlbnQoKS5sZW5ndGgsIGNoKTsgLy8gZWxzZSB3ZSBtYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5iYWNrVXAoc3RyZWFtLmN1cnJlbnQoKS5sZW5ndGggLSAxKTsgLy8gdW5kbyBhbGwgdGhlIGVhdGluZ1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2Ygc3RhdGUuc0V4cHJDb21tZW50ID09IFwibnVtYmVyXCIpIHN0YXRlLnNFeHByQ29tbWVudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIHN0YXRlLnNFeHByUXVvdGUgPT0gXCJudW1iZXJcIikgc3RhdGUuc0V4cHJRdW90ZSsrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlID0gQlJBQ0tFVDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PSBcIilcIiB8fCBjaCA9PSBcIl1cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVHlwZSA9IEJSQUNLRVQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaW5kZW50U3RhY2sgIT0gbnVsbCAmJiBzdGF0ZS5pbmRlbnRTdGFjay50eXBlID09IChjaCA9PSBcIilcIiA/IFwiKFwiIDogXCJbXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9wU3RhY2soc3RhdGUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIHN0YXRlLnNFeHByQ29tbWVudCA9PSBcIm51bWJlclwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoLS1zdGF0ZS5zRXhwckNvbW1lbnQgPT0gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlID0gQ09NTUVOVDsgLy8gZmluYWwgY2xvc2luZyBicmFja2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zRXhwckNvbW1lbnQgPSBmYWxzZTsgLy8gdHVybiBvZmYgcy1leHByIGNvbW1lbnRpbmcgbW9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBzdGF0ZS5zRXhwclF1b3RlID09IFwibnVtYmVyXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZigtLXN0YXRlLnNFeHByUXVvdGUgPT0gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlID0gQVRPTTsgLy8gZmluYWwgY2xvc2luZyBicmFja2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zRXhwclF1b3RlID0gZmFsc2U7IC8vIHR1cm4gb2ZmIHMtZXhwciBxdW90ZSBtb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdfXFwtISQlJiorXFwuXFwvOjw9Pj9AXFxefl0vKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleXdvcmRzICYmIGtleXdvcmRzLnByb3BlcnR5SXNFbnVtZXJhYmxlKHN0cmVhbS5jdXJyZW50KCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVHlwZSA9IEJVSUxUSU47XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgcmV0dXJuVHlwZSA9IFwidmFyaWFibGVcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICh0eXBlb2Ygc3RhdGUuc0V4cHJDb21tZW50ID09IFwibnVtYmVyXCIpID8gQ09NTUVOVCA6ICgodHlwZW9mIHN0YXRlLnNFeHByUXVvdGUgPT0gXCJudW1iZXJcIikgPyBBVE9NIDogcmV0dXJuVHlwZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5kZW50OiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5pbmRlbnRTdGFjayA9PSBudWxsKSByZXR1cm4gc3RhdGUuaW5kZW50YXRpb247XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUuaW5kZW50U3RhY2suaW5kZW50O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsb3NlQnJhY2tldHM6IHtwYWlyczogXCIoKVtde31cXFwiXFxcIlwifSxcbiAgICAgICAgbGluZUNvbW1lbnQ6IFwiOztcIlxuICAgIH07XG59KTtcblxuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LXNjaGVtZVwiLCBcInNjaGVtZVwiKTtcblxufSk7XG4iLCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTW9kZShcInNpZXZlXCIsIGZ1bmN0aW9uKGNvbmZpZykge1xuICBmdW5jdGlvbiB3b3JkcyhzdHIpIHtcbiAgICB2YXIgb2JqID0ge30sIHdvcmRzID0gc3RyLnNwbGl0KFwiIFwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgKytpKSBvYmpbd29yZHNbaV1dID0gdHJ1ZTtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIGtleXdvcmRzID0gd29yZHMoXCJpZiBlbHNpZiBlbHNlIHN0b3AgcmVxdWlyZVwiKTtcbiAgdmFyIGF0b21zID0gd29yZHMoXCJ0cnVlIGZhbHNlIG5vdFwiKTtcbiAgdmFyIGluZGVudFVuaXQgPSBjb25maWcuaW5kZW50VW5pdDtcblxuICBmdW5jdGlvbiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuXG4gICAgdmFyIGNoID0gc3RyZWFtLm5leHQoKTtcbiAgICBpZiAoY2ggPT0gXCIvXCIgJiYgc3RyZWFtLmVhdChcIipcIikpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5DQ29tbWVudDtcbiAgICAgIHJldHVybiB0b2tlbkNDb21tZW50KHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChjaCA9PT0gJyMnKSB7XG4gICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgfVxuXG4gICAgaWYgKGNoID09IFwiXFxcIlwiKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuU3RyaW5nKGNoKTtcbiAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoY2ggPT0gXCIoXCIpIHtcbiAgICAgIHN0YXRlLl9pbmRlbnQucHVzaChcIihcIik7XG4gICAgICAvLyBhZGQgdmlydHVhbCBhbmdlbCB3aW5ncyBzbyB0aGF0IGVkaXRvciBiZWhhdmVzLi4uXG4gICAgICAvLyAuLi5tb3JlIHNhbmUgaW4gY2FzZSBvZiBicm9rZW4gYnJhY2tldHNcbiAgICAgIHN0YXRlLl9pbmRlbnQucHVzaChcIntcIik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoY2ggPT09IFwie1wiKSB7XG4gICAgICBzdGF0ZS5faW5kZW50LnB1c2goXCJ7XCIpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGNoID09IFwiKVwiKSAge1xuICAgICAgc3RhdGUuX2luZGVudC5wb3AoKTtcbiAgICAgIHN0YXRlLl9pbmRlbnQucG9wKCk7XG4gICAgfVxuXG4gICAgaWYgKGNoID09PSBcIn1cIikge1xuICAgICAgc3RhdGUuX2luZGVudC5wb3AoKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChjaCA9PSBcIixcIilcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgaWYgKGNoID09IFwiO1wiKVxuICAgICAgcmV0dXJuIG51bGw7XG5cblxuICAgIGlmICgvW3t9XFwoXFwpLDtdLy50ZXN0KGNoKSlcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgLy8gMSpESUdJVCBcIktcIiAvIFwiTVwiIC8gXCJHXCJcbiAgICBpZiAoL1xcZC8udGVzdChjaCkpIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcZF0vKTtcbiAgICAgIHN0cmVhbS5lYXQoL1tLa01tR2ddLyk7XG4gICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICB9XG5cbiAgICAvLyBcIjpcIiAoQUxQSEEgLyBcIl9cIikgKihBTFBIQSAvIERJR0lUIC8gXCJfXCIpXG4gICAgaWYgKGNoID09IFwiOlwiKSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1thLXpBLVpfXS8pO1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bYS16QS1aMC05X10vKTtcblxuICAgICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgICB9XG5cbiAgICBzdHJlYW0uZWF0V2hpbGUoL1xcdy8pO1xuICAgIHZhciBjdXIgPSBzdHJlYW0uY3VycmVudCgpO1xuXG4gICAgLy8gXCJ0ZXh0OlwiICooU1AgLyBIVEFCKSAoaGFzaC1jb21tZW50IC8gQ1JMRilcbiAgICAvLyAqKG11bHRpbGluZS1saXRlcmFsIC8gbXVsdGlsaW5lLWRvdHN0YXJ0KVxuICAgIC8vIFwiLlwiIENSTEZcbiAgICBpZiAoKGN1ciA9PSBcInRleHRcIikgJiYgc3RyZWFtLmVhdChcIjpcIikpXG4gICAge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbk11bHRpTGluZVN0cmluZztcbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH1cblxuICAgIGlmIChrZXl3b3Jkcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKVxuICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuXG4gICAgaWYgKGF0b21zLnByb3BlcnR5SXNFbnVtZXJhYmxlKGN1cikpXG4gICAgICByZXR1cm4gXCJhdG9tXCI7XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuTXVsdGlMaW5lU3RyaW5nKHN0cmVhbSwgc3RhdGUpXG4gIHtcbiAgICBzdGF0ZS5fbXVsdGlMaW5lU3RyaW5nID0gdHJ1ZTtcbiAgICAvLyB0aGUgZmlyc3QgbGluZSBpcyBzcGVjaWFsIGl0IG1heSBjb250YWluIGEgY29tbWVudFxuICAgIGlmICghc3RyZWFtLnNvbCgpKSB7XG4gICAgICBzdHJlYW0uZWF0U3BhY2UoKTtcblxuICAgICAgaWYgKHN0cmVhbS5wZWVrKCkgPT0gXCIjXCIpIHtcbiAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgICB9XG5cbiAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH1cblxuICAgIGlmICgoc3RyZWFtLm5leHQoKSA9PSBcIi5cIikgICYmIChzdHJlYW0uZW9sKCkpKVxuICAgIHtcbiAgICAgIHN0YXRlLl9tdWx0aUxpbmVTdHJpbmcgPSBmYWxzZTtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgIH1cblxuICAgIHJldHVybiBcInN0cmluZ1wiO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5DQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIG1heWJlRW5kID0gZmFsc2UsIGNoO1xuICAgIHdoaWxlICgoY2ggPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICBpZiAobWF5YmVFbmQgJiYgY2ggPT0gXCIvXCIpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbWF5YmVFbmQgPSAoY2ggPT0gXCIqXCIpO1xuICAgIH1cbiAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlblN0cmluZyhxdW90ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgZXNjYXBlZCA9IGZhbHNlLCBjaDtcbiAgICAgIHdoaWxlICgoY2ggPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChjaCA9PSBxdW90ZSAmJiAhZXNjYXBlZClcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkICYmIGNoID09IFwiXFxcXFwiO1xuICAgICAgfVxuICAgICAgaWYgKCFlc2NhcGVkKSBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKGJhc2UpIHtcbiAgICAgIHJldHVybiB7dG9rZW5pemU6IHRva2VuQmFzZSxcbiAgICAgICAgICAgICAgYmFzZUluZGVudDogYmFzZSB8fCAwLFxuICAgICAgICAgICAgICBfaW5kZW50OiBbXX07XG4gICAgfSxcblxuICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpXG4gICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICByZXR1cm4gKHN0YXRlLnRva2VuaXplIHx8IHRva2VuQmFzZSkoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSxcblxuICAgIGluZGVudDogZnVuY3Rpb24oc3RhdGUsIF90ZXh0QWZ0ZXIpIHtcbiAgICAgIHZhciBsZW5ndGggPSBzdGF0ZS5faW5kZW50Lmxlbmd0aDtcbiAgICAgIGlmIChfdGV4dEFmdGVyICYmIChfdGV4dEFmdGVyWzBdID09IFwifVwiKSlcbiAgICAgICAgbGVuZ3RoLS07XG5cbiAgICAgIGlmIChsZW5ndGggPDApXG4gICAgICAgIGxlbmd0aCA9IDA7XG5cbiAgICAgIHJldHVybiBsZW5ndGggKiBpbmRlbnRVbml0O1xuICAgIH0sXG5cbiAgICBlbGVjdHJpY0NoYXJzOiBcIn1cIlxuICB9O1xufSk7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcImFwcGxpY2F0aW9uL3NpZXZlXCIsIFwic2lldmVcIik7XG5cbn0pO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuLy8gU2xpbSBIaWdobGlnaHRpbmcgZm9yIENvZGVNaXJyb3IgY29weXJpZ2h0IChjKSBIaWNrbkhhY2sgU29mdHdhcmUgR21iaFxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpLCByZXF1aXJlKFwiLi4vaHRtbG1peGVkL2h0bWxtaXhlZFwiKSwgcmVxdWlyZShcIi4uL3J1YnkvcnVieVwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiLCBcIi4uL2h0bWxtaXhlZC9odG1sbWl4ZWRcIiwgXCIuLi9ydWJ5L3J1YnlcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuICBDb2RlTWlycm9yLmRlZmluZU1vZGUoXCJzbGltXCIsIGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHZhciBodG1sTW9kZSA9IENvZGVNaXJyb3IuZ2V0TW9kZShjb25maWcsIHtuYW1lOiBcImh0bWxtaXhlZFwifSk7XG4gICAgdmFyIHJ1YnlNb2RlID0gQ29kZU1pcnJvci5nZXRNb2RlKGNvbmZpZywgXCJydWJ5XCIpO1xuICAgIHZhciBtb2RlcyA9IHsgaHRtbDogaHRtbE1vZGUsIHJ1Ynk6IHJ1YnlNb2RlIH07XG4gICAgdmFyIGVtYmVkZGVkID0ge1xuICAgICAgcnVieTogXCJydWJ5XCIsXG4gICAgICBqYXZhc2NyaXB0OiBcImphdmFzY3JpcHRcIixcbiAgICAgIGNzczogXCJ0ZXh0L2Nzc1wiLFxuICAgICAgc2FzczogXCJ0ZXh0L3gtc2Fzc1wiLFxuICAgICAgc2NzczogXCJ0ZXh0L3gtc2Nzc1wiLFxuICAgICAgbGVzczogXCJ0ZXh0L3gtbGVzc1wiLFxuICAgICAgc3R5bDogXCJ0ZXh0L3gtc3R5bFwiLCAvLyBubyBoaWdobGlnaHRpbmcgc28gZmFyXG4gICAgICBjb2ZmZWU6IFwiY29mZmVlc2NyaXB0XCIsXG4gICAgICBhc2NpaWRvYzogXCJ0ZXh0L3gtYXNjaWlkb2NcIixcbiAgICAgIG1hcmtkb3duOiBcInRleHQveC1tYXJrZG93blwiLFxuICAgICAgdGV4dGlsZTogXCJ0ZXh0L3gtdGV4dGlsZVwiLCAvLyBubyBoaWdobGlnaHRpbmcgc28gZmFyXG4gICAgICBjcmVvbGU6IFwidGV4dC94LWNyZW9sZVwiLCAvLyBubyBoaWdobGlnaHRpbmcgc28gZmFyXG4gICAgICB3aWtpOiBcInRleHQveC13aWtpXCIsIC8vIG5vIGhpZ2hsaWdodGluZyBzbyBmYXJcbiAgICAgIG1lZGlhd2lraTogXCJ0ZXh0L3gtbWVkaWF3aWtpXCIsIC8vIG5vIGhpZ2hsaWdodGluZyBzbyBmYXJcbiAgICAgIHJkb2M6IFwidGV4dC94LXJkb2NcIiwgLy8gbm8gaGlnaGxpZ2h0aW5nIHNvIGZhclxuICAgICAgYnVpbGRlcjogXCJ0ZXh0L3gtYnVpbGRlclwiLCAvLyBubyBoaWdobGlnaHRpbmcgc28gZmFyXG4gICAgICBub2tvZ2lyaTogXCJ0ZXh0L3gtbm9rb2dpcmlcIiwgLy8gbm8gaGlnaGxpZ2h0aW5nIHNvIGZhclxuICAgICAgZXJiOiBcImFwcGxpY2F0aW9uL3gtZXJiXCJcbiAgICB9O1xuICAgIHZhciBlbWJlZGRlZFJlZ2V4cCA9IGZ1bmN0aW9uKG1hcCl7XG4gICAgICB2YXIgYXJyID0gW107XG4gICAgICBmb3IodmFyIGtleSBpbiBtYXApIGFyci5wdXNoKGtleSk7XG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cChcIl4oXCIrYXJyLmpvaW4oJ3wnKStcIik6XCIpO1xuICAgIH0oZW1iZWRkZWQpO1xuXG4gICAgdmFyIHN0eWxlTWFwID0ge1xuICAgICAgXCJjb21tZW50TGluZVwiOiBcImNvbW1lbnRcIixcbiAgICAgIFwic2xpbVN3aXRjaFwiOiBcIm9wZXJhdG9yIHNwZWNpYWxcIixcbiAgICAgIFwic2xpbVRhZ1wiOiBcInRhZ1wiLFxuICAgICAgXCJzbGltSWRcIjogXCJhdHRyaWJ1dGUgZGVmXCIsXG4gICAgICBcInNsaW1DbGFzc1wiOiBcImF0dHJpYnV0ZSBxdWFsaWZpZXJcIixcbiAgICAgIFwic2xpbUF0dHJpYnV0ZVwiOiBcImF0dHJpYnV0ZVwiLFxuICAgICAgXCJzbGltU3VibW9kZVwiOiBcImtleXdvcmQgc3BlY2lhbFwiLFxuICAgICAgXCJjbG9zZUF0dHJpYnV0ZVRhZ1wiOiBudWxsLFxuICAgICAgXCJzbGltRG9jdHlwZVwiOiBudWxsLFxuICAgICAgXCJsaW5lQ29udGludWF0aW9uXCI6IG51bGxcbiAgICB9O1xuICAgIHZhciBjbG9zaW5nID0ge1xuICAgICAgXCJ7XCI6IFwifVwiLFxuICAgICAgXCJbXCI6IFwiXVwiLFxuICAgICAgXCIoXCI6IFwiKVwiXG4gICAgfTtcblxuICAgIHZhciBuYW1lU3RhcnRDaGFyID0gXCJfYS16QS1aXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRcIjtcbiAgICB2YXIgbmFtZUNoYXIgPSBuYW1lU3RhcnRDaGFyICsgXCJcXFxcLTAtOVxceEI3XFx1MDMwMC1cXHUwMzZGXFx1MjAzRi1cXHUyMDQwXCI7XG4gICAgdmFyIG5hbWVSZWdleHAgPSBuZXcgUmVnRXhwKFwiXls6XCIrbmFtZVN0YXJ0Q2hhcitcIl0oPzo6W1wiK25hbWVDaGFyK1wiXXxbXCIrbmFtZUNoYXIrXCJdKilcIik7XG4gICAgdmFyIGF0dHJpYnV0ZU5hbWVSZWdleHAgPSBuZXcgUmVnRXhwKFwiXls6XCIrbmFtZVN0YXJ0Q2hhcitcIl1bOlxcXFwuXCIrbmFtZUNoYXIrXCJdKig/PVxcXFxzKj0pXCIpO1xuICAgIHZhciB3cmFwcGVkQXR0cmlidXRlTmFtZVJlZ2V4cCA9IG5ldyBSZWdFeHAoXCJeWzpcIituYW1lU3RhcnRDaGFyK1wiXVs6XFxcXC5cIituYW1lQ2hhcitcIl0qXCIpO1xuICAgIHZhciBjbGFzc05hbWVSZWdleHAgPSAvXlxcLi0/W19hLXpBLVpdK1tcXHdcXC1dKi87XG4gICAgdmFyIGNsYXNzSWRSZWdleHAgPSAvXiNbX2EtekEtWl0rW1xcd1xcLV0qLztcblxuICAgIGZ1bmN0aW9uIGJhY2t1cChwb3MsIHRva2VuaXplLCBzdHlsZSkge1xuICAgICAgdmFyIHJlc3RvcmUgPSBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5pemU7XG4gICAgICAgIGlmIChzdHJlYW0ucG9zIDwgcG9zKSB7XG4gICAgICAgICAgc3RyZWFtLnBvcyA9IHBvcztcbiAgICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gcmVzdG9yZTtcbiAgICAgICAgcmV0dXJuIHRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXliZUJhY2t1cChzdHJlYW0sIHN0YXRlLCBwYXQsIG9mZnNldCwgc3R5bGUpIHtcbiAgICAgIHZhciBjdXIgPSBzdHJlYW0uY3VycmVudCgpO1xuICAgICAgdmFyIGlkeCA9IGN1ci5zZWFyY2gocGF0KTtcbiAgICAgIGlmIChpZHggPiAtMSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IGJhY2t1cChzdHJlYW0ucG9zLCBzdGF0ZS50b2tlbml6ZSwgc3R5bGUpO1xuICAgICAgICBzdHJlYW0uYmFja1VwKGN1ci5sZW5ndGggLSBpZHggLSBvZmZzZXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnRpbnVlTGluZShzdGF0ZSwgY29sdW1uKSB7XG4gICAgICBzdGF0ZS5zdGFjayA9IHtcbiAgICAgICAgcGFyZW50OiBzdGF0ZS5zdGFjayxcbiAgICAgICAgc3R5bGU6IFwiY29udGludWF0aW9uXCIsXG4gICAgICAgIGluZGVudGVkOiBjb2x1bW4sXG4gICAgICAgIHRva2VuaXplOiBzdGF0ZS5saW5lXG4gICAgICB9O1xuICAgICAgc3RhdGUubGluZSA9IHN0YXRlLnRva2VuaXplO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5pc2hDb250aW51ZShzdGF0ZSkge1xuICAgICAgaWYgKHN0YXRlLmxpbmUgPT0gc3RhdGUudG9rZW5pemUpIHtcbiAgICAgICAgc3RhdGUubGluZSA9IHN0YXRlLnN0YWNrLnRva2VuaXplO1xuICAgICAgICBzdGF0ZS5zdGFjayA9IHN0YXRlLnN0YWNrLnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaW5lQ29udGludWFibGUoY29sdW1uLCB0b2tlbml6ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgZmluaXNoQ29udGludWUoc3RhdGUpO1xuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eXFxcXCQvKSkge1xuICAgICAgICAgIGNvbnRpbnVlTGluZShzdGF0ZSwgY29sdW1uKTtcbiAgICAgICAgICByZXR1cm4gXCJsaW5lQ29udGludWF0aW9uXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0eWxlID0gdG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIGlmIChzdHJlYW0uZW9sKCkgJiYgc3RyZWFtLmN1cnJlbnQoKS5tYXRjaCgvKD86XnxbXlxcXFxdKSg/OlxcXFxcXFxcKSpcXFxcJC8pKSB7XG4gICAgICAgICAgc3RyZWFtLmJhY2tVcCgxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21tYUNvbnRpbnVhYmxlKGNvbHVtbiwgdG9rZW5pemUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIGZpbmlzaENvbnRpbnVlKHN0YXRlKTtcbiAgICAgICAgdmFyIHN0eWxlID0gdG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIGlmIChzdHJlYW0uZW9sKCkgJiYgc3RyZWFtLmN1cnJlbnQoKS5tYXRjaCgvLCQvKSkge1xuICAgICAgICAgIGNvbnRpbnVlTGluZShzdGF0ZSwgY29sdW1uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1YnlJblF1b3RlKGVuZFF1b3RlLCB0b2tlbml6ZSkge1xuICAgICAgLy8gVE9ETzogYWRkIG11bHRpIGxpbmUgc3VwcG9ydFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgdmFyIGNoID0gc3RyZWFtLnBlZWsoKTtcbiAgICAgICAgaWYgKGNoID09IGVuZFF1b3RlICYmIHN0YXRlLnJ1YnlTdGF0ZS50b2tlbml6ZS5sZW5ndGggPT0gMSkge1xuICAgICAgICAgIC8vIHN0ZXAgb3V0IG9mIHJ1YnkgY29udGV4dCBhcyBpdCBzZWVtcyB0byBjb21wbGV0ZSBwcm9jZXNzaW5nIGFsbCB0aGUgYnJhY2VzXG4gICAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuaXplO1xuICAgICAgICAgIHJldHVybiBcImNsb3NlQXR0cmlidXRlVGFnXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHJ1Ynkoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0YXJ0UnVieVNwbGF0KHRva2VuaXplKSB7XG4gICAgICB2YXIgcnVieVN0YXRlO1xuICAgICAgdmFyIHJ1blNwbGF0ID0gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUucnVieVN0YXRlLnRva2VuaXplLmxlbmd0aCA9PSAxICYmICFzdGF0ZS5ydWJ5U3RhdGUuY29udGV4dC5wcmV2KSB7XG4gICAgICAgICAgc3RyZWFtLmJhY2tVcCgxKTtcbiAgICAgICAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHtcbiAgICAgICAgICAgIHN0YXRlLnJ1YnlTdGF0ZSA9IHJ1YnlTdGF0ZTtcbiAgICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5pemU7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1Ynkoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgcnVieVN0YXRlID0gc3RhdGUucnVieVN0YXRlO1xuICAgICAgICBzdGF0ZS5ydWJ5U3RhdGUgPSBDb2RlTWlycm9yLnN0YXJ0U3RhdGUocnVieU1vZGUpO1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHJ1blNwbGF0O1xuICAgICAgICByZXR1cm4gcnVieShzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVieShzdHJlYW0sIHN0YXRlKSB7XG4gICAgICByZXR1cm4gcnVieU1vZGUudG9rZW4oc3RyZWFtLCBzdGF0ZS5ydWJ5U3RhdGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGh0bWxMaW5lKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goL15cXFxcJC8pKSB7XG4gICAgICAgIHJldHVybiBcImxpbmVDb250aW51YXRpb25cIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBodG1sKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBodG1sKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goL14jXFx7LykpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSBydWJ5SW5RdW90ZShcIn1cIiwgc3RhdGUudG9rZW5pemUpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXliZUJhY2t1cChzdHJlYW0sIHN0YXRlLCAvW15cXFxcXSNcXHsvLCAxLCBodG1sTW9kZS50b2tlbihzdHJlYW0sIHN0YXRlLmh0bWxTdGF0ZSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXJ0SHRtbExpbmUobGFzdFRva2VuaXplKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgICB2YXIgc3R5bGUgPSBodG1sTGluZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgaWYgKHN0cmVhbS5lb2woKSkgc3RhdGUudG9rZW5pemUgPSBsYXN0VG9rZW5pemU7XG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhcnRIdG1sTW9kZShzdHJlYW0sIHN0YXRlLCBvZmZzZXQpIHtcbiAgICAgIHN0YXRlLnN0YWNrID0ge1xuICAgICAgICBwYXJlbnQ6IHN0YXRlLnN0YWNrLFxuICAgICAgICBzdHlsZTogXCJodG1sXCIsXG4gICAgICAgIGluZGVudGVkOiBzdHJlYW0uY29sdW1uKCkgKyBvZmZzZXQsIC8vIHBpcGUgKyBzcGFjZVxuICAgICAgICB0b2tlbml6ZTogc3RhdGUubGluZVxuICAgICAgfTtcbiAgICAgIHN0YXRlLmxpbmUgPSBzdGF0ZS50b2tlbml6ZSA9IGh0bWw7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21tZW50KHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgIHJldHVybiBzdGF0ZS5zdGFjay5zdHlsZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21tZW50TW9kZShzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBzdGF0ZS5zdGFjayA9IHtcbiAgICAgICAgcGFyZW50OiBzdGF0ZS5zdGFjayxcbiAgICAgICAgc3R5bGU6IFwiY29tbWVudFwiLFxuICAgICAgICBpbmRlbnRlZDogc3RhdGUuaW5kZW50ZWQgKyAxLFxuICAgICAgICB0b2tlbml6ZTogc3RhdGUubGluZVxuICAgICAgfTtcbiAgICAgIHN0YXRlLmxpbmUgPSBjb21tZW50O1xuICAgICAgcmV0dXJuIGNvbW1lbnQoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXR0cmlidXRlV3JhcHBlcihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAoc3RyZWFtLmVhdChzdGF0ZS5zdGFjay5lbmRRdW90ZSkpIHtcbiAgICAgICAgc3RhdGUubGluZSA9IHN0YXRlLnN0YWNrLmxpbmU7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gc3RhdGUuc3RhY2sudG9rZW5pemU7XG4gICAgICAgIHN0YXRlLnN0YWNrID0gc3RhdGUuc3RhY2sucGFyZW50O1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChzdHJlYW0ubWF0Y2god3JhcHBlZEF0dHJpYnV0ZU5hbWVSZWdleHApKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gYXR0cmlidXRlV3JhcHBlckFzc2lnbjtcbiAgICAgICAgcmV0dXJuIFwic2xpbUF0dHJpYnV0ZVwiO1xuICAgICAgfVxuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhdHRyaWJ1dGVXcmFwcGVyQXNzaWduKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goL149PT8vKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IGF0dHJpYnV0ZVdyYXBwZXJWYWx1ZTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXR0cmlidXRlV3JhcHBlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXR0cmlidXRlV3JhcHBlclZhbHVlKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBjaCA9IHN0cmVhbS5wZWVrKCk7XG4gICAgICBpZiAoY2ggPT0gJ1wiJyB8fCBjaCA9PSBcIlxcJ1wiKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gcmVhZFF1b3RlZChjaCwgXCJzdHJpbmdcIiwgdHJ1ZSwgZmFsc2UsIGF0dHJpYnV0ZVdyYXBwZXIpO1xuICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgICBpZiAoY2ggPT0gJ1snKSB7XG4gICAgICAgIHJldHVybiBzdGFydFJ1YnlTcGxhdChhdHRyaWJ1dGVXcmFwcGVyKShzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goL14odHJ1ZXxmYWxzZXxuaWwpXFxiLykpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSBhdHRyaWJ1dGVXcmFwcGVyO1xuICAgICAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhcnRSdWJ5U3BsYXQoYXR0cmlidXRlV3JhcHBlcikoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhcnRBdHRyaWJ1dGVXcmFwcGVyTW9kZShzdGF0ZSwgZW5kUXVvdGUsIHRva2VuaXplKSB7XG4gICAgICBzdGF0ZS5zdGFjayA9IHtcbiAgICAgICAgcGFyZW50OiBzdGF0ZS5zdGFjayxcbiAgICAgICAgc3R5bGU6IFwid3JhcHBlclwiLFxuICAgICAgICBpbmRlbnRlZDogc3RhdGUuaW5kZW50ZWQgKyAxLFxuICAgICAgICB0b2tlbml6ZTogdG9rZW5pemUsXG4gICAgICAgIGxpbmU6IHN0YXRlLmxpbmUsXG4gICAgICAgIGVuZFF1b3RlOiBlbmRRdW90ZVxuICAgICAgfTtcbiAgICAgIHN0YXRlLmxpbmUgPSBzdGF0ZS50b2tlbml6ZSA9IGF0dHJpYnV0ZVdyYXBwZXI7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdWIoc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXiNcXHsvKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHJ1YnlJblF1b3RlKFwifVwiLCBzdGF0ZS50b2tlbml6ZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIHN1YlN0cmVhbSA9IG5ldyBDb2RlTWlycm9yLlN0cmluZ1N0cmVhbShzdHJlYW0uc3RyaW5nLnNsaWNlKHN0YXRlLnN0YWNrLmluZGVudGVkKSwgc3RyZWFtLnRhYlNpemUpO1xuICAgICAgc3ViU3RyZWFtLnBvcyA9IHN0cmVhbS5wb3MgLSBzdGF0ZS5zdGFjay5pbmRlbnRlZDtcbiAgICAgIHN1YlN0cmVhbS5zdGFydCA9IHN0cmVhbS5zdGFydCAtIHN0YXRlLnN0YWNrLmluZGVudGVkO1xuICAgICAgc3ViU3RyZWFtLmxhc3RDb2x1bW5Qb3MgPSBzdHJlYW0ubGFzdENvbHVtblBvcyAtIHN0YXRlLnN0YWNrLmluZGVudGVkO1xuICAgICAgc3ViU3RyZWFtLmxhc3RDb2x1bW5WYWx1ZSA9IHN0cmVhbS5sYXN0Q29sdW1uVmFsdWUgLSBzdGF0ZS5zdGFjay5pbmRlbnRlZDtcbiAgICAgIHZhciBzdHlsZSA9IHN0YXRlLnN1Yk1vZGUudG9rZW4oc3ViU3RyZWFtLCBzdGF0ZS5zdWJTdGF0ZSk7XG4gICAgICBzdHJlYW0ucG9zID0gc3ViU3RyZWFtLnBvcyArIHN0YXRlLnN0YWNrLmluZGVudGVkO1xuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaXJzdFN1YihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBzdGF0ZS5zdGFjay5pbmRlbnRlZCA9IHN0cmVhbS5jb2x1bW4oKTtcbiAgICAgIHN0YXRlLmxpbmUgPSBzdGF0ZS50b2tlbml6ZSA9IHN1YjtcbiAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVNb2RlKG1vZGUpIHtcbiAgICAgIHZhciBxdWVyeSA9IGVtYmVkZGVkW21vZGVdO1xuICAgICAgdmFyIHNwZWMgPSBDb2RlTWlycm9yLm1pbWVNb2Rlc1txdWVyeV07XG4gICAgICBpZiAoc3BlYykge1xuICAgICAgICByZXR1cm4gQ29kZU1pcnJvci5nZXRNb2RlKGNvbmZpZywgc3BlYyk7XG4gICAgICB9XG4gICAgICB2YXIgZmFjdG9yeSA9IENvZGVNaXJyb3IubW9kZXNbcXVlcnldO1xuICAgICAgaWYgKGZhY3RvcnkpIHtcbiAgICAgICAgcmV0dXJuIGZhY3RvcnkoY29uZmlnLCB7bmFtZTogcXVlcnl9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDb2RlTWlycm9yLmdldE1vZGUoY29uZmlnLCBcIm51bGxcIik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0TW9kZShtb2RlKSB7XG4gICAgICBpZiAoIW1vZGVzLmhhc093blByb3BlcnR5KG1vZGUpKSB7XG4gICAgICAgIHJldHVybiBtb2Rlc1ttb2RlXSA9IGNyZWF0ZU1vZGUobW9kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbW9kZXNbbW9kZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhcnRTdWJNb2RlKG1vZGUsIHN0YXRlKSB7XG4gICAgICB2YXIgc3ViTW9kZSA9IGdldE1vZGUobW9kZSk7XG4gICAgICB2YXIgc3ViU3RhdGUgPSBDb2RlTWlycm9yLnN0YXJ0U3RhdGUoc3ViTW9kZSk7XG5cbiAgICAgIHN0YXRlLnN1Yk1vZGUgPSBzdWJNb2RlO1xuICAgICAgc3RhdGUuc3ViU3RhdGUgPSBzdWJTdGF0ZTtcblxuICAgICAgc3RhdGUuc3RhY2sgPSB7XG4gICAgICAgIHBhcmVudDogc3RhdGUuc3RhY2ssXG4gICAgICAgIHN0eWxlOiBcInN1YlwiLFxuICAgICAgICBpbmRlbnRlZDogc3RhdGUuaW5kZW50ZWQgKyAxLFxuICAgICAgICB0b2tlbml6ZTogc3RhdGUubGluZVxuICAgICAgfTtcbiAgICAgIHN0YXRlLmxpbmUgPSBzdGF0ZS50b2tlbml6ZSA9IGZpcnN0U3ViO1xuICAgICAgcmV0dXJuIFwic2xpbVN1Ym1vZGVcIjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkb2N0eXBlTGluZShzdHJlYW0sIF9zdGF0ZSkge1xuICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgcmV0dXJuIFwic2xpbURvY3R5cGVcIjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGFydExpbmUoc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIGNoID0gc3RyZWFtLnBlZWsoKTtcbiAgICAgIGlmIChjaCA9PSAnPCcpIHtcbiAgICAgICAgcmV0dXJuIChzdGF0ZS50b2tlbml6ZSA9IHN0YXJ0SHRtbExpbmUoc3RhdGUudG9rZW5pemUpKShzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goL15bfCddLykpIHtcbiAgICAgICAgcmV0dXJuIHN0YXJ0SHRtbE1vZGUoc3RyZWFtLCBzdGF0ZSwgMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eXFwvKCF8XFxbXFx3K10pPy8pKSB7XG4gICAgICAgIHJldHVybiBjb21tZW50TW9kZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goL14oLXw9PT9bPD5dPykvKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IGxpbmVDb250aW51YWJsZShzdHJlYW0uY29sdW1uKCksIGNvbW1hQ29udGludWFibGUoc3RyZWFtLmNvbHVtbigpLCBydWJ5KSk7XG4gICAgICAgIHJldHVybiBcInNsaW1Td2l0Y2hcIjtcbiAgICAgIH1cbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goL15kb2N0eXBlXFxiLykpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSBkb2N0eXBlTGluZTtcbiAgICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgbSA9IHN0cmVhbS5tYXRjaChlbWJlZGRlZFJlZ2V4cCk7XG4gICAgICBpZiAobSkge1xuICAgICAgICByZXR1cm4gc3RhcnRTdWJNb2RlKG1bMV0sIHN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNsaW1UYWcoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2xpbShzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAoc3RhdGUuc3RhcnRPZkxpbmUpIHtcbiAgICAgICAgcmV0dXJuIHN0YXJ0TGluZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzbGltVGFnKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNsaW1UYWcoc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKHN0cmVhbS5lYXQoJyonKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHN0YXJ0UnVieVNwbGF0KHNsaW1UYWdFeHRyYXMpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChzdHJlYW0ubWF0Y2gobmFtZVJlZ2V4cCkpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSBzbGltVGFnRXh0cmFzO1xuICAgICAgICByZXR1cm4gXCJzbGltVGFnXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2xpbUNsYXNzKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzbGltVGFnRXh0cmFzKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goL14oPD4/fD48PykvKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHNsaW1DbGFzcztcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2xpbUNsYXNzKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzbGltQ2xhc3Moc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKHN0cmVhbS5tYXRjaChjbGFzc0lkUmVnZXhwKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHNsaW1DbGFzcztcbiAgICAgICAgcmV0dXJuIFwic2xpbUlkXCI7XG4gICAgICB9XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKGNsYXNzTmFtZVJlZ2V4cCkpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSBzbGltQ2xhc3M7XG4gICAgICAgIHJldHVybiBcInNsaW1DbGFzc1wiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNsaW1BdHRyaWJ1dGUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNsaW1BdHRyaWJ1dGUoc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXihbXFxbXFx7XFwoXSkvKSkge1xuICAgICAgICByZXR1cm4gc3RhcnRBdHRyaWJ1dGVXcmFwcGVyTW9kZShzdGF0ZSwgY2xvc2luZ1tSZWdFeHAuJDFdLCBzbGltQXR0cmlidXRlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goYXR0cmlidXRlTmFtZVJlZ2V4cCkpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSBzbGltQXR0cmlidXRlQXNzaWduO1xuICAgICAgICByZXR1cm4gXCJzbGltQXR0cmlidXRlXCI7XG4gICAgICB9XG4gICAgICBpZiAoc3RyZWFtLnBlZWsoKSA9PSAnKicpIHtcbiAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSBzdGFydFJ1YnlTcGxhdChzbGltQ29udGVudCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNsaW1Db250ZW50KHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzbGltQXR0cmlidXRlQXNzaWduKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goL149PT8vKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHNsaW1BdHRyaWJ1dGVWYWx1ZTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICAvLyBzaG91bGQgbmV2ZXIgaGFwcGVuLCBiZWNhdXNlIG9mIGZvcndhcmQgbG9va3VwXG4gICAgICByZXR1cm4gc2xpbUF0dHJpYnV0ZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzbGltQXR0cmlidXRlVmFsdWUoc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIGNoID0gc3RyZWFtLnBlZWsoKTtcbiAgICAgIGlmIChjaCA9PSAnXCInIHx8IGNoID09IFwiXFwnXCIpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSByZWFkUXVvdGVkKGNoLCBcInN0cmluZ1wiLCB0cnVlLCBmYWxzZSwgc2xpbUF0dHJpYnV0ZSk7XG4gICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaCA9PSAnWycpIHtcbiAgICAgICAgcmV0dXJuIHN0YXJ0UnVieVNwbGF0KHNsaW1BdHRyaWJ1dGUpKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgfVxuICAgICAgaWYgKGNoID09ICc6Jykge1xuICAgICAgICByZXR1cm4gc3RhcnRSdWJ5U3BsYXQoc2xpbUF0dHJpYnV0ZVN5bWJvbHMpKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgfVxuICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXih0cnVlfGZhbHNlfG5pbClcXGIvKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHNsaW1BdHRyaWJ1dGU7XG4gICAgICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGFydFJ1YnlTcGxhdChzbGltQXR0cmlidXRlKShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2xpbUF0dHJpYnV0ZVN5bWJvbHMoc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgc3RyZWFtLmJhY2tVcCgxKTtcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goL15bXlxcc10sKD89OikvKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHN0YXJ0UnVieVNwbGF0KHNsaW1BdHRyaWJ1dGVTeW1ib2xzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgcmV0dXJuIHNsaW1BdHRyaWJ1dGUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRRdW90ZWQocXVvdGUsIHN0eWxlLCBlbWJlZCwgdW5lc2NhcGVkLCBuZXh0VG9rZW5pemUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIGZpbmlzaENvbnRpbnVlKHN0YXRlKTtcbiAgICAgICAgdmFyIGZyZXNoID0gc3RyZWFtLmN1cnJlbnQoKS5sZW5ndGggPT0gMDtcbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXlxcXFwkLywgZnJlc2gpKSB7XG4gICAgICAgICAgaWYgKCFmcmVzaCkgcmV0dXJuIHN0eWxlO1xuICAgICAgICAgIGNvbnRpbnVlTGluZShzdGF0ZSwgc3RhdGUuaW5kZW50ZWQpO1xuICAgICAgICAgIHJldHVybiBcImxpbmVDb250aW51YXRpb25cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eI1xcey8sIGZyZXNoKSkge1xuICAgICAgICAgIGlmICghZnJlc2gpIHJldHVybiBzdHlsZTtcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHJ1YnlJblF1b3RlKFwifVwiLCBzdGF0ZS50b2tlbml6ZSk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVzY2FwZWQgPSBmYWxzZSwgY2g7XG4gICAgICAgIHdoaWxlICgoY2ggPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKGNoID09IHF1b3RlICYmICh1bmVzY2FwZWQgfHwgIWVzY2FwZWQpKSB7XG4gICAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IG5leHRUb2tlbml6ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZW1iZWQgJiYgY2ggPT0gXCIjXCIgJiYgIWVzY2FwZWQpIHtcbiAgICAgICAgICAgIGlmIChzdHJlYW0uZWF0KFwie1wiKSkge1xuICAgICAgICAgICAgICBzdHJlYW0uYmFja1VwKDIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkICYmIGNoID09IFwiXFxcXFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJlYW0uZW9sKCkgJiYgZXNjYXBlZCkge1xuICAgICAgICAgIHN0cmVhbS5iYWNrVXAoMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2xpbUNvbnRlbnQoc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXj09Py8pKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gcnVieTtcbiAgICAgICAgcmV0dXJuIFwic2xpbVN3aXRjaFwiO1xuICAgICAgfVxuICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXlxcLyQvKSkgeyAvLyB0YWcgY2xvc2UgaGludFxuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHNsaW07XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXjovKSkgeyAvLyBpbmxpbmUgdGFnXG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gc2xpbVRhZztcbiAgICAgICAgcmV0dXJuIFwic2xpbVN3aXRjaFwiO1xuICAgICAgfVxuICAgICAgc3RhcnRIdG1sTW9kZShzdHJlYW0sIHN0YXRlLCAwKTtcbiAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICB2YXIgbW9kZSA9IHtcbiAgICAgIC8vIGRlZmF1bHQgdG8gaHRtbCBtb2RlXG4gICAgICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWxTdGF0ZSA9IENvZGVNaXJyb3Iuc3RhcnRTdGF0ZShodG1sTW9kZSk7XG4gICAgICAgIHZhciBydWJ5U3RhdGUgPSBDb2RlTWlycm9yLnN0YXJ0U3RhdGUocnVieU1vZGUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGh0bWxTdGF0ZTogaHRtbFN0YXRlLFxuICAgICAgICAgIHJ1YnlTdGF0ZTogcnVieVN0YXRlLFxuICAgICAgICAgIHN0YWNrOiBudWxsLFxuICAgICAgICAgIGxhc3Q6IG51bGwsXG4gICAgICAgICAgdG9rZW5pemU6IHNsaW0sXG4gICAgICAgICAgbGluZTogc2xpbSxcbiAgICAgICAgICBpbmRlbnRlZDogMFxuICAgICAgICB9O1xuICAgICAgfSxcblxuICAgICAgY29weVN0YXRlOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGh0bWxTdGF0ZSA6IENvZGVNaXJyb3IuY29weVN0YXRlKGh0bWxNb2RlLCBzdGF0ZS5odG1sU3RhdGUpLFxuICAgICAgICAgIHJ1YnlTdGF0ZTogQ29kZU1pcnJvci5jb3B5U3RhdGUocnVieU1vZGUsIHN0YXRlLnJ1YnlTdGF0ZSksXG4gICAgICAgICAgc3ViTW9kZTogc3RhdGUuc3ViTW9kZSxcbiAgICAgICAgICBzdWJTdGF0ZTogc3RhdGUuc3ViTW9kZSAmJiBDb2RlTWlycm9yLmNvcHlTdGF0ZShzdGF0ZS5zdWJNb2RlLCBzdGF0ZS5zdWJTdGF0ZSksXG4gICAgICAgICAgc3RhY2s6IHN0YXRlLnN0YWNrLFxuICAgICAgICAgIGxhc3Q6IHN0YXRlLmxhc3QsXG4gICAgICAgICAgdG9rZW5pemU6IHN0YXRlLnRva2VuaXplLFxuICAgICAgICAgIGxpbmU6IHN0YXRlLmxpbmVcbiAgICAgICAgfTtcbiAgICAgIH0sXG5cbiAgICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIGlmIChzdHJlYW0uc29sKCkpIHtcbiAgICAgICAgICBzdGF0ZS5pbmRlbnRlZCA9IHN0cmVhbS5pbmRlbnRhdGlvbigpO1xuICAgICAgICAgIHN0YXRlLnN0YXJ0T2ZMaW5lID0gdHJ1ZTtcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHN0YXRlLmxpbmU7XG4gICAgICAgICAgd2hpbGUgKHN0YXRlLnN0YWNrICYmIHN0YXRlLnN0YWNrLmluZGVudGVkID4gc3RhdGUuaW5kZW50ZWQgJiYgc3RhdGUubGFzdCAhPSBcInNsaW1TdWJtb2RlXCIpIHtcbiAgICAgICAgICAgIHN0YXRlLmxpbmUgPSBzdGF0ZS50b2tlbml6ZSA9IHN0YXRlLnN0YWNrLnRva2VuaXplO1xuICAgICAgICAgICAgc3RhdGUuc3RhY2sgPSBzdGF0ZS5zdGFjay5wYXJlbnQ7XG4gICAgICAgICAgICBzdGF0ZS5zdWJNb2RlID0gbnVsbDtcbiAgICAgICAgICAgIHN0YXRlLnN1YlN0YXRlID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIHN0eWxlID0gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIHN0YXRlLnN0YXJ0T2ZMaW5lID0gZmFsc2U7XG4gICAgICAgIGlmIChzdHlsZSkgc3RhdGUubGFzdCA9IHN0eWxlO1xuICAgICAgICByZXR1cm4gc3R5bGVNYXAuaGFzT3duUHJvcGVydHkoc3R5bGUpID8gc3R5bGVNYXBbc3R5bGVdIDogc3R5bGU7XG4gICAgICB9LFxuXG4gICAgICBibGFua0xpbmU6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgIGlmIChzdGF0ZS5zdWJNb2RlICYmIHN0YXRlLnN1Yk1vZGUuYmxhbmtMaW5lKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlLnN1Yk1vZGUuYmxhbmtMaW5lKHN0YXRlLnN1YlN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgaW5uZXJNb2RlOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUuc3ViTW9kZSkgcmV0dXJuIHtzdGF0ZTogc3RhdGUuc3ViU3RhdGUsIG1vZGU6IHN0YXRlLnN1Yk1vZGV9O1xuICAgICAgICByZXR1cm4ge3N0YXRlOiBzdGF0ZSwgbW9kZTogbW9kZX07XG4gICAgICB9XG5cbiAgICAgIC8vaW5kZW50OiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgLy8gIHJldHVybiBzdGF0ZS5pbmRlbnRlZDtcbiAgICAgIC8vfVxuICAgIH07XG4gICAgcmV0dXJuIG1vZGU7XG4gIH0sIFwiaHRtbG1peGVkXCIsIFwicnVieVwiKTtcblxuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3gtc2xpbVwiLCBcInNsaW1cIik7XG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcImFwcGxpY2F0aW9uL3gtc2xpbVwiLCBcInNsaW1cIik7XG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuQ29kZU1pcnJvci5kZWZpbmVNb2RlKCdzbWFsbHRhbGsnLCBmdW5jdGlvbihjb25maWcpIHtcblxuICB2YXIgc3BlY2lhbENoYXJzID0gL1srXFwtXFwvXFxcXCp+PD49QCV8Jj8hLiw6O15dLztcbiAgdmFyIGtleXdvcmRzID0gL3RydWV8ZmFsc2V8bmlsfHNlbGZ8c3VwZXJ8dGhpc0NvbnRleHQvO1xuXG4gIHZhciBDb250ZXh0ID0gZnVuY3Rpb24odG9rZW5pemVyLCBwYXJlbnQpIHtcbiAgICB0aGlzLm5leHQgPSB0b2tlbml6ZXI7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIH07XG5cbiAgdmFyIFRva2VuID0gZnVuY3Rpb24obmFtZSwgY29udGV4dCwgZW9zKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuZW9zID0gZW9zO1xuICB9O1xuXG4gIHZhciBTdGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY29udGV4dCA9IG5ldyBDb250ZXh0KG5leHQsIG51bGwpO1xuICAgIHRoaXMuZXhwZWN0VmFyaWFibGUgPSB0cnVlO1xuICAgIHRoaXMuaW5kZW50YXRpb24gPSAwO1xuICAgIHRoaXMudXNlckluZGVudGF0aW9uRGVsdGEgPSAwO1xuICB9O1xuXG4gIFN0YXRlLnByb3RvdHlwZS51c2VySW5kZW50ID0gZnVuY3Rpb24oaW5kZW50YXRpb24pIHtcbiAgICB0aGlzLnVzZXJJbmRlbnRhdGlvbkRlbHRhID0gaW5kZW50YXRpb24gPiAwID8gKGluZGVudGF0aW9uIC8gY29uZmlnLmluZGVudFVuaXQgLSB0aGlzLmluZGVudGF0aW9uKSA6IDA7XG4gIH07XG5cbiAgdmFyIG5leHQgPSBmdW5jdGlvbihzdHJlYW0sIGNvbnRleHQsIHN0YXRlKSB7XG4gICAgdmFyIHRva2VuID0gbmV3IFRva2VuKG51bGwsIGNvbnRleHQsIGZhbHNlKTtcbiAgICB2YXIgYUNoYXIgPSBzdHJlYW0ubmV4dCgpO1xuXG4gICAgaWYgKGFDaGFyID09PSAnXCInKSB7XG4gICAgICB0b2tlbiA9IG5leHRDb21tZW50KHN0cmVhbSwgbmV3IENvbnRleHQobmV4dENvbW1lbnQsIGNvbnRleHQpKTtcblxuICAgIH0gZWxzZSBpZiAoYUNoYXIgPT09ICdcXCcnKSB7XG4gICAgICB0b2tlbiA9IG5leHRTdHJpbmcoc3RyZWFtLCBuZXcgQ29udGV4dChuZXh0U3RyaW5nLCBjb250ZXh0KSk7XG5cbiAgICB9IGVsc2UgaWYgKGFDaGFyID09PSAnIycpIHtcbiAgICAgIGlmIChzdHJlYW0ucGVlaygpID09PSAnXFwnJykge1xuICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICB0b2tlbiA9IG5leHRTeW1ib2woc3RyZWFtLCBuZXcgQ29udGV4dChuZXh0U3ltYm9sLCBjb250ZXh0KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc3RyZWFtLmVhdFdoaWxlKC9bXlxccy57fVxcW1xcXSgpXS8pKVxuICAgICAgICAgIHRva2VuLm5hbWUgPSAnc3RyaW5nLTInO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdG9rZW4ubmFtZSA9ICdtZXRhJztcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAoYUNoYXIgPT09ICckJykge1xuICAgICAgaWYgKHN0cmVhbS5uZXh0KCkgPT09ICc8Jykge1xuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1teXFxzPl0vKTtcbiAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIH1cbiAgICAgIHRva2VuLm5hbWUgPSAnc3RyaW5nLTInO1xuXG4gICAgfSBlbHNlIGlmIChhQ2hhciA9PT0gJ3wnICYmIHN0YXRlLmV4cGVjdFZhcmlhYmxlKSB7XG4gICAgICB0b2tlbi5jb250ZXh0ID0gbmV3IENvbnRleHQobmV4dFRlbXBvcmFyaWVzLCBjb250ZXh0KTtcblxuICAgIH0gZWxzZSBpZiAoL1tcXFtcXF17fSgpXS8udGVzdChhQ2hhcikpIHtcbiAgICAgIHRva2VuLm5hbWUgPSAnYnJhY2tldCc7XG4gICAgICB0b2tlbi5lb3MgPSAvW1xcW3soXS8udGVzdChhQ2hhcik7XG5cbiAgICAgIGlmIChhQ2hhciA9PT0gJ1snKSB7XG4gICAgICAgIHN0YXRlLmluZGVudGF0aW9uKys7XG4gICAgICB9IGVsc2UgaWYgKGFDaGFyID09PSAnXScpIHtcbiAgICAgICAgc3RhdGUuaW5kZW50YXRpb24gPSBNYXRoLm1heCgwLCBzdGF0ZS5pbmRlbnRhdGlvbiAtIDEpO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChzcGVjaWFsQ2hhcnMudGVzdChhQ2hhcikpIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZShzcGVjaWFsQ2hhcnMpO1xuICAgICAgdG9rZW4ubmFtZSA9ICdvcGVyYXRvcic7XG4gICAgICB0b2tlbi5lb3MgPSBhQ2hhciAhPT0gJzsnOyAvLyA7IGNhc2NhZGVkIG1lc3NhZ2UgZXhwcmVzc2lvblxuXG4gICAgfSBlbHNlIGlmICgvXFxkLy50ZXN0KGFDaGFyKSkge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFxkXS8pO1xuICAgICAgdG9rZW4ubmFtZSA9ICdudW1iZXInO1xuXG4gICAgfSBlbHNlIGlmICgvW1xcd19dLy50ZXN0KGFDaGFyKSkge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFxkX10vKTtcbiAgICAgIHRva2VuLm5hbWUgPSBzdGF0ZS5leHBlY3RWYXJpYWJsZSA/IChrZXl3b3Jkcy50ZXN0KHN0cmVhbS5jdXJyZW50KCkpID8gJ2tleXdvcmQnIDogJ3ZhcmlhYmxlJykgOiBudWxsO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRva2VuLmVvcyA9IHN0YXRlLmV4cGVjdFZhcmlhYmxlO1xuICAgIH1cblxuICAgIHJldHVybiB0b2tlbjtcbiAgfTtcblxuICB2YXIgbmV4dENvbW1lbnQgPSBmdW5jdGlvbihzdHJlYW0sIGNvbnRleHQpIHtcbiAgICBzdHJlYW0uZWF0V2hpbGUoL1teXCJdLyk7XG4gICAgcmV0dXJuIG5ldyBUb2tlbignY29tbWVudCcsIHN0cmVhbS5lYXQoJ1wiJykgPyBjb250ZXh0LnBhcmVudCA6IGNvbnRleHQsIHRydWUpO1xuICB9O1xuXG4gIHZhciBuZXh0U3RyaW5nID0gZnVuY3Rpb24oc3RyZWFtLCBjb250ZXh0KSB7XG4gICAgc3RyZWFtLmVhdFdoaWxlKC9bXiddLyk7XG4gICAgcmV0dXJuIG5ldyBUb2tlbignc3RyaW5nJywgc3RyZWFtLmVhdCgnXFwnJykgPyBjb250ZXh0LnBhcmVudCA6IGNvbnRleHQsIGZhbHNlKTtcbiAgfTtcblxuICB2YXIgbmV4dFN5bWJvbCA9IGZ1bmN0aW9uKHN0cmVhbSwgY29udGV4dCkge1xuICAgIHN0cmVhbS5lYXRXaGlsZSgvW14nXS8pO1xuICAgIHJldHVybiBuZXcgVG9rZW4oJ3N0cmluZy0yJywgc3RyZWFtLmVhdCgnXFwnJykgPyBjb250ZXh0LnBhcmVudCA6IGNvbnRleHQsIGZhbHNlKTtcbiAgfTtcblxuICB2YXIgbmV4dFRlbXBvcmFyaWVzID0gZnVuY3Rpb24oc3RyZWFtLCBjb250ZXh0KSB7XG4gICAgdmFyIHRva2VuID0gbmV3IFRva2VuKG51bGwsIGNvbnRleHQsIGZhbHNlKTtcbiAgICB2YXIgYUNoYXIgPSBzdHJlYW0ubmV4dCgpO1xuXG4gICAgaWYgKGFDaGFyID09PSAnfCcpIHtcbiAgICAgIHRva2VuLmNvbnRleHQgPSBjb250ZXh0LnBhcmVudDtcbiAgICAgIHRva2VuLmVvcyA9IHRydWU7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXnxdLyk7XG4gICAgICB0b2tlbi5uYW1lID0gJ3ZhcmlhYmxlJztcbiAgICB9XG5cbiAgICByZXR1cm4gdG9rZW47XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgU3RhdGU7XG4gICAgfSxcblxuICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBzdGF0ZS51c2VySW5kZW50KHN0cmVhbS5pbmRlbnRhdGlvbigpKTtcblxuICAgICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG9rZW4gPSBzdGF0ZS5jb250ZXh0Lm5leHQoc3RyZWFtLCBzdGF0ZS5jb250ZXh0LCBzdGF0ZSk7XG4gICAgICBzdGF0ZS5jb250ZXh0ID0gdG9rZW4uY29udGV4dDtcbiAgICAgIHN0YXRlLmV4cGVjdFZhcmlhYmxlID0gdG9rZW4uZW9zO1xuXG4gICAgICByZXR1cm4gdG9rZW4ubmFtZTtcbiAgICB9LFxuXG4gICAgYmxhbmtMaW5lOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgc3RhdGUudXNlckluZGVudCgwKTtcbiAgICB9LFxuXG4gICAgaW5kZW50OiBmdW5jdGlvbihzdGF0ZSwgdGV4dEFmdGVyKSB7XG4gICAgICB2YXIgaSA9IHN0YXRlLmNvbnRleHQubmV4dCA9PT0gbmV4dCAmJiB0ZXh0QWZ0ZXIgJiYgdGV4dEFmdGVyLmNoYXJBdCgwKSA9PT0gJ10nID8gLTEgOiBzdGF0ZS51c2VySW5kZW50YXRpb25EZWx0YTtcbiAgICAgIHJldHVybiAoc3RhdGUuaW5kZW50YXRpb24gKyBpKSAqIGNvbmZpZy5pbmRlbnRVbml0O1xuICAgIH0sXG5cbiAgICBlbGVjdHJpY0NoYXJzOiAnXSdcbiAgfTtcblxufSk7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTUlNRSgndGV4dC94LXN0c3JjJywge25hbWU6ICdzbWFsbHRhbGsnfSk7XG5cbn0pO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuLyoqXG4gKiBTbWFydHkgMiBhbmQgMyBtb2RlLlxuICovXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lTW9kZShcInNtYXJ0eVwiLCBmdW5jdGlvbihjb25maWcsIHBhcnNlckNvbmYpIHtcbiAgICB2YXIgcmlnaHREZWxpbWl0ZXIgPSBwYXJzZXJDb25mLnJpZ2h0RGVsaW1pdGVyIHx8IFwifVwiO1xuICAgIHZhciBsZWZ0RGVsaW1pdGVyID0gcGFyc2VyQ29uZi5sZWZ0RGVsaW1pdGVyIHx8IFwie1wiO1xuICAgIHZhciB2ZXJzaW9uID0gcGFyc2VyQ29uZi52ZXJzaW9uIHx8IDI7XG4gICAgdmFyIGJhc2VNb2RlID0gQ29kZU1pcnJvci5nZXRNb2RlKGNvbmZpZywgcGFyc2VyQ29uZi5iYXNlTW9kZSB8fCBcIm51bGxcIik7XG5cbiAgICB2YXIga2V5RnVuY3Rpb25zID0gW1wiZGVidWdcIiwgXCJleHRlbmRzXCIsIFwiZnVuY3Rpb25cIiwgXCJpbmNsdWRlXCIsIFwibGl0ZXJhbFwiXTtcbiAgICB2YXIgcmVncyA9IHtcbiAgICAgIG9wZXJhdG9yQ2hhcnM6IC9bK1xcLSomJT08PiE/XS8sXG4gICAgICB2YWxpZElkZW50aWZpZXI6IC9bYS16QS1aMC05X10vLFxuICAgICAgc3RyaW5nQ2hhcjogL1snXCJdL1xuICAgIH07XG5cbiAgICB2YXIgbGFzdDtcbiAgICBmdW5jdGlvbiBjb250KHN0eWxlLCBsYXN0VHlwZSkge1xuICAgICAgbGFzdCA9IGxhc3RUeXBlO1xuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoYWluKHN0cmVhbSwgc3RhdGUsIHBhcnNlcikge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSBwYXJzZXI7XG4gICAgICByZXR1cm4gcGFyc2VyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIC8vIFNtYXJ0eSAzIGFsbG93cyB7IGFuZCB9IHN1cnJvdW5kZWQgYnkgd2hpdGVzcGFjZSB0byBOT1Qgc2xpcCBpbnRvIFNtYXJ0eSBtb2RlXG4gICAgZnVuY3Rpb24gZG9lc05vdENvdW50KHN0cmVhbSwgcG9zKSB7XG4gICAgICBpZiAocG9zID09IG51bGwpIHBvcyA9IHN0cmVhbS5wb3M7XG4gICAgICByZXR1cm4gdmVyc2lvbiA9PT0gMyAmJiBsZWZ0RGVsaW1pdGVyID09IFwie1wiICYmXG4gICAgICAgIChwb3MgPT0gc3RyZWFtLnN0cmluZy5sZW5ndGggfHwgL1xccy8udGVzdChzdHJlYW0uc3RyaW5nLmNoYXJBdChwb3MpKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9rZW5Ub3Aoc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIHN0cmluZyA9IHN0cmVhbS5zdHJpbmc7XG4gICAgICBmb3IgKHZhciBzY2FuID0gc3RyZWFtLnBvczs7KSB7XG4gICAgICAgIHZhciBuZXh0TWF0Y2ggPSBzdHJpbmcuaW5kZXhPZihsZWZ0RGVsaW1pdGVyLCBzY2FuKTtcbiAgICAgICAgc2NhbiA9IG5leHRNYXRjaCArIGxlZnREZWxpbWl0ZXIubGVuZ3RoO1xuICAgICAgICBpZiAobmV4dE1hdGNoID09IC0xIHx8ICFkb2VzTm90Q291bnQoc3RyZWFtLCBuZXh0TWF0Y2ggKyBsZWZ0RGVsaW1pdGVyLmxlbmd0aCkpIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKG5leHRNYXRjaCA9PSBzdHJlYW0ucG9zKSB7XG4gICAgICAgIHN0cmVhbS5tYXRjaChsZWZ0RGVsaW1pdGVyKTtcbiAgICAgICAgaWYgKHN0cmVhbS5lYXQoXCIqXCIpKSB7XG4gICAgICAgICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIHRva2VuQmxvY2soXCJjb21tZW50XCIsIFwiKlwiICsgcmlnaHREZWxpbWl0ZXIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS5kZXB0aCsrO1xuICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5TbWFydHk7XG4gICAgICAgICAgbGFzdCA9IFwic3RhcnRUYWdcIjtcbiAgICAgICAgICByZXR1cm4gXCJ0YWdcIjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobmV4dE1hdGNoID4gLTEpIHN0cmVhbS5zdHJpbmcgPSBzdHJpbmcuc2xpY2UoMCwgbmV4dE1hdGNoKTtcbiAgICAgIHZhciB0b2tlbiA9IGJhc2VNb2RlLnRva2VuKHN0cmVhbSwgc3RhdGUuYmFzZSk7XG4gICAgICBpZiAobmV4dE1hdGNoID4gLTEpIHN0cmVhbS5zdHJpbmcgPSBzdHJpbmc7XG4gICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuXG4gICAgLy8gcGFyc2luZyBTbWFydHkgY29udGVudFxuICAgIGZ1bmN0aW9uIHRva2VuU21hcnR5KHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2gocmlnaHREZWxpbWl0ZXIsIHRydWUpKSB7XG4gICAgICAgIGlmICh2ZXJzaW9uID09PSAzKSB7XG4gICAgICAgICAgc3RhdGUuZGVwdGgtLTtcbiAgICAgICAgICBpZiAoc3RhdGUuZGVwdGggPD0gMCkge1xuICAgICAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlblRvcDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlblRvcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udChcInRhZ1wiLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0cmVhbS5tYXRjaChsZWZ0RGVsaW1pdGVyLCB0cnVlKSkge1xuICAgICAgICBzdGF0ZS5kZXB0aCsrO1xuICAgICAgICByZXR1cm4gY29udChcInRhZ1wiLCBcInN0YXJ0VGFnXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICAgICAgaWYgKGNoID09IFwiJFwiKSB7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZShyZWdzLnZhbGlkSWRlbnRpZmllcik7XG4gICAgICAgIHJldHVybiBjb250KFwidmFyaWFibGUtMlwiLCBcInZhcmlhYmxlXCIpO1xuICAgICAgfSBlbHNlIGlmIChjaCA9PSBcInxcIikge1xuICAgICAgICByZXR1cm4gY29udChcIm9wZXJhdG9yXCIsIFwicGlwZVwiKTtcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCIuXCIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnQoXCJvcGVyYXRvclwiLCBcInByb3BlcnR5XCIpO1xuICAgICAgfSBlbHNlIGlmIChyZWdzLnN0cmluZ0NoYXIudGVzdChjaCkpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkF0dHJpYnV0ZShjaCk7XG4gICAgICAgIHJldHVybiBjb250KFwic3RyaW5nXCIsIFwic3RyaW5nXCIpO1xuICAgICAgfSBlbHNlIGlmIChyZWdzLm9wZXJhdG9yQ2hhcnMudGVzdChjaCkpIHtcbiAgICAgICAgc3RyZWFtLmVhdFdoaWxlKHJlZ3Mub3BlcmF0b3JDaGFycyk7XG4gICAgICAgIHJldHVybiBjb250KFwib3BlcmF0b3JcIiwgXCJvcGVyYXRvclwiKTtcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCJbXCIgfHwgY2ggPT0gXCJdXCIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnQoXCJicmFja2V0XCIsIFwiYnJhY2tldFwiKTtcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCIoXCIgfHwgY2ggPT0gXCIpXCIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnQoXCJicmFja2V0XCIsIFwib3BlcmF0b3JcIik7XG4gICAgICB9IGVsc2UgaWYgKC9cXGQvLnRlc3QoY2gpKSB7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvXFxkLyk7XG4gICAgICAgIHJldHVybiBjb250KFwibnVtYmVyXCIsIFwibnVtYmVyXCIpO1xuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBpZiAoc3RhdGUubGFzdCA9PSBcInZhcmlhYmxlXCIpIHtcbiAgICAgICAgICBpZiAoY2ggPT0gXCJAXCIpIHtcbiAgICAgICAgICAgIHN0cmVhbS5lYXRXaGlsZShyZWdzLnZhbGlkSWRlbnRpZmllcik7XG4gICAgICAgICAgICByZXR1cm4gY29udChcInByb3BlcnR5XCIsIFwicHJvcGVydHlcIik7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaCA9PSBcInxcIikge1xuICAgICAgICAgICAgc3RyZWFtLmVhdFdoaWxlKHJlZ3MudmFsaWRJZGVudGlmaWVyKTtcbiAgICAgICAgICAgIHJldHVybiBjb250KFwicXVhbGlmaWVyXCIsIFwibW9kaWZpZXJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLmxhc3QgPT0gXCJwaXBlXCIpIHtcbiAgICAgICAgICBzdHJlYW0uZWF0V2hpbGUocmVncy52YWxpZElkZW50aWZpZXIpO1xuICAgICAgICAgIHJldHVybiBjb250KFwicXVhbGlmaWVyXCIsIFwibW9kaWZpZXJcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGFzdCA9PSBcIndoaXRlc3BhY2VcIikge1xuICAgICAgICAgIHN0cmVhbS5lYXRXaGlsZShyZWdzLnZhbGlkSWRlbnRpZmllcik7XG4gICAgICAgICAgcmV0dXJuIGNvbnQoXCJhdHRyaWJ1dGVcIiwgXCJtb2RpZmllclwiKTtcbiAgICAgICAgfSBpZiAoc3RhdGUubGFzdCA9PSBcInByb3BlcnR5XCIpIHtcbiAgICAgICAgICBzdHJlYW0uZWF0V2hpbGUocmVncy52YWxpZElkZW50aWZpZXIpO1xuICAgICAgICAgIHJldHVybiBjb250KFwicHJvcGVydHlcIiwgbnVsbCk7XG4gICAgICAgIH0gZWxzZSBpZiAoL1xccy8udGVzdChjaCkpIHtcbiAgICAgICAgICBsYXN0ID0gXCJ3aGl0ZXNwYWNlXCI7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RyID0gXCJcIjtcbiAgICAgICAgaWYgKGNoICE9IFwiL1wiKSB7XG4gICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjID0gbnVsbDtcbiAgICAgICAgd2hpbGUgKGMgPSBzdHJlYW0uZWF0KHJlZ3MudmFsaWRJZGVudGlmaWVyKSkge1xuICAgICAgICAgIHN0ciArPSBjO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGk9MCwgaj1rZXlGdW5jdGlvbnMubGVuZ3RoOyBpPGo7IGkrKykge1xuICAgICAgICAgIGlmIChrZXlGdW5jdGlvbnNbaV0gPT0gc3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udChcImtleXdvcmRcIiwgXCJrZXl3b3JkXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoL1xccy8udGVzdChjaCkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udChcInRhZ1wiLCBcInRhZ1wiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b2tlbkF0dHJpYnV0ZShxdW90ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgdmFyIHByZXZDaGFyID0gbnVsbDtcbiAgICAgICAgdmFyIGN1cnJDaGFyID0gbnVsbDtcbiAgICAgICAgd2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcbiAgICAgICAgICBjdXJyQ2hhciA9IHN0cmVhbS5wZWVrKCk7XG4gICAgICAgICAgaWYgKHN0cmVhbS5uZXh0KCkgPT0gcXVvdGUgJiYgcHJldkNoYXIgIT09ICdcXFxcJykge1xuICAgICAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlblNtYXJ0eTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcmV2Q2hhciA9IGN1cnJDaGFyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b2tlbkJsb2NrKHN0eWxlLCB0ZXJtaW5hdG9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuICAgICAgICAgIGlmIChzdHJlYW0ubWF0Y2godGVybWluYXRvcikpIHtcbiAgICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5Ub3A7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBiYXNlOiBDb2RlTWlycm9yLnN0YXJ0U3RhdGUoYmFzZU1vZGUpLFxuICAgICAgICAgIHRva2VuaXplOiB0b2tlblRvcCxcbiAgICAgICAgICBsYXN0OiBudWxsLFxuICAgICAgICAgIGRlcHRoOiAwXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgY29weVN0YXRlOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGJhc2U6IENvZGVNaXJyb3IuY29weVN0YXRlKGJhc2VNb2RlLCBzdGF0ZS5iYXNlKSxcbiAgICAgICAgICB0b2tlbml6ZTogc3RhdGUudG9rZW5pemUsXG4gICAgICAgICAgbGFzdDogc3RhdGUubGFzdCxcbiAgICAgICAgICBkZXB0aDogc3RhdGUuZGVwdGhcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBpbm5lck1vZGU6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgIGlmIChzdGF0ZS50b2tlbml6ZSA9PSB0b2tlblRvcClcbiAgICAgICAgICByZXR1cm4ge21vZGU6IGJhc2VNb2RlLCBzdGF0ZTogc3RhdGUuYmFzZX07XG4gICAgICB9LFxuICAgICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIHN0YXRlLmxhc3QgPSBsYXN0O1xuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICB9LFxuICAgICAgaW5kZW50OiBmdW5jdGlvbihzdGF0ZSwgdGV4dCwgbGluZSkge1xuICAgICAgICBpZiAoc3RhdGUudG9rZW5pemUgPT0gdG9rZW5Ub3AgJiYgYmFzZU1vZGUuaW5kZW50KVxuICAgICAgICAgIHJldHVybiBiYXNlTW9kZS5pbmRlbnQoc3RhdGUuYmFzZSwgdGV4dCwgbGluZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXR1cm4gQ29kZU1pcnJvci5QYXNzO1xuICAgICAgfSxcbiAgICAgIGJsb2NrQ29tbWVudFN0YXJ0OiBsZWZ0RGVsaW1pdGVyICsgXCIqXCIsXG4gICAgICBibG9ja0NvbW1lbnRFbmQ6IFwiKlwiICsgcmlnaHREZWxpbWl0ZXJcbiAgICB9O1xuICB9KTtcblxuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3gtc21hcnR5XCIsIFwic21hcnR5XCIpO1xufSk7XG4iLCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTW9kZShcInNvbHJcIiwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBpc1N0cmluZ0NoYXIgPSAvW15cXHNcXHxcXCFcXCtcXC1cXCpcXD9cXH5cXF5cXCZcXDpcXChcXClcXFtcXF1cXHtcXH1cXFwiXFxcXF0vO1xuICB2YXIgaXNPcGVyYXRvckNoYXIgPSAvW1xcfFxcIVxcK1xcLVxcKlxcP1xcflxcXlxcJl0vO1xuICB2YXIgaXNPcGVyYXRvclN0cmluZyA9IC9eKE9SfEFORHxOT1R8VE8pJC9pO1xuXG4gIGZ1bmN0aW9uIGlzTnVtYmVyKHdvcmQpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh3b3JkKS50b1N0cmluZygpID09PSB3b3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5TdHJpbmcocXVvdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIGVzY2FwZWQgPSBmYWxzZSwgbmV4dDtcbiAgICAgIHdoaWxlICgobmV4dCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgICAgaWYgKG5leHQgPT0gcXVvdGUgJiYgIWVzY2FwZWQpIGJyZWFrO1xuICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQgJiYgbmV4dCA9PSBcIlxcXFxcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFlc2NhcGVkKSBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlbk9wZXJhdG9yKG9wZXJhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBzdHlsZSA9IFwib3BlcmF0b3JcIjtcbiAgICAgIGlmIChvcGVyYXRvciA9PSBcIitcIilcbiAgICAgICAgc3R5bGUgKz0gXCIgcG9zaXRpdmVcIjtcbiAgICAgIGVsc2UgaWYgKG9wZXJhdG9yID09IFwiLVwiKVxuICAgICAgICBzdHlsZSArPSBcIiBuZWdhdGl2ZVwiO1xuICAgICAgZWxzZSBpZiAob3BlcmF0b3IgPT0gXCJ8XCIpXG4gICAgICAgIHN0cmVhbS5lYXQoL1xcfC8pO1xuICAgICAgZWxzZSBpZiAob3BlcmF0b3IgPT0gXCImXCIpXG4gICAgICAgIHN0cmVhbS5lYXQoL1xcJi8pO1xuICAgICAgZWxzZSBpZiAob3BlcmF0b3IgPT0gXCJeXCIpXG4gICAgICAgIHN0eWxlICs9IFwiIGJvb3N0XCI7XG5cbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlbldvcmQoY2gpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIHdvcmQgPSBjaDtcbiAgICAgIHdoaWxlICgoY2ggPSBzdHJlYW0ucGVlaygpKSAmJiBjaC5tYXRjaChpc1N0cmluZ0NoYXIpICE9IG51bGwpIHtcbiAgICAgICAgd29yZCArPSBzdHJlYW0ubmV4dCgpO1xuICAgICAgfVxuXG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgIGlmIChpc09wZXJhdG9yU3RyaW5nLnRlc3Qod29yZCkpXG4gICAgICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gICAgICBlbHNlIGlmIChpc051bWJlcih3b3JkKSlcbiAgICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgICBlbHNlIGlmIChzdHJlYW0ucGVlaygpID09IFwiOlwiKVxuICAgICAgICByZXR1cm4gXCJmaWVsZFwiO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICAgIGlmIChjaCA9PSAnXCInKVxuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlblN0cmluZyhjaCk7XG4gICAgZWxzZSBpZiAoaXNPcGVyYXRvckNoYXIudGVzdChjaCkpXG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuT3BlcmF0b3IoY2gpO1xuICAgIGVsc2UgaWYgKGlzU3RyaW5nQ2hhci50ZXN0KGNoKSlcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5Xb3JkKGNoKTtcblxuICAgIHJldHVybiAoc3RhdGUudG9rZW5pemUgIT0gdG9rZW5CYXNlKSA/IHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpIDogbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b2tlbml6ZTogdG9rZW5CYXNlXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSByZXR1cm4gbnVsbDtcbiAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH07XG59KTtcblxuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LXNvbHJcIiwgXCJzb2xyXCIpO1xuXG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIiksIHJlcXVpcmUoXCIuLi9odG1sbWl4ZWQvaHRtbG1peGVkXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIsIFwiLi4vaHRtbG1peGVkL2h0bWxtaXhlZFwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIHBhcmFtRGF0YSA9IHsgbm9FbmRUYWc6IHRydWUsIHNveVN0YXRlOiBcInBhcmFtLWRlZlwiIH07XG4gIHZhciB0YWdzID0ge1xuICAgIFwiYWxpYXNcIjogeyBub0VuZFRhZzogdHJ1ZSB9LFxuICAgIFwiZGVscGFja2FnZVwiOiB7IG5vRW5kVGFnOiB0cnVlIH0sXG4gICAgXCJuYW1lc3BhY2VcIjogeyBub0VuZFRhZzogdHJ1ZSwgc295U3RhdGU6IFwibmFtZXNwYWNlLWRlZlwiIH0sXG4gICAgXCJAYXR0cmlidXRlXCI6IHBhcmFtRGF0YSxcbiAgICBcIkBhdHRyaWJ1dGU/XCI6IHBhcmFtRGF0YSxcbiAgICBcIkBwYXJhbVwiOiBwYXJhbURhdGEsXG4gICAgXCJAcGFyYW0/XCI6IHBhcmFtRGF0YSxcbiAgICBcIkBpbmplY3RcIjogcGFyYW1EYXRhLFxuICAgIFwiQGluamVjdD9cIjogcGFyYW1EYXRhLFxuICAgIFwiQHN0YXRlXCI6IHBhcmFtRGF0YSxcbiAgICBcInRlbXBsYXRlXCI6IHsgc295U3RhdGU6IFwidGVtcGwtZGVmXCIsIHZhcmlhYmxlU2NvcGU6IHRydWV9LFxuICAgIFwibGl0ZXJhbFwiOiB7IH0sXG4gICAgXCJtc2dcIjoge30sXG4gICAgXCJmYWxsYmFja21zZ1wiOiB7IG5vRW5kVGFnOiB0cnVlLCByZWR1Y2VJbmRlbnQ6IHRydWV9LFxuICAgIFwic2VsZWN0XCI6IHt9LFxuICAgIFwicGx1cmFsXCI6IHt9LFxuICAgIFwibGV0XCI6IHsgc295U3RhdGU6IFwidmFyLWRlZlwiIH0sXG4gICAgXCJpZlwiOiB7fSxcbiAgICBcImVsc2VpZlwiOiB7IG5vRW5kVGFnOiB0cnVlLCByZWR1Y2VJbmRlbnQ6IHRydWV9LFxuICAgIFwiZWxzZVwiOiB7IG5vRW5kVGFnOiB0cnVlLCByZWR1Y2VJbmRlbnQ6IHRydWV9LFxuICAgIFwic3dpdGNoXCI6IHt9LFxuICAgIFwiY2FzZVwiOiB7IG5vRW5kVGFnOiB0cnVlLCByZWR1Y2VJbmRlbnQ6IHRydWV9LFxuICAgIFwiZGVmYXVsdFwiOiB7IG5vRW5kVGFnOiB0cnVlLCByZWR1Y2VJbmRlbnQ6IHRydWV9LFxuICAgIFwiZm9yZWFjaFwiOiB7IHZhcmlhYmxlU2NvcGU6IHRydWUsIHNveVN0YXRlOiBcImZvci1sb29wXCIgfSxcbiAgICBcImlmZW1wdHlcIjogeyBub0VuZFRhZzogdHJ1ZSwgcmVkdWNlSW5kZW50OiB0cnVlfSxcbiAgICBcImZvclwiOiB7IHZhcmlhYmxlU2NvcGU6IHRydWUsIHNveVN0YXRlOiBcImZvci1sb29wXCIgfSxcbiAgICBcImNhbGxcIjogeyBzb3lTdGF0ZTogXCJ0ZW1wbC1yZWZcIiB9LFxuICAgIFwicGFyYW1cIjogeyBzb3lTdGF0ZTogXCJwYXJhbS1yZWZcIn0sXG4gICAgXCJwcmludFwiOiB7IG5vRW5kVGFnOiB0cnVlIH0sXG4gICAgXCJkZWx0ZW1wbGF0ZVwiOiB7IHNveVN0YXRlOiBcInRlbXBsLWRlZlwiLCB2YXJpYWJsZVNjb3BlOiB0cnVlfSxcbiAgICBcImRlbGNhbGxcIjogeyBzb3lTdGF0ZTogXCJ0ZW1wbC1yZWZcIiB9LFxuICAgIFwibG9nXCI6IHt9LFxuICAgIFwiZWxlbWVudFwiOiB7IHZhcmlhYmxlU2NvcGU6IHRydWUgfSxcbiAgfTtcblxuICB2YXIgaW5kZW50aW5nVGFncyA9IE9iamVjdC5rZXlzKHRhZ3MpLmZpbHRlcihmdW5jdGlvbih0YWcpIHtcbiAgICByZXR1cm4gIXRhZ3NbdGFnXS5ub0VuZFRhZyB8fCB0YWdzW3RhZ10ucmVkdWNlSW5kZW50O1xuICB9KTtcblxuICBDb2RlTWlycm9yLmRlZmluZU1vZGUoXCJzb3lcIiwgZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdmFyIHRleHRNb2RlID0gQ29kZU1pcnJvci5nZXRNb2RlKGNvbmZpZywgXCJ0ZXh0L3BsYWluXCIpO1xuICAgIHZhciBtb2RlcyA9IHtcbiAgICAgIGh0bWw6IENvZGVNaXJyb3IuZ2V0TW9kZShjb25maWcsIHtuYW1lOiBcInRleHQvaHRtbFwiLCBtdWx0aWxpbmVUYWdJbmRlbnRGYWN0b3I6IDIsIG11bHRpbGluZVRhZ0luZGVudFBhc3RUYWc6IGZhbHNlLCBhbGxvd01pc3NpbmdUYWdOYW1lOiB0cnVlfSksXG4gICAgICBhdHRyaWJ1dGVzOiB0ZXh0TW9kZSxcbiAgICAgIHRleHQ6IHRleHRNb2RlLFxuICAgICAgdXJpOiB0ZXh0TW9kZSxcbiAgICAgIHRydXN0ZWRfcmVzb3VyY2VfdXJpOiB0ZXh0TW9kZSxcbiAgICAgIGNzczogQ29kZU1pcnJvci5nZXRNb2RlKGNvbmZpZywgXCJ0ZXh0L2Nzc1wiKSxcbiAgICAgIGpzOiBDb2RlTWlycm9yLmdldE1vZGUoY29uZmlnLCB7bmFtZTogXCJ0ZXh0L2phdmFzY3JpcHRcIiwgc3RhdGVtZW50SW5kZW50OiAyICogY29uZmlnLmluZGVudFVuaXR9KVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsYXN0KGFycmF5KSB7XG4gICAgICByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9rZW5VbnRpbChzdHJlYW0sIHN0YXRlLCB1bnRpbFJlZ0V4cCkge1xuICAgICAgaWYgKHN0cmVhbS5zb2woKSkge1xuICAgICAgICBmb3IgKHZhciBpbmRlbnQgPSAwOyBpbmRlbnQgPCBzdGF0ZS5pbmRlbnQ7IGluZGVudCsrKSB7XG4gICAgICAgICAgaWYgKCFzdHJlYW0uZWF0KC9cXHMvKSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGVudCkgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgb2xkU3RyaW5nID0gc3RyZWFtLnN0cmluZztcbiAgICAgIHZhciBtYXRjaCA9IHVudGlsUmVnRXhwLmV4ZWMob2xkU3RyaW5nLnN1YnN0cihzdHJlYW0ucG9zKSk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgLy8gV2UgZG9uJ3QgdXNlIGJhY2tVcCBiZWNhdXNlIGl0IGJhY2tzIHVwIGp1c3QgdGhlIHBvc2l0aW9uLCBub3QgdGhlIHN0YXRlLlxuICAgICAgICAvLyBUaGlzIHVzZXMgYW4gdW5kb2N1bWVudGVkIEFQSS5cbiAgICAgICAgc3RyZWFtLnN0cmluZyA9IG9sZFN0cmluZy5zdWJzdHIoMCwgc3RyZWFtLnBvcyArIG1hdGNoLmluZGV4KTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBzdHJlYW0uaGlkZUZpcnN0Q2hhcnMoc3RhdGUuaW5kZW50LCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxvY2FsU3RhdGUgPSBsYXN0KHN0YXRlLmxvY2FsU3RhdGVzKTtcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RhdGUubW9kZS50b2tlbihzdHJlYW0sIGxvY2FsU3RhdGUuc3RhdGUpO1xuICAgICAgfSk7XG4gICAgICBzdHJlYW0uc3RyaW5nID0gb2xkU3RyaW5nO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb250YWlucyhsaXN0LCBlbGVtZW50KSB7XG4gICAgICB3aGlsZSAobGlzdCkge1xuICAgICAgICBpZiAobGlzdC5lbGVtZW50ID09PSBlbGVtZW50KSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbGlzdCA9IGxpc3QubmV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwZW5kKGxpc3QsIGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgIG5leHQ6IGxpc3RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9wY29udGV4dChzdGF0ZSkge1xuICAgICAgaWYgKCFzdGF0ZS5jb250ZXh0KSByZXR1cm47XG4gICAgICBpZiAoc3RhdGUuY29udGV4dC5zY29wZSkge1xuICAgICAgICBzdGF0ZS52YXJpYWJsZXMgPSBzdGF0ZS5jb250ZXh0LnNjb3BlO1xuICAgICAgfVxuICAgICAgc3RhdGUuY29udGV4dCA9IHN0YXRlLmNvbnRleHQucHJldmlvdXNDb250ZXh0O1xuICAgIH1cblxuICAgIC8vIFJlZmVyZW5jZSBhIHZhcmlhYmxlIGBuYW1lYCBpbiBgbGlzdGAuXG4gICAgLy8gTGV0IGBsb29zZWAgYmUgdHJ1dGh5IHRvIGlnbm9yZSBtaXNzaW5nIGlkZW50aWZpZXJzLlxuICAgIGZ1bmN0aW9uIHJlZihsaXN0LCBuYW1lLCBsb29zZSkge1xuICAgICAgcmV0dXJuIGNvbnRhaW5zKGxpc3QsIG5hbWUpID8gXCJ2YXJpYWJsZS0yXCIgOiAobG9vc2UgPyBcInZhcmlhYmxlXCIgOiBcInZhcmlhYmxlLTIgZXJyb3JcIik7XG4gICAgfVxuXG4gICAgLy8gRGF0YSBmb3IgYW4gb3BlbiBzb3kgdGFnLlxuICAgIGZ1bmN0aW9uIENvbnRleHQocHJldmlvdXNDb250ZXh0LCB0YWcsIHNjb3BlKSB7XG4gICAgICB0aGlzLnByZXZpb3VzQ29udGV4dCA9IHByZXZpb3VzQ29udGV4dDtcbiAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgdGhpcy5raW5kID0gbnVsbDtcbiAgICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHByZXNzaW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBtYXRjaDtcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goL1tbXS8pKSB7XG4gICAgICAgIHN0YXRlLnNveVN0YXRlLnB1c2goXCJsaXN0LWxpdGVyYWxcIik7XG4gICAgICAgIHN0YXRlLmNvbnRleHQgPSBuZXcgQ29udGV4dChzdGF0ZS5jb250ZXh0LCBcImxpc3QtbGl0ZXJhbFwiLCBzdGF0ZS52YXJpYWJsZXMpO1xuICAgICAgICBzdGF0ZS5sb29rdXBWYXJpYWJsZXMgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaCgvbWFwXFxiLykpIHtcbiAgICAgICAgc3RhdGUuc295U3RhdGUucHVzaChcIm1hcC1saXRlcmFsXCIpO1xuICAgICAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaCgvcmVjb3JkXFxiLykpIHtcbiAgICAgICAgc3RhdGUuc295U3RhdGUucHVzaChcInJlY29yZC1saXRlcmFsXCIpO1xuICAgICAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaCgvKFtcXHddKykoPz1cXCgpLykpIHtcbiAgICAgICAgcmV0dXJuIFwidmFyaWFibGUgY2FsbGVlXCI7XG4gICAgICB9IGVsc2UgaWYgKG1hdGNoID0gc3RyZWFtLm1hdGNoKC9eW1wiJ10vKSkge1xuICAgICAgICBzdGF0ZS5zb3lTdGF0ZS5wdXNoKFwic3RyaW5nXCIpO1xuICAgICAgICBzdGF0ZS5xdW90ZUtpbmQgPSBtYXRjaFswXTtcbiAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaCgvXlsoXS8pKSB7XG4gICAgICAgIHN0YXRlLnNveVN0YXRlLnB1c2goXCJvcGVuLXBhcmVudGhlc2VzXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKC8obnVsbHx0cnVlfGZhbHNlKSg/IVxcdykvKSB8fFxuICAgICAgICAgIHN0cmVhbS5tYXRjaCgvMHgoWzAtOWEtZkEtRl17Mix9KS8pIHx8XG4gICAgICAgICAgc3RyZWFtLm1hdGNoKC8tPyhbMC05XSpbLl0pP1swLTldKyhlWzAtOV0qKT8vKSkge1xuICAgICAgICByZXR1cm4gXCJhdG9tXCI7XG4gICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaCgvKFxcfHxbK1xcLSpcXC8lXXxbPSFdPXxcXD86fFs8Pl09PykvKSkge1xuICAgICAgICAvLyBUb2tlbml6ZSBmaWx0ZXIsIGJpbmFyeSwgbnVsbCBwcm9wYWdhdG9yLCBhbmQgZXF1YWxpdHkgb3BlcmF0b3JzLlxuICAgICAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICAgICAgfSBlbHNlIGlmIChtYXRjaCA9IHN0cmVhbS5tYXRjaCgvXlxcJChbXFx3XSspLykpIHtcbiAgICAgICAgcmV0dXJuIHJlZihzdGF0ZS52YXJpYWJsZXMsIG1hdGNoWzFdLCAhc3RhdGUubG9va3VwVmFyaWFibGVzKTtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2ggPSBzdHJlYW0ubWF0Y2goL15cXHcrLykpIHtcbiAgICAgICAgcmV0dXJuIC9eKD86YXN8YW5kfG9yfG5vdHxpbnxpZikkLy50ZXN0KG1hdGNoWzBdKSA/IFwia2V5d29yZFwiIDogbnVsbDtcbiAgICAgIH1cblxuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzb3lTdGF0ZTogW10sXG4gICAgICAgICAgdmFyaWFibGVzOiBwcmVwZW5kKG51bGwsICdpaicpLFxuICAgICAgICAgIHNjb3BlczogbnVsbCxcbiAgICAgICAgICBpbmRlbnQ6IDAsXG4gICAgICAgICAgcXVvdGVLaW5kOiBudWxsLFxuICAgICAgICAgIGNvbnRleHQ6IG51bGwsXG4gICAgICAgICAgbG9va3VwVmFyaWFibGVzOiB0cnVlLCAvLyBJcyB1bmtub3duIHZhcmlhYmxlcyBjb25zaWRlcmVkIGFuIGVycm9yXG4gICAgICAgICAgbG9jYWxTdGF0ZXM6IFt7XG4gICAgICAgICAgICBtb2RlOiBtb2Rlcy5odG1sLFxuICAgICAgICAgICAgc3RhdGU6IENvZGVNaXJyb3Iuc3RhcnRTdGF0ZShtb2Rlcy5odG1sKVxuICAgICAgICAgIH1dXG4gICAgICAgIH07XG4gICAgICB9LFxuXG4gICAgICBjb3B5U3RhdGU6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdGFnOiBzdGF0ZS50YWcsIC8vIExhc3Qgc2VlbiBTb3kgdGFnLlxuICAgICAgICAgIHNveVN0YXRlOiBzdGF0ZS5zb3lTdGF0ZS5jb25jYXQoW10pLFxuICAgICAgICAgIHZhcmlhYmxlczogc3RhdGUudmFyaWFibGVzLFxuICAgICAgICAgIGNvbnRleHQ6IHN0YXRlLmNvbnRleHQsXG4gICAgICAgICAgaW5kZW50OiBzdGF0ZS5pbmRlbnQsIC8vIEluZGVudGF0aW9uIG9mIHRoZSBmb2xsb3dpbmcgbGluZS5cbiAgICAgICAgICBxdW90ZUtpbmQ6IHN0YXRlLnF1b3RlS2luZCxcbiAgICAgICAgICBsb29rdXBWYXJpYWJsZXM6IHN0YXRlLmxvb2t1cFZhcmlhYmxlcyxcbiAgICAgICAgICBsb2NhbFN0YXRlczogc3RhdGUubG9jYWxTdGF0ZXMubWFwKGZ1bmN0aW9uKGxvY2FsU3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIG1vZGU6IGxvY2FsU3RhdGUubW9kZSxcbiAgICAgICAgICAgICAgc3RhdGU6IENvZGVNaXJyb3IuY29weVN0YXRlKGxvY2FsU3RhdGUubW9kZSwgbG9jYWxTdGF0ZS5zdGF0ZSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH0sXG5cbiAgICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIHZhciBtYXRjaDtcblxuICAgICAgICBzd2l0Y2ggKGxhc3Qoc3RhdGUuc295U3RhdGUpKSB7XG4gICAgICAgICAgY2FzZSBcImNvbW1lbnRcIjpcbiAgICAgICAgICAgIGlmIChzdHJlYW0ubWF0Y2goL14uKj9cXCpcXC8vKSkge1xuICAgICAgICAgICAgICBzdGF0ZS5zb3lTdGF0ZS5wb3AoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RhdGUuY29udGV4dCB8fCAhc3RhdGUuY29udGV4dC5zY29wZSkge1xuICAgICAgICAgICAgICB2YXIgcGFyYW1SZSA9IC9AcGFyYW1cXD8/XFxzKyhcXFMrKS9nO1xuICAgICAgICAgICAgICB2YXIgY3VycmVudCA9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAgICAgICAgICAgIGZvciAodmFyIG1hdGNoOyAobWF0Y2ggPSBwYXJhbVJlLmV4ZWMoY3VycmVudCkpOyApIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS52YXJpYWJsZXMgPSBwcmVwZW5kKHN0YXRlLnZhcmlhYmxlcywgbWF0Y2hbMV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gXCJjb21tZW50XCI7XG5cbiAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBzdHJlYW0ubWF0Y2goL14uKj8oW1wiJ118XFxcXFtcXHNcXFNdKS8pO1xuICAgICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoWzFdID09IHN0YXRlLnF1b3RlS2luZCkge1xuICAgICAgICAgICAgICBzdGF0ZS5xdW90ZUtpbmQgPSBudWxsO1xuICAgICAgICAgICAgICBzdGF0ZS5zb3lTdGF0ZS5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzdGF0ZS5zb3lTdGF0ZS5sZW5ndGggfHwgbGFzdChzdGF0ZS5zb3lTdGF0ZSkgIT0gXCJsaXRlcmFsXCIpIHtcbiAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eXFwvXFwqLykpIHtcbiAgICAgICAgICAgIHN0YXRlLnNveVN0YXRlLnB1c2goXCJjb21tZW50XCIpO1xuICAgICAgICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKHN0cmVhbS5zb2woKSA/IC9eXFxzKlxcL1xcLy4qLyA6IC9eXFxzK1xcL1xcLy4qLykpIHtcbiAgICAgICAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGxhc3Qoc3RhdGUuc295U3RhdGUpKSB7XG4gICAgICAgICAgY2FzZSBcInRlbXBsLWRlZlwiOlxuICAgICAgICAgICAgaWYgKG1hdGNoID0gc3RyZWFtLm1hdGNoKC9eXFwuPyhbXFx3XSsoPyFcXC5bXFx3XSspKikvKSkge1xuICAgICAgICAgICAgICBzdGF0ZS5zb3lTdGF0ZS5wb3AoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIFwiZGVmXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICBjYXNlIFwidGVtcGwtcmVmXCI6XG4gICAgICAgICAgICBpZiAobWF0Y2ggPSBzdHJlYW0ubWF0Y2goLyhcXC4/W2EtekEtWl9dW2EtekEtWl8wLTldKykrLykpIHtcbiAgICAgICAgICAgICAgc3RhdGUuc295U3RhdGUucG9wKCk7XG4gICAgICAgICAgICAgIC8vIElmIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaXMgJy4nLCBpdCBjYW4gb25seSBiZSBhIGxvY2FsIHRlbXBsYXRlLlxuICAgICAgICAgICAgICBpZiAobWF0Y2hbMF1bMF0gPT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwidmFyaWFibGUtMlwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlXG4gICAgICAgICAgICAgIHJldHVybiBcInZhcmlhYmxlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2ggPSBzdHJlYW0ubWF0Y2goL15cXCQoW1xcd10rKS8pKSB7XG4gICAgICAgICAgICAgIHN0YXRlLnNveVN0YXRlLnBvcCgpO1xuICAgICAgICAgICAgICByZXR1cm4gcmVmKHN0YXRlLnZhcmlhYmxlcywgbWF0Y2hbMV0sICFzdGF0ZS5sb29rdXBWYXJpYWJsZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICBjYXNlIFwibmFtZXNwYWNlLWRlZlwiOlxuICAgICAgICAgICAgaWYgKG1hdGNoID0gc3RyZWFtLm1hdGNoKC9eXFwuPyhbXFx3XFwuXSspLykpIHtcbiAgICAgICAgICAgICAgc3RhdGUuc295U3RhdGUucG9wKCk7XG4gICAgICAgICAgICAgIHJldHVybiBcInZhcmlhYmxlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICBjYXNlIFwicGFyYW0tZGVmXCI6XG4gICAgICAgICAgICBpZiAobWF0Y2ggPSBzdHJlYW0ubWF0Y2goL15cXCovKSkge1xuICAgICAgICAgICAgICBzdGF0ZS5zb3lTdGF0ZS5wb3AoKTtcbiAgICAgICAgICAgICAgc3RhdGUuc295U3RhdGUucHVzaChcInBhcmFtLXR5cGVcIik7XG4gICAgICAgICAgICAgIHJldHVybiBcInR5cGVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaCA9IHN0cmVhbS5tYXRjaCgvXlxcdysvKSkge1xuICAgICAgICAgICAgICBzdGF0ZS52YXJpYWJsZXMgPSBwcmVwZW5kKHN0YXRlLnZhcmlhYmxlcywgbWF0Y2hbMF0pO1xuICAgICAgICAgICAgICBzdGF0ZS5zb3lTdGF0ZS5wb3AoKTtcbiAgICAgICAgICAgICAgc3RhdGUuc295U3RhdGUucHVzaChcInBhcmFtLXR5cGVcIik7XG4gICAgICAgICAgICAgIHJldHVybiBcImRlZlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICAgICAgY2FzZSBcInBhcmFtLXJlZlwiOlxuICAgICAgICAgICAgaWYgKG1hdGNoID0gc3RyZWFtLm1hdGNoKC9eXFx3Ky8pKSB7XG4gICAgICAgICAgICAgIHN0YXRlLnNveVN0YXRlLnBvcCgpO1xuICAgICAgICAgICAgICByZXR1cm4gXCJwcm9wZXJ0eVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICAgICAgY2FzZSBcIm9wZW4tcGFyZW50aGVzZXNcIjpcbiAgICAgICAgICAgIGlmIChzdHJlYW0ubWF0Y2goL1spXS8pKSB7XG4gICAgICAgICAgICAgIHN0YXRlLnNveVN0YXRlLnBvcCgpO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgICAgICAgY2FzZSBcInBhcmFtLXR5cGVcIjpcbiAgICAgICAgICAgIHZhciBwZWVrQ2hhciA9IHN0cmVhbS5wZWVrKCk7XG4gICAgICAgICAgICBpZiAoXCJ9XT0+LFwiLmluZGV4T2YocGVla0NoYXIpICE9IC0xKSB7XG4gICAgICAgICAgICAgIHN0YXRlLnNveVN0YXRlLnBvcCgpO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGVla0NoYXIgPT0gXCJbXCIpIHtcbiAgICAgICAgICAgICAgc3RhdGUuc295U3RhdGUucHVzaCgncGFyYW0tdHlwZS1yZWNvcmQnKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBlZWtDaGFyID09IFwiKFwiKSB7XG4gICAgICAgICAgICAgIHN0YXRlLnNveVN0YXRlLnB1c2goJ3BhcmFtLXR5cGUtdGVtcGxhdGUnKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBlZWtDaGFyID09IFwiPFwiKSB7XG4gICAgICAgICAgICAgIHN0YXRlLnNveVN0YXRlLnB1c2goJ3BhcmFtLXR5cGUtcGFyYW1ldGVyJyk7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCA9IHN0cmVhbS5tYXRjaCgvXihbXFx3XSt8Wz9dKS8pKSB7XG4gICAgICAgICAgICAgIHJldHVybiBcInR5cGVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICAgIGNhc2UgXCJwYXJhbS10eXBlLXJlY29yZFwiOlxuICAgICAgICAgICAgdmFyIHBlZWtDaGFyID0gc3RyZWFtLnBlZWsoKTtcbiAgICAgICAgICAgIGlmIChwZWVrQ2hhciA9PSBcIl1cIikge1xuICAgICAgICAgICAgICBzdGF0ZS5zb3lTdGF0ZS5wb3AoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eXFx3Ky8pKSB7XG4gICAgICAgICAgICAgIHN0YXRlLnNveVN0YXRlLnB1c2goJ3BhcmFtLXR5cGUnKTtcbiAgICAgICAgICAgICAgcmV0dXJuIFwicHJvcGVydHlcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICAgIGNhc2UgXCJwYXJhbS10eXBlLXBhcmFtZXRlclwiOlxuICAgICAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXls+XS8pKSB7XG4gICAgICAgICAgICAgIHN0YXRlLnNveVN0YXRlLnBvcCgpO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHJlYW0ubWF0Y2goL15bPCxdLykpIHtcbiAgICAgICAgICAgICAgc3RhdGUuc295U3RhdGUucHVzaCgncGFyYW0tdHlwZScpO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICAgIGNhc2UgXCJwYXJhbS10eXBlLXRlbXBsYXRlXCI6XG4gICAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9bPl0vKSkge1xuICAgICAgICAgICAgICBzdGF0ZS5zb3lTdGF0ZS5wb3AoKTtcbiAgICAgICAgICAgICAgc3RhdGUuc295U3RhdGUucHVzaCgncGFyYW0tdHlwZScpO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHJlYW0ubWF0Y2goL15cXHcrLykpIHtcbiAgICAgICAgICAgICAgc3RhdGUuc295U3RhdGUucHVzaCgncGFyYW0tdHlwZScpO1xuICAgICAgICAgICAgICByZXR1cm4gXCJkZWZcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICAgIGNhc2UgXCJ2YXItZGVmXCI6XG4gICAgICAgICAgICBpZiAobWF0Y2ggPSBzdHJlYW0ubWF0Y2goL15cXCQoW1xcd10rKS8pKSB7XG4gICAgICAgICAgICAgIHN0YXRlLnZhcmlhYmxlcyA9IHByZXBlbmQoc3RhdGUudmFyaWFibGVzLCBtYXRjaFsxXSk7XG4gICAgICAgICAgICAgIHN0YXRlLnNveVN0YXRlLnBvcCgpO1xuICAgICAgICAgICAgICByZXR1cm4gXCJkZWZcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICAgIGNhc2UgXCJmb3ItbG9vcFwiOlxuICAgICAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXFxiaW5cXGIvKSkge1xuICAgICAgICAgICAgICBzdGF0ZS5zb3lTdGF0ZS5wb3AoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0cmVhbS5wZWVrKCkgPT0gXCIkXCIpIHtcbiAgICAgICAgICAgICAgc3RhdGUuc295U3RhdGUucHVzaCgndmFyLWRlZicpO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICAgIGNhc2UgXCJyZWNvcmQtbGl0ZXJhbFwiOlxuICAgICAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXlspXS8pKSB7XG4gICAgICAgICAgICAgIHN0YXRlLnNveVN0YXRlLnBvcCgpO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHJlYW0ubWF0Y2goL1soLF0vKSkge1xuICAgICAgICAgICAgICBzdGF0ZS5zb3lTdGF0ZS5wdXNoKFwibWFwLXZhbHVlXCIpXG4gICAgICAgICAgICAgIHN0YXRlLnNveVN0YXRlLnB1c2goXCJyZWNvcmQta2V5XCIpXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyZWFtLm5leHQoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICBjYXNlIFwibWFwLWxpdGVyYWxcIjpcbiAgICAgICAgICAgIGlmIChzdHJlYW0ubWF0Y2goL15bKV0vKSkge1xuICAgICAgICAgICAgICBzdGF0ZS5zb3lTdGF0ZS5wb3AoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9bKCxdLykpIHtcbiAgICAgICAgICAgICAgc3RhdGUuc295U3RhdGUucHVzaChcIm1hcC12YWx1ZVwiKVxuICAgICAgICAgICAgICBzdGF0ZS5zb3lTdGF0ZS5wdXNoKFwibWFwLXZhbHVlXCIpXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyZWFtLm5leHQoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICBjYXNlIFwibGlzdC1saXRlcmFsXCI6XG4gICAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKCddJykpIHtcbiAgICAgICAgICAgICAgc3RhdGUuc295U3RhdGUucG9wKCk7XG4gICAgICAgICAgICAgIHN0YXRlLmxvb2t1cFZhcmlhYmxlcyA9IHRydWU7XG4gICAgICAgICAgICAgIHBvcGNvbnRleHQoc3RhdGUpO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHJlYW0ubWF0Y2goL1xcYmZvclxcYi8pKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmxvb2t1cFZhcmlhYmxlcyA9IHRydWU7XG4gICAgICAgICAgICAgIHN0YXRlLnNveVN0YXRlLnB1c2goJ2Zvci1sb29wJyk7XG4gICAgICAgICAgICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgICAgICAgY2FzZSBcInJlY29yZC1rZXlcIjpcbiAgICAgICAgICAgIGlmIChzdHJlYW0ubWF0Y2goL1tcXHddKy8pKSB7XG4gICAgICAgICAgICAgIHJldHVybiBcInByb3BlcnR5XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eWzpdLykpIHtcbiAgICAgICAgICAgICAgc3RhdGUuc295U3RhdGUucG9wKCk7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICAgICAgY2FzZSBcIm1hcC12YWx1ZVwiOlxuICAgICAgICAgICAgaWYgKHN0cmVhbS5wZWVrKCkgPT0gXCIpXCIgfHwgc3RyZWFtLnBlZWsoKSA9PSBcIixcIiB8fCBzdHJlYW0ubWF0Y2goL15bOildLykpIHtcbiAgICAgICAgICAgICAgc3RhdGUuc295U3RhdGUucG9wKCk7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24oc3RyZWFtLCBzdGF0ZSk7XG5cbiAgICAgICAgICBjYXNlIFwiaW1wb3J0XCI6XG4gICAgICAgICAgICBpZiAoc3RyZWFtLmVhdChcIjtcIikpIHtcbiAgICAgICAgICAgICAgc3RhdGUuc295U3RhdGUucG9wKCk7XG4gICAgICAgICAgICAgIHN0YXRlLmluZGVudCAtPSAyICogY29uZmlnLmluZGVudFVuaXQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXFx3Kyg/PVxccythcykvKSkge1xuICAgICAgICAgICAgICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoID0gc3RyZWFtLm1hdGNoKC9cXHcrLykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIC8oZnJvbXxhcykvLnRlc3QobWF0Y2hbMF0pID8gXCJrZXl3b3JkXCIgOiBcImRlZlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoID0gc3RyZWFtLm1hdGNoKC9eW1wiJ10vKSkge1xuICAgICAgICAgICAgICBzdGF0ZS5zb3lTdGF0ZS5wdXNoKFwic3RyaW5nXCIpO1xuICAgICAgICAgICAgICBzdGF0ZS5xdW90ZUtpbmQgPSBtYXRjaFswXTtcbiAgICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICBjYXNlIFwidGFnXCI6XG4gICAgICAgICAgICB2YXIgZW5kVGFnO1xuICAgICAgICAgICAgdmFyIHRhZ05hbWU7XG4gICAgICAgICAgICBpZiAoc3RhdGUudGFnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZW5kVGFnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdGFnTmFtZSA9ICcnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZW5kVGFnID0gc3RhdGUudGFnWzBdID09IFwiL1wiO1xuICAgICAgICAgICAgICB0YWdOYW1lID0gZW5kVGFnID8gc3RhdGUudGFnLnN1YnN0cmluZygxKSA6IHN0YXRlLnRhZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0YWcgPSB0YWdzW3RhZ05hbWVdO1xuICAgICAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXlxcLz99LykpIHtcbiAgICAgICAgICAgICAgdmFyIHNlbGZDbG9zZWQgPSBzdHJlYW0uY3VycmVudCgpID09IFwiL31cIjtcbiAgICAgICAgICAgICAgaWYgKHNlbGZDbG9zZWQgJiYgIWVuZFRhZykge1xuICAgICAgICAgICAgICAgIHBvcGNvbnRleHQoc3RhdGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzdGF0ZS50YWcgPT0gXCIvdGVtcGxhdGVcIiB8fCBzdGF0ZS50YWcgPT0gXCIvZGVsdGVtcGxhdGVcIikge1xuICAgICAgICAgICAgICAgIHN0YXRlLnZhcmlhYmxlcyA9IHByZXBlbmQobnVsbCwgJ2lqJyk7XG4gICAgICAgICAgICAgICAgc3RhdGUuaW5kZW50ID0gMDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5pbmRlbnQgLT0gY29uZmlnLmluZGVudFVuaXQgKlxuICAgICAgICAgICAgICAgICAgICAoc2VsZkNsb3NlZCB8fCBpbmRlbnRpbmdUYWdzLmluZGV4T2Yoc3RhdGUudGFnKSA9PSAtMSA/IDIgOiAxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdGF0ZS5zb3lTdGF0ZS5wb3AoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goL14oW1xcdz9dKykoPz09KS8pKSB7XG4gICAgICAgICAgICAgIGlmIChzdGF0ZS5jb250ZXh0ICYmIHN0YXRlLmNvbnRleHQudGFnID09IHRhZ05hbWUgJiYgc3RyZWFtLmN1cnJlbnQoKSA9PSBcImtpbmRcIiAmJiAobWF0Y2ggPSBzdHJlYW0ubWF0Y2goL149XCIoW15cIl0rKS8sIGZhbHNlKSkpIHtcbiAgICAgICAgICAgICAgICB2YXIga2luZCA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgICAgIHN0YXRlLmNvbnRleHQua2luZCA9IGtpbmQ7XG4gICAgICAgICAgICAgICAgdmFyIG1vZGUgPSBtb2Rlc1traW5kXSB8fCBtb2Rlcy5odG1sO1xuICAgICAgICAgICAgICAgIHZhciBsb2NhbFN0YXRlID0gbGFzdChzdGF0ZS5sb2NhbFN0YXRlcyk7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsU3RhdGUubW9kZS5pbmRlbnQpIHtcbiAgICAgICAgICAgICAgICAgIHN0YXRlLmluZGVudCArPSBsb2NhbFN0YXRlLm1vZGUuaW5kZW50KGxvY2FsU3RhdGUuc3RhdGUsIFwiXCIsIFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0ZS5sb2NhbFN0YXRlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgICAgICAgICAgICBzdGF0ZTogQ29kZU1pcnJvci5zdGFydFN0YXRlKG1vZGUpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIFwiYXR0cmlidXRlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbihzdHJlYW0sIHN0YXRlKTtcblxuICAgICAgICAgIGNhc2UgXCJ0ZW1wbGF0ZS1jYWxsLWV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgIGlmIChzdHJlYW0ubWF0Y2goL14oW1xcdy0/XSspKD89PSkvKSkge1xuICAgICAgICAgICAgICByZXR1cm4gXCJhdHRyaWJ1dGVcIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLmVhdCgnPicpKSB7XG4gICAgICAgICAgICAgIHN0YXRlLnNveVN0YXRlLnBvcCgpO1xuICAgICAgICAgICAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5lYXQoJy8+JykpIHtcbiAgICAgICAgICAgICAgc3RhdGUuc295U3RhdGUucG9wKCk7XG4gICAgICAgICAgICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICAgIGNhc2UgXCJsaXRlcmFsXCI6XG4gICAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKCd7L2xpdGVyYWx9JywgZmFsc2UpKSB7XG4gICAgICAgICAgICAgIHN0YXRlLnNveVN0YXRlLnBvcCgpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b2tlbihzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b2tlblVudGlsKHN0cmVhbSwgc3RhdGUsIC9cXHtcXC9saXRlcmFsfS8pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgne2xpdGVyYWx9JykpIHtcbiAgICAgICAgICBzdGF0ZS5pbmRlbnQgKz0gY29uZmlnLmluZGVudFVuaXQ7XG4gICAgICAgICAgc3RhdGUuc295U3RhdGUucHVzaChcImxpdGVyYWxcIik7XG4gICAgICAgICAgc3RhdGUuY29udGV4dCA9IG5ldyBDb250ZXh0KHN0YXRlLmNvbnRleHQsIFwibGl0ZXJhbFwiLCBzdGF0ZS52YXJpYWJsZXMpO1xuICAgICAgICAgIHJldHVybiBcImtleXdvcmRcIjtcblxuICAgICAgICAvLyBBIHRhZy1rZXl3b3JkIG11c3QgYmUgZm9sbG93ZWQgYnkgd2hpdGVzcGFjZSwgY29tbWVudCBvciBhIGNsb3NpbmcgdGFnLlxuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoID0gc3RyZWFtLm1hdGNoKC9eXFx7KFsvQFxcXFxdP1xcdytcXD8/KSg/PSR8W1xcc31dfFxcL1svKl0pLykpIHtcbiAgICAgICAgICB2YXIgcHJldlRhZyA9IHN0YXRlLnRhZztcbiAgICAgICAgICBzdGF0ZS50YWcgPSBtYXRjaFsxXTtcbiAgICAgICAgICB2YXIgZW5kVGFnID0gc3RhdGUudGFnWzBdID09IFwiL1wiO1xuICAgICAgICAgIHZhciBpbmRlbnRpbmdUYWcgPSAhIXRhZ3Nbc3RhdGUudGFnXTtcbiAgICAgICAgICB2YXIgdGFnTmFtZSA9IGVuZFRhZyA/IHN0YXRlLnRhZy5zdWJzdHJpbmcoMSkgOiBzdGF0ZS50YWc7XG4gICAgICAgICAgdmFyIHRhZyA9IHRhZ3NbdGFnTmFtZV07XG4gICAgICAgICAgaWYgKHN0YXRlLnRhZyAhPSBcIi9zd2l0Y2hcIilcbiAgICAgICAgICAgIHN0YXRlLmluZGVudCArPSAoKGVuZFRhZyB8fCB0YWcgJiYgdGFnLnJlZHVjZUluZGVudCkgJiYgcHJldlRhZyAhPSBcInN3aXRjaFwiID8gMSA6IDIpICogY29uZmlnLmluZGVudFVuaXQ7XG5cbiAgICAgICAgICBzdGF0ZS5zb3lTdGF0ZS5wdXNoKFwidGFnXCIpO1xuICAgICAgICAgIHZhciB0YWdFcnJvciA9IGZhbHNlO1xuICAgICAgICAgIGlmICh0YWcpIHtcbiAgICAgICAgICAgIGlmICghZW5kVGFnKSB7XG4gICAgICAgICAgICAgIGlmICh0YWcuc295U3RhdGUpIHN0YXRlLnNveVN0YXRlLnB1c2godGFnLnNveVN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGEgbmV3IHRhZywgb3BlbiBhIG5ldyBjb250ZXh0LlxuICAgICAgICAgICAgaWYgKCF0YWcubm9FbmRUYWcgJiYgKGluZGVudGluZ1RhZyB8fCAhZW5kVGFnKSkge1xuICAgICAgICAgICAgICBzdGF0ZS5jb250ZXh0ID0gbmV3IENvbnRleHQoc3RhdGUuY29udGV4dCwgc3RhdGUudGFnLCB0YWcudmFyaWFibGVTY29wZSA/IHN0YXRlLnZhcmlhYmxlcyA6IG51bGwpO1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGNsb3NlIHRoZSBjdXJyZW50IGNvbnRleHQuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVuZFRhZykge1xuICAgICAgICAgICAgICBpZiAoIXN0YXRlLmNvbnRleHQgfHwgc3RhdGUuY29udGV4dC50YWcgIT0gdGFnTmFtZSkge1xuICAgICAgICAgICAgICAgIHRhZ0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5jb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmNvbnRleHQua2luZCkge1xuICAgICAgICAgICAgICAgICAgc3RhdGUubG9jYWxTdGF0ZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICB2YXIgbG9jYWxTdGF0ZSA9IGxhc3Qoc3RhdGUubG9jYWxTdGF0ZXMpO1xuICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsU3RhdGUubW9kZS5pbmRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaW5kZW50IC09IGxvY2FsU3RhdGUubW9kZS5pbmRlbnQobG9jYWxTdGF0ZS5zdGF0ZSwgXCJcIiwgXCJcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvcGNvbnRleHQoc3RhdGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChlbmRUYWcpIHtcbiAgICAgICAgICAgIC8vIEFzc3VtZSBhbGwgdGFncyB3aXRoIGEgY2xvc2luZyB0YWcgYXJlIGRlZmluZWQgaW4gdGhlIGNvbmZpZy5cbiAgICAgICAgICAgIHRhZ0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICh0YWdFcnJvciA/IFwiZXJyb3IgXCIgOiBcIlwiKSArIFwia2V5d29yZFwiO1xuXG4gICAgICAgIC8vIE5vdCBhIHRhZy1rZXl3b3JkOyBpdCdzIGFuIGltcGxpY2l0IHByaW50IHRhZy5cbiAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0uZWF0KCd7JykpIHtcbiAgICAgICAgICBzdGF0ZS50YWcgPSBcInByaW50XCI7XG4gICAgICAgICAgc3RhdGUuaW5kZW50ICs9IDIgKiBjb25maWcuaW5kZW50VW5pdDtcbiAgICAgICAgICBzdGF0ZS5zb3lTdGF0ZS5wdXNoKFwidGFnXCIpO1xuICAgICAgICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgICAgICAgfSBlbHNlIGlmICghc3RhdGUuY29udGV4dCAmJiBzdHJlYW0ubWF0Y2goL1xcYmltcG9ydFxcYi8pKSB7XG4gICAgICAgICAgc3RhdGUuc295U3RhdGUucHVzaChcImltcG9ydFwiKTtcbiAgICAgICAgICBzdGF0ZS5pbmRlbnQgKz0gMiAqIGNvbmZpZy5pbmRlbnRVbml0O1xuICAgICAgICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaCA9IHN0cmVhbS5tYXRjaCgnPHsnKSkge1xuICAgICAgICAgIHN0YXRlLnNveVN0YXRlLnB1c2goXCJ0ZW1wbGF0ZS1jYWxsLWV4cHJlc3Npb25cIik7XG4gICAgICAgICAgc3RhdGUuaW5kZW50ICs9IDIgKiBjb25maWcuaW5kZW50VW5pdDtcbiAgICAgICAgICBzdGF0ZS5zb3lTdGF0ZS5wdXNoKFwidGFnXCIpO1xuICAgICAgICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaCA9IHN0cmVhbS5tYXRjaCgnPC8+JykpIHtcbiAgICAgICAgICBzdGF0ZS5pbmRlbnQgLT0gMSAqIGNvbmZpZy5pbmRlbnRVbml0O1xuICAgICAgICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0b2tlblVudGlsKHN0cmVhbSwgc3RhdGUsIC9cXHt8XFxzK1xcL1xcL3xcXC9cXCovKTtcbiAgICAgIH0sXG5cbiAgICAgIGluZGVudDogZnVuY3Rpb24oc3RhdGUsIHRleHRBZnRlciwgbGluZSkge1xuICAgICAgICB2YXIgaW5kZW50ID0gc3RhdGUuaW5kZW50LCB0b3AgPSBsYXN0KHN0YXRlLnNveVN0YXRlKTtcbiAgICAgICAgaWYgKHRvcCA9PSBcImNvbW1lbnRcIikgcmV0dXJuIENvZGVNaXJyb3IuUGFzcztcblxuICAgICAgICBpZiAodG9wID09IFwibGl0ZXJhbFwiKSB7XG4gICAgICAgICAgaWYgKC9eXFx7XFwvbGl0ZXJhbH0vLnRlc3QodGV4dEFmdGVyKSkgaW5kZW50IC09IGNvbmZpZy5pbmRlbnRVbml0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICgvXlxccypcXHtcXC8odGVtcGxhdGV8ZGVsdGVtcGxhdGUpXFxiLy50ZXN0KHRleHRBZnRlcikpIHJldHVybiAwO1xuICAgICAgICAgIGlmICgvXlxceyhcXC98KGZhbGxiYWNrbXNnfGVsc2VpZnxlbHNlfGlmZW1wdHkpXFxiKS8udGVzdCh0ZXh0QWZ0ZXIpKSBpbmRlbnQgLT0gY29uZmlnLmluZGVudFVuaXQ7XG4gICAgICAgICAgaWYgKHN0YXRlLnRhZyAhPSBcInN3aXRjaFwiICYmIC9eXFx7KGNhc2V8ZGVmYXVsdClcXGIvLnRlc3QodGV4dEFmdGVyKSkgaW5kZW50IC09IGNvbmZpZy5pbmRlbnRVbml0O1xuICAgICAgICAgIGlmICgvXlxce1xcL3N3aXRjaFxcYi8udGVzdCh0ZXh0QWZ0ZXIpKSBpbmRlbnQgLT0gY29uZmlnLmluZGVudFVuaXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvY2FsU3RhdGUgPSBsYXN0KHN0YXRlLmxvY2FsU3RhdGVzKTtcbiAgICAgICAgaWYgKGluZGVudCAmJiBsb2NhbFN0YXRlLm1vZGUuaW5kZW50KSB7XG4gICAgICAgICAgaW5kZW50ICs9IGxvY2FsU3RhdGUubW9kZS5pbmRlbnQobG9jYWxTdGF0ZS5zdGF0ZSwgdGV4dEFmdGVyLCBsaW5lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZW50O1xuICAgICAgfSxcblxuICAgICAgaW5uZXJNb2RlOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUuc295U3RhdGUubGVuZ3RoICYmIGxhc3Qoc3RhdGUuc295U3RhdGUpICE9IFwibGl0ZXJhbFwiKSByZXR1cm4gbnVsbDtcbiAgICAgICAgZWxzZSByZXR1cm4gbGFzdChzdGF0ZS5sb2NhbFN0YXRlcyk7XG4gICAgICB9LFxuXG4gICAgICBlbGVjdHJpY0lucHV0OiAvXlxccypcXHsoXFwvfFxcL3RlbXBsYXRlfFxcL2RlbHRlbXBsYXRlfFxcL3N3aXRjaHxmYWxsYmFja21zZ3xlbHNlaWZ8ZWxzZXxjYXNlfGRlZmF1bHR8aWZlbXB0eXxcXC9saXRlcmFsXFx9KSQvLFxuICAgICAgbGluZUNvbW1lbnQ6IFwiLy9cIixcbiAgICAgIGJsb2NrQ29tbWVudFN0YXJ0OiBcIi8qXCIsXG4gICAgICBibG9ja0NvbW1lbnRFbmQ6IFwiKi9cIixcbiAgICAgIGJsb2NrQ29tbWVudENvbnRpbnVlOiBcIiAqIFwiLFxuICAgICAgdXNlSW5uZXJDb21tZW50czogZmFsc2UsXG4gICAgICBmb2xkOiBcImluZGVudFwiXG4gICAgfTtcbiAgfSwgXCJodG1sbWl4ZWRcIik7XG5cbiAgQ29kZU1pcnJvci5yZWdpc3RlckhlbHBlcihcIndvcmRDaGFyc1wiLCBcInNveVwiLCAvW1xcdyRdLyk7XG5cbiAgQ29kZU1pcnJvci5yZWdpc3RlckhlbHBlcihcImhpbnRXb3Jkc1wiLCBcInNveVwiLCBPYmplY3Qua2V5cyh0YWdzKS5jb25jYXQoXG4gICAgICBbXCJjc3NcIiwgXCJkZWJ1Z2dlclwiXSkpO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQveC1zb3lcIiwgXCJzb3lcIik7XG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwic3BhcnFsXCIsIGZ1bmN0aW9uKGNvbmZpZykge1xuICB2YXIgaW5kZW50VW5pdCA9IGNvbmZpZy5pbmRlbnRVbml0O1xuICB2YXIgY3VyUHVuYztcblxuICBmdW5jdGlvbiB3b3JkUmVnZXhwKHdvcmRzKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoXCJeKD86XCIgKyB3b3Jkcy5qb2luKFwifFwiKSArIFwiKSRcIiwgXCJpXCIpO1xuICB9XG4gIHZhciBvcHMgPSB3b3JkUmVnZXhwKFtcInN0clwiLCBcImxhbmdcIiwgXCJsYW5nbWF0Y2hlc1wiLCBcImRhdGF0eXBlXCIsIFwiYm91bmRcIiwgXCJzYW1ldGVybVwiLCBcImlzaXJpXCIsIFwiaXN1cmlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaXJpXCIsIFwidXJpXCIsIFwiYm5vZGVcIiwgXCJjb3VudFwiLCBcInN1bVwiLCBcIm1pblwiLCBcIm1heFwiLCBcImF2Z1wiLCBcInNhbXBsZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJncm91cF9jb25jYXRcIiwgXCJyYW5kXCIsIFwiYWJzXCIsIFwiY2VpbFwiLCBcImZsb29yXCIsIFwicm91bmRcIiwgXCJjb25jYXRcIiwgXCJzdWJzdHJcIiwgXCJzdHJsZW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiLCBcInVjYXNlXCIsIFwibGNhc2VcIiwgXCJlbmNvZGVfZm9yX3VyaVwiLCBcImNvbnRhaW5zXCIsIFwic3Ryc3RhcnRzXCIsIFwic3RyZW5kc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJzdHJiZWZvcmVcIiwgXCJzdHJhZnRlclwiLCBcInllYXJcIiwgXCJtb250aFwiLCBcImRheVwiLCBcImhvdXJzXCIsIFwibWludXRlc1wiLCBcInNlY29uZHNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidGltZXpvbmVcIiwgXCJ0elwiLCBcIm5vd1wiLCBcInV1aWRcIiwgXCJzdHJ1dWlkXCIsIFwibWQ1XCIsIFwic2hhMVwiLCBcInNoYTI1NlwiLCBcInNoYTM4NFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJzaGE1MTJcIiwgXCJjb2FsZXNjZVwiLCBcImlmXCIsIFwic3RybGFuZ1wiLCBcInN0cmR0XCIsIFwiaXNudW1lcmljXCIsIFwicmVnZXhcIiwgXCJleGlzdHNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaXNibGFua1wiLCBcImlzbGl0ZXJhbFwiLCBcImFcIiwgXCJiaW5kXCJdKTtcbiAgdmFyIGtleXdvcmRzID0gd29yZFJlZ2V4cChbXCJiYXNlXCIsIFwicHJlZml4XCIsIFwic2VsZWN0XCIsIFwiZGlzdGluY3RcIiwgXCJyZWR1Y2VkXCIsIFwiY29uc3RydWN0XCIsIFwiZGVzY3JpYmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhc2tcIiwgXCJmcm9tXCIsIFwibmFtZWRcIiwgXCJ3aGVyZVwiLCBcIm9yZGVyXCIsIFwibGltaXRcIiwgXCJvZmZzZXRcIiwgXCJmaWx0ZXJcIiwgXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImdyYXBoXCIsIFwiYnlcIiwgXCJhc2NcIiwgXCJkZXNjXCIsIFwiYXNcIiwgXCJoYXZpbmdcIiwgXCJ1bmRlZlwiLCBcInZhbHVlc1wiLCBcImdyb3VwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWludXNcIiwgXCJpblwiLCBcIm5vdFwiLCBcInNlcnZpY2VcIiwgXCJzaWxlbnRcIiwgXCJ1c2luZ1wiLCBcImluc2VydFwiLCBcImRlbGV0ZVwiLCBcInVuaW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidHJ1ZVwiLCBcImZhbHNlXCIsIFwid2l0aFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRhdGFcIiwgXCJjb3B5XCIsIFwidG9cIiwgXCJtb3ZlXCIsIFwiYWRkXCIsIFwiY3JlYXRlXCIsIFwiZHJvcFwiLCBcImNsZWFyXCIsIFwibG9hZFwiXSk7XG4gIHZhciBvcGVyYXRvckNoYXJzID0gL1sqK1xcLTw+PSZ8XFxeXFwvIVxcP10vO1xuXG4gIGZ1bmN0aW9uIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGNoID0gc3RyZWFtLm5leHQoKTtcbiAgICBjdXJQdW5jID0gbnVsbDtcbiAgICBpZiAoY2ggPT0gXCIkXCIgfHwgY2ggPT0gXCI/XCIpIHtcbiAgICAgIGlmKGNoID09IFwiP1wiICYmIHN0cmVhbS5tYXRjaCgvXFxzLywgZmFsc2UpKXtcbiAgICAgICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgICAgIH1cbiAgICAgIHN0cmVhbS5tYXRjaCgvXltBLVphLXowLTlfXFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMkZGXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXVtBLVphLXowLTlfXFx1MDBCN1xcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwM0YtXFx1MjA0MFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRF0qLyk7XG4gICAgICByZXR1cm4gXCJ2YXJpYWJsZS0yXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNoID09IFwiPFwiICYmICFzdHJlYW0ubWF0Y2goL15bXFxzXFx1MDBhMD1dLywgZmFsc2UpKSB7XG4gICAgICBzdHJlYW0ubWF0Y2goL15bXlxcc1xcdTAwYTA+XSo+Py8pO1xuICAgICAgcmV0dXJuIFwiYXRvbVwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaCA9PSBcIlxcXCJcIiB8fCBjaCA9PSBcIidcIikge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkxpdGVyYWwoY2gpO1xuICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgICBlbHNlIGlmICgvW3t9XFwoXFwpLFxcLjtcXFtcXF1dLy50ZXN0KGNoKSkge1xuICAgICAgY3VyUHVuYyA9IGNoO1xuICAgICAgcmV0dXJuIFwiYnJhY2tldFwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaCA9PSBcIiNcIikge1xuICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaCA9PT0gXCJeXCIpIHtcbiAgICAgIGNoID0gc3RyZWFtLnBlZWsoKTtcbiAgICAgIGlmIChjaCA9PT0gXCJeXCIpIHN0cmVhbS5lYXQoXCJeXCIpO1xuICAgICAgZWxzZSBzdHJlYW0uZWF0V2hpbGUob3BlcmF0b3JDaGFycyk7XG4gICAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcGVyYXRvckNoYXJzLnRlc3QoY2gpKSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUob3BlcmF0b3JDaGFycyk7XG4gICAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaCA9PSBcIjpcIikge1xuICAgICAgZWF0UG5Mb2NhbChzdHJlYW0pO1xuICAgICAgcmV0dXJuIFwiYXRvbVwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaCA9PSBcIkBcIikge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bYS16XFxkXFwtXS9pKTtcbiAgICAgIHJldHVybiBcIm1ldGFcIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1tfXFx3XFxkXS8pO1xuICAgICAgaWYgKHN0cmVhbS5lYXQoXCI6XCIpKSB7XG4gICAgICAgIGVhdFBuTG9jYWwoc3RyZWFtKTtcbiAgICAgICAgcmV0dXJuIFwiYXRvbVwiO1xuICAgICAgfVxuICAgICAgdmFyIHdvcmQgPSBzdHJlYW0uY3VycmVudCgpO1xuICAgICAgaWYgKG9wcy50ZXN0KHdvcmQpKVxuICAgICAgICByZXR1cm4gXCJidWlsdGluXCI7XG4gICAgICBlbHNlIGlmIChrZXl3b3Jkcy50ZXN0KHdvcmQpKVxuICAgICAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBcInZhcmlhYmxlXCI7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZWF0UG5Mb2NhbChzdHJlYW0pIHtcbiAgICBzdHJlYW0ubWF0Y2goLyhcXC4oPz1bXFx3X1xcLVxcXFwlXSl8WzpcXHdfLV18XFxcXFstXFxcXF9+LiEkJicoKSorLDs9Lz8jQCVdfCVbYS1mXFxkXVthLWZcXGRdKSsvaSk7XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlbkxpdGVyYWwocXVvdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIGVzY2FwZWQgPSBmYWxzZSwgY2g7XG4gICAgICB3aGlsZSAoKGNoID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgICBpZiAoY2ggPT0gcXVvdGUgJiYgIWVzY2FwZWQpIHtcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQgJiYgY2ggPT0gXCJcXFxcXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaENvbnRleHQoc3RhdGUsIHR5cGUsIGNvbCkge1xuICAgIHN0YXRlLmNvbnRleHQgPSB7cHJldjogc3RhdGUuY29udGV4dCwgaW5kZW50OiBzdGF0ZS5pbmRlbnQsIGNvbDogY29sLCB0eXBlOiB0eXBlfTtcbiAgfVxuICBmdW5jdGlvbiBwb3BDb250ZXh0KHN0YXRlKSB7XG4gICAgc3RhdGUuaW5kZW50ID0gc3RhdGUuY29udGV4dC5pbmRlbnQ7XG4gICAgc3RhdGUuY29udGV4dCA9IHN0YXRlLmNvbnRleHQucHJldjtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge3Rva2VuaXplOiB0b2tlbkJhc2UsXG4gICAgICAgICAgICAgIGNvbnRleHQ6IG51bGwsXG4gICAgICAgICAgICAgIGluZGVudDogMCxcbiAgICAgICAgICAgICAgY29sOiAwfTtcbiAgICB9LFxuXG4gICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmIChzdHJlYW0uc29sKCkpIHtcbiAgICAgICAgaWYgKHN0YXRlLmNvbnRleHQgJiYgc3RhdGUuY29udGV4dC5hbGlnbiA9PSBudWxsKSBzdGF0ZS5jb250ZXh0LmFsaWduID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmluZGVudCA9IHN0cmVhbS5pbmRlbnRhdGlvbigpO1xuICAgICAgfVxuICAgICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBzdHlsZSA9IHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgICBpZiAoc3R5bGUgIT0gXCJjb21tZW50XCIgJiYgc3RhdGUuY29udGV4dCAmJiBzdGF0ZS5jb250ZXh0LmFsaWduID09IG51bGwgJiYgc3RhdGUuY29udGV4dC50eXBlICE9IFwicGF0dGVyblwiKSB7XG4gICAgICAgIHN0YXRlLmNvbnRleHQuYWxpZ24gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VyUHVuYyA9PSBcIihcIikgcHVzaENvbnRleHQoc3RhdGUsIFwiKVwiLCBzdHJlYW0uY29sdW1uKCkpO1xuICAgICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBcIltcIikgcHVzaENvbnRleHQoc3RhdGUsIFwiXVwiLCBzdHJlYW0uY29sdW1uKCkpO1xuICAgICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBcIntcIikgcHVzaENvbnRleHQoc3RhdGUsIFwifVwiLCBzdHJlYW0uY29sdW1uKCkpO1xuICAgICAgZWxzZSBpZiAoL1tcXF1cXH1cXCldLy50ZXN0KGN1clB1bmMpKSB7XG4gICAgICAgIHdoaWxlIChzdGF0ZS5jb250ZXh0ICYmIHN0YXRlLmNvbnRleHQudHlwZSA9PSBcInBhdHRlcm5cIikgcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICAgIGlmIChzdGF0ZS5jb250ZXh0ICYmIGN1clB1bmMgPT0gc3RhdGUuY29udGV4dC50eXBlKSB7XG4gICAgICAgICAgcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICAgICAgaWYgKGN1clB1bmMgPT0gXCJ9XCIgJiYgc3RhdGUuY29udGV4dCAmJiBzdGF0ZS5jb250ZXh0LnR5cGUgPT0gXCJwYXR0ZXJuXCIpXG4gICAgICAgICAgICBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBcIi5cIiAmJiBzdGF0ZS5jb250ZXh0ICYmIHN0YXRlLmNvbnRleHQudHlwZSA9PSBcInBhdHRlcm5cIikgcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICBlbHNlIGlmICgvYXRvbXxzdHJpbmd8dmFyaWFibGUvLnRlc3Qoc3R5bGUpICYmIHN0YXRlLmNvbnRleHQpIHtcbiAgICAgICAgaWYgKC9bXFx9XFxdXS8udGVzdChzdGF0ZS5jb250ZXh0LnR5cGUpKVxuICAgICAgICAgIHB1c2hDb250ZXh0KHN0YXRlLCBcInBhdHRlcm5cIiwgc3RyZWFtLmNvbHVtbigpKTtcbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuY29udGV4dC50eXBlID09IFwicGF0dGVyblwiICYmICFzdGF0ZS5jb250ZXh0LmFsaWduKSB7XG4gICAgICAgICAgc3RhdGUuY29udGV4dC5hbGlnbiA9IHRydWU7XG4gICAgICAgICAgc3RhdGUuY29udGV4dC5jb2wgPSBzdHJlYW0uY29sdW1uKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH0sXG5cbiAgICBpbmRlbnQ6IGZ1bmN0aW9uKHN0YXRlLCB0ZXh0QWZ0ZXIpIHtcbiAgICAgIHZhciBmaXJzdENoYXIgPSB0ZXh0QWZ0ZXIgJiYgdGV4dEFmdGVyLmNoYXJBdCgwKTtcbiAgICAgIHZhciBjb250ZXh0ID0gc3RhdGUuY29udGV4dDtcbiAgICAgIGlmICgvW1xcXVxcfV0vLnRlc3QoZmlyc3RDaGFyKSlcbiAgICAgICAgd2hpbGUgKGNvbnRleHQgJiYgY29udGV4dC50eXBlID09IFwicGF0dGVyblwiKSBjb250ZXh0ID0gY29udGV4dC5wcmV2O1xuXG4gICAgICB2YXIgY2xvc2luZyA9IGNvbnRleHQgJiYgZmlyc3RDaGFyID09IGNvbnRleHQudHlwZTtcbiAgICAgIGlmICghY29udGV4dClcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICBlbHNlIGlmIChjb250ZXh0LnR5cGUgPT0gXCJwYXR0ZXJuXCIpXG4gICAgICAgIHJldHVybiBjb250ZXh0LmNvbDtcbiAgICAgIGVsc2UgaWYgKGNvbnRleHQuYWxpZ24pXG4gICAgICAgIHJldHVybiBjb250ZXh0LmNvbCArIChjbG9zaW5nID8gMCA6IDEpO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gY29udGV4dC5pbmRlbnQgKyAoY2xvc2luZyA/IDAgOiBpbmRlbnRVbml0KTtcbiAgICB9LFxuXG4gICAgbGluZUNvbW1lbnQ6IFwiI1wiXG4gIH07XG59KTtcblxuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwiYXBwbGljYXRpb24vc3BhcnFsLXF1ZXJ5XCIsIFwic3BhcnFsXCIpO1xuXG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lTW9kZShcInNwcmVhZHNoZWV0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0cmluZ1R5cGU6IG51bGwsXG4gICAgICAgICAgc3RhY2s6IFtdXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgdG9rZW46IGZ1bmN0aW9uIChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIGlmICghc3RyZWFtKSByZXR1cm47XG5cbiAgICAgICAgLy9jaGVjayBmb3Igc3RhdGUgY2hhbmdlc1xuICAgICAgICBpZiAoc3RhdGUuc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgLy9zdHJpbmdzXG4gICAgICAgICAgaWYgKChzdHJlYW0ucGVlaygpID09ICdcIicpIHx8IChzdHJlYW0ucGVlaygpID09IFwiJ1wiKSkge1xuICAgICAgICAgICAgc3RhdGUuc3RyaW5nVHlwZSA9IHN0cmVhbS5wZWVrKCk7XG4gICAgICAgICAgICBzdHJlYW0ubmV4dCgpOyAvLyBTa2lwIHF1b3RlXG4gICAgICAgICAgICBzdGF0ZS5zdGFjay51bnNoaWZ0KFwic3RyaW5nXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vcmV0dXJuIHN0YXRlXG4gICAgICAgIC8vc3RhY2sgaGFzXG4gICAgICAgIHN3aXRjaCAoc3RhdGUuc3RhY2tbMF0pIHtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgIHdoaWxlIChzdGF0ZS5zdGFja1swXSA9PT0gXCJzdHJpbmdcIiAmJiAhc3RyZWFtLmVvbCgpKSB7XG4gICAgICAgICAgICBpZiAoc3RyZWFtLnBlZWsoKSA9PT0gc3RhdGUuc3RyaW5nVHlwZSkge1xuICAgICAgICAgICAgICBzdHJlYW0ubmV4dCgpOyAvLyBTa2lwIHF1b3RlXG4gICAgICAgICAgICAgIHN0YXRlLnN0YWNrLnNoaWZ0KCk7IC8vIENsZWFyIGZsYWdcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLnBlZWsoKSA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0cmVhbS5tYXRjaCgvXi5bXlxcXFxcXFwiXFwnXSovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG5cbiAgICAgICAgY2FzZSBcImNoYXJhY3RlckNsYXNzXCI6XG4gICAgICAgICAgd2hpbGUgKHN0YXRlLnN0YWNrWzBdID09PSBcImNoYXJhY3RlckNsYXNzXCIgJiYgIXN0cmVhbS5lb2woKSkge1xuICAgICAgICAgICAgaWYgKCEoc3RyZWFtLm1hdGNoKC9eW15cXF1cXFxcXSsvKSB8fCBzdHJlYW0ubWF0Y2goL15cXFxcLi8pKSlcbiAgICAgICAgICAgICAgc3RhdGUuc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwZWVrID0gc3RyZWFtLnBlZWsoKTtcblxuICAgICAgICAvL25vIHN0YWNrXG4gICAgICAgIHN3aXRjaCAocGVlaykge1xuICAgICAgICBjYXNlIFwiW1wiOlxuICAgICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgICAgc3RhdGUuc3RhY2sudW5zaGlmdChcImNoYXJhY3RlckNsYXNzXCIpO1xuICAgICAgICAgIHJldHVybiBcImJyYWNrZXRcIjtcbiAgICAgICAgY2FzZSBcIjpcIjpcbiAgICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gICAgICAgIGNhc2UgXCJcXFxcXCI6XG4gICAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXFxcXFthLXpdKy8pKSByZXR1cm4gXCJzdHJpbmctMlwiO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiBcImF0b21cIjtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgXCIuXCI6XG4gICAgICAgIGNhc2UgXCIsXCI6XG4gICAgICAgIGNhc2UgXCI7XCI6XG4gICAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgIGNhc2UgXCJeXCI6XG4gICAgICAgIGNhc2UgXCI8XCI6XG4gICAgICAgIGNhc2UgXCIvXCI6XG4gICAgICAgIGNhc2UgXCI9XCI6XG4gICAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgICByZXR1cm4gXCJhdG9tXCI7XG4gICAgICAgIGNhc2UgXCIkXCI6XG4gICAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgICByZXR1cm4gXCJidWlsdGluXCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9cXGQrLykpIHtcbiAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eXFx3Ky8pKSByZXR1cm4gXCJlcnJvclwiO1xuICAgICAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaCgvXlthLXpBLVpfXVxcdyovKSkge1xuICAgICAgICAgIGlmIChzdHJlYW0ubWF0Y2goLyg/PVtcXCguXSkvLCBmYWxzZSkpIHJldHVybiBcImtleXdvcmRcIjtcbiAgICAgICAgICByZXR1cm4gXCJ2YXJpYWJsZS0yXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoW1wiW1wiLCBcIl1cIiwgXCIoXCIsIFwiKVwiLCBcIntcIiwgXCJ9XCJdLmluZGV4T2YocGVlaykgIT0gLTEpIHtcbiAgICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAgIHJldHVybiBcImJyYWNrZXRcIjtcbiAgICAgICAgfSBlbHNlIGlmICghc3RyZWFtLmVhdFNwYWNlKCkpIHtcbiAgICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQveC1zcHJlYWRzaGVldFwiLCBcInNwcmVhZHNoZWV0XCIpO1xufSk7XG4iLCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4vLyBTdHlsdXMgbW9kZSBjcmVhdGVkIGJ5IERtaXRyeSBLaXNlbHlvdiBodHRwOi8vZ2l0LmlvL0FhUkJcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwic3R5bHVzXCIsIGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHZhciBpbmRlbnRVbml0ID0gY29uZmlnLmluZGVudFVuaXQsXG4gICAgICAgIGluZGVudFVuaXRTdHJpbmcgPSAnJyxcbiAgICAgICAgdGFnS2V5d29yZHMgPSBrZXlTZXQodGFnS2V5d29yZHNfKSxcbiAgICAgICAgdGFnVmFyaWFibGVzUmVnZXhwID0gL14oYXxifGl8c3xjb2x8ZW0pJC9pLFxuICAgICAgICBwcm9wZXJ0eUtleXdvcmRzID0ga2V5U2V0KHByb3BlcnR5S2V5d29yZHNfKSxcbiAgICAgICAgbm9uU3RhbmRhcmRQcm9wZXJ0eUtleXdvcmRzID0ga2V5U2V0KG5vblN0YW5kYXJkUHJvcGVydHlLZXl3b3Jkc18pLFxuICAgICAgICB2YWx1ZUtleXdvcmRzID0ga2V5U2V0KHZhbHVlS2V5d29yZHNfKSxcbiAgICAgICAgY29sb3JLZXl3b3JkcyA9IGtleVNldChjb2xvcktleXdvcmRzXyksXG4gICAgICAgIGRvY3VtZW50VHlwZXMgPSBrZXlTZXQoZG9jdW1lbnRUeXBlc18pLFxuICAgICAgICBkb2N1bWVudFR5cGVzUmVnZXhwID0gd29yZFJlZ2V4cChkb2N1bWVudFR5cGVzXyksXG4gICAgICAgIG1lZGlhRmVhdHVyZXMgPSBrZXlTZXQobWVkaWFGZWF0dXJlc18pLFxuICAgICAgICBtZWRpYVR5cGVzID0ga2V5U2V0KG1lZGlhVHlwZXNfKSxcbiAgICAgICAgZm9udFByb3BlcnRpZXMgPSBrZXlTZXQoZm9udFByb3BlcnRpZXNfKSxcbiAgICAgICAgb3BlcmF0b3JzUmVnZXhwID0gL15cXHMqKFsuXXsyLDN9fCYmfFxcfFxcfHxcXCpcXCp8Wz8hPTpdPz18Wy0rKlxcLyU8Pl09P3xcXD86fFxcfikvLFxuICAgICAgICB3b3JkT3BlcmF0b3JLZXl3b3Jkc1JlZ2V4cCA9IHdvcmRSZWdleHAod29yZE9wZXJhdG9yS2V5d29yZHNfKSxcbiAgICAgICAgYmxvY2tLZXl3b3JkcyA9IGtleVNldChibG9ja0tleXdvcmRzXyksXG4gICAgICAgIHZlbmRvclByZWZpeGVzUmVnZXhwID0gbmV3IFJlZ0V4cCgvXlxcLShtb3p8bXN8b3x3ZWJraXQpLS9pKSxcbiAgICAgICAgY29tbW9uQXRvbXMgPSBrZXlTZXQoY29tbW9uQXRvbXNfKSxcbiAgICAgICAgZmlyc3RXb3JkTWF0Y2ggPSBcIlwiLFxuICAgICAgICBzdGF0ZXMgPSB7fSxcbiAgICAgICAgY2gsXG4gICAgICAgIHN0eWxlLFxuICAgICAgICB0eXBlLFxuICAgICAgICBvdmVycmlkZTtcblxuICAgIHdoaWxlIChpbmRlbnRVbml0U3RyaW5nLmxlbmd0aCA8IGluZGVudFVuaXQpIGluZGVudFVuaXRTdHJpbmcgKz0gJyAnO1xuXG4gICAgLyoqXG4gICAgICogVG9rZW5pemVyc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBmaXJzdFdvcmRNYXRjaCA9IHN0cmVhbS5zdHJpbmcubWF0Y2goLyheW1xcdy1dK1xccyo9XFxzKiQpfCheXFxzKltcXHctXStcXHMqPVxccypbXFx3LV0pfCheXFxzKihcXC58I3xAfFxcJHxcXCZ8XFxbfFxcZHxcXCt8Ojo/fFxce3xcXD58fnxcXC8pP1xccypbXFx3LV0qKFthLXowLTktXXxcXCp8XFwvXFwqKShcXCh8LCk/KS8pO1xuICAgICAgc3RhdGUuY29udGV4dC5saW5lLmZpcnN0V29yZCA9IGZpcnN0V29yZE1hdGNoID8gZmlyc3RXb3JkTWF0Y2hbMF0ucmVwbGFjZSgvXlxccyovLCBcIlwiKSA6IFwiXCI7XG4gICAgICBzdGF0ZS5jb250ZXh0LmxpbmUuaW5kZW50ID0gc3RyZWFtLmluZGVudGF0aW9uKCk7XG4gICAgICBjaCA9IHN0cmVhbS5wZWVrKCk7XG5cbiAgICAgIC8vIExpbmUgY29tbWVudFxuICAgICAgaWYgKHN0cmVhbS5tYXRjaChcIi8vXCIpKSB7XG4gICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgcmV0dXJuIFtcImNvbW1lbnRcIiwgXCJjb21tZW50XCJdO1xuICAgICAgfVxuICAgICAgLy8gQmxvY2sgY29tbWVudFxuICAgICAgaWYgKHN0cmVhbS5tYXRjaChcIi8qXCIpKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5DQ29tbWVudDtcbiAgICAgICAgcmV0dXJuIHRva2VuQ0NvbW1lbnQoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgICAvLyBTdHJpbmdcbiAgICAgIGlmIChjaCA9PSBcIlxcXCJcIiB8fCBjaCA9PSBcIidcIikge1xuICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuU3RyaW5nKGNoKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgfVxuICAgICAgLy8gRGVmXG4gICAgICBpZiAoY2ggPT0gXCJAXCIpIHtcbiAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFxcXC1dLyk7XG4gICAgICAgIHJldHVybiBbXCJkZWZcIiwgc3RyZWFtLmN1cnJlbnQoKV07XG4gICAgICB9XG4gICAgICAvLyBJRCBzZWxlY3RvciBvciBIZXggY29sb3JcbiAgICAgIGlmIChjaCA9PSBcIiNcIikge1xuICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAvLyBIZXggY29sb3JcbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXlswLTlhLWZdezN9KFswLTlhLWZdKFswLTlhLWZdezJ9KXswLDJ9KT9cXGIoPyEtKS9pKSkge1xuICAgICAgICAgIHJldHVybiBbXCJhdG9tXCIsIFwiYXRvbVwiXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJRCBzZWxlY3RvclxuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eW2Etel1bXFx3LV0qL2kpKSB7XG4gICAgICAgICAgcmV0dXJuIFtcImJ1aWx0aW5cIiwgXCJoYXNoXCJdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBWZW5kb3IgcHJlZml4ZXNcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2godmVuZG9yUHJlZml4ZXNSZWdleHApKSB7XG4gICAgICAgIHJldHVybiBbXCJtZXRhXCIsIFwidmVuZG9yLXByZWZpeGVzXCJdO1xuICAgICAgfVxuICAgICAgLy8gTnVtYmVyc1xuICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXi0/WzAtOV0/XFwuP1swLTldLykpIHtcbiAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bYS16JV0vaSk7XG4gICAgICAgIHJldHVybiBbXCJudW1iZXJcIiwgXCJ1bml0XCJdO1xuICAgICAgfVxuICAgICAgLy8gIWltcG9ydGFudHxvcHRpb25hbFxuICAgICAgaWYgKGNoID09IFwiIVwiKSB7XG4gICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIHJldHVybiBbc3RyZWFtLm1hdGNoKC9eKGltcG9ydGFudHxvcHRpb25hbCkvaSkgPyBcImtleXdvcmRcIjogXCJvcGVyYXRvclwiLCBcImltcG9ydGFudFwiXTtcbiAgICAgIH1cbiAgICAgIC8vIENsYXNzXG4gICAgICBpZiAoY2ggPT0gXCIuXCIgJiYgc3RyZWFtLm1hdGNoKC9eXFwuW2Etel1bXFx3LV0qL2kpKSB7XG4gICAgICAgIHJldHVybiBbXCJxdWFsaWZpZXJcIiwgXCJxdWFsaWZpZXJcIl07XG4gICAgICB9XG4gICAgICAvLyB1cmwgdXJsLXByZWZpeCBkb21haW4gcmVnZXhwXG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKGRvY3VtZW50VHlwZXNSZWdleHApKSB7XG4gICAgICAgIGlmIChzdHJlYW0ucGVlaygpID09IFwiKFwiKSBzdGF0ZS50b2tlbml6ZSA9IHRva2VuUGFyZW50aGVzaXplZDtcbiAgICAgICAgcmV0dXJuIFtcInByb3BlcnR5XCIsIFwid29yZFwiXTtcbiAgICAgIH1cbiAgICAgIC8vIE1peGlucyAvIEZ1bmN0aW9uc1xuICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXlthLXpdW1xcdy1dKlxcKC9pKSkge1xuICAgICAgICBzdHJlYW0uYmFja1VwKDEpO1xuICAgICAgICByZXR1cm4gW1wia2V5d29yZFwiLCBcIm1peGluXCJdO1xuICAgICAgfVxuICAgICAgLy8gQmxvY2sgbWl4aW5zXG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eKFxcK3wtKVthLXpdW1xcdy1dKlxcKC9pKSkge1xuICAgICAgICBzdHJlYW0uYmFja1VwKDEpO1xuICAgICAgICByZXR1cm4gW1wia2V5d29yZFwiLCBcImJsb2NrLW1peGluXCJdO1xuICAgICAgfVxuICAgICAgLy8gUGFyZW50IFJlZmVyZW5jZSBCRU0gbmFtaW5nXG4gICAgICBpZiAoc3RyZWFtLnN0cmluZy5tYXRjaCgvXlxccyomLykgJiYgc3RyZWFtLm1hdGNoKC9eWy1fXStbYS16XVtcXHctXSovKSkge1xuICAgICAgICByZXR1cm4gW1wicXVhbGlmaWVyXCIsIFwicXVhbGlmaWVyXCJdO1xuICAgICAgfVxuICAgICAgLy8gLyBSb290IFJlZmVyZW5jZSAmIFBhcmVudCBSZWZlcmVuY2VcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goL14oXFwvfCYpKC18X3w6fFxcLnwjfFthLXpdKS8pKSB7XG4gICAgICAgIHN0cmVhbS5iYWNrVXAoMSk7XG4gICAgICAgIHJldHVybiBbXCJ2YXJpYWJsZS0zXCIsIFwicmVmZXJlbmNlXCJdO1xuICAgICAgfVxuICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXiZ7MX1cXHMqJC8pKSB7XG4gICAgICAgIHJldHVybiBbXCJ2YXJpYWJsZS0zXCIsIFwicmVmZXJlbmNlXCJdO1xuICAgICAgfVxuICAgICAgLy8gV29yZCBvcGVyYXRvclxuICAgICAgaWYgKHN0cmVhbS5tYXRjaCh3b3JkT3BlcmF0b3JLZXl3b3Jkc1JlZ2V4cCkpIHtcbiAgICAgICAgcmV0dXJuIFtcIm9wZXJhdG9yXCIsIFwib3BlcmF0b3JcIl07XG4gICAgICB9XG4gICAgICAvLyBXb3JkXG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eXFwkP1stX10qW2EtejAtOV0rW1xcdy1dKi9pKSkge1xuICAgICAgICAvLyBWYXJpYWJsZVxuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eKFxcLnxcXFspW1xcdy1cXCdcXFwiXFxdXSsvaSwgZmFsc2UpKSB7XG4gICAgICAgICAgaWYgKCF3b3JkSXNUYWcoc3RyZWFtLmN1cnJlbnQoKSkpIHtcbiAgICAgICAgICAgIHN0cmVhbS5tYXRjaCgnLicpO1xuICAgICAgICAgICAgcmV0dXJuIFtcInZhcmlhYmxlLTJcIiwgXCJ2YXJpYWJsZS1uYW1lXCJdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1widmFyaWFibGUtMlwiLCBcIndvcmRcIl07XG4gICAgICB9XG4gICAgICAvLyBPcGVyYXRvcnNcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2gob3BlcmF0b3JzUmVnZXhwKSkge1xuICAgICAgICByZXR1cm4gW1wib3BlcmF0b3JcIiwgc3RyZWFtLmN1cnJlbnQoKV07XG4gICAgICB9XG4gICAgICAvLyBEZWxpbWl0ZXJzXG4gICAgICBpZiAoL1s6Oyx7fVxcW1xcXVxcKFxcKV0vLnRlc3QoY2gpKSB7XG4gICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIHJldHVybiBbbnVsbCwgY2hdO1xuICAgICAgfVxuICAgICAgLy8gTm9uLWRldGVjdGVkIGl0ZW1zXG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgcmV0dXJuIFtudWxsLCBudWxsXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2tlbiBjb21tZW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9rZW5DQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgbWF5YmVFbmQgPSBmYWxzZSwgY2g7XG4gICAgICB3aGlsZSAoKGNoID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgICBpZiAobWF5YmVFbmQgJiYgY2ggPT0gXCIvXCIpIHtcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IG51bGw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbWF5YmVFbmQgPSAoY2ggPT0gXCIqXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtcImNvbW1lbnRcIiwgXCJjb21tZW50XCJdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRva2VuIHN0cmluZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRva2VuU3RyaW5nKHF1b3RlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgICB2YXIgZXNjYXBlZCA9IGZhbHNlLCBjaDtcbiAgICAgICAgd2hpbGUgKChjaCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoY2ggPT0gcXVvdGUgJiYgIWVzY2FwZWQpIHtcbiAgICAgICAgICAgIGlmIChxdW90ZSA9PSBcIilcIikgc3RyZWFtLmJhY2tVcCgxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQgJiYgY2ggPT0gXCJcXFxcXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoID09IHF1b3RlIHx8ICFlc2NhcGVkICYmIHF1b3RlICE9IFwiKVwiKSBzdGF0ZS50b2tlbml6ZSA9IG51bGw7XG4gICAgICAgIHJldHVybiBbXCJzdHJpbmdcIiwgXCJzdHJpbmdcIl07XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRva2VuIHBhcmVudGhlc2l6ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b2tlblBhcmVudGhlc2l6ZWQoc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgc3RyZWFtLm5leHQoKTsgLy8gTXVzdCBiZSBcIihcIlxuICAgICAgaWYgKCFzdHJlYW0ubWF0Y2goL1xccypbXFxcIlxcJyldLywgZmFsc2UpKVxuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuU3RyaW5nKFwiKVwiKTtcbiAgICAgIGVsc2VcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSBudWxsO1xuICAgICAgcmV0dXJuIFtudWxsLCBcIihcIl07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udGV4dCBtYW5hZ2VtZW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29udGV4dCh0eXBlLCBpbmRlbnQsIHByZXYsIGxpbmUpIHtcbiAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICB0aGlzLmluZGVudCA9IGluZGVudDtcbiAgICAgIHRoaXMucHJldiA9IHByZXY7XG4gICAgICB0aGlzLmxpbmUgPSBsaW5lIHx8IHtmaXJzdFdvcmQ6IFwiXCIsIGluZGVudDogMH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgdHlwZSwgaW5kZW50KSB7XG4gICAgICBpbmRlbnQgPSBpbmRlbnQgPj0gMCA/IGluZGVudCA6IGluZGVudFVuaXQ7XG4gICAgICBzdGF0ZS5jb250ZXh0ID0gbmV3IENvbnRleHQodHlwZSwgc3RyZWFtLmluZGVudGF0aW9uKCkgKyBpbmRlbnQsIHN0YXRlLmNvbnRleHQpO1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9wQ29udGV4dChzdGF0ZSwgY3VycmVudEluZGVudCkge1xuICAgICAgdmFyIGNvbnRleHRJbmRlbnQgPSBzdGF0ZS5jb250ZXh0LmluZGVudCAtIGluZGVudFVuaXQ7XG4gICAgICBjdXJyZW50SW5kZW50ID0gY3VycmVudEluZGVudCB8fCBmYWxzZTtcbiAgICAgIHN0YXRlLmNvbnRleHQgPSBzdGF0ZS5jb250ZXh0LnByZXY7XG4gICAgICBpZiAoY3VycmVudEluZGVudCkgc3RhdGUuY29udGV4dC5pbmRlbnQgPSBjb250ZXh0SW5kZW50O1xuICAgICAgcmV0dXJuIHN0YXRlLmNvbnRleHQudHlwZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXNzKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHJldHVybiBzdGF0ZXNbc3RhdGUuY29udGV4dC50eXBlXSh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb3BBbmRQYXNzKHR5cGUsIHN0cmVhbSwgc3RhdGUsIG4pIHtcbiAgICAgIGZvciAodmFyIGkgPSBuIHx8IDE7IGkgPiAwOyBpLS0pXG4gICAgICAgIHN0YXRlLmNvbnRleHQgPSBzdGF0ZS5jb250ZXh0LnByZXY7XG4gICAgICByZXR1cm4gcGFzcyh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFBhcnNlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdvcmRJc1RhZyh3b3JkKSB7XG4gICAgICByZXR1cm4gd29yZC50b0xvd2VyQ2FzZSgpIGluIHRhZ0tleXdvcmRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdvcmRJc1Byb3BlcnR5KHdvcmQpIHtcbiAgICAgIHdvcmQgPSB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgICByZXR1cm4gd29yZCBpbiBwcm9wZXJ0eUtleXdvcmRzIHx8IHdvcmQgaW4gZm9udFByb3BlcnRpZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd29yZElzQmxvY2sod29yZCkge1xuICAgICAgcmV0dXJuIHdvcmQudG9Mb3dlckNhc2UoKSBpbiBibG9ja0tleXdvcmRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdvcmRJc1ZlbmRvclByZWZpeCh3b3JkKSB7XG4gICAgICByZXR1cm4gd29yZC50b0xvd2VyQ2FzZSgpLm1hdGNoKHZlbmRvclByZWZpeGVzUmVnZXhwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3b3JkQXNWYWx1ZSh3b3JkKSB7XG4gICAgICB2YXIgd29yZExDID0gd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIG92ZXJyaWRlID0gXCJ2YXJpYWJsZS0yXCI7XG4gICAgICBpZiAod29yZElzVGFnKHdvcmQpKSBvdmVycmlkZSA9IFwidGFnXCI7XG4gICAgICBlbHNlIGlmICh3b3JkSXNCbG9jayh3b3JkKSkgb3ZlcnJpZGUgPSBcImJsb2NrLWtleXdvcmRcIjtcbiAgICAgIGVsc2UgaWYgKHdvcmRJc1Byb3BlcnR5KHdvcmQpKSBvdmVycmlkZSA9IFwicHJvcGVydHlcIjtcbiAgICAgIGVsc2UgaWYgKHdvcmRMQyBpbiB2YWx1ZUtleXdvcmRzIHx8IHdvcmRMQyBpbiBjb21tb25BdG9tcykgb3ZlcnJpZGUgPSBcImF0b21cIjtcbiAgICAgIGVsc2UgaWYgKHdvcmRMQyA9PSBcInJldHVyblwiIHx8IHdvcmRMQyBpbiBjb2xvcktleXdvcmRzKSBvdmVycmlkZSA9IFwia2V5d29yZFwiO1xuXG4gICAgICAvLyBGb250IGZhbWlseVxuICAgICAgZWxzZSBpZiAod29yZC5tYXRjaCgvXltBLVpdLykpIG92ZXJyaWRlID0gXCJzdHJpbmdcIjtcbiAgICAgIHJldHVybiBvdmVycmlkZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0eXBlSXNCbG9jayh0eXBlLCBzdHJlYW0pIHtcbiAgICAgIHJldHVybiAoKGVuZE9mTGluZShzdHJlYW0pICYmICh0eXBlID09IFwie1wiIHx8IHR5cGUgPT0gXCJdXCIgfHwgdHlwZSA9PSBcImhhc2hcIiB8fCB0eXBlID09IFwicXVhbGlmaWVyXCIpKSB8fCB0eXBlID09IFwiYmxvY2stbWl4aW5cIik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHlwZUlzSW50ZXJwb2xhdGlvbih0eXBlLCBzdHJlYW0pIHtcbiAgICAgIHJldHVybiB0eXBlID09IFwie1wiICYmIHN0cmVhbS5tYXRjaCgvXlxccypcXCQ/W1xcdy1dKy9pLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHlwZUlzUHNldWRvKHR5cGUsIHN0cmVhbSkge1xuICAgICAgcmV0dXJuIHR5cGUgPT0gXCI6XCIgJiYgc3RyZWFtLm1hdGNoKC9eW2Etei1dKy8sIGZhbHNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGFydE9mTGluZShzdHJlYW0pIHtcbiAgICAgIHJldHVybiBzdHJlYW0uc29sKCkgfHwgc3RyZWFtLnN0cmluZy5tYXRjaChuZXcgUmVnRXhwKFwiXlxcXFxzKlwiICsgZXNjYXBlUmVnRXhwKHN0cmVhbS5jdXJyZW50KCkpKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5kT2ZMaW5lKHN0cmVhbSkge1xuICAgICAgcmV0dXJuIHN0cmVhbS5lb2woKSB8fCBzdHJlYW0ubWF0Y2goL15cXHMqJC8sIGZhbHNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaXJzdFdvcmRPZkxpbmUobGluZSkge1xuICAgICAgdmFyIHJlID0gL15cXHMqWy1fXSpbYS16MC05XStbXFx3LV0qL2k7XG4gICAgICB2YXIgcmVzdWx0ID0gdHlwZW9mIGxpbmUgPT0gXCJzdHJpbmdcIiA/IGxpbmUubWF0Y2gocmUpIDogbGluZS5zdHJpbmcubWF0Y2gocmUpO1xuICAgICAgcmV0dXJuIHJlc3VsdCA/IHJlc3VsdFswXS5yZXBsYWNlKC9eXFxzKi8sIFwiXCIpIDogXCJcIjtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEJsb2NrXG4gICAgICovXG4gICAgc3RhdGVzLmJsb2NrID0gZnVuY3Rpb24odHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKCh0eXBlID09IFwiY29tbWVudFwiICYmIHN0YXJ0T2ZMaW5lKHN0cmVhbSkpIHx8XG4gICAgICAgICAgKHR5cGUgPT0gXCIsXCIgJiYgZW5kT2ZMaW5lKHN0cmVhbSkpIHx8XG4gICAgICAgICAgdHlwZSA9PSBcIm1peGluXCIpIHtcbiAgICAgICAgcmV0dXJuIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0sIFwiYmxvY2tcIiwgMCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZUlzSW50ZXJwb2xhdGlvbih0eXBlLCBzdHJlYW0pKSB7XG4gICAgICAgIHJldHVybiBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLCBcImludGVycG9sYXRpb25cIik7XG4gICAgICB9XG4gICAgICBpZiAoZW5kT2ZMaW5lKHN0cmVhbSkgJiYgdHlwZSA9PSBcIl1cIikge1xuICAgICAgICBpZiAoIS9eXFxzKihcXC58I3w6fFxcW3xcXCp8JikvLnRlc3Qoc3RyZWFtLnN0cmluZykgJiYgIXdvcmRJc1RhZyhmaXJzdFdvcmRPZkxpbmUoc3RyZWFtKSkpIHtcbiAgICAgICAgICByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJibG9ja1wiLCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVJc0Jsb2NrKHR5cGUsIHN0cmVhbSkpIHtcbiAgICAgICAgcmV0dXJuIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0sIFwiYmxvY2tcIik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PSBcIn1cIiAmJiBlbmRPZkxpbmUoc3RyZWFtKSkge1xuICAgICAgICByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJibG9ja1wiLCAwKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09IFwidmFyaWFibGUtbmFtZVwiKSB7XG4gICAgICAgIGlmIChzdHJlYW0uc3RyaW5nLm1hdGNoKC9eXFxzP1xcJFtcXHctXFwuXFxbXFxdXFwnXFxcIl0rJC8pIHx8IHdvcmRJc0Jsb2NrKGZpcnN0V29yZE9mTGluZShzdHJlYW0pKSkge1xuICAgICAgICAgIHJldHVybiBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLCBcInZhcmlhYmxlTmFtZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJ2YXJpYWJsZU5hbWVcIiwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09IFwiPVwiKSB7XG4gICAgICAgIGlmICghZW5kT2ZMaW5lKHN0cmVhbSkgJiYgIXdvcmRJc0Jsb2NrKGZpcnN0V29yZE9mTGluZShzdHJlYW0pKSkge1xuICAgICAgICAgIHJldHVybiBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLCBcImJsb2NrXCIsIDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLCBcImJsb2NrXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT0gXCIqXCIpIHtcbiAgICAgICAgaWYgKGVuZE9mTGluZShzdHJlYW0pIHx8IHN0cmVhbS5tYXRjaCgvXFxzKigsfFxcLnwjfFxcW3w6fHspLyxmYWxzZSkpIHtcbiAgICAgICAgICBvdmVycmlkZSA9IFwidGFnXCI7XG4gICAgICAgICAgcmV0dXJuIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0sIFwiYmxvY2tcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlSXNQc2V1ZG8odHlwZSwgc3RyZWFtKSkge1xuICAgICAgICByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJwc2V1ZG9cIik7XG4gICAgICB9XG4gICAgICBpZiAoL0AoZm9udC1mYWNlfG1lZGlhfHN1cHBvcnRzfCgtbW96LSk/ZG9jdW1lbnQpLy50ZXN0KHR5cGUpKSB7XG4gICAgICAgIHJldHVybiBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLCBlbmRPZkxpbmUoc3RyZWFtKSA/IFwiYmxvY2tcIiA6IFwiYXRCbG9ja1wiKTtcbiAgICAgIH1cbiAgICAgIGlmICgvQCgtKG1venxtc3xvfHdlYmtpdCktKT9rZXlmcmFtZXMkLy50ZXN0KHR5cGUpKSB7XG4gICAgICAgIHJldHVybiBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLCBcImtleWZyYW1lc1wiKTtcbiAgICAgIH1cbiAgICAgIGlmICgvQGV4dGVuZHM/Ly50ZXN0KHR5cGUpKSB7XG4gICAgICAgIHJldHVybiBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLCBcImV4dGVuZFwiLCAwKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlICYmIHR5cGUuY2hhckF0KDApID09IFwiQFwiKSB7XG5cbiAgICAgICAgLy8gUHJvcGVydHkgTG9va3VwXG4gICAgICAgIGlmIChzdHJlYW0uaW5kZW50YXRpb24oKSA+IDAgJiYgd29yZElzUHJvcGVydHkoc3RyZWFtLmN1cnJlbnQoKS5zbGljZSgxKSkpIHtcbiAgICAgICAgICBvdmVycmlkZSA9IFwidmFyaWFibGUtMlwiO1xuICAgICAgICAgIHJldHVybiBcImJsb2NrXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKC8oQGltcG9ydHxAcmVxdWlyZXxAY2hhcnNldCkvLnRlc3QodHlwZSkpIHtcbiAgICAgICAgICByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJibG9ja1wiLCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJibG9ja1wiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09IFwicmVmZXJlbmNlXCIgJiYgZW5kT2ZMaW5lKHN0cmVhbSkpIHtcbiAgICAgICAgcmV0dXJuIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0sIFwiYmxvY2tcIik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PSBcIihcIikge1xuICAgICAgICByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJwYXJlbnNcIik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlID09IFwidmVuZG9yLXByZWZpeGVzXCIpIHtcbiAgICAgICAgcmV0dXJuIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0sIFwidmVuZG9yUHJlZml4ZXNcIik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PSBcIndvcmRcIikge1xuICAgICAgICB2YXIgd29yZCA9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAgICAgIG92ZXJyaWRlID0gd29yZEFzVmFsdWUod29yZCk7XG5cbiAgICAgICAgaWYgKG92ZXJyaWRlID09IFwicHJvcGVydHlcIikge1xuICAgICAgICAgIGlmIChzdGFydE9mTGluZShzdHJlYW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJibG9ja1wiLCAwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3ZlcnJpZGUgPSBcImF0b21cIjtcbiAgICAgICAgICAgIHJldHVybiBcImJsb2NrXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG92ZXJyaWRlID09IFwidGFnXCIpIHtcblxuICAgICAgICAgIC8vIHRhZyBpcyBhIGNzcyB2YWx1ZVxuICAgICAgICAgIGlmICgvZW1iZWR8bWVudXxwcmV8cHJvZ3Jlc3N8c3VifHRhYmxlLy50ZXN0KHdvcmQpKSB7XG4gICAgICAgICAgICBpZiAod29yZElzUHJvcGVydHkoZmlyc3RXb3JkT2ZMaW5lKHN0cmVhbSkpKSB7XG4gICAgICAgICAgICAgIG92ZXJyaWRlID0gXCJhdG9tXCI7XG4gICAgICAgICAgICAgIHJldHVybiBcImJsb2NrXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdGFnIGlzIGFuIGF0dHJpYnV0ZVxuICAgICAgICAgIGlmIChzdHJlYW0uc3RyaW5nLm1hdGNoKG5ldyBSZWdFeHAoXCJcXFxcW1xcXFxzKlwiICsgd29yZCArIFwifFwiICsgd29yZCArXCJcXFxccypcXFxcXVwiKSkpIHtcbiAgICAgICAgICAgIG92ZXJyaWRlID0gXCJhdG9tXCI7XG4gICAgICAgICAgICByZXR1cm4gXCJibG9ja1wiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHRhZyBpcyBhIHZhcmlhYmxlXG4gICAgICAgICAgaWYgKHRhZ1ZhcmlhYmxlc1JlZ2V4cC50ZXN0KHdvcmQpKSB7XG4gICAgICAgICAgICBpZiAoKHN0YXJ0T2ZMaW5lKHN0cmVhbSkgJiYgc3RyZWFtLnN0cmluZy5tYXRjaCgvPS8pKSB8fFxuICAgICAgICAgICAgICAgICghc3RhcnRPZkxpbmUoc3RyZWFtKSAmJlxuICAgICAgICAgICAgICAgICAhc3RyZWFtLnN0cmluZy5tYXRjaCgvXihcXHMqXFwufCN8XFwmfFxcW3xcXC98PnxcXCopLykgJiZcbiAgICAgICAgICAgICAgICAgIXdvcmRJc1RhZyhmaXJzdFdvcmRPZkxpbmUoc3RyZWFtKSkpKSB7XG4gICAgICAgICAgICAgIG92ZXJyaWRlID0gXCJ2YXJpYWJsZS0yXCI7XG4gICAgICAgICAgICAgIGlmICh3b3JkSXNCbG9jayhmaXJzdFdvcmRPZkxpbmUoc3RyZWFtKSkpICByZXR1cm4gXCJibG9ja1wiO1xuICAgICAgICAgICAgICByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJibG9ja1wiLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZW5kT2ZMaW5lKHN0cmVhbSkpIHJldHVybiBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLCBcImJsb2NrXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdmVycmlkZSA9PSBcImJsb2NrLWtleXdvcmRcIikge1xuICAgICAgICAgIG92ZXJyaWRlID0gXCJrZXl3b3JkXCI7XG5cbiAgICAgICAgICAvLyBQb3N0Zml4IGNvbmRpdGlvbmFsc1xuICAgICAgICAgIGlmIChzdHJlYW0uY3VycmVudCgvKGlmfHVubGVzcykvKSAmJiAhc3RhcnRPZkxpbmUoc3RyZWFtKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiYmxvY2tcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0sIFwiYmxvY2tcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdvcmQgPT0gXCJyZXR1cm5cIikgcmV0dXJuIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0sIFwiYmxvY2tcIiwgMCk7XG5cbiAgICAgICAgLy8gUGxhY2Vob2xkZXIgc2VsZWN0b3JcbiAgICAgICAgaWYgKG92ZXJyaWRlID09IFwidmFyaWFibGUtMlwiICYmIHN0cmVhbS5zdHJpbmcubWF0Y2goL15cXHM/XFwkW1xcdy1cXC5cXFtcXF1cXCdcXFwiXSskLykpIHtcbiAgICAgICAgICByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJibG9ja1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXRlLmNvbnRleHQudHlwZTtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBQYXJlbnNcbiAgICAgKi9cbiAgICBzdGF0ZXMucGFyZW5zID0gZnVuY3Rpb24odHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKHR5cGUgPT0gXCIoXCIpIHJldHVybiBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLCBcInBhcmVuc1wiKTtcbiAgICAgIGlmICh0eXBlID09IFwiKVwiKSB7XG4gICAgICAgIGlmIChzdGF0ZS5jb250ZXh0LnByZXYudHlwZSA9PSBcInBhcmVuc1wiKSB7XG4gICAgICAgICAgcmV0dXJuIHBvcENvbnRleHQoc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoc3RyZWFtLnN0cmluZy5tYXRjaCgvXlthLXpdW1xcdy1dKlxcKC9pKSAmJiBlbmRPZkxpbmUoc3RyZWFtKSkgfHxcbiAgICAgICAgICAgIHdvcmRJc0Jsb2NrKGZpcnN0V29yZE9mTGluZShzdHJlYW0pKSB8fFxuICAgICAgICAgICAgLyhcXC58I3w6fFxcW3xcXCp8Jnw+fH58XFwrfFxcLykvLnRlc3QoZmlyc3RXb3JkT2ZMaW5lKHN0cmVhbSkpIHx8XG4gICAgICAgICAgICAoIXN0cmVhbS5zdHJpbmcubWF0Y2goL14tP1thLXpdW1xcdy1cXC5cXFtcXF1cXCdcXFwiXSpcXHMqPS8pICYmXG4gICAgICAgICAgICAgd29yZElzVGFnKGZpcnN0V29yZE9mTGluZShzdHJlYW0pKSkpIHtcbiAgICAgICAgICByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJibG9ja1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtLnN0cmluZy5tYXRjaCgvXltcXCQtXT9bYS16XVtcXHctXFwuXFxbXFxdXFwnXFxcIl0qXFxzKj0vKSB8fFxuICAgICAgICAgICAgc3RyZWFtLnN0cmluZy5tYXRjaCgvXlxccyooXFwofFxcKXxbMC05XSkvKSB8fFxuICAgICAgICAgICAgc3RyZWFtLnN0cmluZy5tYXRjaCgvXlxccytbYS16XVtcXHctXSpcXCgvaSkgfHxcbiAgICAgICAgICAgIHN0cmVhbS5zdHJpbmcubWF0Y2goL15cXHMrW1xcJC1dP1thLXpdL2kpKSB7XG4gICAgICAgICAgcmV0dXJuIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0sIFwiYmxvY2tcIiwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZE9mTGluZShzdHJlYW0pKSByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJibG9ja1wiKTtcbiAgICAgICAgZWxzZSByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJibG9ja1wiLCAwKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlICYmIHR5cGUuY2hhckF0KDApID09IFwiQFwiICYmIHdvcmRJc1Byb3BlcnR5KHN0cmVhbS5jdXJyZW50KCkuc2xpY2UoMSkpKSB7XG4gICAgICAgIG92ZXJyaWRlID0gXCJ2YXJpYWJsZS0yXCI7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PSBcIndvcmRcIikge1xuICAgICAgICB2YXIgd29yZCA9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAgICAgIG92ZXJyaWRlID0gd29yZEFzVmFsdWUod29yZCk7XG4gICAgICAgIGlmIChvdmVycmlkZSA9PSBcInRhZ1wiICYmIHRhZ1ZhcmlhYmxlc1JlZ2V4cC50ZXN0KHdvcmQpKSB7XG4gICAgICAgICAgb3ZlcnJpZGUgPSBcInZhcmlhYmxlLTJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3ZlcnJpZGUgPT0gXCJwcm9wZXJ0eVwiIHx8IHdvcmQgPT0gXCJ0b1wiKSBvdmVycmlkZSA9IFwiYXRvbVwiO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZS1uYW1lXCIpIHtcbiAgICAgICAgcmV0dXJuIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0sIFwidmFyaWFibGVOYW1lXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVJc1BzZXVkbyh0eXBlLCBzdHJlYW0pKSB7XG4gICAgICAgIHJldHVybiBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLCBcInBzZXVkb1wiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGF0ZS5jb250ZXh0LnR5cGU7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogVmVuZG9yIHByZWZpeGVzXG4gICAgICovXG4gICAgc3RhdGVzLnZlbmRvclByZWZpeGVzID0gZnVuY3Rpb24odHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKHR5cGUgPT0gXCJ3b3JkXCIpIHtcbiAgICAgICAgb3ZlcnJpZGUgPSBcInByb3BlcnR5XCI7XG4gICAgICAgIHJldHVybiBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLCBcImJsb2NrXCIsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBvcENvbnRleHQoc3RhdGUpO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIFBzZXVkb1xuICAgICAqL1xuICAgIHN0YXRlcy5wc2V1ZG8gPSBmdW5jdGlvbih0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAoIXdvcmRJc1Byb3BlcnR5KGZpcnN0V29yZE9mTGluZShzdHJlYW0uc3RyaW5nKSkpIHtcbiAgICAgICAgc3RyZWFtLm1hdGNoKC9eW2Etei1dKy8pO1xuICAgICAgICBvdmVycmlkZSA9IFwidmFyaWFibGUtM1wiO1xuICAgICAgICBpZiAoZW5kT2ZMaW5lKHN0cmVhbSkpIHJldHVybiBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLCBcImJsb2NrXCIpO1xuICAgICAgICByZXR1cm4gcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9wQW5kUGFzcyh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBhdEJsb2NrXG4gICAgICovXG4gICAgc3RhdGVzLmF0QmxvY2sgPSBmdW5jdGlvbih0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAodHlwZSA9PSBcIihcIikgcmV0dXJuIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0sIFwiYXRCbG9ja19wYXJlbnNcIik7XG4gICAgICBpZiAodHlwZUlzQmxvY2sodHlwZSwgc3RyZWFtKSkge1xuICAgICAgICByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJibG9ja1wiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlSXNJbnRlcnBvbGF0aW9uKHR5cGUsIHN0cmVhbSkpIHtcbiAgICAgICAgcmV0dXJuIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0sIFwiaW50ZXJwb2xhdGlvblwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09IFwid29yZFwiKSB7XG4gICAgICAgIHZhciB3b3JkID0gc3RyZWFtLmN1cnJlbnQoKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoL14ob25seXxub3R8YW5kfG9yKSQvLnRlc3Qod29yZCkpXG4gICAgICAgICAgb3ZlcnJpZGUgPSBcImtleXdvcmRcIjtcbiAgICAgICAgZWxzZSBpZiAoZG9jdW1lbnRUeXBlcy5oYXNPd25Qcm9wZXJ0eSh3b3JkKSlcbiAgICAgICAgICBvdmVycmlkZSA9IFwidGFnXCI7XG4gICAgICAgIGVsc2UgaWYgKG1lZGlhVHlwZXMuaGFzT3duUHJvcGVydHkod29yZCkpXG4gICAgICAgICAgb3ZlcnJpZGUgPSBcImF0dHJpYnV0ZVwiO1xuICAgICAgICBlbHNlIGlmIChtZWRpYUZlYXR1cmVzLmhhc093blByb3BlcnR5KHdvcmQpKVxuICAgICAgICAgIG92ZXJyaWRlID0gXCJwcm9wZXJ0eVwiO1xuICAgICAgICBlbHNlIGlmIChub25TdGFuZGFyZFByb3BlcnR5S2V5d29yZHMuaGFzT3duUHJvcGVydHkod29yZCkpXG4gICAgICAgICAgb3ZlcnJpZGUgPSBcInN0cmluZy0yXCI7XG4gICAgICAgIGVsc2Ugb3ZlcnJpZGUgPSB3b3JkQXNWYWx1ZShzdHJlYW0uY3VycmVudCgpKTtcbiAgICAgICAgaWYgKG92ZXJyaWRlID09IFwidGFnXCIgJiYgZW5kT2ZMaW5lKHN0cmVhbSkpIHtcbiAgICAgICAgICByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJibG9ja1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT0gXCJvcGVyYXRvclwiICYmIC9eKG5vdHxhbmR8b3IpJC8udGVzdChzdHJlYW0uY3VycmVudCgpKSkge1xuICAgICAgICBvdmVycmlkZSA9IFwia2V5d29yZFwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXRlLmNvbnRleHQudHlwZTtcbiAgICB9O1xuXG4gICAgc3RhdGVzLmF0QmxvY2tfcGFyZW5zID0gZnVuY3Rpb24odHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKHR5cGUgPT0gXCJ7XCIgfHwgdHlwZSA9PSBcIn1cIikgcmV0dXJuIHN0YXRlLmNvbnRleHQudHlwZTtcbiAgICAgIGlmICh0eXBlID09IFwiKVwiKSB7XG4gICAgICAgIGlmIChlbmRPZkxpbmUoc3RyZWFtKSkgcmV0dXJuIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0sIFwiYmxvY2tcIik7XG4gICAgICAgIGVsc2UgcmV0dXJuIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0sIFwiYXRCbG9ja1wiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09IFwid29yZFwiKSB7XG4gICAgICAgIHZhciB3b3JkID0gc3RyZWFtLmN1cnJlbnQoKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBvdmVycmlkZSA9IHdvcmRBc1ZhbHVlKHdvcmQpO1xuICAgICAgICBpZiAoL14obWF4fG1pbikvLnRlc3Qod29yZCkpIG92ZXJyaWRlID0gXCJwcm9wZXJ0eVwiO1xuICAgICAgICBpZiAob3ZlcnJpZGUgPT0gXCJ0YWdcIikge1xuICAgICAgICAgIHRhZ1ZhcmlhYmxlc1JlZ2V4cC50ZXN0KHdvcmQpID8gb3ZlcnJpZGUgPSBcInZhcmlhYmxlLTJcIiA6IG92ZXJyaWRlID0gXCJhdG9tXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlLmNvbnRleHQudHlwZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGF0ZXMuYXRCbG9jayh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBLZXlmcmFtZXNcbiAgICAgKi9cbiAgICBzdGF0ZXMua2V5ZnJhbWVzID0gZnVuY3Rpb24odHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKHN0cmVhbS5pbmRlbnRhdGlvbigpID09IFwiMFwiICYmICgodHlwZSA9PSBcIn1cIiAmJiBzdGFydE9mTGluZShzdHJlYW0pKSB8fCB0eXBlID09IFwiXVwiIHx8IHR5cGUgPT0gXCJoYXNoXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHR5cGUgPT0gXCJxdWFsaWZpZXJcIiB8fCB3b3JkSXNUYWcoc3RyZWFtLmN1cnJlbnQoKSkpKSB7XG4gICAgICAgIHJldHVybiBwb3BBbmRQYXNzKHR5cGUsIHN0cmVhbSwgc3RhdGUpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT0gXCJ7XCIpIHJldHVybiBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLCBcImtleWZyYW1lc1wiKTtcbiAgICAgIGlmICh0eXBlID09IFwifVwiKSB7XG4gICAgICAgIGlmIChzdGFydE9mTGluZShzdHJlYW0pKSByZXR1cm4gcG9wQ29udGV4dChzdGF0ZSwgdHJ1ZSk7XG4gICAgICAgIGVsc2UgcmV0dXJuIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0sIFwia2V5ZnJhbWVzXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT0gXCJ1bml0XCIgJiYgL15bMC05XStcXCUkLy50ZXN0KHN0cmVhbS5jdXJyZW50KCkpKSB7XG4gICAgICAgIHJldHVybiBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLCBcImtleWZyYW1lc1wiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09IFwid29yZFwiKSB7XG4gICAgICAgIG92ZXJyaWRlID0gd29yZEFzVmFsdWUoc3RyZWFtLmN1cnJlbnQoKSk7XG4gICAgICAgIGlmIChvdmVycmlkZSA9PSBcImJsb2NrLWtleXdvcmRcIikge1xuICAgICAgICAgIG92ZXJyaWRlID0gXCJrZXl3b3JkXCI7XG4gICAgICAgICAgcmV0dXJuIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0sIFwia2V5ZnJhbWVzXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoL0AoZm9udC1mYWNlfG1lZGlhfHN1cHBvcnRzfCgtbW96LSk/ZG9jdW1lbnQpLy50ZXN0KHR5cGUpKSB7XG4gICAgICAgIHJldHVybiBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLCBlbmRPZkxpbmUoc3RyZWFtKSA/IFwiYmxvY2tcIiA6IFwiYXRCbG9ja1wiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09IFwibWl4aW5cIikge1xuICAgICAgICByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJibG9ja1wiLCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGF0ZS5jb250ZXh0LnR5cGU7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogSW50ZXJwb2xhdGlvblxuICAgICAqL1xuICAgIHN0YXRlcy5pbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24odHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKHR5cGUgPT0gXCJ7XCIpIHBvcENvbnRleHQoc3RhdGUpICYmIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0sIFwiYmxvY2tcIik7XG4gICAgICBpZiAodHlwZSA9PSBcIn1cIikge1xuICAgICAgICBpZiAoc3RyZWFtLnN0cmluZy5tYXRjaCgvXlxccyooXFwufCN8OnxcXFt8XFwqfCZ8Pnx+fFxcK3xcXC8pL2kpIHx8XG4gICAgICAgICAgICAoc3RyZWFtLnN0cmluZy5tYXRjaCgvXlxccypbYS16XS9pKSAmJiB3b3JkSXNUYWcoZmlyc3RXb3JkT2ZMaW5lKHN0cmVhbSkpKSkge1xuICAgICAgICAgIHJldHVybiBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLCBcImJsb2NrXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RyZWFtLnN0cmluZy5tYXRjaCgvXihcXHt8XFxzKlxcJikvKSB8fFxuICAgICAgICAgICAgc3RyZWFtLm1hdGNoKC9cXHMqW1xcdy1dLyxmYWxzZSkpIHtcbiAgICAgICAgICByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJibG9ja1wiLCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJibG9ja1wiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09IFwidmFyaWFibGUtbmFtZVwiKSB7XG4gICAgICAgIHJldHVybiBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLCBcInZhcmlhYmxlTmFtZVwiLCAwKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09IFwid29yZFwiKSB7XG4gICAgICAgIG92ZXJyaWRlID0gd29yZEFzVmFsdWUoc3RyZWFtLmN1cnJlbnQoKSk7XG4gICAgICAgIGlmIChvdmVycmlkZSA9PSBcInRhZ1wiKSBvdmVycmlkZSA9IFwiYXRvbVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXRlLmNvbnRleHQudHlwZTtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBFeHRlbmQvc1xuICAgICAqL1xuICAgIHN0YXRlcy5leHRlbmQgPSBmdW5jdGlvbih0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAodHlwZSA9PSBcIltcIiB8fCB0eXBlID09IFwiPVwiKSByZXR1cm4gXCJleHRlbmRcIjtcbiAgICAgIGlmICh0eXBlID09IFwiXVwiKSByZXR1cm4gcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICBpZiAodHlwZSA9PSBcIndvcmRcIikge1xuICAgICAgICBvdmVycmlkZSA9IHdvcmRBc1ZhbHVlKHN0cmVhbS5jdXJyZW50KCkpO1xuICAgICAgICByZXR1cm4gXCJleHRlbmRcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBWYXJpYWJsZSBuYW1lXG4gICAgICovXG4gICAgc3RhdGVzLnZhcmlhYmxlTmFtZSA9IGZ1bmN0aW9uKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmICh0eXBlID09IFwic3RyaW5nXCIgfHwgdHlwZSA9PSBcIltcIiB8fCB0eXBlID09IFwiXVwiIHx8IHN0cmVhbS5jdXJyZW50KCkubWF0Y2goL14oXFwufFxcJCkvKSkge1xuICAgICAgICBpZiAoc3RyZWFtLmN1cnJlbnQoKS5tYXRjaCgvXlxcLltcXHctXSsvaSkpIG92ZXJyaWRlID0gXCJ2YXJpYWJsZS0yXCI7XG4gICAgICAgIHJldHVybiBcInZhcmlhYmxlTmFtZVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBvcEFuZFBhc3ModHlwZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfTtcblxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKGJhc2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0b2tlbml6ZTogbnVsbCxcbiAgICAgICAgICBzdGF0ZTogXCJibG9ja1wiLFxuICAgICAgICAgIGNvbnRleHQ6IG5ldyBDb250ZXh0KFwiYmxvY2tcIiwgYmFzZSB8fCAwLCBudWxsKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIGlmICghc3RhdGUudG9rZW5pemUgJiYgc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xuICAgICAgICBzdHlsZSA9IChzdGF0ZS50b2tlbml6ZSB8fCB0b2tlbkJhc2UpKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICBpZiAoc3R5bGUgJiYgdHlwZW9mIHN0eWxlID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICB0eXBlID0gc3R5bGVbMV07XG4gICAgICAgICAgc3R5bGUgPSBzdHlsZVswXTtcbiAgICAgICAgfVxuICAgICAgICBvdmVycmlkZSA9IHN0eWxlO1xuICAgICAgICBzdGF0ZS5zdGF0ZSA9IHN0YXRlc1tzdGF0ZS5zdGF0ZV0odHlwZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIHJldHVybiBvdmVycmlkZTtcbiAgICAgIH0sXG4gICAgICBpbmRlbnQ6IGZ1bmN0aW9uKHN0YXRlLCB0ZXh0QWZ0ZXIsIGxpbmUpIHtcblxuICAgICAgICB2YXIgY3ggPSBzdGF0ZS5jb250ZXh0LFxuICAgICAgICAgICAgY2ggPSB0ZXh0QWZ0ZXIgJiYgdGV4dEFmdGVyLmNoYXJBdCgwKSxcbiAgICAgICAgICAgIGluZGVudCA9IGN4LmluZGVudCxcbiAgICAgICAgICAgIGxpbmVGaXJzdFdvcmQgPSBmaXJzdFdvcmRPZkxpbmUodGV4dEFmdGVyKSxcbiAgICAgICAgICAgIGxpbmVJbmRlbnQgPSBsaW5lLm1hdGNoKC9eXFxzKi8pWzBdLnJlcGxhY2UoL1xcdC9nLCBpbmRlbnRVbml0U3RyaW5nKS5sZW5ndGgsXG4gICAgICAgICAgICBwcmV2TGluZUZpcnN0V29yZCA9IHN0YXRlLmNvbnRleHQucHJldiA/IHN0YXRlLmNvbnRleHQucHJldi5saW5lLmZpcnN0V29yZCA6IFwiXCIsXG4gICAgICAgICAgICBwcmV2TGluZUluZGVudCA9IHN0YXRlLmNvbnRleHQucHJldiA/IHN0YXRlLmNvbnRleHQucHJldi5saW5lLmluZGVudCA6IGxpbmVJbmRlbnQ7XG5cbiAgICAgICAgaWYgKGN4LnByZXYgJiZcbiAgICAgICAgICAgIChjaCA9PSBcIn1cIiAmJiAoY3gudHlwZSA9PSBcImJsb2NrXCIgfHwgY3gudHlwZSA9PSBcImF0QmxvY2tcIiB8fCBjeC50eXBlID09IFwia2V5ZnJhbWVzXCIpIHx8XG4gICAgICAgICAgICAgY2ggPT0gXCIpXCIgJiYgKGN4LnR5cGUgPT0gXCJwYXJlbnNcIiB8fCBjeC50eXBlID09IFwiYXRCbG9ja19wYXJlbnNcIikgfHxcbiAgICAgICAgICAgICBjaCA9PSBcIntcIiAmJiAoY3gudHlwZSA9PSBcImF0XCIpKSkge1xuICAgICAgICAgIGluZGVudCA9IGN4LmluZGVudCAtIGluZGVudFVuaXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoISgvKFxcfSkvLnRlc3QoY2gpKSkge1xuICAgICAgICAgIGlmICgvQHxcXCR8XFxkLy50ZXN0KGNoKSB8fFxuICAgICAgICAgICAgICAvXlxcey8udGVzdCh0ZXh0QWZ0ZXIpIHx8XG4vXlxccypcXC8oXFwvfFxcKikvLnRlc3QodGV4dEFmdGVyKSB8fFxuICAgICAgICAgICAgICAvXlxccypcXC9cXCovLnRlc3QocHJldkxpbmVGaXJzdFdvcmQpIHx8XG4gICAgICAgICAgICAgIC9eXFxzKltcXHctXFwuXFxbXFxdXFwnXFxcIl0rXFxzKihcXD98OnxcXCspPz0vaS50ZXN0KHRleHRBZnRlcikgfHxcbi9eKFxcK3wtKT9bYS16XVtcXHctXSpcXCgvaS50ZXN0KHRleHRBZnRlcikgfHxcbi9ecmV0dXJuLy50ZXN0KHRleHRBZnRlcikgfHxcbiAgICAgICAgICAgICAgd29yZElzQmxvY2sobGluZUZpcnN0V29yZCkpIHtcbiAgICAgICAgICAgIGluZGVudCA9IGxpbmVJbmRlbnQ7XG4gICAgICAgICAgfSBlbHNlIGlmICgvKFxcLnwjfDp8XFxbfFxcKnwmfD58fnxcXCt8XFwvKS8udGVzdChjaCkgfHwgd29yZElzVGFnKGxpbmVGaXJzdFdvcmQpKSB7XG4gICAgICAgICAgICBpZiAoL1xcLFxccyokLy50ZXN0KHByZXZMaW5lRmlyc3RXb3JkKSkge1xuICAgICAgICAgICAgICBpbmRlbnQgPSBwcmV2TGluZUluZGVudDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoL15cXHMrLy50ZXN0KGxpbmUpICYmICgvKFxcLnwjfDp8XFxbfFxcKnwmfD58fnxcXCt8XFwvKS8udGVzdChwcmV2TGluZUZpcnN0V29yZCkgfHwgd29yZElzVGFnKHByZXZMaW5lRmlyc3RXb3JkKSkpIHtcbiAgICAgICAgICAgICAgaW5kZW50ID0gbGluZUluZGVudCA8PSBwcmV2TGluZUluZGVudCA/IHByZXZMaW5lSW5kZW50IDogcHJldkxpbmVJbmRlbnQgKyBpbmRlbnRVbml0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaW5kZW50ID0gbGluZUluZGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKCEvLFxccyokLy50ZXN0KGxpbmUpICYmICh3b3JkSXNWZW5kb3JQcmVmaXgobGluZUZpcnN0V29yZCkgfHwgd29yZElzUHJvcGVydHkobGluZUZpcnN0V29yZCkpKSB7XG4gICAgICAgICAgICBpZiAod29yZElzQmxvY2socHJldkxpbmVGaXJzdFdvcmQpKSB7XG4gICAgICAgICAgICAgIGluZGVudCA9IGxpbmVJbmRlbnQgPD0gcHJldkxpbmVJbmRlbnQgPyBwcmV2TGluZUluZGVudCA6IHByZXZMaW5lSW5kZW50ICsgaW5kZW50VW5pdDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoL15cXHsvLnRlc3QocHJldkxpbmVGaXJzdFdvcmQpKSB7XG4gICAgICAgICAgICAgIGluZGVudCA9IGxpbmVJbmRlbnQgPD0gcHJldkxpbmVJbmRlbnQgPyBsaW5lSW5kZW50IDogcHJldkxpbmVJbmRlbnQgKyBpbmRlbnRVbml0O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh3b3JkSXNWZW5kb3JQcmVmaXgocHJldkxpbmVGaXJzdFdvcmQpIHx8IHdvcmRJc1Byb3BlcnR5KHByZXZMaW5lRmlyc3RXb3JkKSkge1xuICAgICAgICAgICAgICBpbmRlbnQgPSBsaW5lSW5kZW50ID49IHByZXZMaW5lSW5kZW50ID8gcHJldkxpbmVJbmRlbnQgOiBsaW5lSW5kZW50O1xuICAgICAgICAgICAgfSBlbHNlIGlmICgvXihcXC58I3w6fFxcW3xcXCp8JnxAfFxcK3xcXC18Pnx+fFxcLykvLnRlc3QocHJldkxpbmVGaXJzdFdvcmQpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgLz1cXHMqJC8udGVzdChwcmV2TGluZUZpcnN0V29yZCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICB3b3JkSXNUYWcocHJldkxpbmVGaXJzdFdvcmQpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgL15cXCRbXFx3LVxcLlxcW1xcXVxcJ1xcXCJdLy50ZXN0KHByZXZMaW5lRmlyc3RXb3JkKSkge1xuICAgICAgICAgICAgICBpbmRlbnQgPSBwcmV2TGluZUluZGVudCArIGluZGVudFVuaXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpbmRlbnQgPSBsaW5lSW5kZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZW50O1xuICAgICAgfSxcbiAgICAgIGVsZWN0cmljQ2hhcnM6IFwifVwiLFxuICAgICAgYmxvY2tDb21tZW50U3RhcnQ6IFwiLypcIixcbiAgICAgIGJsb2NrQ29tbWVudEVuZDogXCIqL1wiLFxuICAgICAgYmxvY2tDb21tZW50Q29udGludWU6IFwiICogXCIsXG4gICAgICBsaW5lQ29tbWVudDogXCIvL1wiLFxuICAgICAgZm9sZDogXCJpbmRlbnRcIlxuICAgIH07XG4gIH0pO1xuXG4gIC8vIGRldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnRcbiAgdmFyIHRhZ0tleXdvcmRzXyA9IFtcImFcIixcImFiYnJcIixcImFkZHJlc3NcIixcImFyZWFcIixcImFydGljbGVcIixcImFzaWRlXCIsXCJhdWRpb1wiLCBcImJcIiwgXCJiYXNlXCIsXCJiZGlcIiwgXCJiZG9cIixcImJnc291bmRcIixcImJsb2NrcXVvdGVcIixcImJvZHlcIixcImJyXCIsXCJidXR0b25cIixcImNhbnZhc1wiLFwiY2FwdGlvblwiLFwiY2l0ZVwiLCBcImNvZGVcIixcImNvbFwiLFwiY29sZ3JvdXBcIixcImRhdGFcIixcImRhdGFsaXN0XCIsXCJkZFwiLFwiZGVsXCIsXCJkZXRhaWxzXCIsXCJkZm5cIixcImRpdlwiLCBcImRsXCIsXCJkdFwiLFwiZW1cIixcImVtYmVkXCIsXCJmaWVsZHNldFwiLFwiZmlnY2FwdGlvblwiLFwiZmlndXJlXCIsXCJmb290ZXJcIixcImZvcm1cIixcImgxXCIsIFwiaDJcIixcImgzXCIsXCJoNFwiLFwiaDVcIixcImg2XCIsXCJoZWFkXCIsXCJoZWFkZXJcIixcImhncm91cFwiLFwiaHJcIixcImh0bWxcIixcImlcIixcImlmcmFtZVwiLCBcImltZ1wiLFwiaW5wdXRcIixcImluc1wiLFwia2JkXCIsXCJrZXlnZW5cIixcImxhYmVsXCIsXCJsZWdlbmRcIixcImxpXCIsXCJsaW5rXCIsXCJtYWluXCIsXCJtYXBcIiwgXCJtYXJrXCIsXCJtYXJxdWVlXCIsXCJtZW51XCIsXCJtZW51aXRlbVwiLFwibWV0YVwiLFwibWV0ZXJcIixcIm5hdlwiLFwibm9iclwiLFwibm9mcmFtZXNcIiwgXCJub3NjcmlwdFwiLFwib2JqZWN0XCIsXCJvbFwiLFwib3B0Z3JvdXBcIixcIm9wdGlvblwiLFwib3V0cHV0XCIsXCJwXCIsXCJwYXJhbVwiLFwicHJlXCIsIFwicHJvZ3Jlc3NcIixcInFcIixcInJwXCIsXCJydFwiLFwicnVieVwiLFwic1wiLFwic2FtcFwiLFwic2NyaXB0XCIsXCJzZWN0aW9uXCIsXCJzZWxlY3RcIiwgXCJzbWFsbFwiLFwic291cmNlXCIsXCJzcGFuXCIsXCJzdHJvbmdcIixcInN0eWxlXCIsXCJzdWJcIixcInN1bW1hcnlcIixcInN1cFwiLFwidGFibGVcIixcInRib2R5XCIsXCJ0ZFwiLFwidGV4dGFyZWFcIixcInRmb290XCIsXCJ0aFwiLFwidGhlYWRcIixcInRpbWVcIixcInRyXCIsXCJ0cmFja1wiLCBcInVcIixcInVsXCIsXCJ2YXJcIixcInZpZGVvXCJdO1xuXG4gIC8vIGdpdGh1Yi5jb20vY29kZW1pcnJvci9Db2RlTWlycm9yL2Jsb2IvbWFzdGVyL21vZGUvY3NzL2Nzcy5qc1xuICAvLyBOb3RlLCBcInVybC1wcmVmaXhcIiBzaG91bGQgcHJlY2VkZSBcInVybFwiIGluIG9yZGVyIHRvIG1hdGNoIGNvcnJlY3RseSBpbiBkb2N1bWVudFR5cGVzUmVnZXhwXG4gIHZhciBkb2N1bWVudFR5cGVzXyA9IFtcImRvbWFpblwiLCBcInJlZ2V4cFwiLCBcInVybC1wcmVmaXhcIiwgXCJ1cmxcIl07XG4gIHZhciBtZWRpYVR5cGVzXyA9IFtcImFsbFwiLFwiYXVyYWxcIixcImJyYWlsbGVcIixcImhhbmRoZWxkXCIsXCJwcmludFwiLFwicHJvamVjdGlvblwiLFwic2NyZWVuXCIsXCJ0dHlcIixcInR2XCIsXCJlbWJvc3NlZFwiXTtcbiAgdmFyIG1lZGlhRmVhdHVyZXNfID0gW1wid2lkdGhcIixcIm1pbi13aWR0aFwiLFwibWF4LXdpZHRoXCIsXCJoZWlnaHRcIixcIm1pbi1oZWlnaHRcIixcIm1heC1oZWlnaHRcIixcImRldmljZS13aWR0aFwiLFwibWluLWRldmljZS13aWR0aFwiLFwibWF4LWRldmljZS13aWR0aFwiLFwiZGV2aWNlLWhlaWdodFwiLFwibWluLWRldmljZS1oZWlnaHRcIixcIm1heC1kZXZpY2UtaGVpZ2h0XCIsXCJhc3BlY3QtcmF0aW9cIixcIm1pbi1hc3BlY3QtcmF0aW9cIixcIm1heC1hc3BlY3QtcmF0aW9cIixcImRldmljZS1hc3BlY3QtcmF0aW9cIixcIm1pbi1kZXZpY2UtYXNwZWN0LXJhdGlvXCIsXCJtYXgtZGV2aWNlLWFzcGVjdC1yYXRpb1wiLFwiY29sb3JcIixcIm1pbi1jb2xvclwiLFwibWF4LWNvbG9yXCIsXCJjb2xvci1pbmRleFwiLFwibWluLWNvbG9yLWluZGV4XCIsXCJtYXgtY29sb3ItaW5kZXhcIixcIm1vbm9jaHJvbWVcIixcIm1pbi1tb25vY2hyb21lXCIsXCJtYXgtbW9ub2Nocm9tZVwiLFwicmVzb2x1dGlvblwiLFwibWluLXJlc29sdXRpb25cIixcIm1heC1yZXNvbHV0aW9uXCIsXCJzY2FuXCIsXCJncmlkXCJdO1xuICB2YXIgcHJvcGVydHlLZXl3b3Jkc18gPSBbXCJhbGlnbi1jb250ZW50XCIsXCJhbGlnbi1pdGVtc1wiLFwiYWxpZ24tc2VsZlwiLFwiYWxpZ25tZW50LWFkanVzdFwiLFwiYWxpZ25tZW50LWJhc2VsaW5lXCIsXCJhbmNob3ItcG9pbnRcIixcImFuaW1hdGlvblwiLFwiYW5pbWF0aW9uLWRlbGF5XCIsXCJhbmltYXRpb24tZGlyZWN0aW9uXCIsXCJhbmltYXRpb24tZHVyYXRpb25cIixcImFuaW1hdGlvbi1maWxsLW1vZGVcIixcImFuaW1hdGlvbi1pdGVyYXRpb24tY291bnRcIixcImFuaW1hdGlvbi1uYW1lXCIsXCJhbmltYXRpb24tcGxheS1zdGF0ZVwiLFwiYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvblwiLFwiYXBwZWFyYW5jZVwiLFwiYXppbXV0aFwiLFwiYmFja2ZhY2UtdmlzaWJpbGl0eVwiLFwiYmFja2dyb3VuZFwiLFwiYmFja2dyb3VuZC1hdHRhY2htZW50XCIsXCJiYWNrZ3JvdW5kLWNsaXBcIixcImJhY2tncm91bmQtY29sb3JcIixcImJhY2tncm91bmQtaW1hZ2VcIixcImJhY2tncm91bmQtb3JpZ2luXCIsXCJiYWNrZ3JvdW5kLXBvc2l0aW9uXCIsXCJiYWNrZ3JvdW5kLXJlcGVhdFwiLFwiYmFja2dyb3VuZC1zaXplXCIsXCJiYXNlbGluZS1zaGlmdFwiLFwiYmluZGluZ1wiLFwiYmxlZWRcIixcImJvb2ttYXJrLWxhYmVsXCIsXCJib29rbWFyay1sZXZlbFwiLFwiYm9va21hcmstc3RhdGVcIixcImJvb2ttYXJrLXRhcmdldFwiLFwiYm9yZGVyXCIsXCJib3JkZXItYm90dG9tXCIsXCJib3JkZXItYm90dG9tLWNvbG9yXCIsXCJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzXCIsXCJib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1c1wiLFwiYm9yZGVyLWJvdHRvbS1zdHlsZVwiLFwiYm9yZGVyLWJvdHRvbS13aWR0aFwiLFwiYm9yZGVyLWNvbGxhcHNlXCIsXCJib3JkZXItY29sb3JcIixcImJvcmRlci1pbWFnZVwiLFwiYm9yZGVyLWltYWdlLW91dHNldFwiLFwiYm9yZGVyLWltYWdlLXJlcGVhdFwiLFwiYm9yZGVyLWltYWdlLXNsaWNlXCIsXCJib3JkZXItaW1hZ2Utc291cmNlXCIsXCJib3JkZXItaW1hZ2Utd2lkdGhcIixcImJvcmRlci1sZWZ0XCIsXCJib3JkZXItbGVmdC1jb2xvclwiLFwiYm9yZGVyLWxlZnQtc3R5bGVcIixcImJvcmRlci1sZWZ0LXdpZHRoXCIsXCJib3JkZXItcmFkaXVzXCIsXCJib3JkZXItcmlnaHRcIixcImJvcmRlci1yaWdodC1jb2xvclwiLFwiYm9yZGVyLXJpZ2h0LXN0eWxlXCIsXCJib3JkZXItcmlnaHQtd2lkdGhcIixcImJvcmRlci1zcGFjaW5nXCIsXCJib3JkZXItc3R5bGVcIixcImJvcmRlci10b3BcIixcImJvcmRlci10b3AtY29sb3JcIixcImJvcmRlci10b3AtbGVmdC1yYWRpdXNcIixcImJvcmRlci10b3AtcmlnaHQtcmFkaXVzXCIsXCJib3JkZXItdG9wLXN0eWxlXCIsXCJib3JkZXItdG9wLXdpZHRoXCIsXCJib3JkZXItd2lkdGhcIixcImJvdHRvbVwiLFwiYm94LWRlY29yYXRpb24tYnJlYWtcIixcImJveC1zaGFkb3dcIixcImJveC1zaXppbmdcIixcImJyZWFrLWFmdGVyXCIsXCJicmVhay1iZWZvcmVcIixcImJyZWFrLWluc2lkZVwiLFwiY2FwdGlvbi1zaWRlXCIsXCJjbGVhclwiLFwiY2xpcFwiLFwiY29sb3JcIixcImNvbG9yLXByb2ZpbGVcIixcImNvbHVtbi1jb3VudFwiLFwiY29sdW1uLWZpbGxcIixcImNvbHVtbi1nYXBcIixcImNvbHVtbi1ydWxlXCIsXCJjb2x1bW4tcnVsZS1jb2xvclwiLFwiY29sdW1uLXJ1bGUtc3R5bGVcIixcImNvbHVtbi1ydWxlLXdpZHRoXCIsXCJjb2x1bW4tc3BhblwiLFwiY29sdW1uLXdpZHRoXCIsXCJjb2x1bW5zXCIsXCJjb250ZW50XCIsXCJjb3VudGVyLWluY3JlbWVudFwiLFwiY291bnRlci1yZXNldFwiLFwiY3JvcFwiLFwiY3VlXCIsXCJjdWUtYWZ0ZXJcIixcImN1ZS1iZWZvcmVcIixcImN1cnNvclwiLFwiZGlyZWN0aW9uXCIsXCJkaXNwbGF5XCIsXCJkb21pbmFudC1iYXNlbGluZVwiLFwiZHJvcC1pbml0aWFsLWFmdGVyLWFkanVzdFwiLFwiZHJvcC1pbml0aWFsLWFmdGVyLWFsaWduXCIsXCJkcm9wLWluaXRpYWwtYmVmb3JlLWFkanVzdFwiLFwiZHJvcC1pbml0aWFsLWJlZm9yZS1hbGlnblwiLFwiZHJvcC1pbml0aWFsLXNpemVcIixcImRyb3AtaW5pdGlhbC12YWx1ZVwiLFwiZWxldmF0aW9uXCIsXCJlbXB0eS1jZWxsc1wiLFwiZml0XCIsXCJmaXQtcG9zaXRpb25cIixcImZsZXhcIixcImZsZXgtYmFzaXNcIixcImZsZXgtZGlyZWN0aW9uXCIsXCJmbGV4LWZsb3dcIixcImZsZXgtZ3Jvd1wiLFwiZmxleC1zaHJpbmtcIixcImZsZXgtd3JhcFwiLFwiZmxvYXRcIixcImZsb2F0LW9mZnNldFwiLFwiZmxvdy1mcm9tXCIsXCJmbG93LWludG9cIixcImZvbnRcIixcImZvbnQtZmVhdHVyZS1zZXR0aW5nc1wiLFwiZm9udC1mYW1pbHlcIixcImZvbnQta2VybmluZ1wiLFwiZm9udC1sYW5ndWFnZS1vdmVycmlkZVwiLFwiZm9udC1zaXplXCIsXCJmb250LXNpemUtYWRqdXN0XCIsXCJmb250LXN0cmV0Y2hcIixcImZvbnQtc3R5bGVcIixcImZvbnQtc3ludGhlc2lzXCIsXCJmb250LXZhcmlhbnRcIixcImZvbnQtdmFyaWFudC1hbHRlcm5hdGVzXCIsXCJmb250LXZhcmlhbnQtY2Fwc1wiLFwiZm9udC12YXJpYW50LWVhc3QtYXNpYW5cIixcImZvbnQtdmFyaWFudC1saWdhdHVyZXNcIixcImZvbnQtdmFyaWFudC1udW1lcmljXCIsXCJmb250LXZhcmlhbnQtcG9zaXRpb25cIixcImZvbnQtd2VpZ2h0XCIsXCJncmlkXCIsXCJncmlkLWFyZWFcIixcImdyaWQtYXV0by1jb2x1bW5zXCIsXCJncmlkLWF1dG8tZmxvd1wiLFwiZ3JpZC1hdXRvLXBvc2l0aW9uXCIsXCJncmlkLWF1dG8tcm93c1wiLFwiZ3JpZC1jb2x1bW5cIixcImdyaWQtY29sdW1uLWVuZFwiLFwiZ3JpZC1jb2x1bW4tc3RhcnRcIixcImdyaWQtcm93XCIsXCJncmlkLXJvdy1lbmRcIixcImdyaWQtcm93LXN0YXJ0XCIsXCJncmlkLXRlbXBsYXRlXCIsXCJncmlkLXRlbXBsYXRlLWFyZWFzXCIsXCJncmlkLXRlbXBsYXRlLWNvbHVtbnNcIixcImdyaWQtdGVtcGxhdGUtcm93c1wiLFwiaGFuZ2luZy1wdW5jdHVhdGlvblwiLFwiaGVpZ2h0XCIsXCJoeXBoZW5zXCIsXCJpY29uXCIsXCJpbWFnZS1vcmllbnRhdGlvblwiLFwiaW1hZ2UtcmVuZGVyaW5nXCIsXCJpbWFnZS1yZXNvbHV0aW9uXCIsXCJpbmxpbmUtYm94LWFsaWduXCIsXCJqdXN0aWZ5LWNvbnRlbnRcIixcImxlZnRcIixcImxldHRlci1zcGFjaW5nXCIsXCJsaW5lLWJyZWFrXCIsXCJsaW5lLWhlaWdodFwiLFwibGluZS1zdGFja2luZ1wiLFwibGluZS1zdGFja2luZy1ydWJ5XCIsXCJsaW5lLXN0YWNraW5nLXNoaWZ0XCIsXCJsaW5lLXN0YWNraW5nLXN0cmF0ZWd5XCIsXCJsaXN0LXN0eWxlXCIsXCJsaXN0LXN0eWxlLWltYWdlXCIsXCJsaXN0LXN0eWxlLXBvc2l0aW9uXCIsXCJsaXN0LXN0eWxlLXR5cGVcIixcIm1hcmdpblwiLFwibWFyZ2luLWJvdHRvbVwiLFwibWFyZ2luLWxlZnRcIixcIm1hcmdpbi1yaWdodFwiLFwibWFyZ2luLXRvcFwiLFwibWFya2VyLW9mZnNldFwiLFwibWFya3NcIixcIm1hcnF1ZWUtZGlyZWN0aW9uXCIsXCJtYXJxdWVlLWxvb3BcIixcIm1hcnF1ZWUtcGxheS1jb3VudFwiLFwibWFycXVlZS1zcGVlZFwiLFwibWFycXVlZS1zdHlsZVwiLFwibWF4LWhlaWdodFwiLFwibWF4LXdpZHRoXCIsXCJtaW4taGVpZ2h0XCIsXCJtaW4td2lkdGhcIixcIm1vdmUtdG9cIixcIm5hdi1kb3duXCIsXCJuYXYtaW5kZXhcIixcIm5hdi1sZWZ0XCIsXCJuYXYtcmlnaHRcIixcIm5hdi11cFwiLFwib2JqZWN0LWZpdFwiLFwib2JqZWN0LXBvc2l0aW9uXCIsXCJvcGFjaXR5XCIsXCJvcmRlclwiLFwib3JwaGFuc1wiLFwib3V0bGluZVwiLFwib3V0bGluZS1jb2xvclwiLFwib3V0bGluZS1vZmZzZXRcIixcIm91dGxpbmUtc3R5bGVcIixcIm91dGxpbmUtd2lkdGhcIixcIm92ZXJmbG93XCIsXCJvdmVyZmxvdy1zdHlsZVwiLFwib3ZlcmZsb3ctd3JhcFwiLFwib3ZlcmZsb3cteFwiLFwib3ZlcmZsb3cteVwiLFwicGFkZGluZ1wiLFwicGFkZGluZy1ib3R0b21cIixcInBhZGRpbmctbGVmdFwiLFwicGFkZGluZy1yaWdodFwiLFwicGFkZGluZy10b3BcIixcInBhZ2VcIixcInBhZ2UtYnJlYWstYWZ0ZXJcIixcInBhZ2UtYnJlYWstYmVmb3JlXCIsXCJwYWdlLWJyZWFrLWluc2lkZVwiLFwicGFnZS1wb2xpY3lcIixcInBhdXNlXCIsXCJwYXVzZS1hZnRlclwiLFwicGF1c2UtYmVmb3JlXCIsXCJwZXJzcGVjdGl2ZVwiLFwicGVyc3BlY3RpdmUtb3JpZ2luXCIsXCJwaXRjaFwiLFwicGl0Y2gtcmFuZ2VcIixcInBsYXktZHVyaW5nXCIsXCJwb3NpdGlvblwiLFwicHJlc2VudGF0aW9uLWxldmVsXCIsXCJwdW5jdHVhdGlvbi10cmltXCIsXCJxdW90ZXNcIixcInJlZ2lvbi1icmVhay1hZnRlclwiLFwicmVnaW9uLWJyZWFrLWJlZm9yZVwiLFwicmVnaW9uLWJyZWFrLWluc2lkZVwiLFwicmVnaW9uLWZyYWdtZW50XCIsXCJyZW5kZXJpbmctaW50ZW50XCIsXCJyZXNpemVcIixcInJlc3RcIixcInJlc3QtYWZ0ZXJcIixcInJlc3QtYmVmb3JlXCIsXCJyaWNobmVzc1wiLFwicmlnaHRcIixcInJvdGF0aW9uXCIsXCJyb3RhdGlvbi1wb2ludFwiLFwicnVieS1hbGlnblwiLFwicnVieS1vdmVyaGFuZ1wiLFwicnVieS1wb3NpdGlvblwiLFwicnVieS1zcGFuXCIsXCJzaGFwZS1pbWFnZS10aHJlc2hvbGRcIixcInNoYXBlLWluc2lkZVwiLFwic2hhcGUtbWFyZ2luXCIsXCJzaGFwZS1vdXRzaWRlXCIsXCJzaXplXCIsXCJzcGVha1wiLFwic3BlYWstYXNcIixcInNwZWFrLWhlYWRlclwiLFwic3BlYWstbnVtZXJhbFwiLFwic3BlYWstcHVuY3R1YXRpb25cIixcInNwZWVjaC1yYXRlXCIsXCJzdHJlc3NcIixcInN0cmluZy1zZXRcIixcInRhYi1zaXplXCIsXCJ0YWJsZS1sYXlvdXRcIixcInRhcmdldFwiLFwidGFyZ2V0LW5hbWVcIixcInRhcmdldC1uZXdcIixcInRhcmdldC1wb3NpdGlvblwiLFwidGV4dC1hbGlnblwiLFwidGV4dC1hbGlnbi1sYXN0XCIsXCJ0ZXh0LWRlY29yYXRpb25cIixcInRleHQtZGVjb3JhdGlvbi1jb2xvclwiLFwidGV4dC1kZWNvcmF0aW9uLWxpbmVcIixcInRleHQtZGVjb3JhdGlvbi1za2lwXCIsXCJ0ZXh0LWRlY29yYXRpb24tc3R5bGVcIixcInRleHQtZW1waGFzaXNcIixcInRleHQtZW1waGFzaXMtY29sb3JcIixcInRleHQtZW1waGFzaXMtcG9zaXRpb25cIixcInRleHQtZW1waGFzaXMtc3R5bGVcIixcInRleHQtaGVpZ2h0XCIsXCJ0ZXh0LWluZGVudFwiLFwidGV4dC1qdXN0aWZ5XCIsXCJ0ZXh0LW91dGxpbmVcIixcInRleHQtb3ZlcmZsb3dcIixcInRleHQtc2hhZG93XCIsXCJ0ZXh0LXNpemUtYWRqdXN0XCIsXCJ0ZXh0LXNwYWNlLWNvbGxhcHNlXCIsXCJ0ZXh0LXRyYW5zZm9ybVwiLFwidGV4dC11bmRlcmxpbmUtcG9zaXRpb25cIixcInRleHQtd3JhcFwiLFwidG9wXCIsXCJ0cmFuc2Zvcm1cIixcInRyYW5zZm9ybS1vcmlnaW5cIixcInRyYW5zZm9ybS1zdHlsZVwiLFwidHJhbnNpdGlvblwiLFwidHJhbnNpdGlvbi1kZWxheVwiLFwidHJhbnNpdGlvbi1kdXJhdGlvblwiLFwidHJhbnNpdGlvbi1wcm9wZXJ0eVwiLFwidHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb25cIixcInVuaWNvZGUtYmlkaVwiLFwidmVydGljYWwtYWxpZ25cIixcInZpc2liaWxpdHlcIixcInZvaWNlLWJhbGFuY2VcIixcInZvaWNlLWR1cmF0aW9uXCIsXCJ2b2ljZS1mYW1pbHlcIixcInZvaWNlLXBpdGNoXCIsXCJ2b2ljZS1yYW5nZVwiLFwidm9pY2UtcmF0ZVwiLFwidm9pY2Utc3RyZXNzXCIsXCJ2b2ljZS12b2x1bWVcIixcInZvbHVtZVwiLFwid2hpdGUtc3BhY2VcIixcIndpZG93c1wiLFwid2lkdGhcIixcIndpbGwtY2hhbmdlXCIsXCJ3b3JkLWJyZWFrXCIsXCJ3b3JkLXNwYWNpbmdcIixcIndvcmQtd3JhcFwiLFwiei1pbmRleFwiLFwiY2xpcC1wYXRoXCIsXCJjbGlwLXJ1bGVcIixcIm1hc2tcIixcImVuYWJsZS1iYWNrZ3JvdW5kXCIsXCJmaWx0ZXJcIixcImZsb29kLWNvbG9yXCIsXCJmbG9vZC1vcGFjaXR5XCIsXCJsaWdodGluZy1jb2xvclwiLFwic3RvcC1jb2xvclwiLFwic3RvcC1vcGFjaXR5XCIsXCJwb2ludGVyLWV2ZW50c1wiLFwiY29sb3ItaW50ZXJwb2xhdGlvblwiLFwiY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzXCIsXCJjb2xvci1yZW5kZXJpbmdcIixcImZpbGxcIixcImZpbGwtb3BhY2l0eVwiLFwiZmlsbC1ydWxlXCIsXCJpbWFnZS1yZW5kZXJpbmdcIixcIm1hcmtlclwiLFwibWFya2VyLWVuZFwiLFwibWFya2VyLW1pZFwiLFwibWFya2VyLXN0YXJ0XCIsXCJzaGFwZS1yZW5kZXJpbmdcIixcInN0cm9rZVwiLFwic3Ryb2tlLWRhc2hhcnJheVwiLFwic3Ryb2tlLWRhc2hvZmZzZXRcIixcInN0cm9rZS1saW5lY2FwXCIsXCJzdHJva2UtbGluZWpvaW5cIixcInN0cm9rZS1taXRlcmxpbWl0XCIsXCJzdHJva2Utb3BhY2l0eVwiLFwic3Ryb2tlLXdpZHRoXCIsXCJ0ZXh0LXJlbmRlcmluZ1wiLFwiYmFzZWxpbmUtc2hpZnRcIixcImRvbWluYW50LWJhc2VsaW5lXCIsXCJnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsXCIsXCJnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbFwiLFwidGV4dC1hbmNob3JcIixcIndyaXRpbmctbW9kZVwiLFwiZm9udC1zbW9vdGhpbmdcIixcIm9zeC1mb250LXNtb290aGluZ1wiXTtcbiAgdmFyIG5vblN0YW5kYXJkUHJvcGVydHlLZXl3b3Jkc18gPSBbXCJzY3JvbGxiYXItYXJyb3ctY29sb3JcIixcInNjcm9sbGJhci1iYXNlLWNvbG9yXCIsXCJzY3JvbGxiYXItZGFyay1zaGFkb3ctY29sb3JcIixcInNjcm9sbGJhci1mYWNlLWNvbG9yXCIsXCJzY3JvbGxiYXItaGlnaGxpZ2h0LWNvbG9yXCIsXCJzY3JvbGxiYXItc2hhZG93LWNvbG9yXCIsXCJzY3JvbGxiYXItM2QtbGlnaHQtY29sb3JcIixcInNjcm9sbGJhci10cmFjay1jb2xvclwiLFwic2hhcGUtaW5zaWRlXCIsXCJzZWFyY2hmaWVsZC1jYW5jZWwtYnV0dG9uXCIsXCJzZWFyY2hmaWVsZC1kZWNvcmF0aW9uXCIsXCJzZWFyY2hmaWVsZC1yZXN1bHRzLWJ1dHRvblwiLFwic2VhcmNoZmllbGQtcmVzdWx0cy1kZWNvcmF0aW9uXCIsXCJ6b29tXCJdO1xuICB2YXIgZm9udFByb3BlcnRpZXNfID0gW1wiZm9udC1mYW1pbHlcIixcInNyY1wiLFwidW5pY29kZS1yYW5nZVwiLFwiZm9udC12YXJpYW50XCIsXCJmb250LWZlYXR1cmUtc2V0dGluZ3NcIixcImZvbnQtc3RyZXRjaFwiLFwiZm9udC13ZWlnaHRcIixcImZvbnQtc3R5bGVcIl07XG4gIHZhciBjb2xvcktleXdvcmRzXyA9IFtcImFsaWNlYmx1ZVwiLFwiYW50aXF1ZXdoaXRlXCIsXCJhcXVhXCIsXCJhcXVhbWFyaW5lXCIsXCJhenVyZVwiLFwiYmVpZ2VcIixcImJpc3F1ZVwiLFwiYmxhY2tcIixcImJsYW5jaGVkYWxtb25kXCIsXCJibHVlXCIsXCJibHVldmlvbGV0XCIsXCJicm93blwiLFwiYnVybHl3b29kXCIsXCJjYWRldGJsdWVcIixcImNoYXJ0cmV1c2VcIixcImNob2NvbGF0ZVwiLFwiY29yYWxcIixcImNvcm5mbG93ZXJibHVlXCIsXCJjb3Juc2lsa1wiLFwiY3JpbXNvblwiLFwiY3lhblwiLFwiZGFya2JsdWVcIixcImRhcmtjeWFuXCIsXCJkYXJrZ29sZGVucm9kXCIsXCJkYXJrZ3JheVwiLFwiZGFya2dyZWVuXCIsXCJkYXJra2hha2lcIixcImRhcmttYWdlbnRhXCIsXCJkYXJrb2xpdmVncmVlblwiLFwiZGFya29yYW5nZVwiLFwiZGFya29yY2hpZFwiLFwiZGFya3JlZFwiLFwiZGFya3NhbG1vblwiLFwiZGFya3NlYWdyZWVuXCIsXCJkYXJrc2xhdGVibHVlXCIsXCJkYXJrc2xhdGVncmF5XCIsXCJkYXJrdHVycXVvaXNlXCIsXCJkYXJrdmlvbGV0XCIsXCJkZWVwcGlua1wiLFwiZGVlcHNreWJsdWVcIixcImRpbWdyYXlcIixcImRvZGdlcmJsdWVcIixcImZpcmVicmlja1wiLFwiZmxvcmFsd2hpdGVcIixcImZvcmVzdGdyZWVuXCIsXCJmdWNoc2lhXCIsXCJnYWluc2Jvcm9cIixcImdob3N0d2hpdGVcIixcImdvbGRcIixcImdvbGRlbnJvZFwiLFwiZ3JheVwiLFwiZ3JleVwiLFwiZ3JlZW5cIixcImdyZWVueWVsbG93XCIsXCJob25leWRld1wiLFwiaG90cGlua1wiLFwiaW5kaWFucmVkXCIsXCJpbmRpZ29cIixcIml2b3J5XCIsXCJraGFraVwiLFwibGF2ZW5kZXJcIixcImxhdmVuZGVyYmx1c2hcIixcImxhd25ncmVlblwiLFwibGVtb25jaGlmZm9uXCIsXCJsaWdodGJsdWVcIixcImxpZ2h0Y29yYWxcIixcImxpZ2h0Y3lhblwiLFwibGlnaHRnb2xkZW5yb2R5ZWxsb3dcIixcImxpZ2h0Z3JheVwiLFwibGlnaHRncmVlblwiLFwibGlnaHRwaW5rXCIsXCJsaWdodHNhbG1vblwiLFwibGlnaHRzZWFncmVlblwiLFwibGlnaHRza3libHVlXCIsXCJsaWdodHNsYXRlZ3JheVwiLFwibGlnaHRzdGVlbGJsdWVcIixcImxpZ2h0eWVsbG93XCIsXCJsaW1lXCIsXCJsaW1lZ3JlZW5cIixcImxpbmVuXCIsXCJtYWdlbnRhXCIsXCJtYXJvb25cIixcIm1lZGl1bWFxdWFtYXJpbmVcIixcIm1lZGl1bWJsdWVcIixcIm1lZGl1bW9yY2hpZFwiLFwibWVkaXVtcHVycGxlXCIsXCJtZWRpdW1zZWFncmVlblwiLFwibWVkaXVtc2xhdGVibHVlXCIsXCJtZWRpdW1zcHJpbmdncmVlblwiLFwibWVkaXVtdHVycXVvaXNlXCIsXCJtZWRpdW12aW9sZXRyZWRcIixcIm1pZG5pZ2h0Ymx1ZVwiLFwibWludGNyZWFtXCIsXCJtaXN0eXJvc2VcIixcIm1vY2Nhc2luXCIsXCJuYXZham93aGl0ZVwiLFwibmF2eVwiLFwib2xkbGFjZVwiLFwib2xpdmVcIixcIm9saXZlZHJhYlwiLFwib3JhbmdlXCIsXCJvcmFuZ2VyZWRcIixcIm9yY2hpZFwiLFwicGFsZWdvbGRlbnJvZFwiLFwicGFsZWdyZWVuXCIsXCJwYWxldHVycXVvaXNlXCIsXCJwYWxldmlvbGV0cmVkXCIsXCJwYXBheWF3aGlwXCIsXCJwZWFjaHB1ZmZcIixcInBlcnVcIixcInBpbmtcIixcInBsdW1cIixcInBvd2RlcmJsdWVcIixcInB1cnBsZVwiLFwicmViZWNjYXB1cnBsZVwiLFwicmVkXCIsXCJyb3N5YnJvd25cIixcInJveWFsYmx1ZVwiLFwic2FkZGxlYnJvd25cIixcInNhbG1vblwiLFwic2FuZHlicm93blwiLFwic2VhZ3JlZW5cIixcInNlYXNoZWxsXCIsXCJzaWVubmFcIixcInNpbHZlclwiLFwic2t5Ymx1ZVwiLFwic2xhdGVibHVlXCIsXCJzbGF0ZWdyYXlcIixcInNub3dcIixcInNwcmluZ2dyZWVuXCIsXCJzdGVlbGJsdWVcIixcInRhblwiLFwidGVhbFwiLFwidGhpc3RsZVwiLFwidG9tYXRvXCIsXCJ0dXJxdW9pc2VcIixcInZpb2xldFwiLFwid2hlYXRcIixcIndoaXRlXCIsXCJ3aGl0ZXNtb2tlXCIsXCJ5ZWxsb3dcIixcInllbGxvd2dyZWVuXCJdO1xuICB2YXIgdmFsdWVLZXl3b3Jkc18gPSBbXCJhYm92ZVwiLFwiYWJzb2x1dGVcIixcImFjdGl2ZWJvcmRlclwiLFwiYWRkaXRpdmVcIixcImFjdGl2ZWNhcHRpb25cIixcImFmYXJcIixcImFmdGVyLXdoaXRlLXNwYWNlXCIsXCJhaGVhZFwiLFwiYWxpYXNcIixcImFsbFwiLFwiYWxsLXNjcm9sbFwiLFwiYWxwaGFiZXRpY1wiLFwiYWx0ZXJuYXRlXCIsXCJhbHdheXNcIixcImFtaGFyaWNcIixcImFtaGFyaWMtYWJlZ2VkZVwiLFwiYW50aWFsaWFzZWRcIixcImFwcHdvcmtzcGFjZVwiLFwiYXJhYmljLWluZGljXCIsXCJhcm1lbmlhblwiLFwiYXN0ZXJpc2tzXCIsXCJhdHRyXCIsXCJhdXRvXCIsXCJhdm9pZFwiLFwiYXZvaWQtY29sdW1uXCIsXCJhdm9pZC1wYWdlXCIsXCJhdm9pZC1yZWdpb25cIixcImJhY2tncm91bmRcIixcImJhY2t3YXJkc1wiLFwiYmFzZWxpbmVcIixcImJlbG93XCIsXCJiaWRpLW92ZXJyaWRlXCIsXCJiaW5hcnlcIixcImJlbmdhbGlcIixcImJsaW5rXCIsXCJibG9ja1wiLFwiYmxvY2stYXhpc1wiLFwiYm9sZFwiLFwiYm9sZGVyXCIsXCJib3JkZXJcIixcImJvcmRlci1ib3hcIixcImJvdGhcIixcImJvdHRvbVwiLFwiYnJlYWtcIixcImJyZWFrLWFsbFwiLFwiYnJlYWstd29yZFwiLFwiYnVsbGV0c1wiLFwiYnV0dG9uXCIsXCJidXR0b24tYmV2ZWxcIixcImJ1dHRvbmZhY2VcIixcImJ1dHRvbmhpZ2hsaWdodFwiLFwiYnV0dG9uc2hhZG93XCIsXCJidXR0b250ZXh0XCIsXCJjYWxjXCIsXCJjYW1ib2RpYW5cIixcImNhcGl0YWxpemVcIixcImNhcHMtbG9jay1pbmRpY2F0b3JcIixcImNhcHRpb25cIixcImNhcHRpb250ZXh0XCIsXCJjYXJldFwiLFwiY2VsbFwiLFwiY2VudGVyXCIsXCJjaGVja2JveFwiLFwiY2lyY2xlXCIsXCJjamstZGVjaW1hbFwiLFwiY2prLWVhcnRobHktYnJhbmNoXCIsXCJjamstaGVhdmVubHktc3RlbVwiLFwiY2prLWlkZW9ncmFwaGljXCIsXCJjbGVhclwiLFwiY2xpcFwiLFwiY2xvc2UtcXVvdGVcIixcImNvbC1yZXNpemVcIixcImNvbGxhcHNlXCIsXCJjb2x1bW5cIixcImNvbXBhY3RcIixcImNvbmRlbnNlZFwiLFwiY29udGFpblwiLFwiY29udGVudFwiLFwiY29udGVudHNcIixcImNvbnRlbnQtYm94XCIsXCJjb250ZXh0LW1lbnVcIixcImNvbnRpbnVvdXNcIixcImNvcHlcIixcImNvdW50ZXJcIixcImNvdW50ZXJzXCIsXCJjb3ZlclwiLFwiY3JvcFwiLFwiY3Jvc3NcIixcImNyb3NzaGFpclwiLFwiY3VycmVudGNvbG9yXCIsXCJjdXJzaXZlXCIsXCJjeWNsaWNcIixcImRhc2hlZFwiLFwiZGVjaW1hbFwiLFwiZGVjaW1hbC1sZWFkaW5nLXplcm9cIixcImRlZmF1bHRcIixcImRlZmF1bHQtYnV0dG9uXCIsXCJkZXN0aW5hdGlvbi1hdG9wXCIsXCJkZXN0aW5hdGlvbi1pblwiLFwiZGVzdGluYXRpb24tb3V0XCIsXCJkZXN0aW5hdGlvbi1vdmVyXCIsXCJkZXZhbmFnYXJpXCIsXCJkaXNjXCIsXCJkaXNjYXJkXCIsXCJkaXNjbG9zdXJlLWNsb3NlZFwiLFwiZGlzY2xvc3VyZS1vcGVuXCIsXCJkb2N1bWVudFwiLFwiZG90LWRhc2hcIixcImRvdC1kb3QtZGFzaFwiLFwiZG90dGVkXCIsXCJkb3VibGVcIixcImRvd25cIixcImUtcmVzaXplXCIsXCJlYXNlXCIsXCJlYXNlLWluXCIsXCJlYXNlLWluLW91dFwiLFwiZWFzZS1vdXRcIixcImVsZW1lbnRcIixcImVsbGlwc2VcIixcImVsbGlwc2lzXCIsXCJlbWJlZFwiLFwiZW5kXCIsXCJldGhpb3BpY1wiLFwiZXRoaW9waWMtYWJlZ2VkZVwiLFwiZXRoaW9waWMtYWJlZ2VkZS1hbS1ldFwiLFwiZXRoaW9waWMtYWJlZ2VkZS1nZXpcIixcImV0aGlvcGljLWFiZWdlZGUtdGktZXJcIixcImV0aGlvcGljLWFiZWdlZGUtdGktZXRcIixcImV0aGlvcGljLWhhbGVoYW1lLWFhLWVyXCIsXCJldGhpb3BpYy1oYWxlaGFtZS1hYS1ldFwiLFwiZXRoaW9waWMtaGFsZWhhbWUtYW0tZXRcIixcImV0aGlvcGljLWhhbGVoYW1lLWdlelwiLFwiZXRoaW9waWMtaGFsZWhhbWUtb20tZXRcIixcImV0aGlvcGljLWhhbGVoYW1lLXNpZC1ldFwiLFwiZXRoaW9waWMtaGFsZWhhbWUtc28tZXRcIixcImV0aGlvcGljLWhhbGVoYW1lLXRpLWVyXCIsXCJldGhpb3BpYy1oYWxlaGFtZS10aS1ldFwiLFwiZXRoaW9waWMtaGFsZWhhbWUtdGlnXCIsXCJldGhpb3BpYy1udW1lcmljXCIsXCJldy1yZXNpemVcIixcImV4cGFuZGVkXCIsXCJleHRlbmRzXCIsXCJleHRyYS1jb25kZW5zZWRcIixcImV4dHJhLWV4cGFuZGVkXCIsXCJmYW50YXN5XCIsXCJmYXN0XCIsXCJmaWxsXCIsXCJmaXhlZFwiLFwiZmxhdFwiLFwiZmxleFwiLFwiZm9vdG5vdGVzXCIsXCJmb3J3YXJkc1wiLFwiZnJvbVwiLFwiZ2VvbWV0cmljUHJlY2lzaW9uXCIsXCJnZW9yZ2lhblwiLFwiZ3JheXRleHRcIixcImdyb292ZVwiLFwiZ3VqYXJhdGlcIixcImd1cm11a2hpXCIsXCJoYW5kXCIsXCJoYW5ndWxcIixcImhhbmd1bC1jb25zb25hbnRcIixcImhlYnJld1wiLFwiaGVscFwiLFwiaGlkZGVuXCIsXCJoaWRlXCIsXCJoaWdoZXJcIixcImhpZ2hsaWdodFwiLFwiaGlnaGxpZ2h0dGV4dFwiLFwiaGlyYWdhbmFcIixcImhpcmFnYW5hLWlyb2hhXCIsXCJob3Jpem9udGFsXCIsXCJoc2xcIixcImhzbGFcIixcImljb25cIixcImlnbm9yZVwiLFwiaW5hY3RpdmVib3JkZXJcIixcImluYWN0aXZlY2FwdGlvblwiLFwiaW5hY3RpdmVjYXB0aW9udGV4dFwiLFwiaW5maW5pdGVcIixcImluZm9iYWNrZ3JvdW5kXCIsXCJpbmZvdGV4dFwiLFwiaW5oZXJpdFwiLFwiaW5pdGlhbFwiLFwiaW5saW5lXCIsXCJpbmxpbmUtYXhpc1wiLFwiaW5saW5lLWJsb2NrXCIsXCJpbmxpbmUtZmxleFwiLFwiaW5saW5lLXRhYmxlXCIsXCJpbnNldFwiLFwiaW5zaWRlXCIsXCJpbnRyaW5zaWNcIixcImludmVydFwiLFwiaXRhbGljXCIsXCJqYXBhbmVzZS1mb3JtYWxcIixcImphcGFuZXNlLWluZm9ybWFsXCIsXCJqdXN0aWZ5XCIsXCJrYW5uYWRhXCIsXCJrYXRha2FuYVwiLFwia2F0YWthbmEtaXJvaGFcIixcImtlZXAtYWxsXCIsXCJraG1lclwiLFwia29yZWFuLWhhbmd1bC1mb3JtYWxcIixcImtvcmVhbi1oYW5qYS1mb3JtYWxcIixcImtvcmVhbi1oYW5qYS1pbmZvcm1hbFwiLFwibGFuZHNjYXBlXCIsXCJsYW9cIixcImxhcmdlXCIsXCJsYXJnZXJcIixcImxlZnRcIixcImxldmVsXCIsXCJsaWdodGVyXCIsXCJsaW5lLXRocm91Z2hcIixcImxpbmVhclwiLFwibGluZWFyLWdyYWRpZW50XCIsXCJsaW5lc1wiLFwibGlzdC1pdGVtXCIsXCJsaXN0Ym94XCIsXCJsaXN0aXRlbVwiLFwibG9jYWxcIixcImxvZ2ljYWxcIixcImxvdWRcIixcImxvd2VyXCIsXCJsb3dlci1hbHBoYVwiLFwibG93ZXItYXJtZW5pYW5cIixcImxvd2VyLWdyZWVrXCIsXCJsb3dlci1oZXhhZGVjaW1hbFwiLFwibG93ZXItbGF0aW5cIixcImxvd2VyLW5vcndlZ2lhblwiLFwibG93ZXItcm9tYW5cIixcImxvd2VyY2FzZVwiLFwibHRyXCIsXCJtYWxheWFsYW1cIixcIm1hdGNoXCIsXCJtYXRyaXhcIixcIm1hdHJpeDNkXCIsXCJtZWRpYS1jb250cm9scy1iYWNrZ3JvdW5kXCIsXCJtZWRpYS1jdXJyZW50LXRpbWUtZGlzcGxheVwiLFwibWVkaWEtZnVsbHNjcmVlbi1idXR0b25cIixcIm1lZGlhLW11dGUtYnV0dG9uXCIsXCJtZWRpYS1wbGF5LWJ1dHRvblwiLFwibWVkaWEtcmV0dXJuLXRvLXJlYWx0aW1lLWJ1dHRvblwiLFwibWVkaWEtcmV3aW5kLWJ1dHRvblwiLFwibWVkaWEtc2Vlay1iYWNrLWJ1dHRvblwiLFwibWVkaWEtc2Vlay1mb3J3YXJkLWJ1dHRvblwiLFwibWVkaWEtc2xpZGVyXCIsXCJtZWRpYS1zbGlkZXJ0aHVtYlwiLFwibWVkaWEtdGltZS1yZW1haW5pbmctZGlzcGxheVwiLFwibWVkaWEtdm9sdW1lLXNsaWRlclwiLFwibWVkaWEtdm9sdW1lLXNsaWRlci1jb250YWluZXJcIixcIm1lZGlhLXZvbHVtZS1zbGlkZXJ0aHVtYlwiLFwibWVkaXVtXCIsXCJtZW51XCIsXCJtZW51bGlzdFwiLFwibWVudWxpc3QtYnV0dG9uXCIsXCJtZW51bGlzdC10ZXh0XCIsXCJtZW51bGlzdC10ZXh0ZmllbGRcIixcIm1lbnV0ZXh0XCIsXCJtZXNzYWdlLWJveFwiLFwibWlkZGxlXCIsXCJtaW4taW50cmluc2ljXCIsXCJtaXhcIixcIm1vbmdvbGlhblwiLFwibW9ub3NwYWNlXCIsXCJtb3ZlXCIsXCJtdWx0aXBsZVwiLFwibXlhbm1hclwiLFwibi1yZXNpemVcIixcIm5hcnJvd2VyXCIsXCJuZS1yZXNpemVcIixcIm5lc3ctcmVzaXplXCIsXCJuby1jbG9zZS1xdW90ZVwiLFwibm8tZHJvcFwiLFwibm8tb3Blbi1xdW90ZVwiLFwibm8tcmVwZWF0XCIsXCJub25lXCIsXCJub3JtYWxcIixcIm5vdC1hbGxvd2VkXCIsXCJub3dyYXBcIixcIm5zLXJlc2l6ZVwiLFwibnVtYmVyc1wiLFwibnVtZXJpY1wiLFwibnctcmVzaXplXCIsXCJud3NlLXJlc2l6ZVwiLFwib2JsaXF1ZVwiLFwib2N0YWxcIixcIm9wZW4tcXVvdGVcIixcIm9wdGltaXplTGVnaWJpbGl0eVwiLFwib3B0aW1pemVTcGVlZFwiLFwib3JpeWFcIixcIm9yb21vXCIsXCJvdXRzZXRcIixcIm91dHNpZGVcIixcIm91dHNpZGUtc2hhcGVcIixcIm92ZXJsYXlcIixcIm92ZXJsaW5lXCIsXCJwYWRkaW5nXCIsXCJwYWRkaW5nLWJveFwiLFwicGFpbnRlZFwiLFwicGFnZVwiLFwicGF1c2VkXCIsXCJwZXJzaWFuXCIsXCJwZXJzcGVjdGl2ZVwiLFwicGx1cy1kYXJrZXJcIixcInBsdXMtbGlnaHRlclwiLFwicG9pbnRlclwiLFwicG9seWdvblwiLFwicG9ydHJhaXRcIixcInByZVwiLFwicHJlLWxpbmVcIixcInByZS13cmFwXCIsXCJwcmVzZXJ2ZS0zZFwiLFwicHJvZ3Jlc3NcIixcInB1c2gtYnV0dG9uXCIsXCJyYWRpYWwtZ3JhZGllbnRcIixcInJhZGlvXCIsXCJyZWFkLW9ubHlcIixcInJlYWQtd3JpdGVcIixcInJlYWQtd3JpdGUtcGxhaW50ZXh0LW9ubHlcIixcInJlY3RhbmdsZVwiLFwicmVnaW9uXCIsXCJyZWxhdGl2ZVwiLFwicmVwZWF0XCIsXCJyZXBlYXRpbmctbGluZWFyLWdyYWRpZW50XCIsXCJyZXBlYXRpbmctcmFkaWFsLWdyYWRpZW50XCIsXCJyZXBlYXQteFwiLFwicmVwZWF0LXlcIixcInJlc2V0XCIsXCJyZXZlcnNlXCIsXCJyZ2JcIixcInJnYmFcIixcInJpZGdlXCIsXCJyaWdodFwiLFwicm90YXRlXCIsXCJyb3RhdGUzZFwiLFwicm90YXRlWFwiLFwicm90YXRlWVwiLFwicm90YXRlWlwiLFwicm91bmRcIixcInJvdy1yZXNpemVcIixcInJ0bFwiLFwicnVuLWluXCIsXCJydW5uaW5nXCIsXCJzLXJlc2l6ZVwiLFwic2Fucy1zZXJpZlwiLFwic2NhbGVcIixcInNjYWxlM2RcIixcInNjYWxlWFwiLFwic2NhbGVZXCIsXCJzY2FsZVpcIixcInNjcm9sbFwiLFwic2Nyb2xsYmFyXCIsXCJzY3JvbGwtcG9zaXRpb25cIixcInNlLXJlc2l6ZVwiLFwic2VhcmNoZmllbGRcIixcInNlYXJjaGZpZWxkLWNhbmNlbC1idXR0b25cIixcInNlYXJjaGZpZWxkLWRlY29yYXRpb25cIixcInNlYXJjaGZpZWxkLXJlc3VsdHMtYnV0dG9uXCIsXCJzZWFyY2hmaWVsZC1yZXN1bHRzLWRlY29yYXRpb25cIixcInNlbWktY29uZGVuc2VkXCIsXCJzZW1pLWV4cGFuZGVkXCIsXCJzZXBhcmF0ZVwiLFwic2VyaWZcIixcInNob3dcIixcInNpZGFtYVwiLFwic2ltcC1jaGluZXNlLWZvcm1hbFwiLFwic2ltcC1jaGluZXNlLWluZm9ybWFsXCIsXCJzaW5nbGVcIixcInNrZXdcIixcInNrZXdYXCIsXCJza2V3WVwiLFwic2tpcC13aGl0ZS1zcGFjZVwiLFwic2xpZGVcIixcInNsaWRlci1ob3Jpem9udGFsXCIsXCJzbGlkZXItdmVydGljYWxcIixcInNsaWRlcnRodW1iLWhvcml6b250YWxcIixcInNsaWRlcnRodW1iLXZlcnRpY2FsXCIsXCJzbG93XCIsXCJzbWFsbFwiLFwic21hbGwtY2Fwc1wiLFwic21hbGwtY2FwdGlvblwiLFwic21hbGxlclwiLFwic29saWRcIixcInNvbWFsaVwiLFwic291cmNlLWF0b3BcIixcInNvdXJjZS1pblwiLFwic291cmNlLW91dFwiLFwic291cmNlLW92ZXJcIixcInNwYWNlXCIsXCJzcGVsbC1vdXRcIixcInNxdWFyZVwiLFwic3F1YXJlLWJ1dHRvblwiLFwic3RhcnRcIixcInN0YXRpY1wiLFwic3RhdHVzLWJhclwiLFwic3RyZXRjaFwiLFwic3Ryb2tlXCIsXCJzdWJcIixcInN1YnBpeGVsLWFudGlhbGlhc2VkXCIsXCJzdXBlclwiLFwic3ctcmVzaXplXCIsXCJzeW1ib2xpY1wiLFwic3ltYm9sc1wiLFwidGFibGVcIixcInRhYmxlLWNhcHRpb25cIixcInRhYmxlLWNlbGxcIixcInRhYmxlLWNvbHVtblwiLFwidGFibGUtY29sdW1uLWdyb3VwXCIsXCJ0YWJsZS1mb290ZXItZ3JvdXBcIixcInRhYmxlLWhlYWRlci1ncm91cFwiLFwidGFibGUtcm93XCIsXCJ0YWJsZS1yb3ctZ3JvdXBcIixcInRhbWlsXCIsXCJ0ZWx1Z3VcIixcInRleHRcIixcInRleHQtYm90dG9tXCIsXCJ0ZXh0LXRvcFwiLFwidGV4dGFyZWFcIixcInRleHRmaWVsZFwiLFwidGhhaVwiLFwidGhpY2tcIixcInRoaW5cIixcInRocmVlZGRhcmtzaGFkb3dcIixcInRocmVlZGZhY2VcIixcInRocmVlZGhpZ2hsaWdodFwiLFwidGhyZWVkbGlnaHRzaGFkb3dcIixcInRocmVlZHNoYWRvd1wiLFwidGliZXRhblwiLFwidGlncmVcIixcInRpZ3JpbnlhLWVyXCIsXCJ0aWdyaW55YS1lci1hYmVnZWRlXCIsXCJ0aWdyaW55YS1ldFwiLFwidGlncmlueWEtZXQtYWJlZ2VkZVwiLFwidG9cIixcInRvcFwiLFwidHJhZC1jaGluZXNlLWZvcm1hbFwiLFwidHJhZC1jaGluZXNlLWluZm9ybWFsXCIsXCJ0cmFuc2xhdGVcIixcInRyYW5zbGF0ZTNkXCIsXCJ0cmFuc2xhdGVYXCIsXCJ0cmFuc2xhdGVZXCIsXCJ0cmFuc2xhdGVaXCIsXCJ0cmFuc3BhcmVudFwiLFwidWx0cmEtY29uZGVuc2VkXCIsXCJ1bHRyYS1leHBhbmRlZFwiLFwidW5kZXJsaW5lXCIsXCJ1cFwiLFwidXBwZXItYWxwaGFcIixcInVwcGVyLWFybWVuaWFuXCIsXCJ1cHBlci1ncmVla1wiLFwidXBwZXItaGV4YWRlY2ltYWxcIixcInVwcGVyLWxhdGluXCIsXCJ1cHBlci1ub3J3ZWdpYW5cIixcInVwcGVyLXJvbWFuXCIsXCJ1cHBlcmNhc2VcIixcInVyZHVcIixcInVybFwiLFwidmFyXCIsXCJ2ZXJ0aWNhbFwiLFwidmVydGljYWwtdGV4dFwiLFwidmlzaWJsZVwiLFwidmlzaWJsZUZpbGxcIixcInZpc2libGVQYWludGVkXCIsXCJ2aXNpYmxlU3Ryb2tlXCIsXCJ2aXN1YWxcIixcInctcmVzaXplXCIsXCJ3YWl0XCIsXCJ3YXZlXCIsXCJ3aWRlclwiLFwid2luZG93XCIsXCJ3aW5kb3dmcmFtZVwiLFwid2luZG93dGV4dFwiLFwid29yZHNcIixcIngtbGFyZ2VcIixcIngtc21hbGxcIixcInhvclwiLFwieHgtbGFyZ2VcIixcInh4LXNtYWxsXCIsXCJiaWN1YmljXCIsXCJvcHRpbWl6ZXNwZWVkXCIsXCJncmF5c2NhbGVcIixcInJvd1wiLFwicm93LXJldmVyc2VcIixcIndyYXBcIixcIndyYXAtcmV2ZXJzZVwiLFwiY29sdW1uLXJldmVyc2VcIixcImZsZXgtc3RhcnRcIixcImZsZXgtZW5kXCIsXCJzcGFjZS1iZXR3ZWVuXCIsXCJzcGFjZS1hcm91bmRcIiwgXCJ1bnNldFwiXTtcblxuICB2YXIgd29yZE9wZXJhdG9yS2V5d29yZHNfID0gW1wiaW5cIixcImFuZFwiLFwib3JcIixcIm5vdFwiLFwiaXMgbm90XCIsXCJpcyBhXCIsXCJpc1wiLFwiaXNudFwiLFwiZGVmaW5lZFwiLFwiaWYgdW5sZXNzXCJdLFxuICAgICAgYmxvY2tLZXl3b3Jkc18gPSBbXCJmb3JcIixcImlmXCIsXCJlbHNlXCIsXCJ1bmxlc3NcIiwgXCJmcm9tXCIsIFwidG9cIl0sXG4gICAgICBjb21tb25BdG9tc18gPSBbXCJudWxsXCIsXCJ0cnVlXCIsXCJmYWxzZVwiLFwiaHJlZlwiLFwidGl0bGVcIixcInR5cGVcIixcIm5vdC1hbGxvd2VkXCIsXCJyZWFkb25seVwiLFwiZGlzYWJsZWRcIl0sXG4gICAgICBjb21tb25EZWZfID0gW1wiQGZvbnQtZmFjZVwiLCBcIkBrZXlmcmFtZXNcIiwgXCJAbWVkaWFcIiwgXCJAdmlld3BvcnRcIiwgXCJAcGFnZVwiLCBcIkBob3N0XCIsIFwiQHN1cHBvcnRzXCIsIFwiQGJsb2NrXCIsIFwiQGNzc1wiXTtcblxuICB2YXIgaGludFdvcmRzID0gdGFnS2V5d29yZHNfLmNvbmNhdChkb2N1bWVudFR5cGVzXyxtZWRpYVR5cGVzXyxtZWRpYUZlYXR1cmVzXyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlLZXl3b3Jkc18sbm9uU3RhbmRhcmRQcm9wZXJ0eUtleXdvcmRzXyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JLZXl3b3Jkc18sdmFsdWVLZXl3b3Jkc18sZm9udFByb3BlcnRpZXNfLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JkT3BlcmF0b3JLZXl3b3Jkc18sYmxvY2tLZXl3b3Jkc18sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1vbkF0b21zXyxjb21tb25EZWZfKTtcblxuICBmdW5jdGlvbiB3b3JkUmVnZXhwKHdvcmRzKSB7XG4gICAgd29yZHMgPSB3b3Jkcy5zb3J0KGZ1bmN0aW9uKGEsYil7cmV0dXJuIGIgPiBhO30pO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiXigoXCIgKyB3b3Jkcy5qb2luKFwiKXwoXCIpICsgXCIpKVxcXFxiXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24ga2V5U2V0KGFycmF5KSB7XG4gICAgdmFyIGtleXMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKSBrZXlzW2FycmF5W2ldXSA9IHRydWU7XG4gICAgcmV0dXJuIGtleXM7XG4gIH1cblxuICBmdW5jdGlvbiBlc2NhcGVSZWdFeHAodGV4dCkge1xuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoL1stW1xcXXt9KCkqKz8uLFxcXFxeJHwjXFxzXS9nLCBcIlxcXFwkJlwiKTtcbiAgfVxuXG4gIENvZGVNaXJyb3IucmVnaXN0ZXJIZWxwZXIoXCJoaW50V29yZHNcIiwgXCJzdHlsdXNcIiwgaGludFdvcmRzKTtcbiAgQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LXN0eWxcIiwgXCJzdHlsdXNcIik7XG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbi8vIFN3aWZ0IG1vZGUgY3JlYXRlZCBieSBNaWNoYWVsIEthbWluc2t5IGh0dHBzOi8vZ2l0aHViLmNvbS9ta2FtaW5za3kxMVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIilcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKVxuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKVxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKVxuICBlbHNlXG4gICAgbW9kKENvZGVNaXJyb3IpXG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG4gIFwidXNlIHN0cmljdFwiXG5cbiAgZnVuY3Rpb24gd29yZFNldCh3b3Jkcykge1xuICAgIHZhciBzZXQgPSB7fVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyBpKyspIHNldFt3b3Jkc1tpXV0gPSB0cnVlXG4gICAgcmV0dXJuIHNldFxuICB9XG5cbiAgdmFyIGtleXdvcmRzID0gd29yZFNldChbXCJfXCIsXCJ2YXJcIixcImxldFwiLFwiY2xhc3NcIixcImVudW1cIixcImV4dGVuc2lvblwiLFwiaW1wb3J0XCIsXCJwcm90b2NvbFwiLFwic3RydWN0XCIsXCJmdW5jXCIsXCJ0eXBlYWxpYXNcIixcImFzc29jaWF0ZWR0eXBlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwib3BlblwiLFwicHVibGljXCIsXCJpbnRlcm5hbFwiLFwiZmlsZXByaXZhdGVcIixcInByaXZhdGVcIixcImRlaW5pdFwiLFwiaW5pdFwiLFwibmV3XCIsXCJvdmVycmlkZVwiLFwic2VsZlwiLFwic3Vic2NyaXB0XCIsXCJzdXBlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImNvbnZlbmllbmNlXCIsXCJkeW5hbWljXCIsXCJmaW5hbFwiLFwiaW5kaXJlY3RcIixcImxhenlcIixcInJlcXVpcmVkXCIsXCJzdGF0aWNcIixcInVub3duZWRcIixcInVub3duZWQoc2FmZSlcIixcInVub3duZWQodW5zYWZlKVwiLFwid2Vha1wiLFwiYXNcIixcImlzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYnJlYWtcIixcImNhc2VcIixcImNvbnRpbnVlXCIsXCJkZWZhdWx0XCIsXCJlbHNlXCIsXCJmYWxsdGhyb3VnaFwiLFwiZm9yXCIsXCJndWFyZFwiLFwiaWZcIixcImluXCIsXCJyZXBlYXRcIixcInN3aXRjaFwiLFwid2hlcmVcIixcIndoaWxlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiZGVmZXJcIixcInJldHVyblwiLFwiaW5vdXRcIixcIm11dGF0aW5nXCIsXCJub25tdXRhdGluZ1wiLFwiY2F0Y2hcIixcImRvXCIsXCJyZXRocm93c1wiLFwidGhyb3dcIixcInRocm93c1wiLFwidHJ5XCIsXCJkaWRTZXRcIixcImdldFwiLFwic2V0XCIsXCJ3aWxsU2V0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYXNzaWdubWVudFwiLFwiYXNzb2NpYXRpdml0eVwiLFwiaW5maXhcIixcImxlZnRcIixcIm5vbmVcIixcIm9wZXJhdG9yXCIsXCJwb3N0Zml4XCIsXCJwcmVjZWRlbmNlXCIsXCJwcmVjZWRlbmNlZ3JvdXBcIixcInByZWZpeFwiLFwicmlnaHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJBbnlcIixcIkFueU9iamVjdFwiLFwiVHlwZVwiLFwiZHluYW1pY1R5cGVcIixcIlNlbGZcIixcIlByb3RvY29sXCIsXCJfX0NPTFVNTl9fXCIsXCJfX0ZJTEVfX1wiLFwiX19GVU5DVElPTl9fXCIsXCJfX0xJTkVfX1wiXSlcbiAgdmFyIGRlZmluaW5nS2V5d29yZHMgPSB3b3JkU2V0KFtcInZhclwiLFwibGV0XCIsXCJjbGFzc1wiLFwiZW51bVwiLFwiZXh0ZW5zaW9uXCIsXCJpbXBvcnRcIixcInByb3RvY29sXCIsXCJzdHJ1Y3RcIixcImZ1bmNcIixcInR5cGVhbGlhc1wiLFwiYXNzb2NpYXRlZHR5cGVcIixcImZvclwiXSlcbiAgdmFyIGF0b21zID0gd29yZFNldChbXCJ0cnVlXCIsXCJmYWxzZVwiLFwibmlsXCIsXCJzZWxmXCIsXCJzdXBlclwiLFwiX1wiXSlcbiAgdmFyIHR5cGVzID0gd29yZFNldChbXCJBcnJheVwiLFwiQm9vbFwiLFwiQ2hhcmFjdGVyXCIsXCJEaWN0aW9uYXJ5XCIsXCJEb3VibGVcIixcIkZsb2F0XCIsXCJJbnRcIixcIkludDhcIixcIkludDE2XCIsXCJJbnQzMlwiLFwiSW50NjRcIixcIk5ldmVyXCIsXCJPcHRpb25hbFwiLFwiU2V0XCIsXCJTdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgXCJVSW50OFwiLFwiVUludDE2XCIsXCJVSW50MzJcIixcIlVJbnQ2NFwiLFwiVm9pZFwiXSlcbiAgdmFyIG9wZXJhdG9ycyA9IFwiKy0vKiU9fCY8Pn5ePyFcIlxuICB2YXIgcHVuYyA9IFwiOjssLigpe31bXVwiXG4gIHZhciBiaW5hcnkgPSAvXlxcLT8wYlswMV1bMDFfXSovXG4gIHZhciBvY3RhbCA9IC9eXFwtPzBvWzAtN11bMC03X10qL1xuICB2YXIgaGV4YWRlY2ltYWwgPSAvXlxcLT8weFtcXGRBLUZhLWZdW1xcZEEtRmEtZl9dKig/Oig/OlxcLltcXGRBLUZhLWZdW1xcZEEtRmEtZl9dKik/W1BwXVxcLT9cXGRbXFxkX10qKT8vXG4gIHZhciBkZWNpbWFsID0gL15cXC0/XFxkW1xcZF9dKig/OlxcLlxcZFtcXGRfXSopPyg/OltFZV1cXC0/XFxkW1xcZF9dKik/L1xuICB2YXIgaWRlbnRpZmllciA9IC9eXFwkXFxkK3woYD8pW19BLVphLXpdW19BLVphLXokMC05XSpcXDEvXG4gIHZhciBwcm9wZXJ0eSA9IC9eXFwuKD86XFwkXFxkK3woYD8pW19BLVphLXpdW19BLVphLXokMC05XSpcXDEpL1xuICB2YXIgaW5zdHJ1Y3Rpb24gPSAvXlxcI1tBLVphLXpdKy9cbiAgdmFyIGF0dHJpYnV0ZSA9IC9eQCg/OlxcJFxcZCt8KGA/KVtfQS1aYS16XVtfQS1aYS16JDAtOV0qXFwxKS9cbiAgLy92YXIgcmVnZXhwID0gL15cXC8oPyFcXHMpKD86XFwvXFwvKT8oPzpcXFxcLnxbXlxcL10pK1xcLy9cblxuICBmdW5jdGlvbiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSwgcHJldikge1xuICAgIGlmIChzdHJlYW0uc29sKCkpIHN0YXRlLmluZGVudGVkID0gc3RyZWFtLmluZGVudGF0aW9uKClcbiAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsXG5cbiAgICB2YXIgY2ggPSBzdHJlYW0ucGVlaygpXG4gICAgaWYgKGNoID09IFwiL1wiKSB7XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKFwiLy9cIikpIHtcbiAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpXG4gICAgICAgIHJldHVybiBcImNvbW1lbnRcIlxuICAgICAgfVxuICAgICAgaWYgKHN0cmVhbS5tYXRjaChcIi8qXCIpKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplLnB1c2godG9rZW5Db21tZW50KVxuICAgICAgICByZXR1cm4gdG9rZW5Db21tZW50KHN0cmVhbSwgc3RhdGUpXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdHJlYW0ubWF0Y2goaW5zdHJ1Y3Rpb24pKSByZXR1cm4gXCJidWlsdGluXCJcbiAgICBpZiAoc3RyZWFtLm1hdGNoKGF0dHJpYnV0ZSkpIHJldHVybiBcImF0dHJpYnV0ZVwiXG4gICAgaWYgKHN0cmVhbS5tYXRjaChiaW5hcnkpKSByZXR1cm4gXCJudW1iZXJcIlxuICAgIGlmIChzdHJlYW0ubWF0Y2gob2N0YWwpKSByZXR1cm4gXCJudW1iZXJcIlxuICAgIGlmIChzdHJlYW0ubWF0Y2goaGV4YWRlY2ltYWwpKSByZXR1cm4gXCJudW1iZXJcIlxuICAgIGlmIChzdHJlYW0ubWF0Y2goZGVjaW1hbCkpIHJldHVybiBcIm51bWJlclwiXG4gICAgaWYgKHN0cmVhbS5tYXRjaChwcm9wZXJ0eSkpIHJldHVybiBcInByb3BlcnR5XCJcbiAgICBpZiAob3BlcmF0b3JzLmluZGV4T2YoY2gpID4gLTEpIHtcbiAgICAgIHN0cmVhbS5uZXh0KClcbiAgICAgIHJldHVybiBcIm9wZXJhdG9yXCJcbiAgICB9XG4gICAgaWYgKHB1bmMuaW5kZXhPZihjaCkgPiAtMSkge1xuICAgICAgc3RyZWFtLm5leHQoKVxuICAgICAgc3RyZWFtLm1hdGNoKFwiLi5cIilcbiAgICAgIHJldHVybiBcInB1bmN0dWF0aW9uXCJcbiAgICB9XG4gICAgdmFyIHN0cmluZ01hdGNoXG4gICAgaWYgKHN0cmluZ01hdGNoID0gc3RyZWFtLm1hdGNoKC8oXCJcIlwifFwifCcpLykpIHtcbiAgICAgIHZhciB0b2tlbml6ZSA9IHRva2VuU3RyaW5nLmJpbmQobnVsbCwgc3RyaW5nTWF0Y2hbMF0pXG4gICAgICBzdGF0ZS50b2tlbml6ZS5wdXNoKHRva2VuaXplKVxuICAgICAgcmV0dXJuIHRva2VuaXplKHN0cmVhbSwgc3RhdGUpXG4gICAgfVxuXG4gICAgaWYgKHN0cmVhbS5tYXRjaChpZGVudGlmaWVyKSkge1xuICAgICAgdmFyIGlkZW50ID0gc3RyZWFtLmN1cnJlbnQoKVxuICAgICAgaWYgKHR5cGVzLmhhc093blByb3BlcnR5KGlkZW50KSkgcmV0dXJuIFwidmFyaWFibGUtMlwiXG4gICAgICBpZiAoYXRvbXMuaGFzT3duUHJvcGVydHkoaWRlbnQpKSByZXR1cm4gXCJhdG9tXCJcbiAgICAgIGlmIChrZXl3b3Jkcy5oYXNPd25Qcm9wZXJ0eShpZGVudCkpIHtcbiAgICAgICAgaWYgKGRlZmluaW5nS2V5d29yZHMuaGFzT3duUHJvcGVydHkoaWRlbnQpKVxuICAgICAgICAgIHN0YXRlLnByZXYgPSBcImRlZmluZVwiXG4gICAgICAgIHJldHVybiBcImtleXdvcmRcIlxuICAgICAgfVxuICAgICAgaWYgKHByZXYgPT0gXCJkZWZpbmVcIikgcmV0dXJuIFwiZGVmXCJcbiAgICAgIHJldHVybiBcInZhcmlhYmxlXCJcbiAgICB9XG5cbiAgICBzdHJlYW0ubmV4dCgpXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuVW50aWxDbG9zaW5nUGFyZW4oKSB7XG4gICAgdmFyIGRlcHRoID0gMFxuICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlLCBwcmV2KSB7XG4gICAgICB2YXIgaW5uZXIgPSB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSwgcHJldilcbiAgICAgIGlmIChpbm5lciA9PSBcInB1bmN0dWF0aW9uXCIpIHtcbiAgICAgICAgaWYgKHN0cmVhbS5jdXJyZW50KCkgPT0gXCIoXCIpICsrZGVwdGhcbiAgICAgICAgZWxzZSBpZiAoc3RyZWFtLmN1cnJlbnQoKSA9PSBcIilcIikge1xuICAgICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XG4gICAgICAgICAgICBzdHJlYW0uYmFja1VwKDEpXG4gICAgICAgICAgICBzdGF0ZS50b2tlbml6ZS5wb3AoKVxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplW3N0YXRlLnRva2VuaXplLmxlbmd0aCAtIDFdKHN0cmVhbSwgc3RhdGUpXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgLS1kZXB0aFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5uZXJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlblN0cmluZyhvcGVuUXVvdGUsIHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgc2luZ2xlTGluZSA9IG9wZW5RdW90ZS5sZW5ndGggPT0gMVxuICAgIHZhciBjaCwgZXNjYXBlZCA9IGZhbHNlXG4gICAgd2hpbGUgKGNoID0gc3RyZWFtLnBlZWsoKSkge1xuICAgICAgaWYgKGVzY2FwZWQpIHtcbiAgICAgICAgc3RyZWFtLm5leHQoKVxuICAgICAgICBpZiAoY2ggPT0gXCIoXCIpIHtcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZS5wdXNoKHRva2VuVW50aWxDbG9zaW5nUGFyZW4oKSlcbiAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIlxuICAgICAgICB9XG4gICAgICAgIGVzY2FwZWQgPSBmYWxzZVxuICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2gob3BlblF1b3RlKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZS5wb3AoKVxuICAgICAgICByZXR1cm4gXCJzdHJpbmdcIlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyZWFtLm5leHQoKVxuICAgICAgICBlc2NhcGVkID0gY2ggPT0gXCJcXFxcXCJcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNpbmdsZUxpbmUpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplLnBvcCgpXG4gICAgfVxuICAgIHJldHVybiBcInN0cmluZ1wiXG4gIH1cblxuICBmdW5jdGlvbiB0b2tlbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBjaFxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBzdHJlYW0ubWF0Y2goL15bXi8qXSsvLCB0cnVlKVxuICAgICAgY2ggPSBzdHJlYW0ubmV4dCgpXG4gICAgICBpZiAoIWNoKSBicmVha1xuICAgICAgaWYgKGNoID09PSBcIi9cIiAmJiBzdHJlYW0uZWF0KFwiKlwiKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZS5wdXNoKHRva2VuQ29tbWVudClcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT09IFwiKlwiICYmIHN0cmVhbS5lYXQoXCIvXCIpKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplLnBvcCgpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcImNvbW1lbnRcIlxuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dChwcmV2LCBhbGlnbiwgaW5kZW50ZWQpIHtcbiAgICB0aGlzLnByZXYgPSBwcmV2XG4gICAgdGhpcy5hbGlnbiA9IGFsaWduXG4gICAgdGhpcy5pbmRlbnRlZCA9IGluZGVudGVkXG4gIH1cblxuICBmdW5jdGlvbiBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtKSB7XG4gICAgdmFyIGFsaWduID0gc3RyZWFtLm1hdGNoKC9eXFxzKigkfFxcL1tcXC9cXCpdKS8sIGZhbHNlKSA/IG51bGwgOiBzdHJlYW0uY29sdW1uKCkgKyAxXG4gICAgc3RhdGUuY29udGV4dCA9IG5ldyBDb250ZXh0KHN0YXRlLmNvbnRleHQsIGFsaWduLCBzdGF0ZS5pbmRlbnRlZClcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvcENvbnRleHQoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuY29udGV4dCkge1xuICAgICAgc3RhdGUuaW5kZW50ZWQgPSBzdGF0ZS5jb250ZXh0LmluZGVudGVkXG4gICAgICBzdGF0ZS5jb250ZXh0ID0gc3RhdGUuY29udGV4dC5wcmV2XG4gICAgfVxuICB9XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwic3dpZnRcIiwgZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHByZXY6IG51bGwsXG4gICAgICAgICAgY29udGV4dDogbnVsbCxcbiAgICAgICAgICBpbmRlbnRlZDogMCxcbiAgICAgICAgICB0b2tlbml6ZTogW11cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgdmFyIHByZXYgPSBzdGF0ZS5wcmV2XG4gICAgICAgIHN0YXRlLnByZXYgPSBudWxsXG4gICAgICAgIHZhciB0b2tlbml6ZSA9IHN0YXRlLnRva2VuaXplW3N0YXRlLnRva2VuaXplLmxlbmd0aCAtIDFdIHx8IHRva2VuQmFzZVxuICAgICAgICB2YXIgc3R5bGUgPSB0b2tlbml6ZShzdHJlYW0sIHN0YXRlLCBwcmV2KVxuICAgICAgICBpZiAoIXN0eWxlIHx8IHN0eWxlID09IFwiY29tbWVudFwiKSBzdGF0ZS5wcmV2ID0gcHJldlxuICAgICAgICBlbHNlIGlmICghc3RhdGUucHJldikgc3RhdGUucHJldiA9IHN0eWxlXG5cbiAgICAgICAgaWYgKHN0eWxlID09IFwicHVuY3R1YXRpb25cIikge1xuICAgICAgICAgIHZhciBicmFja2V0ID0gL1tcXChcXFtcXHtdfChbXFxdXFwpXFx9XSkvLmV4ZWMoc3RyZWFtLmN1cnJlbnQoKSlcbiAgICAgICAgICBpZiAoYnJhY2tldCkgKGJyYWNrZXRbMV0gPyBwb3BDb250ZXh0IDogcHVzaENvbnRleHQpKHN0YXRlLCBzdHJlYW0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3R5bGVcbiAgICAgIH0sXG5cbiAgICAgIGluZGVudDogZnVuY3Rpb24oc3RhdGUsIHRleHRBZnRlcikge1xuICAgICAgICB2YXIgY3ggPSBzdGF0ZS5jb250ZXh0XG4gICAgICAgIGlmICghY3gpIHJldHVybiAwXG4gICAgICAgIHZhciBjbG9zaW5nID0gL15bXFxdXFx9XFwpXS8udGVzdCh0ZXh0QWZ0ZXIpXG4gICAgICAgIGlmIChjeC5hbGlnbiAhPSBudWxsKSByZXR1cm4gY3guYWxpZ24gLSAoY2xvc2luZyA/IDEgOiAwKVxuICAgICAgICByZXR1cm4gY3guaW5kZW50ZWQgKyAoY2xvc2luZyA/IDAgOiBjb25maWcuaW5kZW50VW5pdClcbiAgICAgIH0sXG5cbiAgICAgIGVsZWN0cmljSW5wdXQ6IC9eXFxzKltcXClcXH1cXF1dJC8sXG5cbiAgICAgIGxpbmVDb21tZW50OiBcIi8vXCIsXG4gICAgICBibG9ja0NvbW1lbnRTdGFydDogXCIvKlwiLFxuICAgICAgYmxvY2tDb21tZW50RW5kOiBcIiovXCIsXG4gICAgICBmb2xkOiBcImJyYWNlXCIsXG4gICAgICBjbG9zZUJyYWNrZXRzOiBcIigpW117fScnXFxcIlxcXCJgYFwiXG4gICAgfVxuICB9KVxuXG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQveC1zd2lmdFwiLFwic3dpZnRcIilcbn0pO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuLy90Y2wgbW9kZSBieSBGb3JkX0xhd25tb3dlciA6OiBCYXNlZCBvbiBWZWxvY2l0eSBtb2RlIGJ5IFN0ZXZlIE8nSGFyYVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTW9kZShcInRjbFwiLCBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gcGFyc2VXb3JkcyhzdHIpIHtcbiAgICB2YXIgb2JqID0ge30sIHdvcmRzID0gc3RyLnNwbGl0KFwiIFwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgKytpKSBvYmpbd29yZHNbaV1dID0gdHJ1ZTtcbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIHZhciBrZXl3b3JkcyA9IHBhcnNlV29yZHMoXCJUY2wgc2FmZSBhZnRlciBhcHBlbmQgYXJyYXkgYXV0b19leGVjb2sgYXV0b19pbXBvcnQgYXV0b19sb2FkIFwiICtcbiAgICAgICAgXCJhdXRvX21raW5kZXggYXV0b19ta2luZGV4X29sZCBhdXRvX3F1YWxpZnkgYXV0b19yZXNldCBiZ2Vycm9yIFwiICtcbiAgICAgICAgXCJiaW5hcnkgYnJlYWsgY2F0Y2ggY2QgY2xvc2UgY29uY2F0IGNvbnRpbnVlIGRkZSBlb2YgZW5jb2RpbmcgZXJyb3IgXCIgK1xuICAgICAgICBcImV2YWwgZXhlYyBleGl0IGV4cHIgZmJsb2NrZWQgZmNvbmZpZ3VyZSBmY29weSBmaWxlIGZpbGVldmVudCBmaWxlbmFtZSBcIiArXG4gICAgICAgIFwiZmlsZW5hbWUgZmx1c2ggZm9yIGZvcmVhY2ggZm9ybWF0IGdldHMgZ2xvYiBnbG9iYWwgaGlzdG9yeSBodHRwIGlmIFwiICtcbiAgICAgICAgXCJpbmNyIGluZm8gaW50ZXJwIGpvaW4gbGFwcGVuZCBsaW5kZXggbGluc2VydCBsaXN0IGxsZW5ndGggbG9hZCBscmFuZ2UgXCIgK1xuICAgICAgICBcImxyZXBsYWNlIGxzZWFyY2ggbHNldCBsc29ydCBtZW1vcnkgbXNnY2F0IG5hbWVzcGFjZSBvcGVuIHBhY2thZ2UgcGFycmF5IFwiICtcbiAgICAgICAgXCJwaWQgcGtnOjpjcmVhdGUgcGtnX21rSW5kZXggcHJvYyBwdXRzIHB3ZCByZV9zeW50YXggcmVhZCByZWdleCByZWdleHAgXCIgK1xuICAgICAgICBcInJlZ2lzdHJ5IHJlZ3N1YiByZW5hbWUgcmVzb3VyY2UgcmV0dXJuIHNjYW4gc2VlayBzZXQgc29ja2V0IHNvdXJjZSBzcGxpdCBcIiArXG4gICAgICAgIFwic3RyaW5nIHN1YnN0IHN3aXRjaCB0Y2xfZW5kT2ZXb3JkIHRjbF9maW5kTGlicmFyeSB0Y2xfc3RhcnRPZk5leHRXb3JkIFwiICtcbiAgICAgICAgXCJ0Y2xfd29yZEJyZWFrQWZ0ZXIgdGNsX3N0YXJ0T2ZQcmV2aW91c1dvcmQgdGNsX3dvcmRCcmVha0JlZm9yZSB0Y2x0ZXN0IFwiICtcbiAgICAgICAgXCJ0Y2x2YXJzIHRlbGwgdGltZSB0cmFjZSB1bmtub3duIHVuc2V0IHVwZGF0ZSB1cGxldmVsIHVwdmFyIHZhcmlhYmxlIFwiICtcbiAgICBcInZ3YWl0XCIpO1xuICAgIHZhciBmdW5jdGlvbnMgPSBwYXJzZVdvcmRzKFwiaWYgZWxzZWlmIGVsc2UgYW5kIG5vdCBvciBlcSBuZSBpbiBuaSBmb3IgZm9yZWFjaCB3aGlsZSBzd2l0Y2hcIik7XG4gICAgdmFyIGlzT3BlcmF0b3JDaGFyID0gL1srXFwtKiYlPTw+IT9eXFwvXFx8XS87XG4gICAgZnVuY3Rpb24gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgZikge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSBmO1xuICAgICAgcmV0dXJuIGYoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgYmVmb3JlUGFyYW1zID0gc3RhdGUuYmVmb3JlUGFyYW1zO1xuICAgICAgc3RhdGUuYmVmb3JlUGFyYW1zID0gZmFsc2U7XG4gICAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICAgICAgaWYgKChjaCA9PSAnXCInIHx8IGNoID09IFwiJ1wiKSAmJiBzdGF0ZS5pblBhcmFtcykge1xuICAgICAgICByZXR1cm4gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgdG9rZW5TdHJpbmcoY2gpKTtcbiAgICAgIH0gZWxzZSBpZiAoL1tcXFtcXF17fVxcKFxcKSw7XFwuXS8udGVzdChjaCkpIHtcbiAgICAgICAgaWYgKGNoID09IFwiKFwiICYmIGJlZm9yZVBhcmFtcykgc3RhdGUuaW5QYXJhbXMgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmIChjaCA9PSBcIilcIikgc3RhdGUuaW5QYXJhbXMgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoL1xcZC8udGVzdChjaCkpIHtcbiAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwuXS8pO1xuICAgICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCIjXCIpIHtcbiAgICAgICAgaWYgKHN0cmVhbS5lYXQoXCIqXCIpKVxuICAgICAgICAgIHJldHVybiBjaGFpbihzdHJlYW0sIHN0YXRlLCB0b2tlbkNvbW1lbnQpO1xuICAgICAgICBpZiAoY2ggPT0gXCIjXCIgJiYgc3RyZWFtLm1hdGNoKC8gKlxcWyAqXFxbLykpXG4gICAgICAgICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIHRva2VuVW5wYXJzZWQpO1xuICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT0gJ1wiJykge1xuICAgICAgICBzdHJlYW0uc2tpcFRvKC9cIi8pO1xuICAgICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgICB9IGVsc2UgaWYgKGNoID09IFwiJFwiKSB7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvWyRfYS16MC05QS1aXFwuezpdLyk7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvfS8pO1xuICAgICAgICBzdGF0ZS5iZWZvcmVQYXJhbXMgPSB0cnVlO1xuICAgICAgICByZXR1cm4gXCJidWlsdGluXCI7XG4gICAgICB9IGVsc2UgaWYgKGlzT3BlcmF0b3JDaGFyLnRlc3QoY2gpKSB7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZShpc09wZXJhdG9yQ2hhcik7XG4gICAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcJF97fVxceGExLVxcdWZmZmZdLyk7XG4gICAgICAgIHZhciB3b3JkID0gc3RyZWFtLmN1cnJlbnQoKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoa2V5d29yZHMgJiYga2V5d29yZHMucHJvcGVydHlJc0VudW1lcmFibGUod29yZCkpXG4gICAgICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICAgICAgICBpZiAoZnVuY3Rpb25zICYmIGZ1bmN0aW9ucy5wcm9wZXJ0eUlzRW51bWVyYWJsZSh3b3JkKSkge1xuICAgICAgICAgIHN0YXRlLmJlZm9yZVBhcmFtcyA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0b2tlblN0cmluZyhxdW90ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBlc2NhcGVkID0gZmFsc2UsIG5leHQsIGVuZCA9IGZhbHNlO1xuICAgICAgd2hpbGUgKChuZXh0ID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgICBpZiAobmV4dCA9PSBxdW90ZSAmJiAhZXNjYXBlZCkge1xuICAgICAgICAgIGVuZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkICYmIG5leHQgPT0gXCJcXFxcXCI7XG4gICAgICB9XG4gICAgICBpZiAoZW5kKSBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiB0b2tlbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIG1heWJlRW5kID0gZmFsc2UsIGNoO1xuICAgICAgd2hpbGUgKGNoID0gc3RyZWFtLm5leHQoKSkge1xuICAgICAgICBpZiAoY2ggPT0gXCIjXCIgJiYgbWF5YmVFbmQpIHtcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBtYXliZUVuZCA9IChjaCA9PSBcIipcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRva2VuVW5wYXJzZWQoc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIG1heWJlRW5kID0gMCwgY2g7XG4gICAgICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgICAgIGlmIChjaCA9PSBcIiNcIiAmJiBtYXliZUVuZCA9PSAyKSB7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoID09IFwiXVwiKVxuICAgICAgICAgIG1heWJlRW5kKys7XG4gICAgICAgIGVsc2UgaWYgKGNoICE9IFwiIFwiKVxuICAgICAgICAgIG1heWJlRW5kID0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIm1ldGFcIjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRva2VuaXplOiB0b2tlbkJhc2UsXG4gICAgICAgICAgYmVmb3JlUGFyYW1zOiBmYWxzZSxcbiAgICAgICAgICBpblBhcmFtczogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICB9LFxuICAgICAgbGluZUNvbW1lbnQ6IFwiI1wiXG4gICAgfTtcbn0pO1xuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LXRjbFwiLCBcInRjbFwiKTtcblxufSk7XG4iLCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgeyAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHsgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICB9IGVsc2UgeyAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbiAgfVxufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgVE9LRU5fU1RZTEVTID0ge1xuICAgIGFkZGl0aW9uOiBcInBvc2l0aXZlXCIsXG4gICAgYXR0cmlidXRlczogXCJhdHRyaWJ1dGVcIixcbiAgICBib2xkOiBcInN0cm9uZ1wiLFxuICAgIGNpdGU6IFwia2V5d29yZFwiLFxuICAgIGNvZGU6IFwiYXRvbVwiLFxuICAgIGRlZmluaXRpb25MaXN0OiBcIm51bWJlclwiLFxuICAgIGRlbGV0aW9uOiBcIm5lZ2F0aXZlXCIsXG4gICAgZGl2OiBcInB1bmN0dWF0aW9uXCIsXG4gICAgZW06IFwiZW1cIixcbiAgICBmb290bm90ZTogXCJ2YXJpYWJsZVwiLFxuICAgIGZvb3RDaXRlOiBcInF1YWxpZmllclwiLFxuICAgIGhlYWRlcjogXCJoZWFkZXJcIixcbiAgICBodG1sOiBcImNvbW1lbnRcIixcbiAgICBpbWFnZTogXCJzdHJpbmdcIixcbiAgICBpdGFsaWM6IFwiZW1cIixcbiAgICBsaW5rOiBcImxpbmtcIixcbiAgICBsaW5rRGVmaW5pdGlvbjogXCJsaW5rXCIsXG4gICAgbGlzdDE6IFwidmFyaWFibGUtMlwiLFxuICAgIGxpc3QyOiBcInZhcmlhYmxlLTNcIixcbiAgICBsaXN0MzogXCJrZXl3b3JkXCIsXG4gICAgbm90ZXh0aWxlOiBcInN0cmluZy0yXCIsXG4gICAgcHJlOiBcIm9wZXJhdG9yXCIsXG4gICAgcDogXCJwcm9wZXJ0eVwiLFxuICAgIHF1b3RlOiBcImJyYWNrZXRcIixcbiAgICBzcGFuOiBcInF1b3RlXCIsXG4gICAgc3BlY2lhbENoYXI6IFwidGFnXCIsXG4gICAgc3Ryb25nOiBcInN0cm9uZ1wiLFxuICAgIHN1YjogXCJidWlsdGluXCIsXG4gICAgc3VwOiBcImJ1aWx0aW5cIixcbiAgICB0YWJsZTogXCJ2YXJpYWJsZS0zXCIsXG4gICAgdGFibGVIZWFkaW5nOiBcIm9wZXJhdG9yXCJcbiAgfTtcblxuICBmdW5jdGlvbiBzdGFydE5ld0xpbmUoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHN0YXRlLm1vZGUgPSBNb2Rlcy5uZXdMYXlvdXQ7XG4gICAgc3RhdGUudGFibGVIZWFkaW5nID0gZmFsc2U7XG5cbiAgICBpZiAoc3RhdGUubGF5b3V0VHlwZSA9PT0gXCJkZWZpbml0aW9uTGlzdFwiICYmIHN0YXRlLnNwYW5uaW5nTGF5b3V0ICYmXG4gICAgICAgIHN0cmVhbS5tYXRjaChSRShcImRlZmluaXRpb25MaXN0RW5kXCIpLCBmYWxzZSkpXG4gICAgICBzdGF0ZS5zcGFubmluZ0xheW91dCA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlUGhyYXNlTW9kaWZpZXIoc3RyZWFtLCBzdGF0ZSwgY2gpIHtcbiAgICBpZiAoY2ggPT09IFwiX1wiKSB7XG4gICAgICBpZiAoc3RyZWFtLmVhdChcIl9cIikpXG4gICAgICAgIHJldHVybiB0b2dnbGVQaHJhc2VNb2RpZmllcihzdHJlYW0sIHN0YXRlLCBcIml0YWxpY1wiLCAvX18vLCAyKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHRvZ2dsZVBocmFzZU1vZGlmaWVyKHN0cmVhbSwgc3RhdGUsIFwiZW1cIiwgL18vLCAxKTtcbiAgICB9XG5cbiAgICBpZiAoY2ggPT09IFwiKlwiKSB7XG4gICAgICBpZiAoc3RyZWFtLmVhdChcIipcIikpIHtcbiAgICAgICAgcmV0dXJuIHRvZ2dsZVBocmFzZU1vZGlmaWVyKHN0cmVhbSwgc3RhdGUsIFwiYm9sZFwiLCAvXFwqXFwqLywgMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdG9nZ2xlUGhyYXNlTW9kaWZpZXIoc3RyZWFtLCBzdGF0ZSwgXCJzdHJvbmdcIiwgL1xcKi8sIDEpO1xuICAgIH1cblxuICAgIGlmIChjaCA9PT0gXCJbXCIpIHtcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goL1xcZCtcXF0vKSkgc3RhdGUuZm9vdENpdGUgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRva2VuU3R5bGVzKHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoY2ggPT09IFwiKFwiKSB7XG4gICAgICB2YXIgc3BlYyA9IHN0cmVhbS5tYXRjaCgvXihyfHRtfGMpXFwpLyk7XG4gICAgICBpZiAoc3BlYylcbiAgICAgICAgcmV0dXJuIHRva2VuU3R5bGVzV2l0aChzdGF0ZSwgVE9LRU5fU1RZTEVTLnNwZWNpYWxDaGFyKTtcbiAgICB9XG5cbiAgICBpZiAoY2ggPT09IFwiPFwiICYmIHN0cmVhbS5tYXRjaCgvKFxcdyspW14+XSs+W148XSs8XFwvXFwxPi8pKVxuICAgICAgcmV0dXJuIHRva2VuU3R5bGVzV2l0aChzdGF0ZSwgVE9LRU5fU1RZTEVTLmh0bWwpO1xuXG4gICAgaWYgKGNoID09PSBcIj9cIiAmJiBzdHJlYW0uZWF0KFwiP1wiKSlcbiAgICAgIHJldHVybiB0b2dnbGVQaHJhc2VNb2RpZmllcihzdHJlYW0sIHN0YXRlLCBcImNpdGVcIiwgL1xcP1xcPy8sIDIpO1xuXG4gICAgaWYgKGNoID09PSBcIj1cIiAmJiBzdHJlYW0uZWF0KFwiPVwiKSlcbiAgICAgIHJldHVybiB0b2dnbGVQaHJhc2VNb2RpZmllcihzdHJlYW0sIHN0YXRlLCBcIm5vdGV4dGlsZVwiLCAvPT0vLCAyKTtcblxuICAgIGlmIChjaCA9PT0gXCItXCIgJiYgIXN0cmVhbS5lYXQoXCItXCIpKVxuICAgICAgcmV0dXJuIHRvZ2dsZVBocmFzZU1vZGlmaWVyKHN0cmVhbSwgc3RhdGUsIFwiZGVsZXRpb25cIiwgLy0vLCAxKTtcblxuICAgIGlmIChjaCA9PT0gXCIrXCIpXG4gICAgICByZXR1cm4gdG9nZ2xlUGhyYXNlTW9kaWZpZXIoc3RyZWFtLCBzdGF0ZSwgXCJhZGRpdGlvblwiLCAvXFwrLywgMSk7XG5cbiAgICBpZiAoY2ggPT09IFwiflwiKVxuICAgICAgcmV0dXJuIHRvZ2dsZVBocmFzZU1vZGlmaWVyKHN0cmVhbSwgc3RhdGUsIFwic3ViXCIsIC9+LywgMSk7XG5cbiAgICBpZiAoY2ggPT09IFwiXlwiKVxuICAgICAgcmV0dXJuIHRvZ2dsZVBocmFzZU1vZGlmaWVyKHN0cmVhbSwgc3RhdGUsIFwic3VwXCIsIC9cXF4vLCAxKTtcblxuICAgIGlmIChjaCA9PT0gXCIlXCIpXG4gICAgICByZXR1cm4gdG9nZ2xlUGhyYXNlTW9kaWZpZXIoc3RyZWFtLCBzdGF0ZSwgXCJzcGFuXCIsIC8lLywgMSk7XG5cbiAgICBpZiAoY2ggPT09IFwiQFwiKVxuICAgICAgcmV0dXJuIHRvZ2dsZVBocmFzZU1vZGlmaWVyKHN0cmVhbSwgc3RhdGUsIFwiY29kZVwiLCAvQC8sIDEpO1xuXG4gICAgaWYgKGNoID09PSBcIiFcIikge1xuICAgICAgdmFyIHR5cGUgPSB0b2dnbGVQaHJhc2VNb2RpZmllcihzdHJlYW0sIHN0YXRlLCBcImltYWdlXCIsIC8oPzpcXChbXlxcKV0rXFwpKT8hLywgMSk7XG4gICAgICBzdHJlYW0ubWF0Y2goL146XFxTKy8pOyAvLyBvcHRpb25hbCBVcmwgcG9ydGlvblxuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIHJldHVybiB0b2tlblN0eWxlcyhzdGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiB0b2dnbGVQaHJhc2VNb2RpZmllcihzdHJlYW0sIHN0YXRlLCBwaHJhc2VNb2RpZmllciwgY2xvc2VSRSwgb3BlblNpemUpIHtcbiAgICB2YXIgY2hhckJlZm9yZSA9IHN0cmVhbS5wb3MgPiBvcGVuU2l6ZSA/IHN0cmVhbS5zdHJpbmcuY2hhckF0KHN0cmVhbS5wb3MgLSBvcGVuU2l6ZSAtIDEpIDogbnVsbDtcbiAgICB2YXIgY2hhckFmdGVyID0gc3RyZWFtLnBlZWsoKTtcbiAgICBpZiAoc3RhdGVbcGhyYXNlTW9kaWZpZXJdKSB7XG4gICAgICBpZiAoKCFjaGFyQWZ0ZXIgfHwgL1xcVy8udGVzdChjaGFyQWZ0ZXIpKSAmJiBjaGFyQmVmb3JlICYmIC9cXFMvLnRlc3QoY2hhckJlZm9yZSkpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0b2tlblN0eWxlcyhzdGF0ZSk7XG4gICAgICAgIHN0YXRlW3BocmFzZU1vZGlmaWVyXSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCghY2hhckJlZm9yZSB8fCAvXFxXLy50ZXN0KGNoYXJCZWZvcmUpKSAmJiBjaGFyQWZ0ZXIgJiYgL1xcUy8udGVzdChjaGFyQWZ0ZXIpICYmXG4gICAgICAgICAgICAgICBzdHJlYW0ubWF0Y2gobmV3IFJlZ0V4cChcIl4uKlxcXFxTXCIgKyBjbG9zZVJFLnNvdXJjZSArIFwiKD86XFxcXFd8JClcIiksIGZhbHNlKSkge1xuICAgICAgc3RhdGVbcGhyYXNlTW9kaWZpZXJdID0gdHJ1ZTtcbiAgICAgIHN0YXRlLm1vZGUgPSBNb2Rlcy5hdHRyaWJ1dGVzO1xuICAgIH1cbiAgICByZXR1cm4gdG9rZW5TdHlsZXMoc3RhdGUpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHRva2VuU3R5bGVzKHN0YXRlKSB7XG4gICAgdmFyIGRpc2FibGVkID0gdGV4dGlsZURpc2FibGVkKHN0YXRlKTtcbiAgICBpZiAoZGlzYWJsZWQpIHJldHVybiBkaXNhYmxlZDtcblxuICAgIHZhciBzdHlsZXMgPSBbXTtcbiAgICBpZiAoc3RhdGUubGF5b3V0VHlwZSkgc3R5bGVzLnB1c2goVE9LRU5fU1RZTEVTW3N0YXRlLmxheW91dFR5cGVdKTtcblxuICAgIHN0eWxlcyA9IHN0eWxlcy5jb25jYXQoYWN0aXZlU3R5bGVzKFxuICAgICAgc3RhdGUsIFwiYWRkaXRpb25cIiwgXCJib2xkXCIsIFwiY2l0ZVwiLCBcImNvZGVcIiwgXCJkZWxldGlvblwiLCBcImVtXCIsIFwiZm9vdENpdGVcIixcbiAgICAgIFwiaW1hZ2VcIiwgXCJpdGFsaWNcIiwgXCJsaW5rXCIsIFwic3BhblwiLCBcInN0cm9uZ1wiLCBcInN1YlwiLCBcInN1cFwiLCBcInRhYmxlXCIsIFwidGFibGVIZWFkaW5nXCIpKTtcblxuICAgIGlmIChzdGF0ZS5sYXlvdXRUeXBlID09PSBcImhlYWRlclwiKVxuICAgICAgc3R5bGVzLnB1c2goVE9LRU5fU1RZTEVTLmhlYWRlciArIFwiLVwiICsgc3RhdGUuaGVhZGVyKTtcblxuICAgIHJldHVybiBzdHlsZXMubGVuZ3RoID8gc3R5bGVzLmpvaW4oXCIgXCIpIDogbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRleHRpbGVEaXNhYmxlZChzdGF0ZSkge1xuICAgIHZhciB0eXBlID0gc3RhdGUubGF5b3V0VHlwZTtcblxuICAgIHN3aXRjaCh0eXBlKSB7XG4gICAgY2FzZSBcIm5vdGV4dGlsZVwiOlxuICAgIGNhc2UgXCJjb2RlXCI6XG4gICAgY2FzZSBcInByZVwiOlxuICAgICAgcmV0dXJuIFRPS0VOX1NUWUxFU1t0eXBlXTtcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHN0YXRlLm5vdGV4dGlsZSlcbiAgICAgICAgcmV0dXJuIFRPS0VOX1NUWUxFUy5ub3RleHRpbGUgKyAodHlwZSA/IChcIiBcIiArIFRPS0VOX1NUWUxFU1t0eXBlXSkgOiBcIlwiKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuU3R5bGVzV2l0aChzdGF0ZSwgZXh0cmFTdHlsZXMpIHtcbiAgICB2YXIgZGlzYWJsZWQgPSB0ZXh0aWxlRGlzYWJsZWQoc3RhdGUpO1xuICAgIGlmIChkaXNhYmxlZCkgcmV0dXJuIGRpc2FibGVkO1xuXG4gICAgdmFyIHR5cGUgPSB0b2tlblN0eWxlcyhzdGF0ZSk7XG4gICAgaWYgKGV4dHJhU3R5bGVzKVxuICAgICAgcmV0dXJuIHR5cGUgPyAodHlwZSArIFwiIFwiICsgZXh0cmFTdHlsZXMpIDogZXh0cmFTdHlsZXM7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBhY3RpdmVTdHlsZXMoc3RhdGUpIHtcbiAgICB2YXIgc3R5bGVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChzdGF0ZVthcmd1bWVudHNbaV1dKVxuICAgICAgICBzdHlsZXMucHVzaChUT0tFTl9TVFlMRVNbYXJndW1lbnRzW2ldXSk7XG4gICAgfVxuICAgIHJldHVybiBzdHlsZXM7XG4gIH1cblxuICBmdW5jdGlvbiBibGFua0xpbmUoc3RhdGUpIHtcbiAgICB2YXIgc3Bhbm5pbmdMYXlvdXQgPSBzdGF0ZS5zcGFubmluZ0xheW91dCwgdHlwZSA9IHN0YXRlLmxheW91dFR5cGU7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc3RhdGUpIGlmIChzdGF0ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgZGVsZXRlIHN0YXRlW2tleV07XG5cbiAgICBzdGF0ZS5tb2RlID0gTW9kZXMubmV3TGF5b3V0O1xuICAgIGlmIChzcGFubmluZ0xheW91dCkge1xuICAgICAgc3RhdGUubGF5b3V0VHlwZSA9IHR5cGU7XG4gICAgICBzdGF0ZS5zcGFubmluZ0xheW91dCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIFJFcyA9IHtcbiAgICBjYWNoZToge30sXG4gICAgc2luZ2xlOiB7XG4gICAgICBiYzogXCJiY1wiLFxuICAgICAgYnE6IFwiYnFcIixcbiAgICAgIGRlZmluaXRpb25MaXN0OiAvLSAuKj86PSsvLFxuICAgICAgZGVmaW5pdGlvbkxpc3RFbmQ6IC8uKj06XFxzKiQvLFxuICAgICAgZGl2OiBcImRpdlwiLFxuICAgICAgZHJhd1RhYmxlOiAvXFx8LipcXHwvLFxuICAgICAgZm9vdDogL2ZuXFxkKy8sXG4gICAgICBoZWFkZXI6IC9oWzEtNl0vLFxuICAgICAgaHRtbDogL1xccyo8KD86XFwvKT8oXFx3KykoPzpbXj5dKyk/Pig/OltePF0rPFxcL1xcMT4pPy8sXG4gICAgICBsaW5rOiAvW15cIl0rXCI6XFxTLyxcbiAgICAgIGxpbmtEZWZpbml0aW9uOiAvXFxbW15cXHNcXF1dK1xcXVxcUysvLFxuICAgICAgbGlzdDogLyg/OiMrfFxcKispLyxcbiAgICAgIG5vdGV4dGlsZTogXCJub3RleHRpbGVcIixcbiAgICAgIHBhcmE6IFwicFwiLFxuICAgICAgcHJlOiBcInByZVwiLFxuICAgICAgdGFibGU6IFwidGFibGVcIixcbiAgICAgIHRhYmxlQ2VsbEF0dHJpYnV0ZXM6IC9bXFwvXFxcXF1cXGQrLyxcbiAgICAgIHRhYmxlSGVhZGluZzogL1xcfF9cXC4vLFxuICAgICAgdGFibGVUZXh0OiAvW15cIl9cXCpcXFtcXChcXD9cXCt+XFxeJUB8LV0rLyxcbiAgICAgIHRleHQ6IC9bXiFcIl89XFwqXFxbXFwoPFxcP1xcK35cXF4lQC1dKy9cbiAgICB9LFxuICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgIGFsaWduOiAvKD86PD58PHw+fD0pLyxcbiAgICAgIHNlbGVjdG9yOiAvXFwoW15cXChdW15cXCldK1xcKS8sXG4gICAgICBsYW5nOiAvXFxbW15cXFtcXF1dK1xcXS8sXG4gICAgICBwYWQ6IC8oPzpcXCgrfFxcKSspezEsMn0vLFxuICAgICAgY3NzOiAvXFx7W15cXH1dK1xcfS9cbiAgICB9LFxuICAgIGNyZWF0ZVJlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgXCJkcmF3VGFibGVcIjpcbiAgICAgICAgcmV0dXJuIFJFcy5tYWtlUmUoXCJeXCIsIFJFcy5zaW5nbGUuZHJhd1RhYmxlLCBcIiRcIik7XG4gICAgICBjYXNlIFwiaHRtbFwiOlxuICAgICAgICByZXR1cm4gUkVzLm1ha2VSZShcIl5cIiwgUkVzLnNpbmdsZS5odG1sLCBcIig/OlwiLCBSRXMuc2luZ2xlLmh0bWwsIFwiKSpcIiwgXCIkXCIpO1xuICAgICAgY2FzZSBcImxpbmtEZWZpbml0aW9uXCI6XG4gICAgICAgIHJldHVybiBSRXMubWFrZVJlKFwiXlwiLCBSRXMuc2luZ2xlLmxpbmtEZWZpbml0aW9uLCBcIiRcIik7XG4gICAgICBjYXNlIFwibGlzdExheW91dFwiOlxuICAgICAgICByZXR1cm4gUkVzLm1ha2VSZShcIl5cIiwgUkVzLnNpbmdsZS5saXN0LCBSRShcImFsbEF0dHJpYnV0ZXNcIiksIFwiKlxcXFxzK1wiKTtcbiAgICAgIGNhc2UgXCJ0YWJsZUNlbGxBdHRyaWJ1dGVzXCI6XG4gICAgICAgIHJldHVybiBSRXMubWFrZVJlKFwiXlwiLCBSRXMuY2hvaWNlUmUoUkVzLnNpbmdsZS50YWJsZUNlbGxBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSRShcImFsbEF0dHJpYnV0ZXNcIikpLCBcIitcXFxcLlwiKTtcbiAgICAgIGNhc2UgXCJ0eXBlXCI6XG4gICAgICAgIHJldHVybiBSRXMubWFrZVJlKFwiXlwiLCBSRShcImFsbFR5cGVzXCIpKTtcbiAgICAgIGNhc2UgXCJ0eXBlTGF5b3V0XCI6XG4gICAgICAgIHJldHVybiBSRXMubWFrZVJlKFwiXlwiLCBSRShcImFsbFR5cGVzXCIpLCBSRShcImFsbEF0dHJpYnV0ZXNcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiKlxcXFwuXFxcXC4/XCIsIFwiKFxcXFxzK3wkKVwiKTtcbiAgICAgIGNhc2UgXCJhdHRyaWJ1dGVzXCI6XG4gICAgICAgIHJldHVybiBSRXMubWFrZVJlKFwiXlwiLCBSRShcImFsbEF0dHJpYnV0ZXNcIiksIFwiK1wiKTtcblxuICAgICAgY2FzZSBcImFsbFR5cGVzXCI6XG4gICAgICAgIHJldHVybiBSRXMuY2hvaWNlUmUoUkVzLnNpbmdsZS5kaXYsIFJFcy5zaW5nbGUuZm9vdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSRXMuc2luZ2xlLmhlYWRlciwgUkVzLnNpbmdsZS5iYywgUkVzLnNpbmdsZS5icSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSRXMuc2luZ2xlLm5vdGV4dGlsZSwgUkVzLnNpbmdsZS5wcmUsIFJFcy5zaW5nbGUudGFibGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUkVzLnNpbmdsZS5wYXJhKTtcblxuICAgICAgY2FzZSBcImFsbEF0dHJpYnV0ZXNcIjpcbiAgICAgICAgcmV0dXJuIFJFcy5jaG9pY2VSZShSRXMuYXR0cmlidXRlcy5zZWxlY3RvciwgUkVzLmF0dHJpYnV0ZXMuY3NzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJFcy5hdHRyaWJ1dGVzLmxhbmcsIFJFcy5hdHRyaWJ1dGVzLmFsaWduLCBSRXMuYXR0cmlidXRlcy5wYWQpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gUkVzLm1ha2VSZShcIl5cIiwgUkVzLnNpbmdsZVtuYW1lXSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBtYWtlUmU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBhdHRlcm4gPSBcIlwiO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGFyZyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgcGF0dGVybiArPSAodHlwZW9mIGFyZyA9PT0gXCJzdHJpbmdcIikgPyBhcmcgOiBhcmcuc291cmNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocGF0dGVybik7XG4gICAgfSxcbiAgICBjaG9pY2VSZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcGFydHMgPSBbYXJndW1lbnRzWzBdXTtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHBhcnRzW2kgKiAyIC0gMV0gPSBcInxcIjtcbiAgICAgICAgcGFydHNbaSAqIDJdID0gYXJndW1lbnRzW2ldO1xuICAgICAgfVxuXG4gICAgICBwYXJ0cy51bnNoaWZ0KFwiKD86XCIpO1xuICAgICAgcGFydHMucHVzaChcIilcIik7XG4gICAgICByZXR1cm4gUkVzLm1ha2VSZS5hcHBseShudWxsLCBwYXJ0cyk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIFJFKG5hbWUpIHtcbiAgICByZXR1cm4gKFJFcy5jYWNoZVtuYW1lXSB8fCAoUkVzLmNhY2hlW25hbWVdID0gUkVzLmNyZWF0ZVJlKG5hbWUpKSk7XG4gIH1cblxuICB2YXIgTW9kZXMgPSB7XG4gICAgbmV3TGF5b3V0OiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKFJFKFwidHlwZUxheW91dFwiKSwgZmFsc2UpKSB7XG4gICAgICAgIHN0YXRlLnNwYW5uaW5nTGF5b3V0ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiAoc3RhdGUubW9kZSA9IE1vZGVzLmJsb2NrVHlwZSkoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgICB2YXIgbmV3TW9kZTtcbiAgICAgIGlmICghdGV4dGlsZURpc2FibGVkKHN0YXRlKSkge1xuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKFJFKFwibGlzdExheW91dFwiKSwgZmFsc2UpKVxuICAgICAgICAgIG5ld01vZGUgPSBNb2Rlcy5saXN0O1xuICAgICAgICBlbHNlIGlmIChzdHJlYW0ubWF0Y2goUkUoXCJkcmF3VGFibGVcIiksIGZhbHNlKSlcbiAgICAgICAgICBuZXdNb2RlID0gTW9kZXMudGFibGU7XG4gICAgICAgIGVsc2UgaWYgKHN0cmVhbS5tYXRjaChSRShcImxpbmtEZWZpbml0aW9uXCIpLCBmYWxzZSkpXG4gICAgICAgICAgbmV3TW9kZSA9IE1vZGVzLmxpbmtEZWZpbml0aW9uO1xuICAgICAgICBlbHNlIGlmIChzdHJlYW0ubWF0Y2goUkUoXCJkZWZpbml0aW9uTGlzdFwiKSkpXG4gICAgICAgICAgbmV3TW9kZSA9IE1vZGVzLmRlZmluaXRpb25MaXN0O1xuICAgICAgICBlbHNlIGlmIChzdHJlYW0ubWF0Y2goUkUoXCJodG1sXCIpLCBmYWxzZSkpXG4gICAgICAgICAgbmV3TW9kZSA9IE1vZGVzLmh0bWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gKHN0YXRlLm1vZGUgPSAobmV3TW9kZSB8fCBNb2Rlcy50ZXh0KSkoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSxcblxuICAgIGJsb2NrVHlwZTogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIG1hdGNoLCB0eXBlO1xuICAgICAgc3RhdGUubGF5b3V0VHlwZSA9IG51bGw7XG5cbiAgICAgIGlmIChtYXRjaCA9IHN0cmVhbS5tYXRjaChSRShcInR5cGVcIikpKVxuICAgICAgICB0eXBlID0gbWF0Y2hbMF07XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiAoc3RhdGUubW9kZSA9IE1vZGVzLnRleHQpKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgICBpZiAobWF0Y2ggPSB0eXBlLm1hdGNoKFJFKFwiaGVhZGVyXCIpKSkge1xuICAgICAgICBzdGF0ZS5sYXlvdXRUeXBlID0gXCJoZWFkZXJcIjtcbiAgICAgICAgc3RhdGUuaGVhZGVyID0gcGFyc2VJbnQobWF0Y2hbMF1bMV0pO1xuICAgICAgfSBlbHNlIGlmICh0eXBlLm1hdGNoKFJFKFwiYnFcIikpKSB7XG4gICAgICAgIHN0YXRlLmxheW91dFR5cGUgPSBcInF1b3RlXCI7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUubWF0Y2goUkUoXCJiY1wiKSkpIHtcbiAgICAgICAgc3RhdGUubGF5b3V0VHlwZSA9IFwiY29kZVwiO1xuICAgICAgfSBlbHNlIGlmICh0eXBlLm1hdGNoKFJFKFwiZm9vdFwiKSkpIHtcbiAgICAgICAgc3RhdGUubGF5b3V0VHlwZSA9IFwiZm9vdG5vdGVcIjtcbiAgICAgIH0gZWxzZSBpZiAodHlwZS5tYXRjaChSRShcIm5vdGV4dGlsZVwiKSkpIHtcbiAgICAgICAgc3RhdGUubGF5b3V0VHlwZSA9IFwibm90ZXh0aWxlXCI7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUubWF0Y2goUkUoXCJwcmVcIikpKSB7XG4gICAgICAgIHN0YXRlLmxheW91dFR5cGUgPSBcInByZVwiO1xuICAgICAgfSBlbHNlIGlmICh0eXBlLm1hdGNoKFJFKFwiZGl2XCIpKSkge1xuICAgICAgICBzdGF0ZS5sYXlvdXRUeXBlID0gXCJkaXZcIjtcbiAgICAgIH0gZWxzZSBpZiAodHlwZS5tYXRjaChSRShcInRhYmxlXCIpKSkge1xuICAgICAgICBzdGF0ZS5sYXlvdXRUeXBlID0gXCJ0YWJsZVwiO1xuICAgICAgfVxuXG4gICAgICBzdGF0ZS5tb2RlID0gTW9kZXMuYXR0cmlidXRlcztcbiAgICAgIHJldHVybiB0b2tlblN0eWxlcyhzdGF0ZSk7XG4gICAgfSxcblxuICAgIHRleHQ6IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goUkUoXCJ0ZXh0XCIpKSkgcmV0dXJuIHRva2VuU3R5bGVzKHN0YXRlKTtcblxuICAgICAgdmFyIGNoID0gc3RyZWFtLm5leHQoKTtcbiAgICAgIGlmIChjaCA9PT0gJ1wiJylcbiAgICAgICAgcmV0dXJuIChzdGF0ZS5tb2RlID0gTW9kZXMubGluaykoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICByZXR1cm4gaGFuZGxlUGhyYXNlTW9kaWZpZXIoc3RyZWFtLCBzdGF0ZSwgY2gpO1xuICAgIH0sXG5cbiAgICBhdHRyaWJ1dGVzOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBzdGF0ZS5tb2RlID0gTW9kZXMubGF5b3V0TGVuZ3RoO1xuXG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKFJFKFwiYXR0cmlidXRlc1wiKSkpXG4gICAgICAgIHJldHVybiB0b2tlblN0eWxlc1dpdGgoc3RhdGUsIFRPS0VOX1NUWUxFUy5hdHRyaWJ1dGVzKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHRva2VuU3R5bGVzKHN0YXRlKTtcbiAgICB9LFxuXG4gICAgbGF5b3V0TGVuZ3RoOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAoc3RyZWFtLmVhdChcIi5cIikgJiYgc3RyZWFtLmVhdChcIi5cIikpXG4gICAgICAgIHN0YXRlLnNwYW5uaW5nTGF5b3V0ID0gdHJ1ZTtcblxuICAgICAgc3RhdGUubW9kZSA9IE1vZGVzLnRleHQ7XG4gICAgICByZXR1cm4gdG9rZW5TdHlsZXMoc3RhdGUpO1xuICAgIH0sXG5cbiAgICBsaXN0OiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBzdHJlYW0ubWF0Y2goUkUoXCJsaXN0XCIpKTtcbiAgICAgIHN0YXRlLmxpc3REZXB0aCA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgIHZhciBsaXN0TW9kID0gKHN0YXRlLmxpc3REZXB0aCAtIDEpICUgMztcbiAgICAgIGlmICghbGlzdE1vZClcbiAgICAgICAgc3RhdGUubGF5b3V0VHlwZSA9IFwibGlzdDFcIjtcbiAgICAgIGVsc2UgaWYgKGxpc3RNb2QgPT09IDEpXG4gICAgICAgIHN0YXRlLmxheW91dFR5cGUgPSBcImxpc3QyXCI7XG4gICAgICBlbHNlXG4gICAgICAgIHN0YXRlLmxheW91dFR5cGUgPSBcImxpc3QzXCI7XG5cbiAgICAgIHN0YXRlLm1vZGUgPSBNb2Rlcy5hdHRyaWJ1dGVzO1xuICAgICAgcmV0dXJuIHRva2VuU3R5bGVzKHN0YXRlKTtcbiAgICB9LFxuXG4gICAgbGluazogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgc3RhdGUubW9kZSA9IE1vZGVzLnRleHQ7XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKFJFKFwibGlua1wiKSkpIHtcbiAgICAgICAgc3RyZWFtLm1hdGNoKC9cXFMrLyk7XG4gICAgICAgIHJldHVybiB0b2tlblN0eWxlc1dpdGgoc3RhdGUsIFRPS0VOX1NUWUxFUy5saW5rKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0b2tlblN0eWxlcyhzdGF0ZSk7XG4gICAgfSxcblxuICAgIGxpbmtEZWZpbml0aW9uOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICByZXR1cm4gdG9rZW5TdHlsZXNXaXRoKHN0YXRlLCBUT0tFTl9TVFlMRVMubGlua0RlZmluaXRpb24pO1xuICAgIH0sXG5cbiAgICBkZWZpbml0aW9uTGlzdDogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgc3RyZWFtLm1hdGNoKFJFKFwiZGVmaW5pdGlvbkxpc3RcIikpO1xuXG4gICAgICBzdGF0ZS5sYXlvdXRUeXBlID0gXCJkZWZpbml0aW9uTGlzdFwiO1xuXG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC9cXHMqJC8pKVxuICAgICAgICBzdGF0ZS5zcGFubmluZ0xheW91dCA9IHRydWU7XG4gICAgICBlbHNlXG4gICAgICAgIHN0YXRlLm1vZGUgPSBNb2Rlcy5hdHRyaWJ1dGVzO1xuXG4gICAgICByZXR1cm4gdG9rZW5TdHlsZXMoc3RhdGUpO1xuICAgIH0sXG5cbiAgICBodG1sOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICByZXR1cm4gdG9rZW5TdHlsZXNXaXRoKHN0YXRlLCBUT0tFTl9TVFlMRVMuaHRtbCk7XG4gICAgfSxcblxuICAgIHRhYmxlOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBzdGF0ZS5sYXlvdXRUeXBlID0gXCJ0YWJsZVwiO1xuICAgICAgcmV0dXJuIChzdGF0ZS5tb2RlID0gTW9kZXMudGFibGVDZWxsKShzdHJlYW0sIHN0YXRlKTtcbiAgICB9LFxuXG4gICAgdGFibGVDZWxsOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKFJFKFwidGFibGVIZWFkaW5nXCIpKSlcbiAgICAgICAgc3RhdGUudGFibGVIZWFkaW5nID0gdHJ1ZTtcbiAgICAgIGVsc2VcbiAgICAgICAgc3RyZWFtLmVhdChcInxcIik7XG5cbiAgICAgIHN0YXRlLm1vZGUgPSBNb2Rlcy50YWJsZUNlbGxBdHRyaWJ1dGVzO1xuICAgICAgcmV0dXJuIHRva2VuU3R5bGVzKHN0YXRlKTtcbiAgICB9LFxuXG4gICAgdGFibGVDZWxsQXR0cmlidXRlczogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgc3RhdGUubW9kZSA9IE1vZGVzLnRhYmxlVGV4dDtcblxuICAgICAgaWYgKHN0cmVhbS5tYXRjaChSRShcInRhYmxlQ2VsbEF0dHJpYnV0ZXNcIikpKVxuICAgICAgICByZXR1cm4gdG9rZW5TdHlsZXNXaXRoKHN0YXRlLCBUT0tFTl9TVFlMRVMuYXR0cmlidXRlcyk7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiB0b2tlblN0eWxlcyhzdGF0ZSk7XG4gICAgfSxcblxuICAgIHRhYmxlVGV4dDogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKHN0cmVhbS5tYXRjaChSRShcInRhYmxlVGV4dFwiKSkpXG4gICAgICAgIHJldHVybiB0b2tlblN0eWxlcyhzdGF0ZSk7XG5cbiAgICAgIGlmIChzdHJlYW0ucGVlaygpID09PSBcInxcIikgeyAvLyBlbmQgb2YgY2VsbFxuICAgICAgICBzdGF0ZS5tb2RlID0gTW9kZXMudGFibGVDZWxsO1xuICAgICAgICByZXR1cm4gdG9rZW5TdHlsZXMoc3RhdGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhbmRsZVBocmFzZU1vZGlmaWVyKHN0cmVhbSwgc3RhdGUsIHN0cmVhbS5uZXh0KCkpO1xuICAgIH1cbiAgfTtcblxuICBDb2RlTWlycm9yLmRlZmluZU1vZGUoXCJ0ZXh0aWxlXCIsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHsgbW9kZTogTW9kZXMubmV3TGF5b3V0IH07XG4gICAgICB9LFxuICAgICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgaWYgKHN0cmVhbS5zb2woKSkgc3RhcnROZXdMaW5lKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICByZXR1cm4gc3RhdGUubW9kZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH0sXG4gICAgICBibGFua0xpbmU6IGJsYW5rTGluZVxuICAgIH07XG4gIH0pO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQveC10ZXh0aWxlXCIsIFwidGV4dGlsZVwiKTtcbn0pO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuLyoqKlxuICAgIHwnJ05hbWUnJ3x0aWRkbHl3aWtpLmpzfFxuICAgIHwnJ0Rlc2NyaXB0aW9uJyd8RW5hYmxlcyBUaWRkbHlXaWtpeSBzeW50YXggaGlnaGxpZ2h0aW5nIHVzaW5nIENvZGVNaXJyb3J8XG4gICAgfCcnQXV0aG9yJyd8UE1hcmlvfFxuICAgIHwnJ1ZlcnNpb24nJ3wwLjEuN3xcbiAgICB8JydTdGF0dXMnJ3wnJ3N0YWJsZScnfFxuICAgIHwnJ1NvdXJjZScnfFtbR2l0SHVifGh0dHBzOi8vZ2l0aHViLmNvbS9wbWFyaW8vQ29kZU1pcnJvcjIvYmxvYi90dy1zeW50YXgvbW9kZS90aWRkbHl3aWtpXV18XG4gICAgfCcnRG9jdW1lbnRhdGlvbicnfGh0dHBzOi8vY29kZW1pcnJvci50aWRkbHlzcGFjZS5jb20vfFxuICAgIHwnJ0xpY2Vuc2UnJ3xbW01JVCBMaWNlbnNlfGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXV18XG4gICAgfCcnQ29yZVZlcnNpb24nJ3wyLjUuMHxcbiAgICB8JydSZXF1aXJlcycnfGNvZGVtaXJyb3IuanN8XG4gICAgfCcnS2V5d29yZHMnJ3xzeW50YXggaGlnaGxpZ2h0aW5nIGNvbG9yIGNvZGUgbWlycm9yIGNvZGVtaXJyb3J8XG4gICAgISBJbmZvXG4gICAgQ29yZVZlcnNpb24gcGFyYW1ldGVyIGlzIG5lZWRlZCBmb3IgVGlkZGx5V2lraSBvbmx5IVxuKioqL1xuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTW9kZShcInRpZGRseXdpa2lcIiwgZnVuY3Rpb24gKCkge1xuICAvLyBUb2tlbml6ZXJcbiAgdmFyIHRleHR3b3JkcyA9IHt9O1xuXG4gIHZhciBrZXl3b3JkcyA9IHtcbiAgICBcImFsbFRhZ3NcIjogdHJ1ZSwgXCJjbG9zZUFsbFwiOiB0cnVlLCBcImxpc3RcIjogdHJ1ZSxcbiAgICBcIm5ld0pvdXJuYWxcIjogdHJ1ZSwgXCJuZXdUaWRkbGVyXCI6IHRydWUsXG4gICAgXCJwZXJtYXZpZXdcIjogdHJ1ZSwgXCJzYXZlQ2hhbmdlc1wiOiB0cnVlLFxuICAgIFwic2VhcmNoXCI6IHRydWUsIFwic2xpZGVyXCI6IHRydWUsIFwidGFic1wiOiB0cnVlLFxuICAgIFwidGFnXCI6IHRydWUsIFwidGFnZ2luZ1wiOiB0cnVlLCBcInRhZ3NcIjogdHJ1ZSxcbiAgICBcInRpZGRsZXJcIjogdHJ1ZSwgXCJ0aW1lbGluZVwiOiB0cnVlLFxuICAgIFwidG9kYXlcIjogdHJ1ZSwgXCJ2ZXJzaW9uXCI6IHRydWUsIFwib3B0aW9uXCI6IHRydWUsXG4gICAgXCJ3aXRoXCI6IHRydWUsIFwiZmlsdGVyXCI6IHRydWVcbiAgfTtcblxuICB2YXIgaXNTcGFjZU5hbWUgPSAvW1xcd19cXC1dL2ksXG4gICAgICByZUhSID0gL15cXC1cXC1cXC1cXC0rJC8sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPGhyPlxuICAgICAgcmVXaWtpQ29tbWVudFN0YXJ0ID0gL15cXC9cXCpcXCpcXCokLywgICAgICAgICAgICAvLyAvKioqXG4gICAgICByZVdpa2lDb21tZW50U3RvcCA9IC9eXFwqXFwqXFwqXFwvJC8sICAgICAgICAgICAgIC8vICoqKi9cbiAgICAgIHJlQmxvY2tRdW90ZSA9IC9ePDw8JC8sXG5cbiAgICAgIHJlSnNDb2RlU3RhcnQgPSAvXlxcL1xcL1xce1xce1xceyQvLCAgICAgICAgICAgICAgICAgICAgICAgLy8gLy97e3sganMgYmxvY2sgc3RhcnRcbiAgICAgIHJlSnNDb2RlU3RvcCA9IC9eXFwvXFwvXFx9XFx9XFx9JC8sICAgICAgICAgICAgICAgICAgICAgICAgLy8gLy99fX0ganMgc3RvcFxuICAgICAgcmVYbWxDb2RlU3RhcnQgPSAvXjwhLS1cXHtcXHtcXHstLT4kLywgICAgICAgICAgIC8vIHhtbCBibG9jayBzdGFydFxuICAgICAgcmVYbWxDb2RlU3RvcCA9IC9ePCEtLVxcfVxcfVxcfS0tPiQvLCAgICAgICAgICAgIC8vIHhtbCBzdG9wXG5cbiAgICAgIHJlQ29kZUJsb2NrU3RhcnQgPSAvXlxce1xce1xceyQvLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIHt7eyBUVyB0ZXh0IGRpdiBibG9jayBzdGFydFxuICAgICAgcmVDb2RlQmxvY2tTdG9wID0gL15cXH1cXH1cXH0kLywgICAgICAgICAgICAgICAgIC8vIH19fSBUVyB0ZXh0IHN0b3BcblxuICAgICAgcmVVbnRpbENvZGVTdG9wID0gLy4qP1xcfVxcfVxcfS87XG5cbiAgZnVuY3Rpb24gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgZikge1xuICAgIHN0YXRlLnRva2VuaXplID0gZjtcbiAgICByZXR1cm4gZihzdHJlYW0sIHN0YXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIHNvbCA9IHN0cmVhbS5zb2woKSwgY2ggPSBzdHJlYW0ucGVlaygpO1xuXG4gICAgc3RhdGUuYmxvY2sgPSBmYWxzZTsgICAgICAgIC8vIGluZGljYXRlcyB0aGUgc3RhcnQgb2YgYSBjb2RlIGJsb2NrLlxuXG4gICAgLy8gY2hlY2sgc3RhcnQgb2YgIGJsb2Nrc1xuICAgIGlmIChzb2wgJiYgL1s8XFwvXFwqe31cXC1dLy50ZXN0KGNoKSkge1xuICAgICAgaWYgKHN0cmVhbS5tYXRjaChyZUNvZGVCbG9ja1N0YXJ0KSkge1xuICAgICAgICBzdGF0ZS5ibG9jayA9IHRydWU7XG4gICAgICAgIHJldHVybiBjaGFpbihzdHJlYW0sIHN0YXRlLCB0d1Rva2VuQ29kZSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKHJlQmxvY2tRdW90ZSkpXG4gICAgICAgIHJldHVybiAncXVvdGUnO1xuICAgICAgaWYgKHN0cmVhbS5tYXRjaChyZVdpa2lDb21tZW50U3RhcnQpIHx8IHN0cmVhbS5tYXRjaChyZVdpa2lDb21tZW50U3RvcCkpXG4gICAgICAgIHJldHVybiAnY29tbWVudCc7XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKHJlSnNDb2RlU3RhcnQpIHx8IHN0cmVhbS5tYXRjaChyZUpzQ29kZVN0b3ApIHx8IHN0cmVhbS5tYXRjaChyZVhtbENvZGVTdGFydCkgfHwgc3RyZWFtLm1hdGNoKHJlWG1sQ29kZVN0b3ApKVxuICAgICAgICByZXR1cm4gJ2NvbW1lbnQnO1xuICAgICAgaWYgKHN0cmVhbS5tYXRjaChyZUhSKSlcbiAgICAgICAgcmV0dXJuICdocic7XG4gICAgfVxuXG4gICAgc3RyZWFtLm5leHQoKTtcbiAgICBpZiAoc29sICYmIC9bXFwvXFwqISM7Oj58XS8udGVzdChjaCkpIHtcbiAgICAgIGlmIChjaCA9PSBcIiFcIikgeyAvLyB0dyBoZWFkZXJcbiAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICByZXR1cm4gXCJoZWFkZXJcIjtcbiAgICAgIH1cbiAgICAgIGlmIChjaCA9PSBcIipcIikgeyAvLyB0dyBsaXN0XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSgnKicpO1xuICAgICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgICB9XG4gICAgICBpZiAoY2ggPT0gXCIjXCIpIHsgLy8gdHcgbnVtYmVyZWQgbGlzdFxuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoJyMnKTtcbiAgICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgICAgfVxuICAgICAgaWYgKGNoID09IFwiO1wiKSB7IC8vIGRlZmluaXRpb24gbGlzdCwgdGVybVxuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoJzsnKTtcbiAgICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgICAgfVxuICAgICAgaWYgKGNoID09IFwiOlwiKSB7IC8vIGRlZmluaXRpb24gbGlzdCwgZGVzY3JpcHRpb25cbiAgICAgICAgc3RyZWFtLmVhdFdoaWxlKCc6Jyk7XG4gICAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICAgIH1cbiAgICAgIGlmIChjaCA9PSBcIj5cIikgeyAvLyBzaW5nbGUgbGluZSBxdW90ZVxuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoXCI+XCIpO1xuICAgICAgICByZXR1cm4gXCJxdW90ZVwiO1xuICAgICAgfVxuICAgICAgaWYgKGNoID09ICd8JylcbiAgICAgICAgcmV0dXJuICdoZWFkZXInO1xuICAgIH1cblxuICAgIGlmIChjaCA9PSAneycgJiYgc3RyZWFtLm1hdGNoKCd7eycpKVxuICAgICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIHR3VG9rZW5Db2RlKTtcblxuICAgIC8vIHJ1ZGltZW50YXJ5IGh0bWw6Ly8gZmlsZTovLyBsaW5rIG1hdGNoaW5nLiBUVyBrbm93cyBtdWNoIG1vcmUgLi4uXG4gICAgaWYgKC9baGZdL2kudGVzdChjaCkgJiZcbiAgICAgICAgL1t0aV0vaS50ZXN0KHN0cmVhbS5wZWVrKCkpICYmXG4gICAgICAgIHN0cmVhbS5tYXRjaCgvXFxiKHR0cHM/fHRwfGlsZSk6XFwvXFwvW1xcLUEtWjAtOSsmQCNcXC8lPz1+X3wkITosLjtdKltBLVowLTkrJkAjXFwvJT1+X3wkXS9pKSlcbiAgICAgIHJldHVybiBcImxpbmtcIjtcblxuICAgIC8vIGp1c3QgYSBsaXR0bGUgc3RyaW5nIGluZGljYXRvciwgZG9uJ3Qgd2FudCB0byBoYXZlIHRoZSB3aG9sZSBzdHJpbmcgY292ZXJlZFxuICAgIGlmIChjaCA9PSAnXCInKVxuICAgICAgcmV0dXJuICdzdHJpbmcnO1xuXG4gICAgaWYgKGNoID09ICd+JykgICAgLy8gX25vXyBDYW1lbENhc2UgaW5kaWNhdG9yIHNob3VsZCBiZSBib2xkXG4gICAgICByZXR1cm4gJ2JyYWNlJztcblxuICAgIGlmICgvW1xcW1xcXV0vLnRlc3QoY2gpICYmIHN0cmVhbS5tYXRjaChjaCkpIC8vIGNoZWNrIGZvciBbWy4uXV1cbiAgICAgIHJldHVybiAnYnJhY2UnO1xuXG4gICAgaWYgKGNoID09IFwiQFwiKSB7ICAgIC8vIGNoZWNrIGZvciBzcGFjZSBsaW5rLiBUT0RPIGZpeCBAQC4uLkBAIGhpZ2hsaWdodGluZ1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKGlzU3BhY2VOYW1lKTtcbiAgICAgIHJldHVybiBcImxpbmtcIjtcbiAgICB9XG5cbiAgICBpZiAoL1xcZC8udGVzdChjaCkpIHsgICAgICAgIC8vIG51bWJlcnNcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvXFxkLyk7XG4gICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICB9XG5cbiAgICBpZiAoY2ggPT0gXCIvXCIpIHsgLy8gdHcgaW52aXNpYmxlIGNvbW1lbnRcbiAgICAgIGlmIChzdHJlYW0uZWF0KFwiJVwiKSkge1xuICAgICAgICByZXR1cm4gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgdHdUb2tlbkNvbW1lbnQpO1xuICAgICAgfSBlbHNlIGlmIChzdHJlYW0uZWF0KFwiL1wiKSkgeyAvL1xuICAgICAgICByZXR1cm4gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgdHdUb2tlbkVtKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2ggPT0gXCJfXCIgJiYgc3RyZWFtLmVhdChcIl9cIikpIC8vIHR3IHVuZGVybGluZVxuICAgICAgICByZXR1cm4gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgdHdUb2tlblVuZGVybGluZSk7XG5cbiAgICAvLyBzdHJpa2V0aHJvdWdoIGFuZCBtZGFzaCBoYW5kbGluZ1xuICAgIGlmIChjaCA9PSBcIi1cIiAmJiBzdHJlYW0uZWF0KFwiLVwiKSkge1xuICAgICAgLy8gaWYgc3RyaWtldGhyb3VnaCBsb29rcyB1Z2x5LCBjaGFuZ2UgQ1NTLlxuICAgICAgaWYgKHN0cmVhbS5wZWVrKCkgIT0gJyAnKVxuICAgICAgICByZXR1cm4gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgdHdUb2tlblN0cmlrZSk7XG4gICAgICAvLyBtZGFzaFxuICAgICAgaWYgKHN0cmVhbS5wZWVrKCkgPT0gJyAnKVxuICAgICAgICByZXR1cm4gJ2JyYWNlJztcbiAgICB9XG5cbiAgICBpZiAoY2ggPT0gXCInXCIgJiYgc3RyZWFtLmVhdChcIidcIikpIC8vIHR3IGJvbGRcbiAgICAgIHJldHVybiBjaGFpbihzdHJlYW0sIHN0YXRlLCB0d1Rva2VuU3Ryb25nKTtcblxuICAgIGlmIChjaCA9PSBcIjxcIiAmJiBzdHJlYW0uZWF0KFwiPFwiKSkgLy8gdHcgbWFjcm9cbiAgICAgIHJldHVybiBjaGFpbihzdHJlYW0sIHN0YXRlLCB0d1Rva2VuTWFjcm8pO1xuXG4gICAgLy8gY29yZSBtYWNybyBoYW5kbGluZ1xuICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcJF9dLyk7XG4gICAgcmV0dXJuIHRleHR3b3Jkcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShzdHJlYW0uY3VycmVudCgpKSA/IFwia2V5d29yZFwiIDogbnVsbFxuICB9XG5cbiAgLy8gdHcgaW52aXNpYmxlIGNvbW1lbnRcbiAgZnVuY3Rpb24gdHdUb2tlbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBtYXliZUVuZCA9IGZhbHNlLCBjaDtcbiAgICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgICBpZiAoY2ggPT0gXCIvXCIgJiYgbWF5YmVFbmQpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbWF5YmVFbmQgPSAoY2ggPT0gXCIlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gIH1cblxuICAvLyB0dyBzdHJvbmcgLyBib2xkXG4gIGZ1bmN0aW9uIHR3VG9rZW5TdHJvbmcoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBtYXliZUVuZCA9IGZhbHNlLFxuICAgIGNoO1xuICAgIHdoaWxlIChjaCA9IHN0cmVhbS5uZXh0KCkpIHtcbiAgICAgIGlmIChjaCA9PSBcIidcIiAmJiBtYXliZUVuZCkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBtYXliZUVuZCA9IChjaCA9PSBcIidcIik7XG4gICAgfVxuICAgIHJldHVybiBcInN0cm9uZ1wiO1xuICB9XG5cbiAgLy8gdHcgY29kZVxuICBmdW5jdGlvbiB0d1Rva2VuQ29kZShzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIHNiID0gc3RhdGUuYmxvY2s7XG5cbiAgICBpZiAoc2IgJiYgc3RyZWFtLmN1cnJlbnQoKSkge1xuICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgIH1cblxuICAgIGlmICghc2IgJiYgc3RyZWFtLm1hdGNoKHJlVW50aWxDb2RlU3RvcCkpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgIH1cblxuICAgIGlmIChzYiAmJiBzdHJlYW0uc29sKCkgJiYgc3RyZWFtLm1hdGNoKHJlQ29kZUJsb2NrU3RvcCkpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgIH1cblxuICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICB9XG5cbiAgLy8gdHcgZW0gLyBpdGFsaWNcbiAgZnVuY3Rpb24gdHdUb2tlbkVtKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgbWF5YmVFbmQgPSBmYWxzZSxcbiAgICBjaDtcbiAgICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgICBpZiAoY2ggPT0gXCIvXCIgJiYgbWF5YmVFbmQpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbWF5YmVFbmQgPSAoY2ggPT0gXCIvXCIpO1xuICAgIH1cbiAgICByZXR1cm4gXCJlbVwiO1xuICB9XG5cbiAgLy8gdHcgdW5kZXJsaW5lZCB0ZXh0XG4gIGZ1bmN0aW9uIHR3VG9rZW5VbmRlcmxpbmUoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBtYXliZUVuZCA9IGZhbHNlLFxuICAgIGNoO1xuICAgIHdoaWxlIChjaCA9IHN0cmVhbS5uZXh0KCkpIHtcbiAgICAgIGlmIChjaCA9PSBcIl9cIiAmJiBtYXliZUVuZCkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBtYXliZUVuZCA9IChjaCA9PSBcIl9cIik7XG4gICAgfVxuICAgIHJldHVybiBcInVuZGVybGluZWRcIjtcbiAgfVxuXG4gIC8vIHR3IHN0cmlrZSB0aHJvdWdoIHRleHQgbG9va3MgdWdseVxuICAvLyBjaGFuZ2UgQ1NTIGlmIG5lZWRlZFxuICBmdW5jdGlvbiB0d1Rva2VuU3RyaWtlKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgbWF5YmVFbmQgPSBmYWxzZSwgY2g7XG5cbiAgICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgICBpZiAoY2ggPT0gXCItXCIgJiYgbWF5YmVFbmQpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbWF5YmVFbmQgPSAoY2ggPT0gXCItXCIpO1xuICAgIH1cbiAgICByZXR1cm4gXCJzdHJpa2V0aHJvdWdoXCI7XG4gIH1cblxuICAvLyBtYWNyb1xuICBmdW5jdGlvbiB0d1Rva2VuTWFjcm8oc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmIChzdHJlYW0uY3VycmVudCgpID09ICc8PCcpIHtcbiAgICAgIHJldHVybiAnbWFjcm8nO1xuICAgIH1cblxuICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG4gICAgaWYgKCFjaCkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGNoID09IFwiPlwiKSB7XG4gICAgICBpZiAoc3RyZWFtLnBlZWsoKSA9PSAnPicpIHtcbiAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgIHJldHVybiBcIm1hY3JvXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwkX10vKTtcbiAgICByZXR1cm4ga2V5d29yZHMucHJvcGVydHlJc0VudW1lcmFibGUoc3RyZWFtLmN1cnJlbnQoKSkgPyBcImtleXdvcmRcIiA6IG51bGxcbiAgfVxuXG4gIC8vIEludGVyZmFjZVxuICByZXR1cm4ge1xuICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7dG9rZW5pemU6IHRva2VuQmFzZX07XG4gICAgfSxcblxuICAgIHRva2VuOiBmdW5jdGlvbiAoc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBzdHlsZSA9IHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH1cbiAgfTtcbn0pO1xuXG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3gtdGlkZGx5d2lraVwiLCBcInRpZGRseXdpa2lcIik7XG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuQ29kZU1pcnJvci5kZWZpbmVNb2RlKCd0aWtpJywgZnVuY3Rpb24oY29uZmlnKSB7XG4gIGZ1bmN0aW9uIGluQmxvY2soc3R5bGUsIHRlcm1pbmF0b3IsIHJldHVyblRva2VuaXplcikge1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKHRlcm1pbmF0b3IpKSB7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSBpblRleHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJldHVyblRva2VuaXplcikgc3RhdGUudG9rZW5pemUgPSByZXR1cm5Ub2tlbml6ZXI7XG5cbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaW5MaW5lKHN0eWxlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHdoaWxlKCFzdHJlYW0uZW9sKCkpIHtcbiAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnRva2VuaXplID0gaW5UZXh0O1xuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBpblRleHQoc3RyZWFtLCBzdGF0ZSkge1xuICAgIGZ1bmN0aW9uIGNoYWluKHBhcnNlcikge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSBwYXJzZXI7XG4gICAgICByZXR1cm4gcGFyc2VyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIHZhciBzb2wgPSBzdHJlYW0uc29sKCk7XG4gICAgdmFyIGNoID0gc3RyZWFtLm5leHQoKTtcblxuICAgIC8vbm9uIHN0YXJ0IG9mIGxpbmVcbiAgICBzd2l0Y2ggKGNoKSB7IC8vc3dpdGNoIGlzIGdlbmVyYWxseSBtdWNoIGZhc3RlciB0aGFuIGlmLCBzbyBpdCBpcyB1c2VkIGhlcmVcbiAgICBjYXNlIFwie1wiOiAvL3BsdWdpblxuICAgICAgc3RyZWFtLmVhdChcIi9cIik7XG4gICAgICBzdHJlYW0uZWF0U3BhY2UoKTtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW15cXHNcXHUwMGEwPVxcXCJcXCdcXC8/KH1dLyk7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IGluUGx1Z2luO1xuICAgICAgcmV0dXJuIFwidGFnXCI7XG4gICAgY2FzZSBcIl9cIjogLy9ib2xkXG4gICAgICBpZiAoc3RyZWFtLmVhdChcIl9cIikpXG4gICAgICAgIHJldHVybiBjaGFpbihpbkJsb2NrKFwic3Ryb25nXCIsIFwiX19cIiwgaW5UZXh0KSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiJ1wiOiAvL2l0YWxpY3NcbiAgICAgIGlmIChzdHJlYW0uZWF0KFwiJ1wiKSlcbiAgICAgICAgcmV0dXJuIGNoYWluKGluQmxvY2soXCJlbVwiLCBcIicnXCIsIGluVGV4dCkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIihcIjovLyBXaWtpIExpbmtcbiAgICAgIGlmIChzdHJlYW0uZWF0KFwiKFwiKSlcbiAgICAgICAgcmV0dXJuIGNoYWluKGluQmxvY2soXCJ2YXJpYWJsZS0yXCIsIFwiKSlcIiwgaW5UZXh0KSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiW1wiOi8vIFdlYmxpbmtcbiAgICAgIHJldHVybiBjaGFpbihpbkJsb2NrKFwidmFyaWFibGUtM1wiLCBcIl1cIiwgaW5UZXh0KSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwifFwiOiAvL3RhYmxlXG4gICAgICBpZiAoc3RyZWFtLmVhdChcInxcIikpXG4gICAgICAgIHJldHVybiBjaGFpbihpbkJsb2NrKFwiY29tbWVudFwiLCBcInx8XCIpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCItXCI6XG4gICAgICBpZiAoc3RyZWFtLmVhdChcIj1cIikpIHsvL3RpdGxlQmFyXG4gICAgICAgIHJldHVybiBjaGFpbihpbkJsb2NrKFwiaGVhZGVyIHN0cmluZ1wiLCBcIj0tXCIsIGluVGV4dCkpO1xuICAgICAgfSBlbHNlIGlmIChzdHJlYW0uZWF0KFwiLVwiKSkgey8vZGVsZXRlZFxuICAgICAgICByZXR1cm4gY2hhaW4oaW5CbG9jayhcImVycm9yIHR3LWRlbGV0ZWRcIiwgXCItLVwiLCBpblRleHQpKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCI9XCI6IC8vdW5kZXJsaW5lXG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKFwiPT1cIikpXG4gICAgICAgIHJldHVybiBjaGFpbihpbkJsb2NrKFwidHctdW5kZXJsaW5lXCIsIFwiPT09XCIsIGluVGV4dCkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIjpcIjpcbiAgICAgIGlmIChzdHJlYW0uZWF0KFwiOlwiKSlcbiAgICAgICAgcmV0dXJuIGNoYWluKGluQmxvY2soXCJjb21tZW50XCIsIFwiOjpcIikpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIl5cIjogLy9ib3hcbiAgICAgIHJldHVybiBjaGFpbihpbkJsb2NrKFwidHctYm94XCIsIFwiXlwiKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiflwiOiAvL25wXG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKFwibnB+XCIpKVxuICAgICAgICByZXR1cm4gY2hhaW4oaW5CbG9jayhcIm1ldGFcIiwgXCJ+L25wflwiKSk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvL3N0YXJ0IG9mIGxpbmUgdHlwZXNcbiAgICBpZiAoc29sKSB7XG4gICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICBjYXNlIFwiIVwiOiAvL2hlYWRlciBhdCBzdGFydCBvZiBsaW5lXG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2goJyEhISEhJykpIHtcbiAgICAgICAgICByZXR1cm4gY2hhaW4oaW5MaW5lKFwiaGVhZGVyIHN0cmluZ1wiKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKCchISEhJykpIHtcbiAgICAgICAgICByZXR1cm4gY2hhaW4oaW5MaW5lKFwiaGVhZGVyIHN0cmluZ1wiKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKCchISEnKSkge1xuICAgICAgICAgIHJldHVybiBjaGFpbihpbkxpbmUoXCJoZWFkZXIgc3RyaW5nXCIpKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goJyEhJykpIHtcbiAgICAgICAgICByZXR1cm4gY2hhaW4oaW5MaW5lKFwiaGVhZGVyIHN0cmluZ1wiKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNoYWluKGluTGluZShcImhlYWRlciBzdHJpbmdcIikpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIipcIjogLy91bm9yZGVyZWQgbGlzdCBsaW5lIGl0ZW0sIG9yIDxsaSAvPiBhdCBzdGFydCBvZiBsaW5lXG4gICAgICBjYXNlIFwiI1wiOiAvL29yZGVyZWQgbGlzdCBsaW5lIGl0ZW0sIG9yIDxsaSAvPiBhdCBzdGFydCBvZiBsaW5lXG4gICAgICBjYXNlIFwiK1wiOiAvL29yZGVyZWQgbGlzdCBsaW5lIGl0ZW0sIG9yIDxsaSAvPiBhdCBzdGFydCBvZiBsaW5lXG4gICAgICAgIHJldHVybiBjaGFpbihpbkxpbmUoXCJ0dy1saXN0aXRlbSBicmFja2V0XCIpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9zdHJlYW0uZWF0V2hpbGUoL1sme10vKTsgd2FzIGVhdGluZyB1cCBwbHVnaW5zLCB0dXJuZWQgb2ZmIHRvIGFjdCBsZXNzIGxpa2UgaHRtbCBhbmQgbW9yZSBsaWtlIHRpa2lcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBpbmRlbnRVbml0ID0gY29uZmlnLmluZGVudFVuaXQ7XG5cbiAgLy8gUmV0dXJuIHZhcmlhYmxlcyBmb3IgdG9rZW5pemVyc1xuICB2YXIgcGx1Z2luTmFtZSwgdHlwZTtcbiAgZnVuY3Rpb24gaW5QbHVnaW4oc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG4gICAgdmFyIHBlZWsgPSBzdHJlYW0ucGVlaygpO1xuXG4gICAgaWYgKGNoID09IFwifVwiKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IGluVGV4dDtcbiAgICAgIC8vdHlwZSA9IGNoID09IFwiKVwiID8gXCJlbmRQbHVnaW5cIiA6IFwic2VsZmNsb3NlUGx1Z2luXCI7IGluUGx1Z2luXG4gICAgICByZXR1cm4gXCJ0YWdcIjtcbiAgICB9IGVsc2UgaWYgKGNoID09IFwiKFwiIHx8IGNoID09IFwiKVwiKSB7XG4gICAgICByZXR1cm4gXCJicmFja2V0XCI7XG4gICAgfSBlbHNlIGlmIChjaCA9PSBcIj1cIikge1xuICAgICAgdHlwZSA9IFwiZXF1YWxzXCI7XG5cbiAgICAgIGlmIChwZWVrID09IFwiPlwiKSB7XG4gICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIHBlZWsgPSBzdHJlYW0ucGVlaygpO1xuICAgICAgfVxuXG4gICAgICAvL2hlcmUgd2UgZGV0ZWN0IHZhbHVlcyBkaXJlY3RseSBhZnRlciBlcXVhbCBjaGFyYWN0ZXIgd2l0aCBubyBxdW90ZXNcbiAgICAgIGlmICghL1tcXCdcXFwiXS8udGVzdChwZWVrKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IGluQXR0cmlidXRlTm9RdW90ZSgpO1xuICAgICAgfVxuICAgICAgLy9lbmQgZGV0ZWN0IHZhbHVlc1xuXG4gICAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICAgIH0gZWxzZSBpZiAoL1tcXCdcXFwiXS8udGVzdChjaCkpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gaW5BdHRyaWJ1dGUoY2gpO1xuICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1teXFxzXFx1MDBhMD1cXFwiXFwnXFwvP10vKTtcbiAgICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbkF0dHJpYnV0ZShxdW90ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuICAgICAgICBpZiAoc3RyZWFtLm5leHQoKSA9PSBxdW90ZSkge1xuICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gaW5QbHVnaW47XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBpbkF0dHJpYnV0ZU5vUXVvdGUoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG4gICAgICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIHZhciBwZWVrID0gc3RyZWFtLnBlZWsoKTtcbiAgICAgICAgaWYgKGNoID09IFwiIFwiIHx8IGNoID09IFwiLFwiIHx8IC9bICl9XS8udGVzdChwZWVrKSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSBpblBsdWdpbjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gXCJzdHJpbmdcIjtcbn07XG4gICAgICAgICAgICAgICAgICAgICB9XG5cbnZhciBjdXJTdGF0ZSwgc2V0U3R5bGU7XG5mdW5jdGlvbiBwYXNzKCkge1xuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBjdXJTdGF0ZS5jYy5wdXNoKGFyZ3VtZW50c1tpXSk7XG59XG5cbmZ1bmN0aW9uIGNvbnQoKSB7XG4gIHBhc3MuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHB1c2hDb250ZXh0KHBsdWdpbk5hbWUsIHN0YXJ0T2ZMaW5lKSB7XG4gIHZhciBub0luZGVudCA9IGN1clN0YXRlLmNvbnRleHQgJiYgY3VyU3RhdGUuY29udGV4dC5ub0luZGVudDtcbiAgY3VyU3RhdGUuY29udGV4dCA9IHtcbiAgICBwcmV2OiBjdXJTdGF0ZS5jb250ZXh0LFxuICAgIHBsdWdpbk5hbWU6IHBsdWdpbk5hbWUsXG4gICAgaW5kZW50OiBjdXJTdGF0ZS5pbmRlbnRlZCxcbiAgICBzdGFydE9mTGluZTogc3RhcnRPZkxpbmUsXG4gICAgbm9JbmRlbnQ6IG5vSW5kZW50XG4gIH07XG59XG5cbmZ1bmN0aW9uIHBvcENvbnRleHQoKSB7XG4gIGlmIChjdXJTdGF0ZS5jb250ZXh0KSBjdXJTdGF0ZS5jb250ZXh0ID0gY3VyU3RhdGUuY29udGV4dC5wcmV2O1xufVxuXG5mdW5jdGlvbiBlbGVtZW50KHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gXCJvcGVuUGx1Z2luXCIpIHtjdXJTdGF0ZS5wbHVnaW5OYW1lID0gcGx1Z2luTmFtZTsgcmV0dXJuIGNvbnQoYXR0cmlidXRlcywgZW5kcGx1Z2luKGN1clN0YXRlLnN0YXJ0T2ZMaW5lKSk7fVxuICBlbHNlIGlmICh0eXBlID09IFwiY2xvc2VQbHVnaW5cIikge1xuICAgIHZhciBlcnIgPSBmYWxzZTtcbiAgICBpZiAoY3VyU3RhdGUuY29udGV4dCkge1xuICAgICAgZXJyID0gY3VyU3RhdGUuY29udGV4dC5wbHVnaW5OYW1lICE9IHBsdWdpbk5hbWU7XG4gICAgICBwb3BDb250ZXh0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVyciA9IHRydWU7XG4gICAgfVxuICAgIGlmIChlcnIpIHNldFN0eWxlID0gXCJlcnJvclwiO1xuICAgIHJldHVybiBjb250KGVuZGNsb3NlcGx1Z2luKGVycikpO1xuICB9XG4gIGVsc2UgaWYgKHR5cGUgPT0gXCJzdHJpbmdcIikge1xuICAgIGlmICghY3VyU3RhdGUuY29udGV4dCB8fCBjdXJTdGF0ZS5jb250ZXh0Lm5hbWUgIT0gXCIhY2RhdGFcIikgcHVzaENvbnRleHQoXCIhY2RhdGFcIik7XG4gICAgaWYgKGN1clN0YXRlLnRva2VuaXplID09IGluVGV4dCkgcG9wQ29udGV4dCgpO1xuICAgIHJldHVybiBjb250KCk7XG4gIH1cbiAgZWxzZSByZXR1cm4gY29udCgpO1xufVxuXG5mdW5jdGlvbiBlbmRwbHVnaW4oc3RhcnRPZkxpbmUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBpZiAoXG4gICAgICB0eXBlID09IFwic2VsZmNsb3NlUGx1Z2luXCIgfHxcbiAgICAgICAgdHlwZSA9PSBcImVuZFBsdWdpblwiXG4gICAgKVxuICAgICAgcmV0dXJuIGNvbnQoKTtcbiAgICBpZiAodHlwZSA9PSBcImVuZFBsdWdpblwiKSB7cHVzaENvbnRleHQoY3VyU3RhdGUucGx1Z2luTmFtZSwgc3RhcnRPZkxpbmUpOyByZXR1cm4gY29udCgpO31cbiAgICByZXR1cm4gY29udCgpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBlbmRjbG9zZXBsdWdpbihlcnIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBpZiAoZXJyKSBzZXRTdHlsZSA9IFwiZXJyb3JcIjtcbiAgICBpZiAodHlwZSA9PSBcImVuZFBsdWdpblwiKSByZXR1cm4gY29udCgpO1xuICAgIHJldHVybiBwYXNzKCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJpYnV0ZXModHlwZSkge1xuICBpZiAodHlwZSA9PSBcImtleXdvcmRcIikge3NldFN0eWxlID0gXCJhdHRyaWJ1dGVcIjsgcmV0dXJuIGNvbnQoYXR0cmlidXRlcyk7fVxuICBpZiAodHlwZSA9PSBcImVxdWFsc1wiKSByZXR1cm4gY29udChhdHR2YWx1ZSwgYXR0cmlidXRlcyk7XG4gIHJldHVybiBwYXNzKCk7XG59XG5mdW5jdGlvbiBhdHR2YWx1ZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IFwia2V5d29yZFwiKSB7c2V0U3R5bGUgPSBcInN0cmluZ1wiOyByZXR1cm4gY29udCgpO31cbiAgaWYgKHR5cGUgPT0gXCJzdHJpbmdcIikgcmV0dXJuIGNvbnQoYXR0dmFsdWVtYXliZSk7XG4gIHJldHVybiBwYXNzKCk7XG59XG5mdW5jdGlvbiBhdHR2YWx1ZW1heWJlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gXCJzdHJpbmdcIikgcmV0dXJuIGNvbnQoYXR0dmFsdWVtYXliZSk7XG4gIGVsc2UgcmV0dXJuIHBhc3MoKTtcbn1cbnJldHVybiB7XG4gIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7dG9rZW5pemU6IGluVGV4dCwgY2M6IFtdLCBpbmRlbnRlZDogMCwgc3RhcnRPZkxpbmU6IHRydWUsIHBsdWdpbk5hbWU6IG51bGwsIGNvbnRleHQ6IG51bGx9O1xuICB9LFxuICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmIChzdHJlYW0uc29sKCkpIHtcbiAgICAgIHN0YXRlLnN0YXJ0T2ZMaW5lID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmluZGVudGVkID0gc3RyZWFtLmluZGVudGF0aW9uKCk7XG4gICAgfVxuICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkgcmV0dXJuIG51bGw7XG5cbiAgICBzZXRTdHlsZSA9IHR5cGUgPSBwbHVnaW5OYW1lID0gbnVsbDtcbiAgICB2YXIgc3R5bGUgPSBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICBpZiAoKHN0eWxlIHx8IHR5cGUpICYmIHN0eWxlICE9IFwiY29tbWVudFwiKSB7XG4gICAgICBjdXJTdGF0ZSA9IHN0YXRlO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGNvbWIgPSBzdGF0ZS5jYy5wb3AoKSB8fCBlbGVtZW50O1xuICAgICAgICBpZiAoY29tYih0eXBlIHx8IHN0eWxlKSkgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRlLnN0YXJ0T2ZMaW5lID0gZmFsc2U7XG4gICAgcmV0dXJuIHNldFN0eWxlIHx8IHN0eWxlO1xuICB9LFxuICBpbmRlbnQ6IGZ1bmN0aW9uKHN0YXRlLCB0ZXh0QWZ0ZXIpIHtcbiAgICB2YXIgY29udGV4dCA9IHN0YXRlLmNvbnRleHQ7XG4gICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5ub0luZGVudCkgcmV0dXJuIDA7XG4gICAgaWYgKGNvbnRleHQgJiYgL157XFwvLy50ZXN0KHRleHRBZnRlcikpXG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnByZXY7XG4gICAgd2hpbGUgKGNvbnRleHQgJiYgIWNvbnRleHQuc3RhcnRPZkxpbmUpXG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnByZXY7XG4gICAgaWYgKGNvbnRleHQpIHJldHVybiBjb250ZXh0LmluZGVudCArIGluZGVudFVuaXQ7XG4gICAgZWxzZSByZXR1cm4gMDtcbiAgfSxcbiAgZWxlY3RyaWNDaGFyczogXCIvXCJcbn07XG59KTtcblxuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC90aWtpXCIsIFwidGlraVwiKTtcblxufSk7XG4iLCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTW9kZShcInRvbWxcIiwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluU3RyaW5nOiBmYWxzZSxcbiAgICAgICAgc3RyaW5nVHlwZTogXCJcIixcbiAgICAgICAgbGhzOiB0cnVlLFxuICAgICAgICBpbkFycmF5OiAwXG4gICAgICB9O1xuICAgIH0sXG4gICAgdG9rZW46IGZ1bmN0aW9uIChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAvL2NoZWNrIGZvciBzdGF0ZSBjaGFuZ2VzXG4gICAgICBpZiAoIXN0YXRlLmluU3RyaW5nICYmICgoc3RyZWFtLnBlZWsoKSA9PSAnXCInKSB8fCAoc3RyZWFtLnBlZWsoKSA9PSBcIidcIikpKSB7XG4gICAgICAgIHN0YXRlLnN0cmluZ1R5cGUgPSBzdHJlYW0ucGVlaygpO1xuICAgICAgICBzdHJlYW0ubmV4dCgpOyAvLyBTa2lwIHF1b3RlXG4gICAgICAgIHN0YXRlLmluU3RyaW5nID0gdHJ1ZTsgLy8gVXBkYXRlIHN0YXRlXG4gICAgICB9XG4gICAgICBpZiAoc3RyZWFtLnNvbCgpICYmIHN0YXRlLmluQXJyYXkgPT09IDApIHtcbiAgICAgICAgc3RhdGUubGhzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vcmV0dXJuIHN0YXRlXG4gICAgICBpZiAoc3RhdGUuaW5TdHJpbmcpIHtcbiAgICAgICAgd2hpbGUgKHN0YXRlLmluU3RyaW5nICYmICFzdHJlYW0uZW9sKCkpIHtcbiAgICAgICAgICBpZiAoc3RyZWFtLnBlZWsoKSA9PT0gc3RhdGUuc3RyaW5nVHlwZSkge1xuICAgICAgICAgICAgc3RyZWFtLm5leHQoKTsgLy8gU2tpcCBxdW90ZVxuICAgICAgICAgICAgc3RhdGUuaW5TdHJpbmcgPSBmYWxzZTsgLy8gQ2xlYXIgZmxhZ1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLnBlZWsoKSA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyZWFtLm1hdGNoKC9eLlteXFxcXFxcXCJcXCddKi8pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGUubGhzID8gXCJwcm9wZXJ0eSBzdHJpbmdcIiA6IFwic3RyaW5nXCI7IC8vIFRva2VuIHN0eWxlXG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmluQXJyYXkgJiYgc3RyZWFtLnBlZWsoKSA9PT0gJ10nKSB7XG4gICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIHN0YXRlLmluQXJyYXktLTtcbiAgICAgICAgcmV0dXJuICdicmFja2V0JztcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGhzICYmIHN0cmVhbS5wZWVrKCkgPT09ICdbJyAmJiBzdHJlYW0uc2tpcFRvKCddJykpIHtcbiAgICAgICAgc3RyZWFtLm5leHQoKTsvL3NraXAgY2xvc2luZyBdXG4gICAgICAgIC8vIGFycmF5IG9mIG9iamVjdHMgaGFzIGFuIGV4dHJhIG9wZW4gJiBjbG9zZSBbXVxuICAgICAgICBpZiAoc3RyZWFtLnBlZWsoKSA9PT0gJ10nKSBzdHJlYW0ubmV4dCgpO1xuICAgICAgICByZXR1cm4gXCJhdG9tXCI7XG4gICAgICB9IGVsc2UgaWYgKHN0cmVhbS5wZWVrKCkgPT09IFwiI1wiKSB7XG4gICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgICAgfSBlbHNlIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGhzICYmIHN0cmVhbS5lYXRXaGlsZShmdW5jdGlvbiAoYykgeyByZXR1cm4gYyAhPSAnPScgJiYgYyAhPSAnICc7IH0pKSB7XG4gICAgICAgIHJldHVybiBcInByb3BlcnR5XCI7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxocyAmJiBzdHJlYW0ucGVlaygpID09PSBcIj1cIikge1xuICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICBzdGF0ZS5saHMgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2UgaWYgKCFzdGF0ZS5saHMgJiYgc3RyZWFtLm1hdGNoKC9eXFxkXFxkXFxkXFxkW1xcZFxcLVxcOlxcLlRdKlovKSkge1xuICAgICAgICByZXR1cm4gJ2F0b20nOyAvL2RhdGVcbiAgICAgIH0gZWxzZSBpZiAoIXN0YXRlLmxocyAmJiAoc3RyZWFtLm1hdGNoKCd0cnVlJykgfHwgc3RyZWFtLm1hdGNoKCdmYWxzZScpKSkge1xuICAgICAgICByZXR1cm4gJ2F0b20nO1xuICAgICAgfSBlbHNlIGlmICghc3RhdGUubGhzICYmIHN0cmVhbS5wZWVrKCkgPT09ICdbJykge1xuICAgICAgICBzdGF0ZS5pbkFycmF5Kys7XG4gICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIHJldHVybiAnYnJhY2tldCc7XG4gICAgICB9IGVsc2UgaWYgKCFzdGF0ZS5saHMgJiYgc3RyZWFtLm1hdGNoKC9eXFwtP1xcZCsoPzpcXC5cXGQrKT8vKSkge1xuICAgICAgICByZXR1cm4gJ251bWJlcic7XG4gICAgICB9IGVsc2UgaWYgKCFzdHJlYW0uZWF0U3BhY2UoKSkge1xuICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xufSk7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTUlNRSgndGV4dC94LXRvbWwnLCAndG9tbCcpO1xuXG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIiksIHJlcXVpcmUoXCIuLi9odG1sbWl4ZWQvaHRtbG1peGVkXCIpLFxuICAgICAgICByZXF1aXJlKFwiLi4vLi4vYWRkb24vbW9kZS9vdmVybGF5XCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIsIFwiLi4vaHRtbG1peGVkL2h0bWxtaXhlZFwiLFxuICAgICAgICAgICAgXCIuLi8uLi9hZGRvbi9tb2RlL292ZXJsYXlcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lTW9kZShcInRvcm5hZG86aW5uZXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGtleXdvcmRzID0gW1wiYW5kXCIsXCJhc1wiLFwiYXNzZXJ0XCIsXCJhdXRvZXNjYXBlXCIsXCJibG9ja1wiLFwiYnJlYWtcIixcImNsYXNzXCIsXCJjb21tZW50XCIsXCJjb250ZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY29udGludWVcIixcImRhdGV0aW1lXCIsXCJkZWZcIixcImRlbFwiLFwiZWxpZlwiLFwiZWxzZVwiLFwiZW5kXCIsXCJlc2NhcGVcIixcImV4Y2VwdFwiLFxuICAgICAgICAgICAgICAgICAgICBcImV4ZWNcIixcImV4dGVuZHNcIixcImZhbHNlXCIsXCJmaW5hbGx5XCIsXCJmb3JcIixcImZyb21cIixcImdsb2JhbFwiLFwiaWZcIixcImltcG9ydFwiLFwiaW5cIixcbiAgICAgICAgICAgICAgICAgICAgXCJpbmNsdWRlXCIsXCJpc1wiLFwianNvbl9lbmNvZGVcIixcImxhbWJkYVwiLFwibGVuZ3RoXCIsXCJsaW5raWZ5XCIsXCJsb2FkXCIsXCJtb2R1bGVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJub25lXCIsXCJub3RcIixcIm9yXCIsXCJwYXNzXCIsXCJwcmludFwiLFwicHV0XCIsXCJyYWlzZVwiLFwicmF3XCIsXCJyZXR1cm5cIixcInNlbGZcIixcInNldFwiLFxuICAgICAgICAgICAgICAgICAgICBcInNxdWVlemVcIixcInN1cGVyXCIsXCJ0cnVlXCIsXCJ0cnlcIixcInVybF9lc2NhcGVcIixcIndoaWxlXCIsXCJ3aXRoXCIsXCJ3aXRob3V0XCIsXCJ4aHRtbF9lc2NhcGVcIixcInlpZWxkXCJdO1xuICAgIGtleXdvcmRzID0gbmV3IFJlZ0V4cChcIl4oKFwiICsga2V5d29yZHMuam9pbihcIil8KFwiKSArIFwiKSlcXFxcYlwiKTtcblxuICAgIGZ1bmN0aW9uIHRva2VuQmFzZSAoc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXlxce10vKTtcbiAgICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG4gICAgICBpZiAoY2ggPT0gXCJ7XCIpIHtcbiAgICAgICAgaWYgKGNoID0gc3RyZWFtLmVhdCgvXFx7fCV8Iy8pKSB7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSBpblRhZyhjaCk7XG4gICAgICAgICAgcmV0dXJuIFwidGFnXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaW5UYWcgKGNsb3NlKSB7XG4gICAgICBpZiAoY2xvc2UgPT0gXCJ7XCIpIHtcbiAgICAgICAgY2xvc2UgPSBcIn1cIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICAgICAgICBpZiAoKGNoID09IGNsb3NlKSAmJiBzdHJlYW0uZWF0KFwifVwiKSkge1xuICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgICAgIHJldHVybiBcInRhZ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2goa2V5d29yZHMpKSB7XG4gICAgICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbG9zZSA9PSBcIiNcIiA/IFwiY29tbWVudFwiIDogXCJzdHJpbmdcIjtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzdGFydFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7dG9rZW5pemU6IHRva2VuQmFzZX07XG4gICAgICB9LFxuICAgICAgdG9rZW46IGZ1bmN0aW9uIChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcblxuICBDb2RlTWlycm9yLmRlZmluZU1vZGUoXCJ0b3JuYWRvXCIsIGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHZhciBodG1sQmFzZSA9IENvZGVNaXJyb3IuZ2V0TW9kZShjb25maWcsIFwidGV4dC9odG1sXCIpO1xuICAgIHZhciB0b3JuYWRvSW5uZXIgPSBDb2RlTWlycm9yLmdldE1vZGUoY29uZmlnLCBcInRvcm5hZG86aW5uZXJcIik7XG4gICAgcmV0dXJuIENvZGVNaXJyb3Iub3ZlcmxheU1vZGUoaHRtbEJhc2UsIHRvcm5hZG9Jbm5lcik7XG4gIH0pO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQveC10b3JuYWRvXCIsIFwidG9ybmFkb1wiKTtcbn0pO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlXG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTW9kZSgndHJvZmYnLCBmdW5jdGlvbigpIHtcblxuICB2YXIgd29yZHMgPSB7fTtcblxuICBmdW5jdGlvbiB0b2tlbkJhc2Uoc3RyZWFtKSB7XG4gICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSByZXR1cm4gbnVsbDtcblxuICAgIHZhciBzb2wgPSBzdHJlYW0uc29sKCk7XG4gICAgdmFyIGNoID0gc3RyZWFtLm5leHQoKTtcblxuICAgIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKCdmQicpIHx8IHN0cmVhbS5tYXRjaCgnZlInKSB8fCBzdHJlYW0ubWF0Y2goJ2ZJJykgfHxcbiAgICAgICAgICBzdHJlYW0ubWF0Y2goJ3UnKSAgfHwgc3RyZWFtLm1hdGNoKCdkJykgIHx8XG4gICAgICAgICAgc3RyZWFtLm1hdGNoKCclJykgIHx8IHN0cmVhbS5tYXRjaCgnJicpKSB7XG4gICAgICAgIHJldHVybiAnc3RyaW5nJztcbiAgICAgIH1cbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goJ21bJykpIHtcbiAgICAgICAgc3RyZWFtLnNraXBUbygnXScpO1xuICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICByZXR1cm4gJ3N0cmluZyc7XG4gICAgICB9XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKCdzKycpIHx8IHN0cmVhbS5tYXRjaCgncy0nKSkge1xuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXGQtXS8pO1xuICAgICAgICByZXR1cm4gJ3N0cmluZyc7XG4gICAgICB9XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKCdcXCgnKSB8fCBzdHJlYW0ubWF0Y2goJypcXCgnKSkge1xuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHctXS8pO1xuICAgICAgICByZXR1cm4gJ3N0cmluZyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ3N0cmluZyc7XG4gICAgfVxuICAgIGlmIChzb2wgJiYgKGNoID09PSAnLicgfHwgY2ggPT09ICdcXCcnKSkge1xuICAgICAgaWYgKHN0cmVhbS5lYXQoJ1xcXFwnKSAmJiBzdHJlYW0uZWF0KCdcXFwiJykpIHtcbiAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICByZXR1cm4gJ2NvbW1lbnQnO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc29sICYmIGNoID09PSAnLicpIHtcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goJ0IgJykgfHwgc3RyZWFtLm1hdGNoKCdJICcpIHx8IHN0cmVhbS5tYXRjaCgnUiAnKSkge1xuICAgICAgICByZXR1cm4gJ2F0dHJpYnV0ZSc7XG4gICAgICB9XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKCdUSCAnKSB8fCBzdHJlYW0ubWF0Y2goJ1NIICcpIHx8IHN0cmVhbS5tYXRjaCgnU1MgJykgfHwgc3RyZWFtLm1hdGNoKCdIUCAnKSkge1xuICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgIHJldHVybiAncXVvdGUnO1xuICAgICAgfVxuICAgICAgaWYgKChzdHJlYW0ubWF0Y2goL1tBLVpdLykgJiYgc3RyZWFtLm1hdGNoKC9bQS1aXS8pKSB8fCAoc3RyZWFtLm1hdGNoKC9bYS16XS8pICYmIHN0cmVhbS5tYXRjaCgvW2Etel0vKSkpIHtcbiAgICAgICAgcmV0dXJuICdhdHRyaWJ1dGUnO1xuICAgICAgfVxuICAgIH1cbiAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHctXS8pO1xuICAgIHZhciBjdXIgPSBzdHJlYW0uY3VycmVudCgpO1xuICAgIHJldHVybiB3b3Jkcy5oYXNPd25Qcm9wZXJ0eShjdXIpID8gd29yZHNbY3VyXSA6IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlbml6ZShzdHJlYW0sIHN0YXRlKSB7XG4gICAgcmV0dXJuIChzdGF0ZS50b2tlbnNbMF0gfHwgdG9rZW5CYXNlKSAoc3RyZWFtLCBzdGF0ZSk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtyZXR1cm4ge3Rva2VuczpbXX07fSxcbiAgICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgcmV0dXJuIHRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfTtcbn0pO1xuXG5Db2RlTWlycm9yLmRlZmluZU1JTUUoJ3RleHQvdHJvZmYnLCAndHJvZmYnKTtcbkNvZGVNaXJyb3IuZGVmaW5lTUlNRSgndGV4dC94LXRyb2ZmJywgJ3Ryb2ZmJyk7XG5Db2RlTWlycm9yLmRlZmluZU1JTUUoJ2FwcGxpY2F0aW9uL3gtdHJvZmYnLCAndHJvZmYnKTtcblxufSk7XG4iLCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBDb2RlTWlycm9yLmRlZmluZU1vZGUoXCJ0dGNuLWNmZ1wiLCBmdW5jdGlvbihjb25maWcsIHBhcnNlckNvbmZpZykge1xuICAgIHZhciBpbmRlbnRVbml0ID0gY29uZmlnLmluZGVudFVuaXQsXG4gICAgICAgIGtleXdvcmRzID0gcGFyc2VyQ29uZmlnLmtleXdvcmRzIHx8IHt9LFxuICAgICAgICBmaWxlTkN0cmxNYXNrT3B0aW9ucyA9IHBhcnNlckNvbmZpZy5maWxlTkN0cmxNYXNrT3B0aW9ucyB8fCB7fSxcbiAgICAgICAgZXh0ZXJuYWxDb21tYW5kcyA9IHBhcnNlckNvbmZpZy5leHRlcm5hbENvbW1hbmRzIHx8IHt9LFxuICAgICAgICBtdWx0aUxpbmVTdHJpbmdzID0gcGFyc2VyQ29uZmlnLm11bHRpTGluZVN0cmluZ3MsXG4gICAgICAgIGluZGVudFN0YXRlbWVudHMgPSBwYXJzZXJDb25maWcuaW5kZW50U3RhdGVtZW50cyAhPT0gZmFsc2U7XG4gICAgdmFyIGlzT3BlcmF0b3JDaGFyID0gL1tcXHxdLztcbiAgICB2YXIgY3VyUHVuYztcblxuICAgIGZ1bmN0aW9uIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICAgICAgaWYgKGNoID09ICdcIicgfHwgY2ggPT0gXCInXCIpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlblN0cmluZyhjaCk7XG4gICAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIGlmICgvWzo9XS8udGVzdChjaCkpIHtcbiAgICAgICAgY3VyUHVuYyA9IGNoO1xuICAgICAgICByZXR1cm4gXCJwdW5jdHVhdGlvblwiO1xuICAgICAgfVxuICAgICAgaWYgKGNoID09IFwiI1wiKXtcbiAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgICB9XG4gICAgICBpZiAoL1xcZC8udGVzdChjaCkpIHtcbiAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwuXS8pO1xuICAgICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICAgIH1cbiAgICAgIGlmIChpc09wZXJhdG9yQ2hhci50ZXN0KGNoKSkge1xuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoaXNPcGVyYXRvckNoYXIpO1xuICAgICAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICAgICAgfVxuICAgICAgaWYgKGNoID09IFwiW1wiKXtcbiAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3X1xcXV0vKTtcbiAgICAgICAgcmV0dXJuIFwibnVtYmVyIHNlY3Rpb25UaXRsZVwiO1xuICAgICAgfVxuXG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXCRfXS8pO1xuICAgICAgdmFyIGN1ciA9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAgICBpZiAoa2V5d29yZHMucHJvcGVydHlJc0VudW1lcmFibGUoY3VyKSkgcmV0dXJuIFwia2V5d29yZFwiO1xuICAgICAgaWYgKGZpbGVOQ3RybE1hc2tPcHRpb25zLnByb3BlcnR5SXNFbnVtZXJhYmxlKGN1cikpXG4gICAgICAgIHJldHVybiBcIm5lZ2F0aXZlIGZpbGVOQ3RybE1hc2tPcHRpb25zXCI7XG4gICAgICBpZiAoZXh0ZXJuYWxDb21tYW5kcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSByZXR1cm4gXCJuZWdhdGl2ZSBleHRlcm5hbENvbW1hbmRzXCI7XG5cbiAgICAgIHJldHVybiBcInZhcmlhYmxlXCI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9rZW5TdHJpbmcocXVvdGUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIHZhciBlc2NhcGVkID0gZmFsc2UsIG5leHQsIGVuZCA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAoKG5leHQgPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKG5leHQgPT0gcXVvdGUgJiYgIWVzY2FwZWQpe1xuICAgICAgICAgICAgdmFyIGFmdGVyTmV4dCA9IHN0cmVhbS5wZWVrKCk7XG4gICAgICAgICAgICAvL2xvb2sgaWYgdGhlIGNoYXJhY3RlciBpZiB0aGUgcXVvdGUgaXMgbGlrZSB0aGUgQiBpbiAnMTAxMDAwMTAnQlxuICAgICAgICAgICAgaWYgKGFmdGVyTmV4dCl7XG4gICAgICAgICAgICAgIGFmdGVyTmV4dCA9IGFmdGVyTmV4dC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICBpZihhZnRlck5leHQgPT0gXCJiXCIgfHwgYWZ0ZXJOZXh0ID09IFwiaFwiIHx8IGFmdGVyTmV4dCA9PSBcIm9cIilcbiAgICAgICAgICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5kID0gdHJ1ZTsgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZCAmJiBuZXh0ID09IFwiXFxcXFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgfHwgIShlc2NhcGVkIHx8IG11bHRpTGluZVN0cmluZ3MpKVxuICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIENvbnRleHQoaW5kZW50ZWQsIGNvbHVtbiwgdHlwZSwgYWxpZ24sIHByZXYpIHtcbiAgICAgIHRoaXMuaW5kZW50ZWQgPSBpbmRlbnRlZDtcbiAgICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgIHRoaXMuYWxpZ24gPSBhbGlnbjtcbiAgICAgIHRoaXMucHJldiA9IHByZXY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hDb250ZXh0KHN0YXRlLCBjb2wsIHR5cGUpIHtcbiAgICAgIHZhciBpbmRlbnQgPSBzdGF0ZS5pbmRlbnRlZDtcbiAgICAgIGlmIChzdGF0ZS5jb250ZXh0ICYmIHN0YXRlLmNvbnRleHQudHlwZSA9PSBcInN0YXRlbWVudFwiKVxuICAgICAgICBpbmRlbnQgPSBzdGF0ZS5jb250ZXh0LmluZGVudGVkO1xuICAgICAgcmV0dXJuIHN0YXRlLmNvbnRleHQgPSBuZXcgQ29udGV4dChpbmRlbnQsIGNvbCwgdHlwZSwgbnVsbCwgc3RhdGUuY29udGV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcENvbnRleHQoc3RhdGUpIHtcbiAgICAgIHZhciB0ID0gc3RhdGUuY29udGV4dC50eXBlO1xuICAgICAgaWYgKHQgPT0gXCIpXCIgfHwgdCA9PSBcIl1cIiB8fCB0ID09IFwifVwiKVxuICAgICAgICBzdGF0ZS5pbmRlbnRlZCA9IHN0YXRlLmNvbnRleHQuaW5kZW50ZWQ7XG4gICAgICByZXR1cm4gc3RhdGUuY29udGV4dCA9IHN0YXRlLmNvbnRleHQucHJldjtcbiAgICB9XG5cbiAgICAvL0ludGVyZmFjZVxuICAgIHJldHVybiB7XG4gICAgICBzdGFydFN0YXRlOiBmdW5jdGlvbihiYXNlY29sdW1uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdG9rZW5pemU6IG51bGwsXG4gICAgICAgICAgY29udGV4dDogbmV3IENvbnRleHQoKGJhc2Vjb2x1bW4gfHwgMCkgLSBpbmRlbnRVbml0LCAwLCBcInRvcFwiLCBmYWxzZSksXG4gICAgICAgICAgaW5kZW50ZWQ6IDAsXG4gICAgICAgICAgc3RhcnRPZkxpbmU6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH0sXG5cbiAgICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIHZhciBjdHggPSBzdGF0ZS5jb250ZXh0O1xuICAgICAgICBpZiAoc3RyZWFtLnNvbCgpKSB7XG4gICAgICAgICAgaWYgKGN0eC5hbGlnbiA9PSBudWxsKSBjdHguYWxpZ24gPSBmYWxzZTtcbiAgICAgICAgICBzdGF0ZS5pbmRlbnRlZCA9IHN0cmVhbS5pbmRlbnRhdGlvbigpO1xuICAgICAgICAgIHN0YXRlLnN0YXJ0T2ZMaW5lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xuICAgICAgICBjdXJQdW5jID0gbnVsbDtcbiAgICAgICAgdmFyIHN0eWxlID0gKHN0YXRlLnRva2VuaXplIHx8IHRva2VuQmFzZSkoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIGlmIChzdHlsZSA9PSBcImNvbW1lbnRcIikgcmV0dXJuIHN0eWxlO1xuICAgICAgICBpZiAoY3R4LmFsaWduID09IG51bGwpIGN0eC5hbGlnbiA9IHRydWU7XG5cbiAgICAgICAgaWYgKChjdXJQdW5jID09IFwiO1wiIHx8IGN1clB1bmMgPT0gXCI6XCIgfHwgY3VyUHVuYyA9PSBcIixcIilcbiAgICAgICAgICAgICYmIGN0eC50eXBlID09IFwic3RhdGVtZW50XCIpe1xuICAgICAgICAgIHBvcENvbnRleHQoc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1clB1bmMgPT0gXCJ7XCIpIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0uY29sdW1uKCksIFwifVwiKTtcbiAgICAgICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBcIltcIikgcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbS5jb2x1bW4oKSwgXCJdXCIpO1xuICAgICAgICBlbHNlIGlmIChjdXJQdW5jID09IFwiKFwiKSBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLmNvbHVtbigpLCBcIilcIik7XG4gICAgICAgIGVsc2UgaWYgKGN1clB1bmMgPT0gXCJ9XCIpIHtcbiAgICAgICAgICB3aGlsZSAoY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIikgY3R4ID0gcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICAgICAgaWYgKGN0eC50eXBlID09IFwifVwiKSBjdHggPSBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgICAgICB3aGlsZSAoY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIikgY3R4ID0gcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBjdHgudHlwZSkgcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICAgIGVsc2UgaWYgKGluZGVudFN0YXRlbWVudHMgJiYgKCgoY3R4LnR5cGUgPT0gXCJ9XCIgfHwgY3R4LnR5cGUgPT0gXCJ0b3BcIilcbiAgICAgICAgICAgICYmIGN1clB1bmMgIT0gJzsnKSB8fCAoY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIlxuICAgICAgICAgICAgJiYgY3VyUHVuYyA9PSBcIm5ld3N0YXRlbWVudFwiKSkpXG4gICAgICAgICAgcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbS5jb2x1bW4oKSwgXCJzdGF0ZW1lbnRcIik7XG4gICAgICAgIHN0YXRlLnN0YXJ0T2ZMaW5lID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgIH0sXG5cbiAgICAgIGVsZWN0cmljQ2hhcnM6IFwie31cIixcbiAgICAgIGxpbmVDb21tZW50OiBcIiNcIixcbiAgICAgIGZvbGQ6IFwiYnJhY2VcIlxuICAgIH07XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHdvcmRzKHN0cikge1xuICAgIHZhciBvYmogPSB7fSwgd29yZHMgPSBzdHIuc3BsaXQoXCIgXCIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyArK2kpXG4gICAgICBvYmpbd29yZHNbaV1dID0gdHJ1ZTtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LXR0Y24tY2ZnXCIsIHtcbiAgICBuYW1lOiBcInR0Y24tY2ZnXCIsXG4gICAga2V5d29yZHM6IHdvcmRzKFwiWWVzIE5vIExvZ0ZpbGUgRmlsZU1hc2sgQ29uc29sZU1hc2sgQXBwZW5kRmlsZVwiICtcbiAgICBcIiBUaW1lU3RhbXBGb3JtYXQgTG9nRXZlbnRUeXBlcyBTb3VyY2VJbmZvRm9ybWF0XCIgK1xuICAgIFwiIExvZ0VudGl0eU5hbWUgTG9nU291cmNlSW5mbyBEaXNrRnVsbEFjdGlvblwiICtcbiAgICBcIiBMb2dGaWxlTnVtYmVyIExvZ0ZpbGVTaXplIE1hdGNoaW5nSGludHMgRGV0YWlsZWRcIiArXG4gICAgXCIgQ29tcGFjdCBTdWJDYXRlZ29yaWVzIFN0YWNrIFNpbmdsZSBOb25lIFNlY29uZHNcIiArXG4gICAgXCIgRGF0ZVRpbWUgVGltZSBTdG9wIEVycm9yIFJldHJ5IERlbGV0ZSBUQ1BQb3J0IEtpbGxUaW1lclwiICtcbiAgICBcIiBOdW1IQ3MgVW5peFNvY2tldHNFbmFibGVkIExvY2FsQWRkcmVzc1wiKSxcbiAgICBmaWxlTkN0cmxNYXNrT3B0aW9uczogd29yZHMoXCJUVENOX0VYRUNVVE9SIFRUQ05fRVJST1IgVFRDTl9XQVJOSU5HXCIgK1xuICAgIFwiIFRUQ05fUE9SVEVWRU5UIFRUQ05fVElNRVJPUCBUVENOX1ZFUkRJQ1RPUFwiICtcbiAgICBcIiBUVENOX0RFRkFVTFRPUCBUVENOX1RFU1RDQVNFIFRUQ05fQUNUSU9OXCIgK1xuICAgIFwiIFRUQ05fVVNFUiBUVENOX0ZVTkNUSU9OIFRUQ05fU1RBVElTVElDU1wiICtcbiAgICBcIiBUVENOX1BBUkFMTEVMIFRUQ05fTUFUQ0hJTkcgVFRDTl9ERUJVR1wiICtcbiAgICBcIiBFWEVDVVRPUiBFUlJPUiBXQVJOSU5HIFBPUlRFVkVOVCBUSU1FUk9QXCIgK1xuICAgIFwiIFZFUkRJQ1RPUCBERUZBVUxUT1AgVEVTVENBU0UgQUNUSU9OIFVTRVJcIiArXG4gICAgXCIgRlVOQ1RJT04gU1RBVElTVElDUyBQQVJBTExFTCBNQVRDSElORyBERUJVR1wiICtcbiAgICBcIiBMT0dfQUxMIExPR19OT1RISU5HIEFDVElPTl9VTlFVQUxJRklFRFwiICtcbiAgICBcIiBERUJVR19FTkNERUMgREVCVUdfVEVTVFBPUlRcIiArXG4gICAgXCIgREVCVUdfVU5RVUFMSUZJRUQgREVGQVVMVE9QX0FDVElWQVRFXCIgK1xuICAgIFwiIERFRkFVTFRPUF9ERUFDVElWQVRFIERFRkFVTFRPUF9FWElUXCIgK1xuICAgIFwiIERFRkFVTFRPUF9VTlFVQUxJRklFRCBFUlJPUl9VTlFVQUxJRklFRFwiICtcbiAgICBcIiBFWEVDVVRPUl9DT01QT05FTlQgRVhFQ1VUT1JfQ09ORklHREFUQVwiICtcbiAgICBcIiBFWEVDVVRPUl9FWFRDT01NQU5EIEVYRUNVVE9SX0xPR09QVElPTlNcIiArXG4gICAgXCIgRVhFQ1VUT1JfUlVOVElNRSBFWEVDVVRPUl9VTlFVQUxJRklFRFwiICtcbiAgICBcIiBGVU5DVElPTl9STkQgRlVOQ1RJT05fVU5RVUFMSUZJRURcIiArXG4gICAgXCIgTUFUQ0hJTkdfRE9ORSBNQVRDSElOR19NQ1NVQ0NFU1NcIiArXG4gICAgXCIgTUFUQ0hJTkdfTUNVTlNVQ0MgTUFUQ0hJTkdfTU1TVUNDRVNTXCIgK1xuICAgIFwiIE1BVENISU5HX01NVU5TVUNDIE1BVENISU5HX1BDU1VDQ0VTU1wiICtcbiAgICBcIiBNQVRDSElOR19QQ1VOU1VDQyBNQVRDSElOR19QTVNVQ0NFU1NcIiArXG4gICAgXCIgTUFUQ0hJTkdfUE1VTlNVQ0MgTUFUQ0hJTkdfUFJPQkxFTVwiICtcbiAgICBcIiBNQVRDSElOR19USU1FT1VUIE1BVENISU5HX1VOUVVBTElGSUVEXCIgK1xuICAgIFwiIFBBUkFMTEVMX1BPUlRDT05OIFBBUkFMTEVMX1BPUlRNQVBcIiArXG4gICAgXCIgUEFSQUxMRUxfUFRDIFBBUkFMTEVMX1VOUVVBTElGSUVEXCIgK1xuICAgIFwiIFBPUlRFVkVOVF9EVUFMUkVDViBQT1JURVZFTlRfRFVBTFNFTkRcIiArXG4gICAgXCIgUE9SVEVWRU5UX01DUkVDViBQT1JURVZFTlRfTUNTRU5EXCIgK1xuICAgIFwiIFBPUlRFVkVOVF9NTVJFQ1YgUE9SVEVWRU5UX01NU0VORFwiICtcbiAgICBcIiBQT1JURVZFTlRfTVFVRVVFIFBPUlRFVkVOVF9QQ0lOXCIgK1xuICAgIFwiIFBPUlRFVkVOVF9QQ09VVCBQT1JURVZFTlRfUE1JTlwiICtcbiAgICBcIiBQT1JURVZFTlRfUE1PVVQgUE9SVEVWRU5UX1BRVUVVRVwiICtcbiAgICBcIiBQT1JURVZFTlRfU1RBVEUgUE9SVEVWRU5UX1VOUVVBTElGSUVEXCIgK1xuICAgIFwiIFNUQVRJU1RJQ1NfVU5RVUFMSUZJRUQgU1RBVElTVElDU19WRVJESUNUXCIgK1xuICAgIFwiIFRFU1RDQVNFX0ZJTklTSCBURVNUQ0FTRV9TVEFSVFwiICtcbiAgICBcIiBURVNUQ0FTRV9VTlFVQUxJRklFRCBUSU1FUk9QX0dVQVJEXCIgK1xuICAgIFwiIFRJTUVST1BfUkVBRCBUSU1FUk9QX1NUQVJUIFRJTUVST1BfU1RPUFwiICtcbiAgICBcIiBUSU1FUk9QX1RJTUVPVVQgVElNRVJPUF9VTlFVQUxJRklFRFwiICtcbiAgICBcIiBVU0VSX1VOUVVBTElGSUVEIFZFUkRJQ1RPUF9GSU5BTFwiICtcbiAgICBcIiBWRVJESUNUT1BfR0VUVkVSRElDVCBWRVJESUNUT1BfU0VUVkVSRElDVFwiICtcbiAgICBcIiBWRVJESUNUT1BfVU5RVUFMSUZJRUQgV0FSTklOR19VTlFVQUxJRklFRFwiKSxcbiAgICBleHRlcm5hbENvbW1hbmRzOiB3b3JkcyhcIkJlZ2luQ29udHJvbFBhcnQgRW5kQ29udHJvbFBhcnQgQmVnaW5UZXN0Q2FzZVwiICtcbiAgICBcIiBFbmRUZXN0Q2FzZVwiKSxcbiAgICBtdWx0aUxpbmVTdHJpbmdzOiB0cnVlXG4gIH0pO1xufSk7IiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwidHRjblwiLCBmdW5jdGlvbihjb25maWcsIHBhcnNlckNvbmZpZykge1xuICAgIHZhciBpbmRlbnRVbml0ID0gY29uZmlnLmluZGVudFVuaXQsXG4gICAgICAgIGtleXdvcmRzID0gcGFyc2VyQ29uZmlnLmtleXdvcmRzIHx8IHt9LFxuICAgICAgICBidWlsdGluID0gcGFyc2VyQ29uZmlnLmJ1aWx0aW4gfHwge30sXG4gICAgICAgIHRpbWVyT3BzID0gcGFyc2VyQ29uZmlnLnRpbWVyT3BzIHx8IHt9LFxuICAgICAgICBwb3J0T3BzICA9IHBhcnNlckNvbmZpZy5wb3J0T3BzIHx8IHt9LFxuICAgICAgICBjb25maWdPcHMgPSBwYXJzZXJDb25maWcuY29uZmlnT3BzIHx8IHt9LFxuICAgICAgICB2ZXJkaWN0T3BzID0gcGFyc2VyQ29uZmlnLnZlcmRpY3RPcHMgfHwge30sXG4gICAgICAgIHN1dE9wcyA9IHBhcnNlckNvbmZpZy5zdXRPcHMgfHwge30sXG4gICAgICAgIGZ1bmN0aW9uT3BzID0gcGFyc2VyQ29uZmlnLmZ1bmN0aW9uT3BzIHx8IHt9LFxuXG4gICAgICAgIHZlcmRpY3RDb25zdHMgPSBwYXJzZXJDb25maWcudmVyZGljdENvbnN0cyB8fCB7fSxcbiAgICAgICAgYm9vbGVhbkNvbnN0cyA9IHBhcnNlckNvbmZpZy5ib29sZWFuQ29uc3RzIHx8IHt9LFxuICAgICAgICBvdGhlckNvbnN0cyAgID0gcGFyc2VyQ29uZmlnLm90aGVyQ29uc3RzIHx8IHt9LFxuXG4gICAgICAgIHR5cGVzID0gcGFyc2VyQ29uZmlnLnR5cGVzIHx8IHt9LFxuICAgICAgICB2aXNpYmlsaXR5TW9kaWZpZXJzID0gcGFyc2VyQ29uZmlnLnZpc2liaWxpdHlNb2RpZmllcnMgfHwge30sXG4gICAgICAgIHRlbXBsYXRlTWF0Y2ggPSBwYXJzZXJDb25maWcudGVtcGxhdGVNYXRjaCB8fCB7fSxcbiAgICAgICAgbXVsdGlMaW5lU3RyaW5ncyA9IHBhcnNlckNvbmZpZy5tdWx0aUxpbmVTdHJpbmdzLFxuICAgICAgICBpbmRlbnRTdGF0ZW1lbnRzID0gcGFyc2VyQ29uZmlnLmluZGVudFN0YXRlbWVudHMgIT09IGZhbHNlO1xuICAgIHZhciBpc09wZXJhdG9yQ2hhciA9IC9bK1xcLSomQD08PiFcXC9dLztcbiAgICB2YXIgY3VyUHVuYztcblxuICAgIGZ1bmN0aW9uIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuXG4gICAgICBpZiAoY2ggPT0gJ1wiJyB8fCBjaCA9PSBcIidcIikge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuU3RyaW5nKGNoKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgfVxuICAgICAgaWYgKC9bXFxbXFxde31cXChcXCksO1xcXFw6XFw/XFwuXS8udGVzdChjaCkpIHtcbiAgICAgICAgY3VyUHVuYyA9IGNoO1xuICAgICAgICByZXR1cm4gXCJwdW5jdHVhdGlvblwiO1xuICAgICAgfVxuICAgICAgaWYgKGNoID09IFwiI1wiKXtcbiAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICByZXR1cm4gXCJhdG9tIHByZXByb2Nlc3NvclwiO1xuICAgICAgfVxuICAgICAgaWYgKGNoID09IFwiJVwiKXtcbiAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9cXGIvKTtcbiAgICAgICAgcmV0dXJuIFwiYXRvbSB0dGNuM01hY3Jvc1wiO1xuICAgICAgfVxuICAgICAgaWYgKC9cXGQvLnRlc3QoY2gpKSB7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcLl0vKTtcbiAgICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgICB9XG4gICAgICBpZiAoY2ggPT0gXCIvXCIpIHtcbiAgICAgICAgaWYgKHN0cmVhbS5lYXQoXCIqXCIpKSB7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkNvbW1lbnQ7XG4gICAgICAgICAgcmV0dXJuIHRva2VuQ29tbWVudChzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtLmVhdChcIi9cIikpIHtcbiAgICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNPcGVyYXRvckNoYXIudGVzdChjaCkpIHtcbiAgICAgICAgaWYoY2ggPT0gXCJAXCIpe1xuICAgICAgICAgIGlmKHN0cmVhbS5tYXRjaChcInRyeVwiKSB8fCBzdHJlYW0ubWF0Y2goXCJjYXRjaFwiKVxuICAgICAgICAgICAgICB8fCBzdHJlYW0ubWF0Y2goXCJsYXp5XCIpKXtcbiAgICAgICAgICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtLmVhdFdoaWxlKGlzT3BlcmF0b3JDaGFyKTtcbiAgICAgICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgICAgIH1cbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcJF9cXHhhMS1cXHVmZmZmXS8pO1xuICAgICAgdmFyIGN1ciA9IHN0cmVhbS5jdXJyZW50KCk7XG5cbiAgICAgIGlmIChrZXl3b3Jkcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSByZXR1cm4gXCJrZXl3b3JkXCI7XG4gICAgICBpZiAoYnVpbHRpbi5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSByZXR1cm4gXCJidWlsdGluXCI7XG5cbiAgICAgIGlmICh0aW1lck9wcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSByZXR1cm4gXCJkZWYgdGltZXJPcHNcIjtcbiAgICAgIGlmIChjb25maWdPcHMucHJvcGVydHlJc0VudW1lcmFibGUoY3VyKSkgcmV0dXJuIFwiZGVmIGNvbmZpZ09wc1wiO1xuICAgICAgaWYgKHZlcmRpY3RPcHMucHJvcGVydHlJc0VudW1lcmFibGUoY3VyKSkgcmV0dXJuIFwiZGVmIHZlcmRpY3RPcHNcIjtcbiAgICAgIGlmIChwb3J0T3BzLnByb3BlcnR5SXNFbnVtZXJhYmxlKGN1cikpIHJldHVybiBcImRlZiBwb3J0T3BzXCI7XG4gICAgICBpZiAoc3V0T3BzLnByb3BlcnR5SXNFbnVtZXJhYmxlKGN1cikpIHJldHVybiBcImRlZiBzdXRPcHNcIjtcbiAgICAgIGlmIChmdW5jdGlvbk9wcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSByZXR1cm4gXCJkZWYgZnVuY3Rpb25PcHNcIjtcblxuICAgICAgaWYgKHZlcmRpY3RDb25zdHMucHJvcGVydHlJc0VudW1lcmFibGUoY3VyKSkgcmV0dXJuIFwic3RyaW5nIHZlcmRpY3RDb25zdHNcIjtcbiAgICAgIGlmIChib29sZWFuQ29uc3RzLnByb3BlcnR5SXNFbnVtZXJhYmxlKGN1cikpIHJldHVybiBcInN0cmluZyBib29sZWFuQ29uc3RzXCI7XG4gICAgICBpZiAob3RoZXJDb25zdHMucHJvcGVydHlJc0VudW1lcmFibGUoY3VyKSkgcmV0dXJuIFwic3RyaW5nIG90aGVyQ29uc3RzXCI7XG5cbiAgICAgIGlmICh0eXBlcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSByZXR1cm4gXCJidWlsdGluIHR5cGVzXCI7XG4gICAgICBpZiAodmlzaWJpbGl0eU1vZGlmaWVycy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKVxuICAgICAgICByZXR1cm4gXCJidWlsdGluIHZpc2liaWxpdHlNb2RpZmllcnNcIjtcbiAgICAgIGlmICh0ZW1wbGF0ZU1hdGNoLnByb3BlcnR5SXNFbnVtZXJhYmxlKGN1cikpIHJldHVybiBcImF0b20gdGVtcGxhdGVNYXRjaFwiO1xuXG4gICAgICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRva2VuU3RyaW5nKHF1b3RlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgICB2YXIgZXNjYXBlZCA9IGZhbHNlLCBuZXh0LCBlbmQgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKChuZXh0ID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChuZXh0ID09IHF1b3RlICYmICFlc2NhcGVkKXtcbiAgICAgICAgICAgIHZhciBhZnRlclF1b3RlID0gc3RyZWFtLnBlZWsoKTtcbiAgICAgICAgICAgIC8vbG9vayBpZiB0aGUgY2hhcmFjdGVyIGFmdGVyIHRoZSBxdW90ZSBpcyBsaWtlIHRoZSBCIGluICcxMDEwMDAxMCdCXG4gICAgICAgICAgICBpZiAoYWZ0ZXJRdW90ZSl7XG4gICAgICAgICAgICAgIGFmdGVyUXVvdGUgPSBhZnRlclF1b3RlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgIGlmKGFmdGVyUXVvdGUgPT0gXCJiXCIgfHwgYWZ0ZXJRdW90ZSA9PSBcImhcIiB8fCBhZnRlclF1b3RlID09IFwib1wiKVxuICAgICAgICAgICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbmQgPSB0cnVlOyBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkICYmIG5leHQgPT0gXCJcXFxcXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCB8fCAhKGVzY2FwZWQgfHwgbXVsdGlMaW5lU3RyaW5ncykpXG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSBudWxsO1xuICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9rZW5Db21tZW50KHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBtYXliZUVuZCA9IGZhbHNlLCBjaDtcbiAgICAgIHdoaWxlIChjaCA9IHN0cmVhbS5uZXh0KCkpIHtcbiAgICAgICAgaWYgKGNoID09IFwiL1wiICYmIG1heWJlRW5kKSB7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG1heWJlRW5kID0gKGNoID09IFwiKlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBDb250ZXh0KGluZGVudGVkLCBjb2x1bW4sIHR5cGUsIGFsaWduLCBwcmV2KSB7XG4gICAgICB0aGlzLmluZGVudGVkID0gaW5kZW50ZWQ7XG4gICAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICB0aGlzLmFsaWduID0gYWxpZ247XG4gICAgICB0aGlzLnByZXYgPSBwcmV2O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHB1c2hDb250ZXh0KHN0YXRlLCBjb2wsIHR5cGUpIHtcbiAgICAgIHZhciBpbmRlbnQgPSBzdGF0ZS5pbmRlbnRlZDtcbiAgICAgIGlmIChzdGF0ZS5jb250ZXh0ICYmIHN0YXRlLmNvbnRleHQudHlwZSA9PSBcInN0YXRlbWVudFwiKVxuICAgICAgICBpbmRlbnQgPSBzdGF0ZS5jb250ZXh0LmluZGVudGVkO1xuICAgICAgcmV0dXJuIHN0YXRlLmNvbnRleHQgPSBuZXcgQ29udGV4dChpbmRlbnQsIGNvbCwgdHlwZSwgbnVsbCwgc3RhdGUuY29udGV4dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9wQ29udGV4dChzdGF0ZSkge1xuICAgICAgdmFyIHQgPSBzdGF0ZS5jb250ZXh0LnR5cGU7XG4gICAgICBpZiAodCA9PSBcIilcIiB8fCB0ID09IFwiXVwiIHx8IHQgPT0gXCJ9XCIpXG4gICAgICAgIHN0YXRlLmluZGVudGVkID0gc3RhdGUuY29udGV4dC5pbmRlbnRlZDtcbiAgICAgIHJldHVybiBzdGF0ZS5jb250ZXh0ID0gc3RhdGUuY29udGV4dC5wcmV2O1xuICAgIH1cblxuICAgIC8vSW50ZXJmYWNlXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKGJhc2Vjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0b2tlbml6ZTogbnVsbCxcbiAgICAgICAgICBjb250ZXh0OiBuZXcgQ29udGV4dCgoYmFzZWNvbHVtbiB8fCAwKSAtIGluZGVudFVuaXQsIDAsIFwidG9wXCIsIGZhbHNlKSxcbiAgICAgICAgICBpbmRlbnRlZDogMCxcbiAgICAgICAgICBzdGFydE9mTGluZTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfSxcblxuICAgICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgdmFyIGN0eCA9IHN0YXRlLmNvbnRleHQ7XG4gICAgICAgIGlmIChzdHJlYW0uc29sKCkpIHtcbiAgICAgICAgICBpZiAoY3R4LmFsaWduID09IG51bGwpIGN0eC5hbGlnbiA9IGZhbHNlO1xuICAgICAgICAgIHN0YXRlLmluZGVudGVkID0gc3RyZWFtLmluZGVudGF0aW9uKCk7XG4gICAgICAgICAgc3RhdGUuc3RhcnRPZkxpbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkgcmV0dXJuIG51bGw7XG4gICAgICAgIGN1clB1bmMgPSBudWxsO1xuICAgICAgICB2YXIgc3R5bGUgPSAoc3RhdGUudG9rZW5pemUgfHwgdG9rZW5CYXNlKShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgaWYgKHN0eWxlID09IFwiY29tbWVudFwiKSByZXR1cm4gc3R5bGU7XG4gICAgICAgIGlmIChjdHguYWxpZ24gPT0gbnVsbCkgY3R4LmFsaWduID0gdHJ1ZTtcblxuICAgICAgICBpZiAoKGN1clB1bmMgPT0gXCI7XCIgfHwgY3VyUHVuYyA9PSBcIjpcIiB8fCBjdXJQdW5jID09IFwiLFwiKVxuICAgICAgICAgICAgJiYgY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIil7XG4gICAgICAgICAgcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBcIntcIikgcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbS5jb2x1bW4oKSwgXCJ9XCIpO1xuICAgICAgICBlbHNlIGlmIChjdXJQdW5jID09IFwiW1wiKSBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLmNvbHVtbigpLCBcIl1cIik7XG4gICAgICAgIGVsc2UgaWYgKGN1clB1bmMgPT0gXCIoXCIpIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0uY29sdW1uKCksIFwiKVwiKTtcbiAgICAgICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBcIn1cIikge1xuICAgICAgICAgIHdoaWxlIChjdHgudHlwZSA9PSBcInN0YXRlbWVudFwiKSBjdHggPSBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgICAgICBpZiAoY3R4LnR5cGUgPT0gXCJ9XCIpIGN0eCA9IHBvcENvbnRleHQoc3RhdGUpO1xuICAgICAgICAgIHdoaWxlIChjdHgudHlwZSA9PSBcInN0YXRlbWVudFwiKSBjdHggPSBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJQdW5jID09IGN0eC50eXBlKSBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgICAgZWxzZSBpZiAoaW5kZW50U3RhdGVtZW50cyAmJlxuICAgICAgICAgICAgKCgoY3R4LnR5cGUgPT0gXCJ9XCIgfHwgY3R4LnR5cGUgPT0gXCJ0b3BcIikgJiYgY3VyUHVuYyAhPSAnOycpIHx8XG4gICAgICAgICAgICAoY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIiAmJiBjdXJQdW5jID09IFwibmV3c3RhdGVtZW50XCIpKSlcbiAgICAgICAgICBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLmNvbHVtbigpLCBcInN0YXRlbWVudFwiKTtcblxuICAgICAgICBzdGF0ZS5zdGFydE9mTGluZSA9IGZhbHNlO1xuXG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgIH0sXG5cbiAgICAgIGVsZWN0cmljQ2hhcnM6IFwie31cIixcbiAgICAgIGJsb2NrQ29tbWVudFN0YXJ0OiBcIi8qXCIsXG4gICAgICBibG9ja0NvbW1lbnRFbmQ6IFwiKi9cIixcbiAgICAgIGxpbmVDb21tZW50OiBcIi8vXCIsXG4gICAgICBmb2xkOiBcImJyYWNlXCJcbiAgICB9O1xuICB9KTtcblxuICBmdW5jdGlvbiB3b3JkcyhzdHIpIHtcbiAgICB2YXIgb2JqID0ge30sIHdvcmRzID0gc3RyLnNwbGl0KFwiIFwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgKytpKSBvYmpbd29yZHNbaV1dID0gdHJ1ZTtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVmKG1pbWVzLCBtb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBtaW1lcyA9PSBcInN0cmluZ1wiKSBtaW1lcyA9IFttaW1lc107XG4gICAgdmFyIHdvcmRzID0gW107XG4gICAgZnVuY3Rpb24gYWRkKG9iaikge1xuICAgICAgaWYgKG9iaikgZm9yICh2YXIgcHJvcCBpbiBvYmopIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkpXG4gICAgICAgIHdvcmRzLnB1c2gocHJvcCk7XG4gICAgfVxuXG4gICAgYWRkKG1vZGUua2V5d29yZHMpO1xuICAgIGFkZChtb2RlLmJ1aWx0aW4pO1xuICAgIGFkZChtb2RlLnRpbWVyT3BzKTtcbiAgICBhZGQobW9kZS5wb3J0T3BzKTtcblxuICAgIGlmICh3b3Jkcy5sZW5ndGgpIHtcbiAgICAgIG1vZGUuaGVscGVyVHlwZSA9IG1pbWVzWzBdO1xuICAgICAgQ29kZU1pcnJvci5yZWdpc3RlckhlbHBlcihcImhpbnRXb3Jkc1wiLCBtaW1lc1swXSwgd29yZHMpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWltZXMubGVuZ3RoOyArK2kpXG4gICAgICBDb2RlTWlycm9yLmRlZmluZU1JTUUobWltZXNbaV0sIG1vZGUpO1xuICB9XG5cbiAgZGVmKFtcInRleHQveC10dGNuXCIsIFwidGV4dC94LXR0Y24zXCIsIFwidGV4dC94LXR0Y25wcFwiXSwge1xuICAgIG5hbWU6IFwidHRjblwiLFxuICAgIGtleXdvcmRzOiB3b3JkcyhcImFjdGl2YXRlIGFkZHJlc3MgYWxpdmUgYWxsIGFsdCBhbHRzdGVwIGFuZCBhbmQ0YiBhbnlcIiArXG4gICAgXCIgYnJlYWsgY2FzZSBjb21wb25lbnQgY29uc3QgY29udGludWUgY29udHJvbCBkZWFjdGl2YXRlXCIgK1xuICAgIFwiIGRpc3BsYXkgZG8gZWxzZSBlbmNvZGUgZW51bWVyYXRlZCBleGNlcHQgZXhjZXB0aW9uXCIgK1xuICAgIFwiIGV4ZWN1dGUgZXh0ZW5kcyBleHRlbnNpb24gZXh0ZXJuYWwgZm9yIGZyb20gZnVuY3Rpb25cIiArXG4gICAgXCIgZ290byBncm91cCBpZiBpbXBvcnQgaW4gaW5maW5pdHkgaW5vdXQgaW50ZXJsZWF2ZVwiICtcbiAgICBcIiBsYWJlbCBsYW5ndWFnZSBsZW5ndGggbG9nIG1hdGNoIG1lc3NhZ2UgbWl4ZWQgbW9kXCIgK1xuICAgIFwiIG1vZGlmaWVzIG1vZHVsZSBtb2R1bGVwYXIgbXRjIG5vYmxvY2sgbm90IG5vdDRiIG5vd2FpdFwiICtcbiAgICBcIiBvZiBvbiBvcHRpb25hbCBvciBvcjRiIG91dCBvdmVycmlkZSBwYXJhbSBwYXR0ZXJuIHBvcnRcIiArXG4gICAgXCIgcHJvY2VkdXJlIHJlY29yZCByZWN1cnNpdmUgcmVtIHJlcGVhdCByZXR1cm4gcnVucyBzZWxlY3RcIiArXG4gICAgXCIgc2VsZiBzZW5kZXIgc2V0IHNpZ25hdHVyZSBzeXN0ZW0gdGVtcGxhdGUgdGVzdGNhc2UgdG9cIiArXG4gICAgXCIgdHlwZSB1bmlvbiB2YWx1ZSB2YWx1ZW9mIHZhciB2YXJpYW50IHdoaWxlIHdpdGggeG9yIHhvcjRiXCIpLFxuICAgIGJ1aWx0aW46IHdvcmRzKFwiYml0MmhleCBiaXQyaW50IGJpdDJvY3QgYml0MnN0ciBjaGFyMmludCBjaGFyMm9jdCBlbmN2YWx1ZVwiICtcbiAgICBcIiBkZWNvbXAgZGVjdmFsdWUgZmxvYXQyaW50IGZsb2F0MnN0ciBoZXgyYml0IGhleDJpbnRcIiArXG4gICAgXCIgaGV4Mm9jdCBoZXgyc3RyIGludDJiaXQgaW50MmNoYXIgaW50MmZsb2F0IGludDJoZXhcIiArXG4gICAgXCIgaW50Mm9jdCBpbnQyc3RyIGludDJ1bmljaGFyIGlzYm91bmQgaXNjaG9zZW4gaXNwcmVzZW50XCIgK1xuICAgIFwiIGlzdmFsdWUgbGVuZ3Rob2YgbG9nMnN0ciBvY3QyYml0IG9jdDJjaGFyIG9jdDJoZXggb2N0MmludFwiICtcbiAgICBcIiBvY3Qyc3RyIHJlZ2V4cCByZXBsYWNlIHJuZCBzaXplb2Ygc3RyMmJpdCBzdHIyZmxvYXRcIiArXG4gICAgXCIgc3RyMmhleCBzdHIyaW50IHN0cjJvY3Qgc3Vic3RyIHVuaWNoYXIyaW50IHVuaWNoYXIyY2hhclwiICtcbiAgICBcIiBlbnVtMmludFwiKSxcbiAgICB0eXBlczogd29yZHMoXCJhbnl0eXBlIGJpdHN0cmluZyBib29sZWFuIGNoYXIgY2hhcnN0cmluZyBkZWZhdWx0IGZsb2F0XCIgK1xuICAgIFwiIGhleHN0cmluZyBpbnRlZ2VyIG9iamlkIG9jdGV0c3RyaW5nIHVuaXZlcnNhbCB2ZXJkaWN0dHlwZSB0aW1lclwiKSxcbiAgICB0aW1lck9wczogd29yZHMoXCJyZWFkIHJ1bm5pbmcgc3RhcnQgc3RvcCB0aW1lb3V0XCIpLFxuICAgIHBvcnRPcHM6IHdvcmRzKFwiY2FsbCBjYXRjaCBjaGVjayBjbGVhciBnZXRjYWxsIGdldHJlcGx5IGhhbHQgcmFpc2UgcmVjZWl2ZVwiICtcbiAgICBcIiByZXBseSBzZW5kIHRyaWdnZXJcIiksXG4gICAgY29uZmlnT3BzOiB3b3JkcyhcImNyZWF0ZSBjb25uZWN0IGRpc2Nvbm5lY3QgZG9uZSBraWxsIGtpbGxlZCBtYXAgdW5tYXBcIiksXG4gICAgdmVyZGljdE9wczogd29yZHMoXCJnZXR2ZXJkaWN0IHNldHZlcmRpY3RcIiksXG4gICAgc3V0T3BzOiB3b3JkcyhcImFjdGlvblwiKSxcbiAgICBmdW5jdGlvbk9wczogd29yZHMoXCJhcHBseSBkZXJlZmVycyByZWZlcnNcIiksXG5cbiAgICB2ZXJkaWN0Q29uc3RzOiB3b3JkcyhcImVycm9yIGZhaWwgaW5jb25jIG5vbmUgcGFzc1wiKSxcbiAgICBib29sZWFuQ29uc3RzOiB3b3JkcyhcInRydWUgZmFsc2VcIiksXG4gICAgb3RoZXJDb25zdHM6IHdvcmRzKFwibnVsbCBOVUxMIG9taXRcIiksXG5cbiAgICB2aXNpYmlsaXR5TW9kaWZpZXJzOiB3b3JkcyhcInByaXZhdGUgcHVibGljIGZyaWVuZFwiKSxcbiAgICB0ZW1wbGF0ZU1hdGNoOiB3b3JkcyhcImNvbXBsZW1lbnQgaWZwcmVzZW50IHN1YnNldCBzdXBlcnNldCBwZXJtdXRhdGlvblwiKSxcbiAgICBtdWx0aUxpbmVTdHJpbmdzOiB0cnVlXG4gIH0pO1xufSk7XG4iLCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTW9kZShcInR1cnRsZVwiLCBmdW5jdGlvbihjb25maWcpIHtcbiAgdmFyIGluZGVudFVuaXQgPSBjb25maWcuaW5kZW50VW5pdDtcbiAgdmFyIGN1clB1bmM7XG5cbiAgZnVuY3Rpb24gd29yZFJlZ2V4cCh3b3Jkcykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiXig/OlwiICsgd29yZHMuam9pbihcInxcIikgKyBcIikkXCIsIFwiaVwiKTtcbiAgfVxuICB2YXIgb3BzID0gd29yZFJlZ2V4cChbXSk7XG4gIHZhciBrZXl3b3JkcyA9IHdvcmRSZWdleHAoW1wiQHByZWZpeFwiLCBcIkBiYXNlXCIsIFwiYVwiXSk7XG4gIHZhciBvcGVyYXRvckNoYXJzID0gL1sqK1xcLTw+PSZ8XS87XG5cbiAgZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICAgIGN1clB1bmMgPSBudWxsO1xuICAgIGlmIChjaCA9PSBcIjxcIiAmJiAhc3RyZWFtLm1hdGNoKC9eW1xcc1xcdTAwYTA9XS8sIGZhbHNlKSkge1xuICAgICAgc3RyZWFtLm1hdGNoKC9eW15cXHNcXHUwMGEwPl0qPj8vKTtcbiAgICAgIHJldHVybiBcImF0b21cIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2ggPT0gXCJcXFwiXCIgfHwgY2ggPT0gXCInXCIpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5MaXRlcmFsKGNoKTtcbiAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoL1t7fVxcKFxcKSxcXC47XFxbXFxdXS8udGVzdChjaCkpIHtcbiAgICAgIGN1clB1bmMgPSBjaDtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaCA9PSBcIiNcIikge1xuICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcGVyYXRvckNoYXJzLnRlc3QoY2gpKSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUob3BlcmF0b3JDaGFycyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2ggPT0gXCI6XCIpIHtcbiAgICAgICAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bX1xcd1xcZF0vKTtcbiAgICAgIGlmKHN0cmVhbS5wZWVrKCkgPT0gXCI6XCIpIHtcbiAgICAgICAgcmV0dXJuIFwidmFyaWFibGUtM1wiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICB2YXIgd29yZCA9IHN0cmVhbS5jdXJyZW50KCk7XG5cbiAgICAgICAgICAgICBpZihrZXl3b3Jkcy50ZXN0KHdvcmQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJtZXRhXCI7XG4gICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgaWYoY2ggPj0gXCJBXCIgJiYgY2ggPD0gXCJaXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICAgICAgICAgICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgd29yZCA9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAgICBpZiAob3BzLnRlc3Qod29yZCkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgZWxzZSBpZiAoa2V5d29yZHMudGVzdCh3b3JkKSlcbiAgICAgICAgcmV0dXJuIFwibWV0YVwiO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuTGl0ZXJhbChxdW90ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgZXNjYXBlZCA9IGZhbHNlLCBjaDtcbiAgICAgIHdoaWxlICgoY2ggPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChjaCA9PSBxdW90ZSAmJiAhZXNjYXBlZCkge1xuICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZCAmJiBjaCA9PSBcIlxcXFxcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoQ29udGV4dChzdGF0ZSwgdHlwZSwgY29sKSB7XG4gICAgc3RhdGUuY29udGV4dCA9IHtwcmV2OiBzdGF0ZS5jb250ZXh0LCBpbmRlbnQ6IHN0YXRlLmluZGVudCwgY29sOiBjb2wsIHR5cGU6IHR5cGV9O1xuICB9XG4gIGZ1bmN0aW9uIHBvcENvbnRleHQoc3RhdGUpIHtcbiAgICBzdGF0ZS5pbmRlbnQgPSBzdGF0ZS5jb250ZXh0LmluZGVudDtcbiAgICBzdGF0ZS5jb250ZXh0ID0gc3RhdGUuY29udGV4dC5wcmV2O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7dG9rZW5pemU6IHRva2VuQmFzZSxcbiAgICAgICAgICAgICAgY29udGV4dDogbnVsbCxcbiAgICAgICAgICAgICAgaW5kZW50OiAwLFxuICAgICAgICAgICAgICBjb2w6IDB9O1xuICAgIH0sXG5cbiAgICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKHN0cmVhbS5zb2woKSkge1xuICAgICAgICBpZiAoc3RhdGUuY29udGV4dCAmJiBzdGF0ZS5jb250ZXh0LmFsaWduID09IG51bGwpIHN0YXRlLmNvbnRleHQuYWxpZ24gPSBmYWxzZTtcbiAgICAgICAgc3RhdGUuaW5kZW50ID0gc3RyZWFtLmluZGVudGF0aW9uKCk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xuICAgICAgdmFyIHN0eWxlID0gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG5cbiAgICAgIGlmIChzdHlsZSAhPSBcImNvbW1lbnRcIiAmJiBzdGF0ZS5jb250ZXh0ICYmIHN0YXRlLmNvbnRleHQuYWxpZ24gPT0gbnVsbCAmJiBzdGF0ZS5jb250ZXh0LnR5cGUgIT0gXCJwYXR0ZXJuXCIpIHtcbiAgICAgICAgc3RhdGUuY29udGV4dC5hbGlnbiA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXJQdW5jID09IFwiKFwiKSBwdXNoQ29udGV4dChzdGF0ZSwgXCIpXCIsIHN0cmVhbS5jb2x1bW4oKSk7XG4gICAgICBlbHNlIGlmIChjdXJQdW5jID09IFwiW1wiKSBwdXNoQ29udGV4dChzdGF0ZSwgXCJdXCIsIHN0cmVhbS5jb2x1bW4oKSk7XG4gICAgICBlbHNlIGlmIChjdXJQdW5jID09IFwie1wiKSBwdXNoQ29udGV4dChzdGF0ZSwgXCJ9XCIsIHN0cmVhbS5jb2x1bW4oKSk7XG4gICAgICBlbHNlIGlmICgvW1xcXVxcfVxcKV0vLnRlc3QoY3VyUHVuYykpIHtcbiAgICAgICAgd2hpbGUgKHN0YXRlLmNvbnRleHQgJiYgc3RhdGUuY29udGV4dC50eXBlID09IFwicGF0dGVyblwiKSBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgICAgaWYgKHN0YXRlLmNvbnRleHQgJiYgY3VyUHVuYyA9PSBzdGF0ZS5jb250ZXh0LnR5cGUpIHBvcENvbnRleHQoc3RhdGUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBcIi5cIiAmJiBzdGF0ZS5jb250ZXh0ICYmIHN0YXRlLmNvbnRleHQudHlwZSA9PSBcInBhdHRlcm5cIikgcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICBlbHNlIGlmICgvYXRvbXxzdHJpbmd8dmFyaWFibGUvLnRlc3Qoc3R5bGUpICYmIHN0YXRlLmNvbnRleHQpIHtcbiAgICAgICAgaWYgKC9bXFx9XFxdXS8udGVzdChzdGF0ZS5jb250ZXh0LnR5cGUpKVxuICAgICAgICAgIHB1c2hDb250ZXh0KHN0YXRlLCBcInBhdHRlcm5cIiwgc3RyZWFtLmNvbHVtbigpKTtcbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuY29udGV4dC50eXBlID09IFwicGF0dGVyblwiICYmICFzdGF0ZS5jb250ZXh0LmFsaWduKSB7XG4gICAgICAgICAgc3RhdGUuY29udGV4dC5hbGlnbiA9IHRydWU7XG4gICAgICAgICAgc3RhdGUuY29udGV4dC5jb2wgPSBzdHJlYW0uY29sdW1uKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH0sXG5cbiAgICBpbmRlbnQ6IGZ1bmN0aW9uKHN0YXRlLCB0ZXh0QWZ0ZXIpIHtcbiAgICAgIHZhciBmaXJzdENoYXIgPSB0ZXh0QWZ0ZXIgJiYgdGV4dEFmdGVyLmNoYXJBdCgwKTtcbiAgICAgIHZhciBjb250ZXh0ID0gc3RhdGUuY29udGV4dDtcbiAgICAgIGlmICgvW1xcXVxcfV0vLnRlc3QoZmlyc3RDaGFyKSlcbiAgICAgICAgd2hpbGUgKGNvbnRleHQgJiYgY29udGV4dC50eXBlID09IFwicGF0dGVyblwiKSBjb250ZXh0ID0gY29udGV4dC5wcmV2O1xuXG4gICAgICB2YXIgY2xvc2luZyA9IGNvbnRleHQgJiYgZmlyc3RDaGFyID09IGNvbnRleHQudHlwZTtcbiAgICAgIGlmICghY29udGV4dClcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICBlbHNlIGlmIChjb250ZXh0LnR5cGUgPT0gXCJwYXR0ZXJuXCIpXG4gICAgICAgIHJldHVybiBjb250ZXh0LmNvbDtcbiAgICAgIGVsc2UgaWYgKGNvbnRleHQuYWxpZ24pXG4gICAgICAgIHJldHVybiBjb250ZXh0LmNvbCArIChjbG9zaW5nID8gMCA6IDEpO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gY29udGV4dC5pbmRlbnQgKyAoY2xvc2luZyA/IDAgOiBpbmRlbnRVbml0KTtcbiAgICB9LFxuXG4gICAgbGluZUNvbW1lbnQ6IFwiI1wiXG4gIH07XG59KTtcblxuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC90dXJ0bGVcIiwgXCJ0dXJ0bGVcIik7XG5cbn0pO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSwgIHJlcXVpcmUoXCIuLi8uLi9hZGRvbi9tb2RlL211bHRpcGxleFwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiLCBcIi4uLy4uL2FkZG9uL21vZGUvbXVsdGlwbGV4XCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBDb2RlTWlycm9yLmRlZmluZU1vZGUoXCJ0d2lnOmlubmVyXCIsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBrZXl3b3JkcyA9IFtcImFuZFwiLCBcImFzXCIsIFwiYXV0b2VzY2FwZVwiLCBcImVuZGF1dG9lc2NhcGVcIiwgXCJibG9ja1wiLCBcImRvXCIsIFwiZW5kYmxvY2tcIiwgXCJlbHNlXCIsIFwiZWxzZWlmXCIsIFwiZXh0ZW5kc1wiLCBcImZvclwiLCBcImVuZGZvclwiLCBcImVtYmVkXCIsIFwiZW5kZW1iZWRcIiwgXCJmaWx0ZXJcIiwgXCJlbmRmaWx0ZXJcIiwgXCJmbHVzaFwiLCBcImZyb21cIiwgXCJpZlwiLCBcImVuZGlmXCIsIFwiaW5cIiwgXCJpc1wiLCBcImluY2x1ZGVcIiwgXCJpbXBvcnRcIiwgXCJub3RcIiwgXCJvclwiLCBcInNldFwiLCBcInNwYWNlbGVzc1wiLCBcImVuZHNwYWNlbGVzc1wiLCBcIndpdGhcIiwgXCJlbmR3aXRoXCIsIFwidHJhbnNcIiwgXCJlbmR0cmFuc1wiLCBcImJsb2NrdHJhbnNcIiwgXCJlbmRibG9ja3RyYW5zXCIsIFwibWFjcm9cIiwgXCJlbmRtYWNyb1wiLCBcInVzZVwiLCBcInZlcmJhdGltXCIsIFwiZW5kdmVyYmF0aW1cIl0sXG4gICAgICAgIG9wZXJhdG9yID0gL15bK1xcLSomJT08PiE/fH5eXS8sXG4gICAgICAgIHNpZ24gPSAvXls6XFxbXFwoXFx7XS8sXG4gICAgICAgIGF0b20gPSBbXCJ0cnVlXCIsIFwiZmFsc2VcIiwgXCJudWxsXCIsIFwiZW1wdHlcIiwgXCJkZWZpbmVkXCIsIFwiZGl2aXNpYmxlYnlcIiwgXCJkaXZpc2libGUgYnlcIiwgXCJldmVuXCIsIFwib2RkXCIsIFwiaXRlcmFibGVcIiwgXCJzYW1lYXNcIiwgXCJzYW1lIGFzXCJdLFxuICAgICAgICBudW1iZXIgPSAvXihcXGRbK1xcLVxcKlxcL10pP1xcZCsoXFwuXFxkKyk/LztcblxuICAgIGtleXdvcmRzID0gbmV3IFJlZ0V4cChcIigoXCIgKyBrZXl3b3Jkcy5qb2luKFwiKXwoXCIpICsgXCIpKVxcXFxiXCIpO1xuICAgIGF0b20gPSBuZXcgUmVnRXhwKFwiKChcIiArIGF0b20uam9pbihcIil8KFwiKSArIFwiKSlcXFxcYlwiKTtcblxuICAgIGZ1bmN0aW9uIHRva2VuQmFzZSAoc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIGNoID0gc3RyZWFtLnBlZWsoKTtcblxuICAgICAgLy9Db21tZW50XG4gICAgICBpZiAoc3RhdGUuaW5jb21tZW50KSB7XG4gICAgICAgIGlmICghc3RyZWFtLnNraXBUbyhcIiN9XCIpKSB7XG4gICAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvXFwjfH0vKTtcbiAgICAgICAgICBzdGF0ZS5pbmNvbW1lbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgICAvL1RhZ1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5pbnRhZykge1xuICAgICAgICAvL0FmdGVyIG9wZXJhdG9yXG4gICAgICAgIGlmIChzdGF0ZS5vcGVyYXRvcikge1xuICAgICAgICAgIHN0YXRlLm9wZXJhdG9yID0gZmFsc2U7XG4gICAgICAgICAgaWYgKHN0cmVhbS5tYXRjaChhdG9tKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiYXRvbVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKG51bWJlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvL0FmdGVyIHNpZ25cbiAgICAgICAgaWYgKHN0YXRlLnNpZ24pIHtcbiAgICAgICAgICBzdGF0ZS5zaWduID0gZmFsc2U7XG4gICAgICAgICAgaWYgKHN0cmVhbS5tYXRjaChhdG9tKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiYXRvbVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKG51bWJlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGF0ZS5pbnN0cmluZykge1xuICAgICAgICAgIGlmIChjaCA9PSBzdGF0ZS5pbnN0cmluZykge1xuICAgICAgICAgICAgc3RhdGUuaW5zdHJpbmcgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PSBcIidcIiB8fCBjaCA9PSAnXCInKSB7XG4gICAgICAgICAgc3RhdGUuaW5zdHJpbmcgPSBjaDtcbiAgICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaChzdGF0ZS5pbnRhZyArIFwifVwiKSB8fCBzdHJlYW0uZWF0KFwiLVwiKSAmJiBzdHJlYW0ubWF0Y2goc3RhdGUuaW50YWcgKyBcIn1cIikpIHtcbiAgICAgICAgICBzdGF0ZS5pbnRhZyA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBcInRhZ1wiO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaChvcGVyYXRvcikpIHtcbiAgICAgICAgICBzdGF0ZS5vcGVyYXRvciA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goc2lnbikpIHtcbiAgICAgICAgICBzdGF0ZS5zaWduID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc3RyZWFtLmVhdChcIiBcIikgfHwgc3RyZWFtLnNvbCgpKSB7XG4gICAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKGtleXdvcmRzKSkge1xuICAgICAgICAgICAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKGF0b20pKSB7XG4gICAgICAgICAgICAgIHJldHVybiBcImF0b21cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHJlYW0ubWF0Y2gobnVtYmVyKSkge1xuICAgICAgICAgICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHJlYW0uc29sKCkpIHtcbiAgICAgICAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xuICAgICAgfSBlbHNlIGlmIChzdHJlYW0uZWF0KFwie1wiKSkge1xuICAgICAgICBpZiAoc3RyZWFtLmVhdChcIiNcIikpIHtcbiAgICAgICAgICBzdGF0ZS5pbmNvbW1lbnQgPSB0cnVlO1xuICAgICAgICAgIGlmICghc3RyZWFtLnNraXBUbyhcIiN9XCIpKSB7XG4gICAgICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvXFwjfH0vKTtcbiAgICAgICAgICAgIHN0YXRlLmluY29tbWVudCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgICAgIC8vT3BlbiB0YWdcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9IHN0cmVhbS5lYXQoL1xce3wlLykpIHtcbiAgICAgICAgICAvL0NhY2hlIGNsb3NlIHRhZ1xuICAgICAgICAgIHN0YXRlLmludGFnID0gY2g7XG4gICAgICAgICAgaWYgKGNoID09IFwie1wiKSB7XG4gICAgICAgICAgICBzdGF0ZS5pbnRhZyA9IFwifVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHJlYW0uZWF0KFwiLVwiKTtcbiAgICAgICAgICByZXR1cm4gXCJ0YWdcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfSxcbiAgICAgIHRva2VuOiBmdW5jdGlvbiAoc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgICByZXR1cm4gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lTW9kZShcInR3aWdcIiwgZnVuY3Rpb24oY29uZmlnLCBwYXJzZXJDb25maWcpIHtcbiAgICB2YXIgdHdpZ0lubmVyID0gQ29kZU1pcnJvci5nZXRNb2RlKGNvbmZpZywgXCJ0d2lnOmlubmVyXCIpO1xuICAgIGlmICghcGFyc2VyQ29uZmlnIHx8ICFwYXJzZXJDb25maWcuYmFzZSkgcmV0dXJuIHR3aWdJbm5lcjtcbiAgICByZXR1cm4gQ29kZU1pcnJvci5tdWx0aXBsZXhpbmdNb2RlKFxuICAgICAgQ29kZU1pcnJvci5nZXRNb2RlKGNvbmZpZywgcGFyc2VyQ29uZmlnLmJhc2UpLCB7XG4gICAgICAgIG9wZW46IC9cXHtbeyMlXS8sIGNsb3NlOiAvW30jJV1cXH0vLCBtb2RlOiB0d2lnSW5uZXIsIHBhcnNlRGVsaW1pdGVyczogdHJ1ZVxuICAgICAgfVxuICAgICk7XG4gIH0pO1xuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3gtdHdpZ1wiLCBcInR3aWdcIik7XG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwidmJcIiwgZnVuY3Rpb24oY29uZiwgcGFyc2VyQ29uZikge1xuICAgIHZhciBFUlJPUkNMQVNTID0gJ2Vycm9yJztcblxuICAgIGZ1bmN0aW9uIHdvcmRSZWdleHAod29yZHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoXCJeKChcIiArIHdvcmRzLmpvaW4oXCIpfChcIikgKyBcIikpXFxcXGJcIiwgXCJpXCIpO1xuICAgIH1cblxuICAgIHZhciBzaW5nbGVPcGVyYXRvcnMgPSBuZXcgUmVnRXhwKFwiXltcXFxcK1xcXFwtXFxcXCovJSZcXFxcXFxcXHxcXFxcXn48PiFdXCIpO1xuICAgIHZhciBzaW5nbGVEZWxpbWl0ZXJzID0gbmV3IFJlZ0V4cCgnXltcXFxcKFxcXFwpXFxcXFtcXFxcXVxcXFx7XFxcXH1ALDpgPTtcXFxcLl0nKTtcbiAgICB2YXIgZG91YmxlT3BlcmF0b3JzID0gbmV3IFJlZ0V4cChcIl4oKD09KXwoPD4pfCg8PSl8KD49KXwoPD4pfCg8PCl8KD4+KXwoLy8pfChcXFxcKlxcXFwqKSlcIik7XG4gICAgdmFyIGRvdWJsZURlbGltaXRlcnMgPSBuZXcgUmVnRXhwKFwiXigoXFxcXCs9KXwoXFxcXC09KXwoXFxcXCo9KXwoJT0pfCgvPSl8KCY9KXwoXFxcXHw9KXwoXFxcXF49KSlcIik7XG4gICAgdmFyIHRyaXBsZURlbGltaXRlcnMgPSBuZXcgUmVnRXhwKFwiXigoLy89KXwoPj49KXwoPDw9KXwoXFxcXCpcXFxcKj0pKVwiKTtcbiAgICB2YXIgaWRlbnRpZmllcnMgPSBuZXcgUmVnRXhwKFwiXltfQS1aYS16XVtfQS1aYS16MC05XSpcIik7XG5cbiAgICB2YXIgb3BlbmluZ0tleXdvcmRzID0gWydjbGFzcycsJ21vZHVsZScsICdzdWInLCdlbnVtJywnc2VsZWN0Jywnd2hpbGUnLCdpZicsJ2Z1bmN0aW9uJywgJ2dldCcsJ3NldCcsJ3Byb3BlcnR5JywgJ3RyeScsICdzdHJ1Y3R1cmUnLCAnc3luY2xvY2snLCAndXNpbmcnLCAnd2l0aCddO1xuICAgIHZhciBtaWRkbGVLZXl3b3JkcyA9IFsnZWxzZScsJ2Vsc2VpZicsJ2Nhc2UnLCAnY2F0Y2gnLCAnZmluYWxseSddO1xuICAgIHZhciBlbmRLZXl3b3JkcyA9IFsnbmV4dCcsJ2xvb3AnXTtcblxuICAgIHZhciBvcGVyYXRvcktleXdvcmRzID0gWydhbmQnLCBcImFuZGFsc29cIiwgJ29yJywgJ29yZWxzZScsICd4b3InLCAnaW4nLCAnbm90JywgJ2lzJywgJ2lzbm90JywgJ2xpa2UnXTtcbiAgICB2YXIgd29yZE9wZXJhdG9ycyA9IHdvcmRSZWdleHAob3BlcmF0b3JLZXl3b3Jkcyk7XG5cbiAgICB2YXIgY29tbW9uS2V5d29yZHMgPSBbXCIjY29uc3RcIiwgXCIjZWxzZVwiLCBcIiNlbHNlaWZcIiwgXCIjZW5kXCIsIFwiI2lmXCIsIFwiI3JlZ2lvblwiLCBcImFkZGhhbmRsZXJcIiwgXCJhZGRyZXNzb2ZcIiwgXCJhbGlhc1wiLCBcImFzXCIsIFwiYnlyZWZcIiwgXCJieXZhbFwiLCBcImNib29sXCIsIFwiY2J5dGVcIiwgXCJjY2hhclwiLCBcImNkYXRlXCIsIFwiY2RibFwiLCBcImNkZWNcIiwgXCJjaW50XCIsIFwiY2xuZ1wiLCBcImNvYmpcIiwgXCJjb21wYXJlXCIsIFwiY29uc3RcIiwgXCJjb250aW51ZVwiLCBcImNzYnl0ZVwiLCBcImNzaG9ydFwiLCBcImNzbmdcIiwgXCJjc3RyXCIsIFwiY3VpbnRcIiwgXCJjdWxuZ1wiLCBcImN1c2hvcnRcIiwgXCJkZWNsYXJlXCIsIFwiZGVmYXVsdFwiLCBcImRlbGVnYXRlXCIsIFwiZGltXCIsIFwiZGlyZWN0Y2FzdFwiLCBcImVhY2hcIiwgXCJlcmFzZVwiLCBcImVycm9yXCIsIFwiZXZlbnRcIiwgXCJleGl0XCIsIFwiZXhwbGljaXRcIiwgXCJmYWxzZVwiLCBcImZvclwiLCBcImZyaWVuZFwiLCBcImdldHR5cGVcIiwgXCJnb3RvXCIsIFwiaGFuZGxlc1wiLCBcImltcGxlbWVudHNcIiwgXCJpbXBvcnRzXCIsIFwiaW5mZXJcIiwgXCJpbmhlcml0c1wiLCBcImludGVyZmFjZVwiLCBcImlzZmFsc2VcIiwgXCJpc3RydWVcIiwgXCJsaWJcIiwgXCJtZVwiLCBcIm1vZFwiLCBcIm11c3Rpbmhlcml0XCIsIFwibXVzdG92ZXJyaWRlXCIsIFwibXlcIiwgXCJteWJhc2VcIiwgXCJteWNsYXNzXCIsIFwibmFtZXNwYWNlXCIsIFwibmFycm93aW5nXCIsIFwibmV3XCIsIFwibm90aGluZ1wiLCBcIm5vdGluaGVyaXRhYmxlXCIsIFwibm90b3ZlcnJpZGFibGVcIiwgXCJvZlwiLCBcIm9mZlwiLCBcIm9uXCIsIFwib3BlcmF0b3JcIiwgXCJvcHRpb25cIiwgXCJvcHRpb25hbFwiLCBcIm91dFwiLCBcIm92ZXJsb2Fkc1wiLCBcIm92ZXJyaWRhYmxlXCIsIFwib3ZlcnJpZGVzXCIsIFwicGFyYW1hcnJheVwiLCBcInBhcnRpYWxcIiwgXCJwcml2YXRlXCIsIFwicHJvdGVjdGVkXCIsIFwicHVibGljXCIsIFwicmFpc2VldmVudFwiLCBcInJlYWRvbmx5XCIsIFwicmVkaW1cIiwgXCJyZW1vdmVoYW5kbGVyXCIsIFwicmVzdW1lXCIsIFwicmV0dXJuXCIsIFwic2hhZG93c1wiLCBcInNoYXJlZFwiLCBcInN0YXRpY1wiLCBcInN0ZXBcIiwgXCJzdG9wXCIsIFwic3RyaWN0XCIsIFwidGhlblwiLCBcInRocm93XCIsIFwidG9cIiwgXCJ0cnVlXCIsIFwidHJ5Y2FzdFwiLCBcInR5cGVvZlwiLCBcInVudGlsXCIsIFwidW50aWxcIiwgXCJ3aGVuXCIsIFwid2lkZW5pbmdcIiwgXCJ3aXRoZXZlbnRzXCIsIFwid3JpdGVvbmx5XCJdO1xuXG4gICAgdmFyIGNvbW1vbnR5cGVzID0gWydvYmplY3QnLCAnYm9vbGVhbicsICdjaGFyJywgJ3N0cmluZycsICdieXRlJywgJ3NieXRlJywgJ3Nob3J0JywgJ3VzaG9ydCcsICdpbnQxNicsICd1aW50MTYnLCAnaW50ZWdlcicsICd1aW50ZWdlcicsICdpbnQzMicsICd1aW50MzInLCAnbG9uZycsICd1bG9uZycsICdpbnQ2NCcsICd1aW50NjQnLCAnZGVjaW1hbCcsICdzaW5nbGUnLCAnZG91YmxlJywgJ2Zsb2F0JywgJ2RhdGUnLCAnZGF0ZXRpbWUnLCAnaW50cHRyJywgJ3VpbnRwdHInXTtcblxuICAgIHZhciBrZXl3b3JkcyA9IHdvcmRSZWdleHAoY29tbW9uS2V5d29yZHMpO1xuICAgIHZhciB0eXBlcyA9IHdvcmRSZWdleHAoY29tbW9udHlwZXMpO1xuICAgIHZhciBzdHJpbmdQcmVmaXhlcyA9ICdcIic7XG5cbiAgICB2YXIgb3BlbmluZyA9IHdvcmRSZWdleHAob3BlbmluZ0tleXdvcmRzKTtcbiAgICB2YXIgbWlkZGxlID0gd29yZFJlZ2V4cChtaWRkbGVLZXl3b3Jkcyk7XG4gICAgdmFyIGNsb3NpbmcgPSB3b3JkUmVnZXhwKGVuZEtleXdvcmRzKTtcbiAgICB2YXIgZG91YmxlQ2xvc2luZyA9IHdvcmRSZWdleHAoWydlbmQnXSk7XG4gICAgdmFyIGRvT3BlbmluZyA9IHdvcmRSZWdleHAoWydkbyddKTtcblxuICAgIHZhciBpbmRlbnRJbmZvID0gbnVsbDtcblxuICAgIENvZGVNaXJyb3IucmVnaXN0ZXJIZWxwZXIoXCJoaW50V29yZHNcIiwgXCJ2YlwiLCBvcGVuaW5nS2V5d29yZHMuY29uY2F0KG1pZGRsZUtleXdvcmRzKS5jb25jYXQoZW5kS2V5d29yZHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQob3BlcmF0b3JLZXl3b3JkcykuY29uY2F0KGNvbW1vbktleXdvcmRzKS5jb25jYXQoY29tbW9udHlwZXMpKTtcblxuICAgIGZ1bmN0aW9uIGluZGVudChfc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgc3RhdGUuY3VycmVudEluZGVudCsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZGVudChfc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgc3RhdGUuY3VycmVudEluZGVudC0tO1xuICAgIH1cbiAgICAvLyB0b2tlbml6ZXJzXG4gICAgZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaCA9IHN0cmVhbS5wZWVrKCk7XG5cbiAgICAgICAgLy8gSGFuZGxlIENvbW1lbnRzXG4gICAgICAgIGlmIChjaCA9PT0gXCInXCIpIHtcbiAgICAgICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgICAgIHJldHVybiAnY29tbWVudCc7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIEhhbmRsZSBOdW1iZXIgTGl0ZXJhbHNcbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXigoJkgpfCgmTykpP1swLTlcXC5hLWZdL2ksIGZhbHNlKSkge1xuICAgICAgICAgICAgdmFyIGZsb2F0TGl0ZXJhbCA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gRmxvYXRzXG4gICAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eXFxkKlxcLlxcZCtGPy9pKSkgeyBmbG9hdExpdGVyYWwgPSB0cnVlOyB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdHJlYW0ubWF0Y2goL15cXGQrXFwuXFxkKkY/LykpIHsgZmxvYXRMaXRlcmFsID0gdHJ1ZTsgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RyZWFtLm1hdGNoKC9eXFwuXFxkK0Y/LykpIHsgZmxvYXRMaXRlcmFsID0gdHJ1ZTsgfVxuXG4gICAgICAgICAgICBpZiAoZmxvYXRMaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgLy8gRmxvYXQgbGl0ZXJhbHMgbWF5IGJlIFwiaW1hZ2luYXJ5XCJcbiAgICAgICAgICAgICAgICBzdHJlYW0uZWF0KC9KL2kpO1xuICAgICAgICAgICAgICAgIHJldHVybiAnbnVtYmVyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEludGVnZXJzXG4gICAgICAgICAgICB2YXIgaW50TGl0ZXJhbCA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gSGV4XG4gICAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eJkhbMC05YS1mXSsvaSkpIHsgaW50TGl0ZXJhbCA9IHRydWU7IH1cbiAgICAgICAgICAgIC8vIE9jdGFsXG4gICAgICAgICAgICBlbHNlIGlmIChzdHJlYW0ubWF0Y2goL14mT1swLTddKy9pKSkgeyBpbnRMaXRlcmFsID0gdHJ1ZTsgfVxuICAgICAgICAgICAgLy8gRGVjaW1hbFxuICAgICAgICAgICAgZWxzZSBpZiAoc3RyZWFtLm1hdGNoKC9eWzEtOV1cXGQqRj8vKSkge1xuICAgICAgICAgICAgICAgIC8vIERlY2ltYWwgbGl0ZXJhbHMgbWF5IGJlIFwiaW1hZ2luYXJ5XCJcbiAgICAgICAgICAgICAgICBzdHJlYW0uZWF0KC9KL2kpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gLSBDYW4geW91IGhhdmUgaW1hZ2luYXJ5IGxvbmdzP1xuICAgICAgICAgICAgICAgIGludExpdGVyYWwgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gWmVybyBieSBpdHNlbGYgd2l0aCBubyBvdGhlciBwaWVjZSBvZiBudW1iZXIuXG4gICAgICAgICAgICBlbHNlIGlmIChzdHJlYW0ubWF0Y2goL14wKD8hW1xcZHhdKS9pKSkgeyBpbnRMaXRlcmFsID0gdHJ1ZTsgfVxuICAgICAgICAgICAgaWYgKGludExpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICAvLyBJbnRlZ2VyIGxpdGVyYWxzIG1heSBiZSBcImxvbmdcIlxuICAgICAgICAgICAgICAgIHN0cmVhbS5lYXQoL0wvaSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdudW1iZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIFN0cmluZ3NcbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaChzdHJpbmdQcmVmaXhlcykpIHtcbiAgICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5TdHJpbmdGYWN0b3J5KHN0cmVhbS5jdXJyZW50KCkpO1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIG9wZXJhdG9ycyBhbmQgRGVsaW1pdGVyc1xuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKHRyaXBsZURlbGltaXRlcnMpIHx8IHN0cmVhbS5tYXRjaChkb3VibGVEZWxpbWl0ZXJzKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaChkb3VibGVPcGVyYXRvcnMpXG4gICAgICAgICAgICB8fCBzdHJlYW0ubWF0Y2goc2luZ2xlT3BlcmF0b3JzKVxuICAgICAgICAgICAgfHwgc3RyZWFtLm1hdGNoKHdvcmRPcGVyYXRvcnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ29wZXJhdG9yJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKHNpbmdsZURlbGltaXRlcnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKGRvT3BlbmluZykpIHtcbiAgICAgICAgICAgIGluZGVudChzdHJlYW0sc3RhdGUpO1xuICAgICAgICAgICAgc3RhdGUuZG9JbkN1cnJlbnRMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiAna2V5d29yZCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaChvcGVuaW5nKSkge1xuICAgICAgICAgICAgaWYgKCEgc3RhdGUuZG9JbkN1cnJlbnRMaW5lKVxuICAgICAgICAgICAgICBpbmRlbnQoc3RyZWFtLHN0YXRlKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgc3RhdGUuZG9JbkN1cnJlbnRMaW5lID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gJ2tleXdvcmQnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2gobWlkZGxlKSkge1xuICAgICAgICAgICAgcmV0dXJuICdrZXl3b3JkJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2goZG91YmxlQ2xvc2luZykpIHtcbiAgICAgICAgICAgIGRlZGVudChzdHJlYW0sc3RhdGUpO1xuICAgICAgICAgICAgZGVkZW50KHN0cmVhbSxzdGF0ZSk7XG4gICAgICAgICAgICByZXR1cm4gJ2tleXdvcmQnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2goY2xvc2luZykpIHtcbiAgICAgICAgICAgIGRlZGVudChzdHJlYW0sc3RhdGUpO1xuICAgICAgICAgICAgcmV0dXJuICdrZXl3b3JkJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2godHlwZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2tleXdvcmQnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaChrZXl3b3JkcykpIHtcbiAgICAgICAgICAgIHJldHVybiAna2V5d29yZCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKGlkZW50aWZpZXJzKSkge1xuICAgICAgICAgICAgcmV0dXJuICd2YXJpYWJsZSc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGUgbm9uLWRldGVjdGVkIGl0ZW1zXG4gICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIHJldHVybiBFUlJPUkNMQVNTO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRva2VuU3RyaW5nRmFjdG9yeShkZWxpbWl0ZXIpIHtcbiAgICAgICAgdmFyIHNpbmdsZWxpbmUgPSBkZWxpbWl0ZXIubGVuZ3RoID09IDE7XG4gICAgICAgIHZhciBPVVRDTEFTUyA9ICdzdHJpbmcnO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgICAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuICAgICAgICAgICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW14nXCJdLyk7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmVhbS5tYXRjaChkZWxpbWl0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gT1VUQ0xBU1M7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmVhdCgvWydcIl0vKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2luZ2xlbGluZSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZXJDb25mLnNpbmdsZUxpbmVTdHJpbmdFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEVSUk9SQ0xBU1M7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE9VVENMQVNTO1xuICAgICAgICB9O1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gdG9rZW5MZXhlcihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB2YXIgY3VycmVudCA9IHN0cmVhbS5jdXJyZW50KCk7XG5cbiAgICAgICAgLy8gSGFuZGxlICcuJyBjb25uZWN0ZWQgaWRlbnRpZmllcnNcbiAgICAgICAgaWYgKGN1cnJlbnQgPT09ICcuJykge1xuICAgICAgICAgICAgc3R5bGUgPSBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgICAgIGlmIChzdHlsZSA9PT0gJ3ZhcmlhYmxlJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAndmFyaWFibGUnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRVJST1JDTEFTUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG5cbiAgICAgICAgdmFyIGRlbGltaXRlcl9pbmRleCA9ICdbKHsnLmluZGV4T2YoY3VycmVudCk7XG4gICAgICAgIGlmIChkZWxpbWl0ZXJfaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBpbmRlbnQoc3RyZWFtLCBzdGF0ZSApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRlbnRJbmZvID09PSAnZGVkZW50Jykge1xuICAgICAgICAgICAgaWYgKGRlZGVudChzdHJlYW0sIHN0YXRlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBFUlJPUkNMQVNTO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlbGltaXRlcl9pbmRleCA9ICddKX0nLmluZGV4T2YoY3VycmVudCk7XG4gICAgICAgIGlmIChkZWxpbWl0ZXJfaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBpZiAoZGVkZW50KHN0cmVhbSwgc3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEVSUk9SQ0xBU1M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgfVxuXG4gICAgdmFyIGV4dGVybmFsID0ge1xuICAgICAgICBlbGVjdHJpY0NoYXJzOlwiZERwUHRUZkZlRSBcIixcbiAgICAgICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0b2tlbml6ZTogdG9rZW5CYXNlLFxuICAgICAgICAgICAgICBsYXN0VG9rZW46IG51bGwsXG4gICAgICAgICAgICAgIGN1cnJlbnRJbmRlbnQ6IDAsXG4gICAgICAgICAgICAgIG5leHRMaW5lSW5kZW50OiAwLFxuICAgICAgICAgICAgICBkb0luQ3VycmVudExpbmU6IGZhbHNlXG5cblxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgICAgIGlmIChzdHJlYW0uc29sKCkpIHtcbiAgICAgICAgICAgICAgc3RhdGUuY3VycmVudEluZGVudCArPSBzdGF0ZS5uZXh0TGluZUluZGVudDtcbiAgICAgICAgICAgICAgc3RhdGUubmV4dExpbmVJbmRlbnQgPSAwO1xuICAgICAgICAgICAgICBzdGF0ZS5kb0luQ3VycmVudExpbmUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0eWxlID0gdG9rZW5MZXhlcihzdHJlYW0sIHN0YXRlKTtcblxuICAgICAgICAgICAgc3RhdGUubGFzdFRva2VuID0ge3N0eWxlOnN0eWxlLCBjb250ZW50OiBzdHJlYW0uY3VycmVudCgpfTtcblxuXG5cbiAgICAgICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgICAgfSxcblxuICAgICAgICBpbmRlbnQ6IGZ1bmN0aW9uKHN0YXRlLCB0ZXh0QWZ0ZXIpIHtcbiAgICAgICAgICAgIHZhciB0cnVlVGV4dCA9IHRleHRBZnRlci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJykgO1xuICAgICAgICAgICAgaWYgKHRydWVUZXh0Lm1hdGNoKGNsb3NpbmcpIHx8IHRydWVUZXh0Lm1hdGNoKGRvdWJsZUNsb3NpbmcpIHx8IHRydWVUZXh0Lm1hdGNoKG1pZGRsZSkpIHJldHVybiBjb25mLmluZGVudFVuaXQqKHN0YXRlLmN1cnJlbnRJbmRlbnQtMSk7XG4gICAgICAgICAgICBpZihzdGF0ZS5jdXJyZW50SW5kZW50IDwgMCkgcmV0dXJuIDA7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUuY3VycmVudEluZGVudCAqIGNvbmYuaW5kZW50VW5pdDtcbiAgICAgICAgfSxcblxuICAgICAgICBsaW5lQ29tbWVudDogXCInXCJcbiAgICB9O1xuICAgIHJldHVybiBleHRlcm5hbDtcbn0pO1xuXG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3gtdmJcIiwgXCJ2YlwiKTtcblxufSk7XG4iLCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4vKlxuRm9yIGV4dHJhIEFTUCBjbGFzc2ljIG9iamVjdHMsIGluaXRpYWxpemUgQ29kZU1pcnJvciBpbnN0YW5jZSB3aXRoIHRoaXMgb3B0aW9uOlxuICAgIGlzQVNQOiB0cnVlXG5cbkUuRy46XG4gICAgdmFyIGVkaXRvciA9IENvZGVNaXJyb3IuZnJvbVRleHRBcmVhKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY29kZVwiKSwge1xuICAgICAgICBsaW5lTnVtYmVyczogdHJ1ZSxcbiAgICAgICAgaXNBU1A6IHRydWVcbiAgICAgIH0pO1xuKi9cblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcblwidXNlIHN0cmljdFwiO1xuXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoXCJ2YnNjcmlwdFwiLCBmdW5jdGlvbihjb25mLCBwYXJzZXJDb25mKSB7XG4gICAgdmFyIEVSUk9SQ0xBU1MgPSAnZXJyb3InO1xuXG4gICAgZnVuY3Rpb24gd29yZFJlZ2V4cCh3b3Jkcykge1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChcIl4oKFwiICsgd29yZHMuam9pbihcIil8KFwiKSArIFwiKSlcXFxcYlwiLCBcImlcIik7XG4gICAgfVxuXG4gICAgdmFyIHNpbmdsZU9wZXJhdG9ycyA9IG5ldyBSZWdFeHAoXCJeW1xcXFwrXFxcXC1cXFxcKi8mXFxcXFxcXFxcXFxcXjw+PV1cIik7XG4gICAgdmFyIGRvdWJsZU9wZXJhdG9ycyA9IG5ldyBSZWdFeHAoXCJeKCg8Pil8KDw9KXwoPj0pKVwiKTtcbiAgICB2YXIgc2luZ2xlRGVsaW1pdGVycyA9IG5ldyBSZWdFeHAoJ15bXFxcXC4sXScpO1xuICAgIHZhciBicmFja2V0cyA9IG5ldyBSZWdFeHAoJ15bXFxcXChcXFxcKV0nKTtcbiAgICB2YXIgaWRlbnRpZmllcnMgPSBuZXcgUmVnRXhwKFwiXltBLVphLXpdW19BLVphLXowLTldKlwiKTtcblxuICAgIHZhciBvcGVuaW5nS2V5d29yZHMgPSBbJ2NsYXNzJywnc3ViJywnc2VsZWN0Jywnd2hpbGUnLCdpZicsJ2Z1bmN0aW9uJywgJ3Byb3BlcnR5JywgJ3dpdGgnLCAnZm9yJ107XG4gICAgdmFyIG1pZGRsZUtleXdvcmRzID0gWydlbHNlJywnZWxzZWlmJywnY2FzZSddO1xuICAgIHZhciBlbmRLZXl3b3JkcyA9IFsnbmV4dCcsJ2xvb3AnLCd3ZW5kJ107XG5cbiAgICB2YXIgd29yZE9wZXJhdG9ycyA9IHdvcmRSZWdleHAoWydhbmQnLCAnb3InLCAnbm90JywgJ3hvcicsICdpcycsICdtb2QnLCAnZXF2JywgJ2ltcCddKTtcbiAgICB2YXIgY29tbW9ua2V5d29yZHMgPSBbJ2RpbScsICdyZWRpbScsICd0aGVuJywgICd1bnRpbCcsICdyYW5kb21pemUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAnYnl2YWwnLCdieXJlZicsJ25ldycsJ3Byb3BlcnR5JywgJ2V4aXQnLCAnaW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAnY29uc3QnLCdwcml2YXRlJywgJ3B1YmxpYycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdnZXQnLCdzZXQnLCdsZXQnLCAnc3RvcCcsICdvbiBlcnJvciByZXN1bWUgbmV4dCcsICdvbiBlcnJvciBnb3RvIDAnLCAnb3B0aW9uIGV4cGxpY2l0JywgJ2NhbGwnLCAnbWUnXTtcblxuICAgIC8vVGhpcyBsaXN0IHdhcyBmcm9tOiBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvZjh0YmM3OXgodj12cy44NCkuYXNweFxuICAgIHZhciBhdG9tV29yZHMgPSBbJ3RydWUnLCAnZmFsc2UnLCAnbm90aGluZycsICdlbXB0eScsICdudWxsJ107XG4gICAgLy9UaGlzIGxpc3Qgd2FzIGZyb206IGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS8zY2E4dGZlayh2PXZzLjg0KS5hc3B4XG4gICAgdmFyIGJ1aWx0aW5GdW5jc1dvcmRzID0gWydhYnMnLCAnYXJyYXknLCAnYXNjJywgJ2F0bicsICdjYm9vbCcsICdjYnl0ZScsICdjY3VyJywgJ2NkYXRlJywgJ2NkYmwnLCAnY2hyJywgJ2NpbnQnLCAnY2xuZycsICdjb3MnLCAnY3NuZycsICdjc3RyJywgJ2RhdGUnLCAnZGF0ZWFkZCcsICdkYXRlZGlmZicsICdkYXRlcGFydCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGF0ZXNlcmlhbCcsICdkYXRldmFsdWUnLCAnZGF5JywgJ2VzY2FwZScsICdldmFsJywgJ2V4ZWN1dGUnLCAnZXhwJywgJ2ZpbHRlcicsICdmb3JtYXRjdXJyZW5jeScsICdmb3JtYXRkYXRldGltZScsICdmb3JtYXRudW1iZXInLCAnZm9ybWF0cGVyY2VudCcsICdnZXRsb2NhbGUnLCAnZ2V0b2JqZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRyZWYnLCAnaGV4JywgJ2hvdXInLCAnaW5wdXRib3gnLCAnaW5zdHInLCAnaW5zdHJyZXYnLCAnaW50JywgJ2ZpeCcsICdpc2FycmF5JywgJ2lzZGF0ZScsICdpc2VtcHR5JywgJ2lzbnVsbCcsICdpc251bWVyaWMnLCAnaXNvYmplY3QnLCAnam9pbicsICdsYm91bmQnLCAnbGNhc2UnLCAnbGVmdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGVuJywgJ2xvYWRwaWN0dXJlJywgJ2xvZycsICdsdHJpbScsICdydHJpbScsICd0cmltJywgJ21hdGhzJywgJ21pZCcsICdtaW51dGUnLCAnbW9udGgnLCAnbW9udGhuYW1lJywgJ21zZ2JveCcsICdub3cnLCAnb2N0JywgJ3JlcGxhY2UnLCAncmdiJywgJ3JpZ2h0JywgJ3JuZCcsICdyb3VuZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc2NyaXB0ZW5naW5lJywgJ3NjcmlwdGVuZ2luZWJ1aWxkdmVyc2lvbicsICdzY3JpcHRlbmdpbmVtYWpvcnZlcnNpb24nLCAnc2NyaXB0ZW5naW5lbWlub3J2ZXJzaW9uJywgJ3NlY29uZCcsICdzZXRsb2NhbGUnLCAnc2duJywgJ3NpbicsICdzcGFjZScsICdzcGxpdCcsICdzcXInLCAnc3RyY29tcCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3RyaW5nJywgJ3N0cnJldmVyc2UnLCAndGFuJywgJ3RpbWUnLCAndGltZXInLCAndGltZXNlcmlhbCcsICd0aW1ldmFsdWUnLCAndHlwZW5hbWUnLCAndWJvdW5kJywgJ3VjYXNlJywgJ3VuZXNjYXBlJywgJ3ZhcnR5cGUnLCAnd2Vla2RheScsICd3ZWVrZGF5bmFtZScsICd5ZWFyJ107XG5cbiAgICAvL1RoaXMgbGlzdCB3YXMgZnJvbTogaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L3lkejRjZmszKHY9dnMuODQpLmFzcHhcbiAgICB2YXIgYnVpbHRpbkNvbnN0cyA9IFsndmJCbGFjaycsICd2YlJlZCcsICd2YkdyZWVuJywgJ3ZiWWVsbG93JywgJ3ZiQmx1ZScsICd2Yk1hZ2VudGEnLCAndmJDeWFuJywgJ3ZiV2hpdGUnLCAndmJCaW5hcnlDb21wYXJlJywgJ3ZiVGV4dENvbXBhcmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICd2YlN1bmRheScsICd2Yk1vbmRheScsICd2YlR1ZXNkYXknLCAndmJXZWRuZXNkYXknLCAndmJUaHVyc2RheScsICd2YkZyaWRheScsICd2YlNhdHVyZGF5JywgJ3ZiVXNlU3lzdGVtRGF5T2ZXZWVrJywgJ3ZiRmlyc3RKYW4xJywgJ3ZiRmlyc3RGb3VyRGF5cycsICd2YkZpcnN0RnVsbFdlZWsnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICd2YkdlbmVyYWxEYXRlJywgJ3ZiTG9uZ0RhdGUnLCAndmJTaG9ydERhdGUnLCAndmJMb25nVGltZScsICd2YlNob3J0VGltZScsICd2Yk9iamVjdEVycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAndmJPS09ubHknLCAndmJPS0NhbmNlbCcsICd2YkFib3J0UmV0cnlJZ25vcmUnLCAndmJZZXNOb0NhbmNlbCcsICd2Ylllc05vJywgJ3ZiUmV0cnlDYW5jZWwnLCAndmJDcml0aWNhbCcsICd2YlF1ZXN0aW9uJywgJ3ZiRXhjbGFtYXRpb24nLCAndmJJbmZvcm1hdGlvbicsICd2YkRlZmF1bHRCdXR0b24xJywgJ3ZiRGVmYXVsdEJ1dHRvbjInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICd2YkRlZmF1bHRCdXR0b24zJywgJ3ZiRGVmYXVsdEJ1dHRvbjQnLCAndmJBcHBsaWNhdGlvbk1vZGFsJywgJ3ZiU3lzdGVtTW9kYWwnLCAndmJPSycsICd2YkNhbmNlbCcsICd2YkFib3J0JywgJ3ZiUmV0cnknLCAndmJJZ25vcmUnLCAndmJZZXMnLCAndmJObycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3ZiQ3InLCAnVmJDckxmJywgJ3ZiRm9ybUZlZWQnLCAndmJMZicsICd2Yk5ld0xpbmUnLCAndmJOdWxsQ2hhcicsICd2Yk51bGxTdHJpbmcnLCAndmJUYWInLCAndmJWZXJ0aWNhbFRhYicsICd2YlVzZURlZmF1bHQnLCAndmJUcnVlJywgJ3ZiRmFsc2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICd2YkVtcHR5JywgJ3ZiTnVsbCcsICd2YkludGVnZXInLCAndmJMb25nJywgJ3ZiU2luZ2xlJywgJ3ZiRG91YmxlJywgJ3ZiQ3VycmVuY3knLCAndmJEYXRlJywgJ3ZiU3RyaW5nJywgJ3ZiT2JqZWN0JywgJ3ZiRXJyb3InLCAndmJCb29sZWFuJywgJ3ZiVmFyaWFudCcsICd2YkRhdGFPYmplY3QnLCAndmJEZWNpbWFsJywgJ3ZiQnl0ZScsICd2YkFycmF5J107XG4gICAgLy9UaGlzIGxpc3Qgd2FzIGZyb206IGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9oa2MzNzVlYSh2PXZzLjg0KS5hc3B4XG4gICAgdmFyIGJ1aWx0aW5PYmpzV29yZHMgPSBbJ1dTY3JpcHQnLCAnZXJyJywgJ2RlYnVnJywgJ1JlZ0V4cCddO1xuICAgIHZhciBrbm93blByb3BlcnRpZXMgPSBbJ2Rlc2NyaXB0aW9uJywgJ2ZpcnN0aW5kZXgnLCAnZ2xvYmFsJywgJ2hlbHBjb250ZXh0JywgJ2hlbHBmaWxlJywgJ2lnbm9yZWNhc2UnLCAnbGVuZ3RoJywgJ251bWJlcicsICdwYXR0ZXJuJywgJ3NvdXJjZScsICd2YWx1ZScsICdjb3VudCddO1xuICAgIHZhciBrbm93bk1ldGhvZHMgPSBbJ2NsZWFyJywgJ2V4ZWN1dGUnLCAncmFpc2UnLCAncmVwbGFjZScsICd0ZXN0JywgJ3dyaXRlJywgJ3dyaXRlbGluZScsICdjbG9zZScsICdvcGVuJywgJ3N0YXRlJywgJ2VvZicsICd1cGRhdGUnLCAnYWRkbmV3JywgJ2VuZCcsICdjcmVhdGVvYmplY3QnLCAncXVpdCddO1xuXG4gICAgdmFyIGFzcEJ1aWx0aW5PYmpzV29yZHMgPSBbJ3NlcnZlcicsICdyZXNwb25zZScsICdyZXF1ZXN0JywgJ3Nlc3Npb24nLCAnYXBwbGljYXRpb24nXTtcbiAgICB2YXIgYXNwS25vd25Qcm9wZXJ0aWVzID0gWydidWZmZXInLCAnY2FjaGVjb250cm9sJywgJ2NoYXJzZXQnLCAnY29udGVudHR5cGUnLCAnZXhwaXJlcycsICdleHBpcmVzYWJzb2x1dGUnLCAnaXNjbGllbnRjb25uZWN0ZWQnLCAncGljcycsICdzdGF0dXMnLCAvL3Jlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY2xpZW50Y2VydGlmaWNhdGUnLCAnY29va2llcycsICdmb3JtJywgJ3F1ZXJ5c3RyaW5nJywgJ3NlcnZlcnZhcmlhYmxlcycsICd0b3RhbGJ5dGVzJywgLy9yZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY29udGVudHMnLCAnc3RhdGljb2JqZWN0cycsIC8vYXBwbGljYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjb2RlcGFnZScsICdsY2lkJywgJ3Nlc3Npb25pZCcsICd0aW1lb3V0JywgLy9zZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc2NyaXB0dGltZW91dCddOyAvL3NlcnZlclxuICAgIHZhciBhc3BLbm93bk1ldGhvZHMgPSBbJ2FkZGhlYWRlcicsICdhcHBlbmR0b2xvZycsICdiaW5hcnl3cml0ZScsICdlbmQnLCAnZmx1c2gnLCAncmVkaXJlY3QnLCAvL3Jlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAnYmluYXJ5cmVhZCcsIC8vcmVxdWVzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JlbW92ZScsICdyZW1vdmVhbGwnLCAnbG9jaycsICd1bmxvY2snLCAvL2FwcGxpY2F0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAnYWJhbmRvbicsIC8vc2Vzc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2dldGxhc3RlcnJvcicsICdodG1sZW5jb2RlJywgJ21hcHBhdGgnLCAndHJhbnNmZXInLCAndXJsZW5jb2RlJ107IC8vc2VydmVyXG5cbiAgICB2YXIga25vd25Xb3JkcyA9IGtub3duTWV0aG9kcy5jb25jYXQoa25vd25Qcm9wZXJ0aWVzKTtcblxuICAgIGJ1aWx0aW5PYmpzV29yZHMgPSBidWlsdGluT2Jqc1dvcmRzLmNvbmNhdChidWlsdGluQ29uc3RzKTtcblxuICAgIGlmIChjb25mLmlzQVNQKXtcbiAgICAgICAgYnVpbHRpbk9ianNXb3JkcyA9IGJ1aWx0aW5PYmpzV29yZHMuY29uY2F0KGFzcEJ1aWx0aW5PYmpzV29yZHMpO1xuICAgICAgICBrbm93bldvcmRzID0ga25vd25Xb3Jkcy5jb25jYXQoYXNwS25vd25NZXRob2RzLCBhc3BLbm93blByb3BlcnRpZXMpO1xuICAgIH07XG5cbiAgICB2YXIga2V5d29yZHMgPSB3b3JkUmVnZXhwKGNvbW1vbmtleXdvcmRzKTtcbiAgICB2YXIgYXRvbXMgPSB3b3JkUmVnZXhwKGF0b21Xb3Jkcyk7XG4gICAgdmFyIGJ1aWx0aW5GdW5jcyA9IHdvcmRSZWdleHAoYnVpbHRpbkZ1bmNzV29yZHMpO1xuICAgIHZhciBidWlsdGluT2JqcyA9IHdvcmRSZWdleHAoYnVpbHRpbk9ianNXb3Jkcyk7XG4gICAgdmFyIGtub3duID0gd29yZFJlZ2V4cChrbm93bldvcmRzKTtcbiAgICB2YXIgc3RyaW5nUHJlZml4ZXMgPSAnXCInO1xuXG4gICAgdmFyIG9wZW5pbmcgPSB3b3JkUmVnZXhwKG9wZW5pbmdLZXl3b3Jkcyk7XG4gICAgdmFyIG1pZGRsZSA9IHdvcmRSZWdleHAobWlkZGxlS2V5d29yZHMpO1xuICAgIHZhciBjbG9zaW5nID0gd29yZFJlZ2V4cChlbmRLZXl3b3Jkcyk7XG4gICAgdmFyIGRvdWJsZUNsb3NpbmcgPSB3b3JkUmVnZXhwKFsnZW5kJ10pO1xuICAgIHZhciBkb09wZW5pbmcgPSB3b3JkUmVnZXhwKFsnZG8nXSk7XG4gICAgdmFyIG5vSW5kZW50V29yZHMgPSB3b3JkUmVnZXhwKFsnb24gZXJyb3IgcmVzdW1lIG5leHQnLCAnZXhpdCddKTtcbiAgICB2YXIgY29tbWVudCA9IHdvcmRSZWdleHAoWydyZW0nXSk7XG5cblxuICAgIGZ1bmN0aW9uIGluZGVudChfc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgc3RhdGUuY3VycmVudEluZGVudCsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZGVudChfc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgc3RhdGUuY3VycmVudEluZGVudC0tO1xuICAgIH1cbiAgICAvLyB0b2tlbml6ZXJzXG4gICAgZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3NwYWNlJztcbiAgICAgICAgICAgIC8vcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2ggPSBzdHJlYW0ucGVlaygpO1xuXG4gICAgICAgIC8vIEhhbmRsZSBDb21tZW50c1xuICAgICAgICBpZiAoY2ggPT09IFwiJ1wiKSB7XG4gICAgICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgICAgICByZXR1cm4gJ2NvbW1lbnQnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2goY29tbWVudCkpe1xuICAgICAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICAgICAgcmV0dXJuICdjb21tZW50JztcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gSGFuZGxlIE51bWJlciBMaXRlcmFsc1xuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eKCgmSCl8KCZPKSk/WzAtOVxcLl0vaSwgZmFsc2UpICYmICFzdHJlYW0ubWF0Y2goL14oKCZIKXwoJk8pKT9bMC05XFwuXStbYS16X10vaSwgZmFsc2UpKSB7XG4gICAgICAgICAgICB2YXIgZmxvYXRMaXRlcmFsID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBGbG9hdHNcbiAgICAgICAgICAgIGlmIChzdHJlYW0ubWF0Y2goL15cXGQqXFwuXFxkKy9pKSkgeyBmbG9hdExpdGVyYWwgPSB0cnVlOyB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdHJlYW0ubWF0Y2goL15cXGQrXFwuXFxkKi8pKSB7IGZsb2F0TGl0ZXJhbCA9IHRydWU7IH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0cmVhbS5tYXRjaCgvXlxcLlxcZCsvKSkgeyBmbG9hdExpdGVyYWwgPSB0cnVlOyB9XG5cbiAgICAgICAgICAgIGlmIChmbG9hdExpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICAvLyBGbG9hdCBsaXRlcmFscyBtYXkgYmUgXCJpbWFnaW5hcnlcIlxuICAgICAgICAgICAgICAgIHN0cmVhbS5lYXQoL0ovaSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdudW1iZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW50ZWdlcnNcbiAgICAgICAgICAgIHZhciBpbnRMaXRlcmFsID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBIZXhcbiAgICAgICAgICAgIGlmIChzdHJlYW0ubWF0Y2goL14mSFswLTlhLWZdKy9pKSkgeyBpbnRMaXRlcmFsID0gdHJ1ZTsgfVxuICAgICAgICAgICAgLy8gT2N0YWxcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0cmVhbS5tYXRjaCgvXiZPWzAtN10rL2kpKSB7IGludExpdGVyYWwgPSB0cnVlOyB9XG4gICAgICAgICAgICAvLyBEZWNpbWFsXG4gICAgICAgICAgICBlbHNlIGlmIChzdHJlYW0ubWF0Y2goL15bMS05XVxcZCpGPy8pKSB7XG4gICAgICAgICAgICAgICAgLy8gRGVjaW1hbCBsaXRlcmFscyBtYXkgYmUgXCJpbWFnaW5hcnlcIlxuICAgICAgICAgICAgICAgIHN0cmVhbS5lYXQoL0ovaSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyAtIENhbiB5b3UgaGF2ZSBpbWFnaW5hcnkgbG9uZ3M/XG4gICAgICAgICAgICAgICAgaW50TGl0ZXJhbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBaZXJvIGJ5IGl0c2VsZiB3aXRoIG5vIG90aGVyIHBpZWNlIG9mIG51bWJlci5cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0cmVhbS5tYXRjaCgvXjAoPyFbXFxkeF0pL2kpKSB7IGludExpdGVyYWwgPSB0cnVlOyB9XG4gICAgICAgICAgICBpZiAoaW50TGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgIC8vIEludGVnZXIgbGl0ZXJhbHMgbWF5IGJlIFwibG9uZ1wiXG4gICAgICAgICAgICAgICAgc3RyZWFtLmVhdCgvTC9pKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ251bWJlcic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGUgU3RyaW5nc1xuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKHN0cmluZ1ByZWZpeGVzKSkge1xuICAgICAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlblN0cmluZ0ZhY3Rvcnkoc3RyZWFtLmN1cnJlbnQoKSk7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGUgb3BlcmF0b3JzIGFuZCBEZWxpbWl0ZXJzXG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2goZG91YmxlT3BlcmF0b3JzKVxuICAgICAgICAgICAgfHwgc3RyZWFtLm1hdGNoKHNpbmdsZU9wZXJhdG9ycylcbiAgICAgICAgICAgIHx8IHN0cmVhbS5tYXRjaCh3b3JkT3BlcmF0b3JzKSkge1xuICAgICAgICAgICAgcmV0dXJuICdvcGVyYXRvcic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaChzaW5nbGVEZWxpbWl0ZXJzKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKGJyYWNrZXRzKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiYnJhY2tldFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaChub0luZGVudFdvcmRzKSkge1xuICAgICAgICAgICAgc3RhdGUuZG9JbkN1cnJlbnRMaW5lID0gdHJ1ZTtcblxuICAgICAgICAgICAgcmV0dXJuICdrZXl3b3JkJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2goZG9PcGVuaW5nKSkge1xuICAgICAgICAgICAgaW5kZW50KHN0cmVhbSxzdGF0ZSk7XG4gICAgICAgICAgICBzdGF0ZS5kb0luQ3VycmVudExpbmUgPSB0cnVlO1xuXG4gICAgICAgICAgICByZXR1cm4gJ2tleXdvcmQnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2gob3BlbmluZykpIHtcbiAgICAgICAgICAgIGlmICghIHN0YXRlLmRvSW5DdXJyZW50TGluZSlcbiAgICAgICAgICAgICAgaW5kZW50KHN0cmVhbSxzdGF0ZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHN0YXRlLmRvSW5DdXJyZW50TGluZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4gJ2tleXdvcmQnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2gobWlkZGxlKSkge1xuICAgICAgICAgICAgcmV0dXJuICdrZXl3b3JkJztcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaChkb3VibGVDbG9zaW5nKSkge1xuICAgICAgICAgICAgZGVkZW50KHN0cmVhbSxzdGF0ZSk7XG4gICAgICAgICAgICBkZWRlbnQoc3RyZWFtLHN0YXRlKTtcblxuICAgICAgICAgICAgcmV0dXJuICdrZXl3b3JkJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKGNsb3NpbmcpKSB7XG4gICAgICAgICAgICBpZiAoISBzdGF0ZS5kb0luQ3VycmVudExpbmUpXG4gICAgICAgICAgICAgIGRlZGVudChzdHJlYW0sc3RhdGUpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBzdGF0ZS5kb0luQ3VycmVudExpbmUgPSBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuICdrZXl3b3JkJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2goa2V5d29yZHMpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2tleXdvcmQnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaChhdG9tcykpIHtcbiAgICAgICAgICAgIHJldHVybiAnYXRvbSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKGtub3duKSkge1xuICAgICAgICAgICAgcmV0dXJuICd2YXJpYWJsZS0yJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2goYnVpbHRpbkZ1bmNzKSkge1xuICAgICAgICAgICAgcmV0dXJuICdidWlsdGluJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2goYnVpbHRpbk9ianMpKXtcbiAgICAgICAgICAgIHJldHVybiAndmFyaWFibGUtMic7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKGlkZW50aWZpZXJzKSkge1xuICAgICAgICAgICAgcmV0dXJuICd2YXJpYWJsZSc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGUgbm9uLWRldGVjdGVkIGl0ZW1zXG4gICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIHJldHVybiBFUlJPUkNMQVNTO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRva2VuU3RyaW5nRmFjdG9yeShkZWxpbWl0ZXIpIHtcbiAgICAgICAgdmFyIHNpbmdsZWxpbmUgPSBkZWxpbWl0ZXIubGVuZ3RoID09IDE7XG4gICAgICAgIHZhciBPVVRDTEFTUyA9ICdzdHJpbmcnO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgICAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuICAgICAgICAgICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW14nXCJdLyk7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmVhbS5tYXRjaChkZWxpbWl0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gT1VUQ0xBU1M7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmVhdCgvWydcIl0vKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2luZ2xlbGluZSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZXJDb25mLnNpbmdsZUxpbmVTdHJpbmdFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEVSUk9SQ0xBU1M7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE9VVENMQVNTO1xuICAgICAgICB9O1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gdG9rZW5MZXhlcihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB2YXIgY3VycmVudCA9IHN0cmVhbS5jdXJyZW50KCk7XG5cbiAgICAgICAgLy8gSGFuZGxlICcuJyBjb25uZWN0ZWQgaWRlbnRpZmllcnNcbiAgICAgICAgaWYgKGN1cnJlbnQgPT09ICcuJykge1xuICAgICAgICAgICAgc3R5bGUgPSBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcblxuICAgICAgICAgICAgY3VycmVudCA9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAgICAgICAgICBpZiAoc3R5bGUgJiYgKHN0eWxlLnN1YnN0cigwLCA4KSA9PT0gJ3ZhcmlhYmxlJyB8fCBzdHlsZT09PSdidWlsdGluJyB8fCBzdHlsZT09PSdrZXl3b3JkJykpey8vfHwga25vd25Xb3Jkcy5pbmRleE9mKGN1cnJlbnQuc3Vic3RyaW5nKDEpKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlID09PSAnYnVpbHRpbicgfHwgc3R5bGUgPT09ICdrZXl3b3JkJykgc3R5bGU9J3ZhcmlhYmxlJztcbiAgICAgICAgICAgICAgICBpZiAoa25vd25Xb3Jkcy5pbmRleE9mKGN1cnJlbnQuc3Vic3RyKDEpKSA+IC0xKSBzdHlsZT0ndmFyaWFibGUtMic7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBFUlJPUkNMQVNTO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH1cblxuICAgIHZhciBleHRlcm5hbCA9IHtcbiAgICAgICAgZWxlY3RyaWNDaGFyczpcImREcFB0VGZGZUUgXCIsXG4gICAgICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdG9rZW5pemU6IHRva2VuQmFzZSxcbiAgICAgICAgICAgICAgbGFzdFRva2VuOiBudWxsLFxuICAgICAgICAgICAgICBjdXJyZW50SW5kZW50OiAwLFxuICAgICAgICAgICAgICBuZXh0TGluZUluZGVudDogMCxcbiAgICAgICAgICAgICAgZG9JbkN1cnJlbnRMaW5lOiBmYWxzZSxcbiAgICAgICAgICAgICAgaWdub3JlS2V5d29yZDogZmFsc2VcblxuXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgICAgICAgaWYgKHN0cmVhbS5zb2woKSkge1xuICAgICAgICAgICAgICBzdGF0ZS5jdXJyZW50SW5kZW50ICs9IHN0YXRlLm5leHRMaW5lSW5kZW50O1xuICAgICAgICAgICAgICBzdGF0ZS5uZXh0TGluZUluZGVudCA9IDA7XG4gICAgICAgICAgICAgIHN0YXRlLmRvSW5DdXJyZW50TGluZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0b2tlbkxleGVyKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgICAgICAgICBzdGF0ZS5sYXN0VG9rZW4gPSB7c3R5bGU6c3R5bGUsIGNvbnRlbnQ6IHN0cmVhbS5jdXJyZW50KCl9O1xuXG4gICAgICAgICAgICBpZiAoc3R5bGU9PT0nc3BhY2UnKSBzdHlsZT1udWxsO1xuXG4gICAgICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5kZW50OiBmdW5jdGlvbihzdGF0ZSwgdGV4dEFmdGVyKSB7XG4gICAgICAgICAgICB2YXIgdHJ1ZVRleHQgPSB0ZXh0QWZ0ZXIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpIDtcbiAgICAgICAgICAgIGlmICh0cnVlVGV4dC5tYXRjaChjbG9zaW5nKSB8fCB0cnVlVGV4dC5tYXRjaChkb3VibGVDbG9zaW5nKSB8fCB0cnVlVGV4dC5tYXRjaChtaWRkbGUpKSByZXR1cm4gY29uZi5pbmRlbnRVbml0KihzdGF0ZS5jdXJyZW50SW5kZW50LTEpO1xuICAgICAgICAgICAgaWYoc3RhdGUuY3VycmVudEluZGVudCA8IDApIHJldHVybiAwO1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLmN1cnJlbnRJbmRlbnQgKiBjb25mLmluZGVudFVuaXQ7XG4gICAgICAgIH1cblxuICAgIH07XG4gICAgcmV0dXJuIGV4dGVybmFsO1xufSk7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQvdmJzY3JpcHRcIiwgXCJ2YnNjcmlwdFwiKTtcblxufSk7XG4iLCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTW9kZShcInZlbG9jaXR5XCIsIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIHBhcnNlV29yZHMoc3RyKSB7XG4gICAgICAgIHZhciBvYmogPSB7fSwgd29yZHMgPSBzdHIuc3BsaXQoXCIgXCIpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgKytpKSBvYmpbd29yZHNbaV1dID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICB2YXIga2V5d29yZHMgPSBwYXJzZVdvcmRzKFwiI2VuZCAjZWxzZSAjYnJlYWsgI3N0b3AgI1tbICNdXSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiN7ZW5kfSAje2Vsc2V9ICN7YnJlYWt9ICN7c3RvcH1cIik7XG4gICAgdmFyIGZ1bmN0aW9ucyA9IHBhcnNlV29yZHMoXCIjaWYgI2Vsc2VpZiAjZm9yZWFjaCAjc2V0ICNpbmNsdWRlICNwYXJzZSAjbWFjcm8gI2RlZmluZSAjZXZhbHVhdGUgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiI3tpZn0gI3tlbHNlaWZ9ICN7Zm9yZWFjaH0gI3tzZXR9ICN7aW5jbHVkZX0gI3twYXJzZX0gI3ttYWNyb30gI3tkZWZpbmV9ICN7ZXZhbHVhdGV9XCIpO1xuICAgIHZhciBzcGVjaWFscyA9IHBhcnNlV29yZHMoXCIkZm9yZWFjaC5jb3VudCAkZm9yZWFjaC5oYXNOZXh0ICRmb3JlYWNoLmZpcnN0ICRmb3JlYWNoLmxhc3QgJGZvcmVhY2gudG9wbW9zdCAkZm9yZWFjaC5wYXJlbnQuY291bnQgJGZvcmVhY2gucGFyZW50Lmhhc05leHQgJGZvcmVhY2gucGFyZW50LmZpcnN0ICRmb3JlYWNoLnBhcmVudC5sYXN0ICRmb3JlYWNoLnBhcmVudCAkdmVsb2NpdHlDb3VudCAkIWJvZHlDb250ZW50ICRib2R5Q29udGVudFwiKTtcbiAgICB2YXIgaXNPcGVyYXRvckNoYXIgPSAvWytcXC0qJiU9PD4hPzpcXC98XS87XG5cbiAgICBmdW5jdGlvbiBjaGFpbihzdHJlYW0sIHN0YXRlLCBmKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gZjtcbiAgICAgICAgcmV0dXJuIGYoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIHZhciBiZWZvcmVQYXJhbXMgPSBzdGF0ZS5iZWZvcmVQYXJhbXM7XG4gICAgICAgIHN0YXRlLmJlZm9yZVBhcmFtcyA9IGZhbHNlO1xuICAgICAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAvLyBzdGFydCBvZiB1bnBhcnNlZCBzdHJpbmc/XG4gICAgICAgIGlmICgoY2ggPT0gXCInXCIpICYmICFzdGF0ZS5pblN0cmluZyAmJiBzdGF0ZS5pblBhcmFtcykge1xuICAgICAgICAgICAgc3RhdGUubGFzdFRva2VuV2FzQnVpbHRpbiA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIHRva2VuU3RyaW5nKGNoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RhcnQgb2YgcGFyc2VkIHN0cmluZz9cbiAgICAgICAgZWxzZSBpZiAoKGNoID09ICdcIicpKSB7XG4gICAgICAgICAgICBzdGF0ZS5sYXN0VG9rZW5XYXNCdWlsdGluID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc3RhdGUuaW5TdHJpbmcpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5pblN0cmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhdGUuaW5QYXJhbXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIHRva2VuU3RyaW5nKGNoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaXMgaXQgb25lIG9mIHRoZSBzcGVjaWFsIHNpZ25zIFtde30oKS4sOz8gU2VwYXJhdG9yP1xuICAgICAgICBlbHNlIGlmICgvW1xcW1xcXXt9XFwoXFwpLDtcXC5dLy50ZXN0KGNoKSkge1xuICAgICAgICAgICAgaWYgKGNoID09IFwiKFwiICYmIGJlZm9yZVBhcmFtcylcbiAgICAgICAgICAgICAgICBzdGF0ZS5pblBhcmFtcyA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIGlmIChjaCA9PSBcIilcIikge1xuICAgICAgICAgICAgICAgIHN0YXRlLmluUGFyYW1zID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc3RhdGUubGFzdFRva2VuV2FzQnVpbHRpbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdGFydCBvZiBhIG51bWJlciB2YWx1ZT9cbiAgICAgICAgZWxzZSBpZiAoL1xcZC8udGVzdChjaCkpIHtcbiAgICAgICAgICAgIHN0YXRlLmxhc3RUb2tlbldhc0J1aWx0aW4gPSBmYWxzZTtcbiAgICAgICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcLl0vKTtcbiAgICAgICAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIG11bHRpIGxpbmUgY29tbWVudD9cbiAgICAgICAgZWxzZSBpZiAoY2ggPT0gXCIjXCIgJiYgc3RyZWFtLmVhdChcIipcIikpIHtcbiAgICAgICAgICAgIHN0YXRlLmxhc3RUb2tlbldhc0J1aWx0aW4gPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBjaGFpbihzdHJlYW0sIHN0YXRlLCB0b2tlbkNvbW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHVucGFyc2VkIGNvbnRlbnQ/XG4gICAgICAgIGVsc2UgaWYgKGNoID09IFwiI1wiICYmIHN0cmVhbS5tYXRjaCgvICpcXFsgKlxcWy8pKSB7XG4gICAgICAgICAgICBzdGF0ZS5sYXN0VG9rZW5XYXNCdWlsdGluID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgdG9rZW5VbnBhcnNlZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2luZ2xlIGxpbmUgY29tbWVudD9cbiAgICAgICAgZWxzZSBpZiAoY2ggPT0gXCIjXCIgJiYgc3RyZWFtLmVhdChcIiNcIikpIHtcbiAgICAgICAgICAgIHN0YXRlLmxhc3RUb2tlbldhc0J1aWx0aW4gPSBmYWxzZTtcbiAgICAgICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyB2YXJpYWJsZT9cbiAgICAgICAgZWxzZSBpZiAoY2ggPT0gXCIkXCIpIHtcbiAgICAgICAgICAgIHN0cmVhbS5lYXQoXCIhXCIpO1xuICAgICAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFxkXFwkX1xcLnt9LV0vKTtcbiAgICAgICAgICAgIC8vIGlzIGl0IG9uZSBvZiB0aGUgc3BlY2lhbHM/XG4gICAgICAgICAgICBpZiAoc3BlY2lhbHMgJiYgc3BlY2lhbHMucHJvcGVydHlJc0VudW1lcmFibGUoc3RyZWFtLmN1cnJlbnQoKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5sYXN0VG9rZW5XYXNCdWlsdGluID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5iZWZvcmVQYXJhbXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBcImJ1aWx0aW5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpcyBpdCBhIG9wZXJhdG9yP1xuICAgICAgICBlbHNlIGlmIChpc09wZXJhdG9yQ2hhci50ZXN0KGNoKSkge1xuICAgICAgICAgICAgc3RhdGUubGFzdFRva2VuV2FzQnVpbHRpbiA9IGZhbHNlO1xuICAgICAgICAgICAgc3RyZWFtLmVhdFdoaWxlKGlzT3BlcmF0b3JDaGFyKTtcbiAgICAgICAgICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBnZXQgdGhlIHdob2xlIHdvcmRcbiAgICAgICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcJF97fUBdLyk7XG4gICAgICAgICAgICB2YXIgd29yZCA9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAgICAgICAgICAvLyBpcyBpdCBvbmUgb2YgdGhlIGxpc3RlZCBrZXl3b3Jkcz9cbiAgICAgICAgICAgIGlmIChrZXl3b3JkcyAmJiBrZXl3b3Jkcy5wcm9wZXJ0eUlzRW51bWVyYWJsZSh3b3JkKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gICAgICAgICAgICAvLyBpcyBpdCBvbmUgb2YgdGhlIGxpc3RlZCBmdW5jdGlvbnM/XG4gICAgICAgICAgICBpZiAoZnVuY3Rpb25zICYmIGZ1bmN0aW9ucy5wcm9wZXJ0eUlzRW51bWVyYWJsZSh3b3JkKSB8fFxuICAgICAgICAgICAgICAgICAgICAoc3RyZWFtLmN1cnJlbnQoKS5tYXRjaCgvXiNAP1thLXowLTlfXSsgKiQvaSkgJiYgc3RyZWFtLnBlZWsoKT09XCIoXCIpICYmXG4gICAgICAgICAgICAgICAgICAgICAhKGZ1bmN0aW9ucyAmJiBmdW5jdGlvbnMucHJvcGVydHlJc0VudW1lcmFibGUod29yZC50b0xvd2VyQ2FzZSgpKSkpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5iZWZvcmVQYXJhbXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YXRlLmxhc3RUb2tlbldhc0J1aWx0aW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUuaW5TdHJpbmcpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5sYXN0VG9rZW5XYXNCdWlsdGluID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyZWFtLnBvcyA+IHdvcmQubGVuZ3RoICYmIHN0cmVhbS5zdHJpbmcuY2hhckF0KHN0cmVhbS5wb3Mtd29yZC5sZW5ndGgtMSk9PVwiLlwiICYmIHN0YXRlLmxhc3RUb2tlbldhc0J1aWx0aW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiYnVpbHRpblwiO1xuICAgICAgICAgICAgLy8gZGVmYXVsdDoganVzdCBhIFwid29yZFwiXG4gICAgICAgICAgICBzdGF0ZS5sYXN0VG9rZW5XYXNCdWlsdGluID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRva2VuU3RyaW5nKHF1b3RlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgZXNjYXBlZCA9IGZhbHNlLCBuZXh0LCBlbmQgPSBmYWxzZTtcbiAgICAgICAgICAgIHdoaWxlICgobmV4dCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoKG5leHQgPT0gcXVvdGUpICYmICFlc2NhcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocXVvdGU9PSdcIicgJiYgc3RyZWFtLnBlZWsoKSA9PSAnJCcgJiYgIWVzY2FwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaW5TdHJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkICYmIG5leHQgPT0gXCJcXFxcXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kKSBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRva2VuQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIHZhciBtYXliZUVuZCA9IGZhbHNlLCBjaDtcbiAgICAgICAgd2hpbGUgKGNoID0gc3RyZWFtLm5leHQoKSkge1xuICAgICAgICAgICAgaWYgKGNoID09IFwiI1wiICYmIG1heWJlRW5kKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXliZUVuZCA9IChjaCA9PSBcIipcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRva2VuVW5wYXJzZWQoc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgICB2YXIgbWF5YmVFbmQgPSAwLCBjaDtcbiAgICAgICAgd2hpbGUgKGNoID0gc3RyZWFtLm5leHQoKSkge1xuICAgICAgICAgICAgaWYgKGNoID09IFwiI1wiICYmIG1heWJlRW5kID09IDIpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaCA9PSBcIl1cIilcbiAgICAgICAgICAgICAgICBtYXliZUVuZCsrO1xuICAgICAgICAgICAgZWxzZSBpZiAoY2ggIT0gXCIgXCIpXG4gICAgICAgICAgICAgICAgbWF5YmVFbmQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIm1ldGFcIjtcbiAgICB9XG4gICAgLy8gSW50ZXJmYWNlXG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9rZW5pemU6IHRva2VuQmFzZSxcbiAgICAgICAgICAgICAgICBiZWZvcmVQYXJhbXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGluUGFyYW1zOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpblN0cmluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgbGFzdFRva2VuV2FzQnVpbHRpbjogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGJsb2NrQ29tbWVudFN0YXJ0OiBcIiMqXCIsXG4gICAgICAgIGJsb2NrQ29tbWVudEVuZDogXCIqI1wiLFxuICAgICAgICBsaW5lQ29tbWVudDogXCIjI1wiLFxuICAgICAgICBmb2xkOiBcInZlbG9jaXR5XCJcbiAgICB9O1xufSk7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQvdmVsb2NpdHlcIiwgXCJ2ZWxvY2l0eVwiKTtcblxufSk7XG4iLCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTW9kZShcInZlcmlsb2dcIiwgZnVuY3Rpb24oY29uZmlnLCBwYXJzZXJDb25maWcpIHtcblxuICB2YXIgaW5kZW50VW5pdCA9IGNvbmZpZy5pbmRlbnRVbml0LFxuICAgICAgc3RhdGVtZW50SW5kZW50VW5pdCA9IHBhcnNlckNvbmZpZy5zdGF0ZW1lbnRJbmRlbnRVbml0IHx8IGluZGVudFVuaXQsXG4gICAgICBkb250QWxpZ25DYWxscyA9IHBhcnNlckNvbmZpZy5kb250QWxpZ25DYWxscyxcbiAgICAgIC8vIGNvbXBpbGVyRGlyZWN0aXZlc1VzZVJlZ3VsYXJJbmRlbnRhdGlvbiAtIElmIHNldCwgQ29tcGlsZXIgZGlyZWN0aXZlXG4gICAgICAvLyBpbmRlbnRhdGlvbiBmb2xsb3dzIHRoZSBzYW1lIHJ1bGVzIGFzIGV2ZXJ5dGhpbmcgZWxzZS4gT3RoZXJ3aXNlIGlmXG4gICAgICAvLyBmYWxzZSwgY29tcGlsZXIgZGlyZWN0aXZlcyB3aWxsIHRyYWNrIHRoZWlyIG93biBpbmRlbnRhdGlvbi5cbiAgICAgIC8vIEZvciBleGFtcGxlLCBgaWZkZWYgbmVzdGVkIGluc2lkZSBhbm90aGVyIGBpZm5kZWYgd2lsbCBiZSBpbmRlbnRlZCxcbiAgICAgIC8vIGJ1dCBhIGBpZmRlZiBpbnNpZGUgYSBmdW5jdGlvbiBibG9jayBtYXkgbm90IGJlIGluZGVudGVkLlxuICAgICAgY29tcGlsZXJEaXJlY3RpdmVzVXNlUmVndWxhckluZGVudGF0aW9uID0gcGFyc2VyQ29uZmlnLmNvbXBpbGVyRGlyZWN0aXZlc1VzZVJlZ3VsYXJJbmRlbnRhdGlvbixcbiAgICAgIG5vSW5kZW50S2V5d29yZHMgPSBwYXJzZXJDb25maWcubm9JbmRlbnRLZXl3b3JkcyB8fCBbXSxcbiAgICAgIG11bHRpTGluZVN0cmluZ3MgPSBwYXJzZXJDb25maWcubXVsdGlMaW5lU3RyaW5ncyxcbiAgICAgIGhvb2tzID0gcGFyc2VyQ29uZmlnLmhvb2tzIHx8IHt9O1xuXG4gIGZ1bmN0aW9uIHdvcmRzKHN0cikge1xuICAgIHZhciBvYmogPSB7fSwgd29yZHMgPSBzdHIuc3BsaXQoXCIgXCIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyArK2kpIG9ialt3b3Jkc1tpXV0gPSB0cnVlO1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICAvKipcbiAgICogS2V5d29yZHMgZnJvbSBJRUVFIDE4MDAtMjAxMlxuICAgKi9cbiAgdmFyIGtleXdvcmRzID0gd29yZHMoXG4gICAgXCJhY2NlcHRfb24gYWxpYXMgYWx3YXlzIGFsd2F5c19jb21iIGFsd2F5c19mZiBhbHdheXNfbGF0Y2ggYW5kIGFzc2VydCBhc3NpZ24gYXNzdW1lIGF1dG9tYXRpYyBiZWZvcmUgYmVnaW4gYmluZCBcIiArXG4gICAgXCJiaW5zIGJpbnNvZiBiaXQgYnJlYWsgYnVmIGJ1ZmlmMCBidWZpZjEgYnl0ZSBjYXNlIGNhc2V4IGNhc2V6IGNlbGwgY2hhbmRsZSBjaGVja2VyIGNsYXNzIGNsb2NraW5nIGNtb3MgY29uZmlnIFwiICtcbiAgICBcImNvbnN0IGNvbnN0cmFpbnQgY29udGV4dCBjb250aW51ZSBjb3ZlciBjb3Zlcmdyb3VwIGNvdmVycG9pbnQgY3Jvc3MgZGVhc3NpZ24gZGVmYXVsdCBkZWZwYXJhbSBkZXNpZ24gZGlzYWJsZSBcIiArXG4gICAgXCJkaXN0IGRvIGVkZ2UgZWxzZSBlbmQgZW5kY2FzZSBlbmRjaGVja2VyIGVuZGNsYXNzIGVuZGNsb2NraW5nIGVuZGNvbmZpZyBlbmRmdW5jdGlvbiBlbmRnZW5lcmF0ZSBlbmRncm91cCBcIiArXG4gICAgXCJlbmRpbnRlcmZhY2UgZW5kbW9kdWxlIGVuZHBhY2thZ2UgZW5kcHJpbWl0aXZlIGVuZHByb2dyYW0gZW5kcHJvcGVydHkgZW5kc3BlY2lmeSBlbmRzZXF1ZW5jZSBlbmR0YWJsZSBlbmR0YXNrIFwiICtcbiAgICBcImVudW0gZXZlbnQgZXZlbnR1YWxseSBleHBlY3QgZXhwb3J0IGV4dGVuZHMgZXh0ZXJuIGZpbmFsIGZpcnN0X21hdGNoIGZvciBmb3JjZSBmb3JlYWNoIGZvcmV2ZXIgZm9yayBmb3Jram9pbiBcIiArXG4gICAgXCJmdW5jdGlvbiBnZW5lcmF0ZSBnZW52YXIgZ2xvYmFsIGhpZ2h6MCBoaWdoejEgaWYgaWZmIGlmbm9uZSBpZ25vcmVfYmlucyBpbGxlZ2FsX2JpbnMgaW1wbGVtZW50cyBpbXBsaWVzIGltcG9ydCBcIiArXG4gICAgXCJpbmNkaXIgaW5jbHVkZSBpbml0aWFsIGlub3V0IGlucHV0IGluc2lkZSBpbnN0YW5jZSBpbnQgaW50ZWdlciBpbnRlcmNvbm5lY3QgaW50ZXJmYWNlIGludGVyc2VjdCBqb2luIGpvaW5fYW55IFwiICtcbiAgICBcImpvaW5fbm9uZSBsYXJnZSBsZXQgbGlibGlzdCBsaWJyYXJ5IGxvY2FsIGxvY2FscGFyYW0gbG9naWMgbG9uZ2ludCBtYWNyb21vZHVsZSBtYXRjaGVzIG1lZGl1bSBtb2Rwb3J0IG1vZHVsZSBcIiArXG4gICAgXCJuYW5kIG5lZ2VkZ2UgbmV0dHlwZSBuZXcgbmV4dHRpbWUgbm1vcyBub3Igbm9zaG93Y2FuY2VsbGVkIG5vdCBub3RpZjAgbm90aWYxIG51bGwgb3Igb3V0cHV0IHBhY2thZ2UgcGFja2VkIFwiICtcbiAgICBcInBhcmFtZXRlciBwbW9zIHBvc2VkZ2UgcHJpbWl0aXZlIHByaW9yaXR5IHByb2dyYW0gcHJvcGVydHkgcHJvdGVjdGVkIHB1bGwwIHB1bGwxIHB1bGxkb3duIHB1bGx1cCBcIiArXG4gICAgXCJwdWxzZXN0eWxlX29uZGV0ZWN0IHB1bHNlc3R5bGVfb25ldmVudCBwdXJlIHJhbmQgcmFuZGMgcmFuZGNhc2UgcmFuZHNlcXVlbmNlIHJjbW9zIHJlYWwgcmVhbHRpbWUgcmVmIHJlZyBcIiArXG4gICAgXCJyZWplY3Rfb24gcmVsZWFzZSByZXBlYXQgcmVzdHJpY3QgcmV0dXJuIHJubW9zIHJwbW9zIHJ0cmFuIHJ0cmFuaWYwIHJ0cmFuaWYxIHNfYWx3YXlzIHNfZXZlbnR1YWxseSBzX25leHR0aW1lIFwiICtcbiAgICBcInNfdW50aWwgc191bnRpbF93aXRoIHNjYWxhcmVkIHNlcXVlbmNlIHNob3J0aW50IHNob3J0cmVhbCBzaG93Y2FuY2VsbGVkIHNpZ25lZCBzbWFsbCBzb2Z0IHNvbHZlIHNwZWNpZnkgXCIgK1xuICAgIFwic3BlY3BhcmFtIHN0YXRpYyBzdHJpbmcgc3Ryb25nIHN0cm9uZzAgc3Ryb25nMSBzdHJ1Y3Qgc3VwZXIgc3VwcGx5MCBzdXBwbHkxIHN5bmNfYWNjZXB0X29uIHN5bmNfcmVqZWN0X29uIFwiICtcbiAgICBcInRhYmxlIHRhZ2dlZCB0YXNrIHRoaXMgdGhyb3VnaG91dCB0aW1lIHRpbWVwcmVjaXNpb24gdGltZXVuaXQgdHJhbiB0cmFuaWYwIHRyYW5pZjEgdHJpIHRyaTAgdHJpMSB0cmlhbmQgdHJpb3IgXCIgK1xuICAgIFwidHJpcmVnIHR5cGUgdHlwZWRlZiB1bmlvbiB1bmlxdWUgdW5pcXVlMCB1bnNpZ25lZCB1bnRpbCB1bnRpbF93aXRoIHVudHlwZWQgdXNlIHV3aXJlIHZhciB2ZWN0b3JlZCB2aXJ0dWFsIHZvaWQgXCIgK1xuICAgIFwid2FpdCB3YWl0X29yZGVyIHdhbmQgd2VhayB3ZWFrMCB3ZWFrMSB3aGlsZSB3aWxkY2FyZCB3aXJlIHdpdGggd2l0aGluIHdvciB4bm9yIHhvclwiKTtcblxuICAvKiogT3BlcmF0b3JzIGZyb20gSUVFRSAxODAwLTIwMTJcbiAgICAgdW5hcnlfb3BlcmF0b3IgOjo9XG4gICAgICAgKyB8IC0gfCAhIHwgfiB8ICYgfCB+JiB8IHwgfCB+fCB8IF4gfCB+XiB8IF5+XG4gICAgIGJpbmFyeV9vcGVyYXRvciA6Oj1cbiAgICAgICArIHwgLSB8ICogfCAvIHwgJSB8ID09IHwgIT0gfCA9PT0gfCAhPT0gfCA9PT8gfCAhPT8gfCAmJiB8IHx8IHwgKipcbiAgICAgICB8IDwgfCA8PSB8ID4gfCA+PSB8ICYgfCB8IHwgXiB8IF5+IHwgfl4gfCA+PiB8IDw8IHwgPj4+IHwgPDw8XG4gICAgICAgfCAtPiB8IDwtPlxuICAgICBpbmNfb3JfZGVjX29wZXJhdG9yIDo6PSArKyB8IC0tXG4gICAgIHVuYXJ5X21vZHVsZV9wYXRoX29wZXJhdG9yIDo6PVxuICAgICAgICEgfCB+IHwgJiB8IH4mIHwgfCB8IH58IHwgXiB8IH5eIHwgXn5cbiAgICAgYmluYXJ5X21vZHVsZV9wYXRoX29wZXJhdG9yIDo6PVxuICAgICAgID09IHwgIT0gfCAmJiB8IHx8IHwgJiB8IHwgfCBeIHwgXn4gfCB+XlxuICAqL1xuICB2YXIgaXNPcGVyYXRvckNoYXIgPSAvW1xcK1xcLVxcKlxcLyF+JnxeJT0/Ojw+XS87XG4gIHZhciBpc0JyYWNrZXRDaGFyID0gL1tcXFtcXF17fSgpXS87XG5cbiAgdmFyIHVuc2lnbmVkTnVtYmVyID0gL1xcZFswLTlfXSovO1xuICB2YXIgZGVjaW1hbExpdGVyYWwgPSAvXFxkKlxccyoncz9kXFxzKlxcZFswLTlfXSovaTtcbiAgdmFyIGJpbmFyeUxpdGVyYWwgPSAvXFxkKlxccyoncz9iXFxzKlt4ejAxXVt4ejAxX10qL2k7XG4gIHZhciBvY3RMaXRlcmFsID0gL1xcZCpcXHMqJ3M/b1xccypbeHowLTddW3h6MC03X10qL2k7XG4gIHZhciBoZXhMaXRlcmFsID0gL1xcZCpcXHMqJ3M/aFxccypbMC05YS1meHo/XVswLTlhLWZ4ej9fXSovaTtcbiAgdmFyIHJlYWxMaXRlcmFsID0gLyhcXGRbXFxkX10qKFxcLlxcZFtcXGRfXSopP0UtP1tcXGRfXSspfChcXGRbXFxkX10qXFwuXFxkW1xcZF9dKikvaTtcblxuICB2YXIgY2xvc2luZ0JyYWNrZXRPcldvcmQgPSAvXigoYD9cXHcrKXxbKX1cXF1dKS87XG4gIHZhciBjbG9zaW5nQnJhY2tldCA9IC9bKX1cXF1dLztcbiAgdmFyIGNvbXBpbGVyRGlyZWN0aXZlUmVnZXggICAgICA9IG5ldyBSZWdFeHAoXG4gICAgXCJeKGAoPzppZmRlZnxpZm5kZWZ8ZWxzaWZ8ZWxzZXxlbmRpZnx1bmRlZnx1bmRlZmluZWFsbHxkZWZpbmV8aW5jbHVkZXxiZWdpbl9rZXl3b3Jkc3xjZWxsZGVmaW5lfGRlZmF1bHR8XCIgK1xuICAgIFwibmV0dHlwZXxlbmRfa2V5d29yZHN8ZW5kY2VsbGRlZmluZXxsaW5lfG5vdW5jb25uZWN0ZWRfZHJpdmV8cHJhZ21hfHJlc2V0YWxsfHRpbWVzY2FsZXx1bmNvbm5lY3RlZF9kcml2ZSkpXFxcXGJcIik7XG4gIHZhciBjb21waWxlckRpcmVjdGl2ZUJlZ2luUmVnZXggPSAvXihgKD86aWZkZWZ8aWZuZGVmfGVsc2lmfGVsc2UpKVxcYi87XG4gIHZhciBjb21waWxlckRpcmVjdGl2ZUVuZFJlZ2V4ICAgPSAvXihgKD86ZWxzaWZ8ZWxzZXxlbmRpZikpXFxiLztcblxuICB2YXIgY3VyUHVuYztcbiAgdmFyIGN1cktleXdvcmQ7XG5cbiAgLy8gQmxvY2sgb3BlbmluZ3Mgd2hpY2ggYXJlIGNsb3NlZCBieSBhIG1hdGNoaW5nIGtleXdvcmQgaW4gdGhlIGZvcm0gb2YgKFwiZW5kXCIgKyBrZXl3b3JkKVxuICAvLyBFLmcuIFwidGFza1wiID0+IFwiZW5kdGFza1wiXG4gIHZhciBibG9ja0tleXdvcmRzID0gd29yZHMoXG4gICAgXCJjYXNlIGNoZWNrZXIgY2xhc3MgY2xvY2tpbmcgY29uZmlnIGZ1bmN0aW9uIGdlbmVyYXRlIGludGVyZmFjZSBtb2R1bGUgcGFja2FnZSBcIiArXG4gICAgXCJwcmltaXRpdmUgcHJvZ3JhbSBwcm9wZXJ0eSBzcGVjaWZ5IHNlcXVlbmNlIHRhYmxlIHRhc2tcIlxuICApO1xuXG4gIC8vIE9wZW5pbmcvY2xvc2luZyBwYWlyc1xuICB2YXIgb3BlbkNsb3NlID0ge307XG4gIGZvciAodmFyIGtleXdvcmQgaW4gYmxvY2tLZXl3b3Jkcykge1xuICAgIG9wZW5DbG9zZVtrZXl3b3JkXSA9IFwiZW5kXCIgKyBrZXl3b3JkO1xuICB9XG4gIG9wZW5DbG9zZVtcImJlZ2luXCJdID0gXCJlbmRcIjtcbiAgb3BlbkNsb3NlW1wiY2FzZXhcIl0gPSBcImVuZGNhc2VcIjtcbiAgb3BlbkNsb3NlW1wiY2FzZXpcIl0gPSBcImVuZGNhc2VcIjtcbiAgb3BlbkNsb3NlW1wiZG9cIiAgIF0gPSBcIndoaWxlXCI7XG4gIG9wZW5DbG9zZVtcImZvcmtcIiBdID0gXCJqb2luO2pvaW5fYW55O2pvaW5fbm9uZVwiO1xuICBvcGVuQ2xvc2VbXCJjb3Zlcmdyb3VwXCJdID0gXCJlbmRncm91cFwiO1xuICBvcGVuQ2xvc2VbXCJtYWNyb19iZWdpblwiXSA9IFwibWFjcm9fZW5kXCI7XG5cbiAgZm9yICh2YXIgaSBpbiBub0luZGVudEtleXdvcmRzKSB7XG4gICAgdmFyIGtleXdvcmQgPSBub0luZGVudEtleXdvcmRzW2ldO1xuICAgIGlmIChvcGVuQ2xvc2Vba2V5d29yZF0pIHtcbiAgICAgIG9wZW5DbG9zZVtrZXl3b3JkXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICAvLyBLZXl3b3JkcyB3aGljaCBvcGVuIHN0YXRlbWVudHMgdGhhdCBhcmUgZW5kZWQgd2l0aCBhIHNlbWktY29sb25cbiAgdmFyIHN0YXRlbWVudEtleXdvcmRzID0gd29yZHMoXCJhbHdheXMgYWx3YXlzX2NvbWIgYWx3YXlzX2ZmIGFsd2F5c19sYXRjaCBhc3NlcnQgYXNzaWduIGFzc3VtZSBlbHNlIGV4cG9ydCBmb3IgZm9yZWFjaCBmb3JldmVyIGlmIGltcG9ydCBpbml0aWFsIHJlcGVhdCB3aGlsZSBleHRlcm4gdHlwZWRlZlwiKTtcblxuICBmdW5jdGlvbiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0cmVhbS5wZWVrKCksIHN0eWxlO1xuICAgIGlmIChob29rc1tjaF0gJiYgKHN0eWxlID0gaG9va3NbY2hdKHN0cmVhbSwgc3RhdGUpKSAhPSBmYWxzZSkgcmV0dXJuIHN0eWxlO1xuICAgIGlmIChob29rcy50b2tlbkJhc2UgJiYgKHN0eWxlID0gaG9va3MudG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpKSAhPSBmYWxzZSlcbiAgICAgIHJldHVybiBzdHlsZTtcblxuICAgIGlmICgvWyw7OlxcLl0vLnRlc3QoY2gpKSB7XG4gICAgICBjdXJQdW5jID0gc3RyZWFtLm5leHQoKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoaXNCcmFja2V0Q2hhci50ZXN0KGNoKSkge1xuICAgICAgY3VyUHVuYyA9IHN0cmVhbS5uZXh0KCk7XG4gICAgICByZXR1cm4gXCJicmFja2V0XCI7XG4gICAgfVxuICAgIC8vIE1hY3JvcyAodGljay1kZWZpbmVzKVxuICAgIGlmIChjaCA9PSAnYCcpIHtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICBpZiAoc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwkX10vKSkge1xuICAgICAgICB2YXIgY3VyID0gc3RyZWFtLmN1cnJlbnQoKTtcbiAgICAgICAgY3VyS2V5d29yZCA9IGN1cjtcbiAgICAgICAgLy8gTWFjcm9zIHRoYXQgZW5kIGluIF9iZWdpbiwgYXJlIHN0YXJ0IG9mIGJsb2NrIGFuZCBlbmQgd2l0aCBfZW5kXG4gICAgICAgIGlmIChjdXIuc3RhcnRzV2l0aChcImB1dm1fXCIpICYmIGN1ci5lbmRzV2l0aChcIl9iZWdpblwiKSkge1xuICAgICAgICAgIHZhciBrZXl3b3JkQ2xvc2UgPSBjdXJLZXl3b3JkLnN1YnN0cigwLGN1cktleXdvcmQubGVuZ3RoIC0gNSkgKyBcImVuZFwiO1xuICAgICAgICAgIG9wZW5DbG9zZVtjdXJdID0ga2V5d29yZENsb3NlO1xuICAgICAgICAgIGN1clB1bmMgPSBcIm5ld2Jsb2NrXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyZWFtLmVhdFNwYWNlKCk7XG4gICAgICAgICAgaWYgKHN0cmVhbS5wZWVrKCkgPT0gJygnKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGEgYmxvY2tcbiAgICAgICAgICAgIGN1clB1bmMgPSBcIm5ld21hY3JvXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB3aXRoU3BhY2UgPSBzdHJlYW0uY3VycmVudCgpO1xuICAgICAgICAgIC8vIE1vdmUgdGhlIHN0cmVhbSBiYWNrIGJlZm9yZSB0aGUgc3BhY2VzXG4gICAgICAgICAgc3RyZWFtLmJhY2tVcCh3aXRoU3BhY2UubGVuZ3RoIC0gY3VyLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiZGVmXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gU3lzdGVtIGNhbGxzXG4gICAgaWYgKGNoID09ICckJykge1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIGlmIChzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXCRfXS8pKSB7XG4gICAgICAgIHJldHVybiBcIm1ldGFcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBUaW1lIGxpdGVyYWxzXG4gICAgaWYgKGNoID09ICcjJykge1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcZF8uXS8pO1xuICAgICAgcmV0dXJuIFwiZGVmXCI7XG4gICAgfVxuICAgIC8vIEV2ZW50XG4gICAgaWYgKGNoID09ICdAJykge1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW0BdLyk7XG4gICAgICByZXR1cm4gXCJkZWZcIjtcbiAgICB9XG4gICAgLy8gU3RyaW5nc1xuICAgIGlmIChjaCA9PSAnXCInKSB7XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlblN0cmluZyhjaCk7XG4gICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICAgIC8vIENvbW1lbnRzXG4gICAgaWYgKGNoID09IFwiL1wiKSB7XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgaWYgKHN0cmVhbS5lYXQoXCIqXCIpKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5Db21tZW50O1xuICAgICAgICByZXR1cm4gdG9rZW5Db21tZW50KHN0cmVhbSwgc3RhdGUpO1xuICAgICAgfVxuICAgICAgaWYgKHN0cmVhbS5lYXQoXCIvXCIpKSB7XG4gICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgICAgfVxuICAgICAgc3RyZWFtLmJhY2tVcCgxKTtcbiAgICB9XG5cbiAgICAvLyBOdW1lcmljIGxpdGVyYWxzXG4gICAgaWYgKHN0cmVhbS5tYXRjaChyZWFsTGl0ZXJhbCkgfHxcbiAgICAgICAgc3RyZWFtLm1hdGNoKGRlY2ltYWxMaXRlcmFsKSB8fFxuICAgICAgICBzdHJlYW0ubWF0Y2goYmluYXJ5TGl0ZXJhbCkgfHxcbiAgICAgICAgc3RyZWFtLm1hdGNoKG9jdExpdGVyYWwpIHx8XG4gICAgICAgIHN0cmVhbS5tYXRjaChoZXhMaXRlcmFsKSB8fFxuICAgICAgICBzdHJlYW0ubWF0Y2godW5zaWduZWROdW1iZXIpIHx8XG4gICAgICAgIHN0cmVhbS5tYXRjaChyZWFsTGl0ZXJhbCkpIHtcbiAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgIH1cblxuICAgIC8vIE9wZXJhdG9yc1xuICAgIGlmIChzdHJlYW0uZWF0V2hpbGUoaXNPcGVyYXRvckNoYXIpKSB7XG4gICAgICBjdXJQdW5jID0gc3RyZWFtLmN1cnJlbnQoKTtcbiAgICAgIHJldHVybiBcIm1ldGFcIjtcbiAgICB9XG5cbiAgICAvLyBLZXl3b3JkcyAvIHBsYWluIHZhcmlhYmxlc1xuICAgIGlmIChzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXCRfXS8pKSB7XG4gICAgICB2YXIgY3VyID0gc3RyZWFtLmN1cnJlbnQoKTtcbiAgICAgIGlmIChrZXl3b3Jkc1tjdXJdKSB7XG4gICAgICAgIGlmIChvcGVuQ2xvc2VbY3VyXSkge1xuICAgICAgICAgIGN1clB1bmMgPSBcIm5ld2Jsb2NrXCI7XG4gICAgICAgICAgaWYgKGN1ciA9PT0gXCJmb3JrXCIpIHtcbiAgICAgICAgICAgIC8vIEZvcmsgY2FuIGJlIGEgc3RhdGVtZW50IGluc3RlYWQgb2YgYmxvY2sgaW4gY2FzZXMgb2Y6XG4gICAgICAgICAgICAvLyBcImRpc2FibGUgZm9yaztcIiBhbmQgXCJ3YWl0IGZvcms7XCIgKHRyYWlsaW5nIHNlbWljb2xvbilcbiAgICAgICAgICAgIHN0cmVhbS5lYXRTcGFjZSgpXG4gICAgICAgICAgICBpZiAoc3RyZWFtLnBlZWsoKSA9PSAnOycpIHtcbiAgICAgICAgICAgICAgY3VyUHVuYyA9IFwibmV3c3RhdGVtZW50XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJlYW0uYmFja1VwKHN0cmVhbS5jdXJyZW50KCkubGVuZ3RoIC0gY3VyLmxlbmd0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZW1lbnRLZXl3b3Jkc1tjdXJdKSB7XG4gICAgICAgICAgY3VyUHVuYyA9IFwibmV3c3RhdGVtZW50XCI7XG4gICAgICAgIH1cbiAgICAgICAgY3VyS2V5d29yZCA9IGN1cjtcbiAgICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwidmFyaWFibGVcIjtcbiAgICB9XG5cbiAgICBzdHJlYW0ubmV4dCgpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5TdHJpbmcocXVvdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIGVzY2FwZWQgPSBmYWxzZSwgbmV4dCwgZW5kID0gZmFsc2U7XG4gICAgICB3aGlsZSAoKG5leHQgPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChuZXh0ID09IHF1b3RlICYmICFlc2NhcGVkKSB7ZW5kID0gdHJ1ZTsgYnJlYWs7fVxuICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQgJiYgbmV4dCA9PSBcIlxcXFxcIjtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQgfHwgIShlc2NhcGVkIHx8IG11bHRpTGluZVN0cmluZ3MpKVxuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBtYXliZUVuZCA9IGZhbHNlLCBjaDtcbiAgICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgICBpZiAoY2ggPT0gXCIvXCIgJiYgbWF5YmVFbmQpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbWF5YmVFbmQgPSAoY2ggPT0gXCIqXCIpO1xuICAgIH1cbiAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KGluZGVudGVkLCBjb2x1bW4sIHR5cGUsIHNjb3Bla2luZCwgYWxpZ24sIHByZXYpIHtcbiAgICB0aGlzLmluZGVudGVkID0gaW5kZW50ZWQ7XG4gICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnNjb3Bla2luZCA9IHNjb3Bla2luZDtcbiAgICB0aGlzLmFsaWduID0gYWxpZ247XG4gICAgdGhpcy5wcmV2ID0gcHJldjtcbiAgfVxuICBmdW5jdGlvbiBwdXNoQ29udGV4dChzdGF0ZSwgY29sLCB0eXBlLCBzY29wZWtpbmQpIHtcbiAgICB2YXIgaW5kZW50ID0gc3RhdGUuaW5kZW50ZWQ7XG4gICAgdmFyIGMgPSBuZXcgQ29udGV4dChpbmRlbnQsIGNvbCwgdHlwZSwgc2NvcGVraW5kID8gc2NvcGVraW5kIDogXCJcIiwgbnVsbCwgc3RhdGUuY29udGV4dCk7XG4gICAgcmV0dXJuIHN0YXRlLmNvbnRleHQgPSBjO1xuICB9XG4gIGZ1bmN0aW9uIHBvcENvbnRleHQoc3RhdGUpIHtcbiAgICB2YXIgdCA9IHN0YXRlLmNvbnRleHQudHlwZTtcbiAgICBpZiAodCA9PSBcIilcIiB8fCB0ID09IFwiXVwiIHx8IHQgPT0gXCJ9XCIpIHtcbiAgICAgIHN0YXRlLmluZGVudGVkID0gc3RhdGUuY29udGV4dC5pbmRlbnRlZDtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLmNvbnRleHQgPSBzdGF0ZS5jb250ZXh0LnByZXY7XG4gIH1cblxuICBmdW5jdGlvbiBpc0Nsb3NpbmcodGV4dCwgY29udGV4dENsb3NpbmcpIHtcbiAgICBpZiAodGV4dCA9PSBjb250ZXh0Q2xvc2luZykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbnRleHRDbG9zaW5nIG1heSBiZSBtdWx0aXBsZSBrZXl3b3JkcyBzZXBhcmF0ZWQgYnkgO1xuICAgICAgdmFyIGNsb3NpbmdLZXl3b3JkcyA9IGNvbnRleHRDbG9zaW5nLnNwbGl0KFwiO1wiKTtcbiAgICAgIGZvciAodmFyIGkgaW4gY2xvc2luZ0tleXdvcmRzKSB7XG4gICAgICAgIGlmICh0ZXh0ID09IGNsb3NpbmdLZXl3b3Jkc1tpXSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNJbnNpZGVTY29wZUtpbmQoY3R4LCBzY29wZWtpbmQpIHtcbiAgICBpZiAoY3R4ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGN0eC5zY29wZWtpbmQgPT09IHNjb3Bla2luZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBpc0luc2lkZVNjb3BlS2luZChjdHgucHJldiwgc2NvcGVraW5kKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkRWxlY3RyaWNJbnB1dFJlZ0V4KCkge1xuICAgIC8vIFJlaW5kZW50YXRpb24gc2hvdWxkIG9jY3VyIG9uIGFueSBicmFja2V0IGNoYXI6IHt9KClbXVxuICAgIC8vIG9yIG9uIGEgbWF0Y2ggb2YgYW55IG9mIHRoZSBibG9jayBjbG9zaW5nIGtleXdvcmRzLCBhdFxuICAgIC8vIHRoZSBlbmQgb2YgYSBsaW5lXG4gICAgdmFyIGFsbENsb3NpbmdzID0gW107XG4gICAgZm9yICh2YXIgaSBpbiBvcGVuQ2xvc2UpIHtcbiAgICAgIGlmIChvcGVuQ2xvc2VbaV0pIHtcbiAgICAgICAgdmFyIGNsb3NpbmdzID0gb3BlbkNsb3NlW2ldLnNwbGl0KFwiO1wiKTtcbiAgICAgICAgZm9yICh2YXIgaiBpbiBjbG9zaW5ncykge1xuICAgICAgICAgIGFsbENsb3NpbmdzLnB1c2goY2xvc2luZ3Nbal0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciByZSA9IG5ldyBSZWdFeHAoXCJbe30oKVxcXFxbXFxcXF1dfChcIiArIGFsbENsb3NpbmdzLmpvaW4oXCJ8XCIpICsgXCIpJFwiKTtcbiAgICByZXR1cm4gcmU7XG4gIH1cblxuICAvLyBJbnRlcmZhY2VcbiAgcmV0dXJuIHtcblxuICAgIC8vIFJlZ2V4IHRvIGZvcmNlIGN1cnJlbnQgbGluZSB0byByZWluZGVudFxuICAgIGVsZWN0cmljSW5wdXQ6IGJ1aWxkRWxlY3RyaWNJbnB1dFJlZ0V4KCksXG5cbiAgICBzdGFydFN0YXRlOiBmdW5jdGlvbihiYXNlY29sdW1uKSB7XG4gICAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgIHRva2VuaXplOiBudWxsLFxuICAgICAgICBjb250ZXh0OiBuZXcgQ29udGV4dCgoYmFzZWNvbHVtbiB8fCAwKSAtIGluZGVudFVuaXQsIDAsIFwidG9wXCIsIFwidG9wXCIsIGZhbHNlKSxcbiAgICAgICAgaW5kZW50ZWQ6IDAsXG4gICAgICAgIGNvbXBpbGVyRGlyZWN0aXZlSW5kZW50ZWQ6IDAsXG4gICAgICAgIHN0YXJ0T2ZMaW5lOiB0cnVlXG4gICAgICB9O1xuICAgICAgaWYgKGhvb2tzLnN0YXJ0U3RhdGUpIGhvb2tzLnN0YXJ0U3RhdGUoc3RhdGUpO1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG5cbiAgICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIGN0eCA9IHN0YXRlLmNvbnRleHQ7XG4gICAgICBpZiAoc3RyZWFtLnNvbCgpKSB7XG4gICAgICAgIGlmIChjdHguYWxpZ24gPT0gbnVsbCkgY3R4LmFsaWduID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmluZGVudGVkID0gc3RyZWFtLmluZGVudGF0aW9uKCk7XG4gICAgICAgIHN0YXRlLnN0YXJ0T2ZMaW5lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChob29rcy50b2tlbikge1xuICAgICAgICAvLyBDYWxsIGhvb2ssIHdpdGggYW4gb3B0aW9uYWwgcmV0dXJuIHZhbHVlIG9mIGEgc3R5bGUgdG8gb3ZlcnJpZGUgdmVyaWxvZyBzdHlsaW5nLlxuICAgICAgICB2YXIgc3R5bGUgPSBob29rcy50b2tlbihzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgaWYgKHN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkgcmV0dXJuIG51bGw7XG4gICAgICBjdXJQdW5jID0gbnVsbDtcbiAgICAgIGN1cktleXdvcmQgPSBudWxsO1xuICAgICAgdmFyIHN0eWxlID0gKHN0YXRlLnRva2VuaXplIHx8IHRva2VuQmFzZSkoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBpZiAoc3R5bGUgPT0gXCJjb21tZW50XCIgfHwgc3R5bGUgPT0gXCJtZXRhXCIgfHwgc3R5bGUgPT0gXCJ2YXJpYWJsZVwiKSB7XG4gICAgICAgIGlmICgoKGN1clB1bmMgPT09IFwiPVwiKSB8fCAoY3VyUHVuYyA9PT0gXCI8PVwiKSkgJiYgIWlzSW5zaWRlU2NvcGVLaW5kKGN0eCwgXCJhc3NpZ25tZW50XCIpKSB7XG4gICAgICAgICAgLy8gJzw9JyBjb3VsZCBiZSBub25ibG9ja2luZyBhc3NpZ25tZW50IG9yIGxlc3N0aGFuLWVxdWFscyAod2hpY2ggc2hvdWxkbid0IGNhdXNlIGluZGVudClcbiAgICAgICAgICAvLyAgICAgIFNlYXJjaCB0aHJvdWdoIHRoZSBjb250ZXh0IHRvIHNlZSBpZiB3ZSBhcmUgYWxyZWFkeSBpbiBhbiBhc3NpZ25tZW50LlxuICAgICAgICAgIC8vICc9JyBjb3VsZCBiZSBpbnNpZGUgcG9ydCBkZWNsYXJhdGlvbiB3aXRoIGNvbW1hIG9yICcpJyBhZnRlcndhcmQsIG9yIGluc2lkZSBmb3IoOzspIGJsb2NrLlxuICAgICAgICAgIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0uY29sdW1uKCkgKyBjdXJQdW5jLmxlbmd0aCwgXCJhc3NpZ25tZW50XCIsIFwiYXNzaWdubWVudFwiKTtcbiAgICAgICAgICBpZiAoY3R4LmFsaWduID09IG51bGwpIGN0eC5hbGlnbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgfVxuICAgICAgaWYgKGN0eC5hbGlnbiA9PSBudWxsKSBjdHguYWxpZ24gPSB0cnVlO1xuXG4gICAgICB2YXIgaXNDbG9zaW5nQXNzaWdubWVudCA9IGN0eC50eXBlID09IFwiYXNzaWdubWVudFwiICYmXG4gICAgICAgIGNsb3NpbmdCcmFja2V0LnRlc3QoY3VyUHVuYykgJiYgY3R4LnByZXYgJiYgY3R4LnByZXYudHlwZSA9PT0gY3VyUHVuYztcbiAgICAgIGlmIChjdXJQdW5jID09IGN0eC50eXBlIHx8IGlzQ2xvc2luZ0Fzc2lnbm1lbnQpIHtcbiAgICAgICAgaWYgKGlzQ2xvc2luZ0Fzc2lnbm1lbnQpIHtcbiAgICAgICAgICBjdHggPSBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBjdHggPSBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgICAgaWYgKGN1clB1bmMgPT0gXCIpXCIpIHtcbiAgICAgICAgICAvLyBIYW5kbGUgY2xvc2luZyBtYWNyb3MsIGFzc3VtaW5nIHRoZXkgY291bGQgaGF2ZSBhIHNlbWljb2xvbiBvciBiZWdpbi9lbmQgYmxvY2sgaW5zaWRlLlxuICAgICAgICAgIGlmIChjdHggJiYgKGN0eC50eXBlID09PSBcIm1hY3JvXCIpKSB7XG4gICAgICAgICAgICBjdHggPSBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgICAgICAgIHdoaWxlIChjdHggJiYgKGN0eC50eXBlID09IFwic3RhdGVtZW50XCIgfHwgY3R4LnR5cGUgPT0gXCJhc3NpZ25tZW50XCIpKSBjdHggPSBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY3VyUHVuYyA9PSBcIn1cIikge1xuICAgICAgICAgIC8vIEhhbmRsZSBjbG9zaW5nIHN0YXRlbWVudHMgbGlrZSBjb25zdHJhaW50IGJsb2NrOiBcImZvcmVhY2ggKCkge31cIiB3aGljaFxuICAgICAgICAgIC8vIGRvIG5vdCBoYXZlIHNlbWljb2xvbiBhdCBlbmQuXG4gICAgICAgICAgaWYgKGN0eCAmJiAoY3R4LnR5cGUgPT09IFwic3RhdGVtZW50XCIpKSB7XG4gICAgICAgICAgICB3aGlsZSAoY3R4ICYmIChjdHgudHlwZSA9PSBcInN0YXRlbWVudFwiKSkgY3R4ID0gcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCgoY3VyUHVuYyA9PSBcIjtcIiB8fCBjdXJQdW5jID09IFwiLFwiKSAmJiAoY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIiB8fCBjdHgudHlwZSA9PSBcImFzc2lnbm1lbnRcIikpIHx8XG4gICAgICAgICAgICAgICAoY3R4LnR5cGUgJiYgaXNDbG9zaW5nKGN1cktleXdvcmQsIGN0eC50eXBlKSkpIHtcbiAgICAgICAgY3R4ID0gcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICAgIHdoaWxlIChjdHggJiYgKGN0eC50eXBlID09IFwic3RhdGVtZW50XCIgfHwgY3R4LnR5cGUgPT0gXCJhc3NpZ25tZW50XCIpKSBjdHggPSBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgIH0gZWxzZSBpZiAoY3VyUHVuYyA9PSBcIntcIikge1xuICAgICAgICBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLmNvbHVtbigpLCBcIn1cIik7XG4gICAgICB9IGVsc2UgaWYgKGN1clB1bmMgPT0gXCJbXCIpIHtcbiAgICAgICAgcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbS5jb2x1bW4oKSwgXCJdXCIpO1xuICAgICAgfSBlbHNlIGlmIChjdXJQdW5jID09IFwiKFwiKSB7XG4gICAgICAgIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0uY29sdW1uKCksIFwiKVwiKTtcbiAgICAgIH0gZWxzZSBpZiAoY3R4ICYmIGN0eC50eXBlID09IFwiZW5kY2FzZVwiICYmIGN1clB1bmMgPT0gXCI6XCIpIHtcbiAgICAgICAgcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbS5jb2x1bW4oKSwgXCJzdGF0ZW1lbnRcIiwgXCJjYXNlXCIpO1xuICAgICAgfSBlbHNlIGlmIChjdXJQdW5jID09IFwibmV3c3RhdGVtZW50XCIpIHtcbiAgICAgICAgcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbS5jb2x1bW4oKSwgXCJzdGF0ZW1lbnRcIiwgY3VyS2V5d29yZCk7XG4gICAgICB9IGVsc2UgaWYgKGN1clB1bmMgPT0gXCJuZXdibG9ja1wiKSB7XG4gICAgICAgIGlmIChjdXJLZXl3b3JkID09IFwiZnVuY3Rpb25cIiAmJiBjdHggJiYgKGN0eC50eXBlID09IFwic3RhdGVtZW50XCIgfHwgY3R4LnR5cGUgPT0gXCJlbmRncm91cFwiKSkge1xuICAgICAgICAgIC8vIFRoZSAnZnVuY3Rpb24nIGtleXdvcmQgY2FuIGFwcGVhciBpbiBzb21lIG90aGVyIGNvbnRleHRzIHdoZXJlIGl0IGFjdHVhbGx5IGRvZXMgbm90XG4gICAgICAgICAgLy8gaW5kaWNhdGUgYSBmdW5jdGlvbiAoaW1wb3J0L2V4cG9ydCBEUEkgYW5kIGNvdmVyZ3JvdXAgZGVmaW5pdGlvbnMpLlxuICAgICAgICAgIC8vIERvIG5vdGhpbmcgaW4gdGhpcyBjYXNlXG4gICAgICAgIH0gZWxzZSBpZiAoY3VyS2V5d29yZCA9PSBcInRhc2tcIiAmJiBjdHggJiYgY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIikge1xuICAgICAgICAgIC8vIFNhbWUgdGhpbmcgZm9yIHRhc2tcbiAgICAgICAgfSBlbHNlIGlmIChjdXJLZXl3b3JkID09IFwiY2xhc3NcIiAmJiBjdHggJiYgY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIikge1xuICAgICAgICAgIC8vIFNhbWUgdGhpbmcgZm9yIGNsYXNzIChlLmcuIHR5cGVkZWYpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNsb3NlID0gb3BlbkNsb3NlW2N1cktleXdvcmRdO1xuICAgICAgICAgIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0uY29sdW1uKCksIGNsb3NlLCBjdXJLZXl3b3JkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjdXJQdW5jID09IFwibmV3bWFjcm9cIiB8fCAoY3VyS2V5d29yZCAmJiBjdXJLZXl3b3JkLm1hdGNoKGNvbXBpbGVyRGlyZWN0aXZlUmVnZXgpKSkge1xuICAgICAgICBpZiAoY3VyUHVuYyA9PSBcIm5ld21hY3JvXCIpIHtcbiAgICAgICAgICAvLyBNYWNyb3MgKGVzcGVjaWFsbHkgaWYgdGhleSBoYXZlIHBhcmVudGhlc2lzKSBwb3RlbnRpYWxseSBoYXZlIGEgc2VtaWNvbG9uXG4gICAgICAgICAgLy8gb3IgY29tcGxldGUgc3RhdGVtZW50L2Jsb2NrIGluc2lkZSwgYW5kIHNob3VsZCBiZSB0cmVhdGVkIGFzIHN1Y2guXG4gICAgICAgICAgcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbS5jb2x1bW4oKSwgXCJtYWNyb1wiLCBcIm1hY3JvXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJLZXl3b3JkLm1hdGNoKGNvbXBpbGVyRGlyZWN0aXZlRW5kUmVnZXgpKSB7XG4gICAgICAgICAgc3RhdGUuY29tcGlsZXJEaXJlY3RpdmVJbmRlbnRlZCAtPSBzdGF0ZW1lbnRJbmRlbnRVbml0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJLZXl3b3JkLm1hdGNoKGNvbXBpbGVyRGlyZWN0aXZlQmVnaW5SZWdleCkpIHtcbiAgICAgICAgICBzdGF0ZS5jb21waWxlckRpcmVjdGl2ZUluZGVudGVkICs9IHN0YXRlbWVudEluZGVudFVuaXQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RhdGUuc3RhcnRPZkxpbmUgPSBmYWxzZTtcbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9LFxuXG4gICAgaW5kZW50OiBmdW5jdGlvbihzdGF0ZSwgdGV4dEFmdGVyKSB7XG4gICAgICBpZiAoc3RhdGUudG9rZW5pemUgIT0gdG9rZW5CYXNlICYmIHN0YXRlLnRva2VuaXplICE9IG51bGwpIHJldHVybiBDb2RlTWlycm9yLlBhc3M7XG4gICAgICBpZiAoaG9va3MuaW5kZW50KSB7XG4gICAgICAgIHZhciBmcm9tSG9vayA9IGhvb2tzLmluZGVudChzdGF0ZSk7XG4gICAgICAgIGlmIChmcm9tSG9vayA+PSAwKSByZXR1cm4gZnJvbUhvb2s7XG4gICAgICB9XG4gICAgICB2YXIgY3R4ID0gc3RhdGUuY29udGV4dCwgZmlyc3RDaGFyID0gdGV4dEFmdGVyICYmIHRleHRBZnRlci5jaGFyQXQoMCk7XG4gICAgICBpZiAoY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIiAmJiBmaXJzdENoYXIgPT0gXCJ9XCIpIGN0eCA9IGN0eC5wcmV2O1xuICAgICAgdmFyIGNsb3NpbmcgPSBmYWxzZTtcbiAgICAgIHZhciBwb3NzaWJsZUNsb3NpbmcgPSB0ZXh0QWZ0ZXIubWF0Y2goY2xvc2luZ0JyYWNrZXRPcldvcmQpO1xuICAgICAgaWYgKHBvc3NpYmxlQ2xvc2luZylcbiAgICAgICAgY2xvc2luZyA9IGlzQ2xvc2luZyhwb3NzaWJsZUNsb3NpbmdbMF0sIGN0eC50eXBlKTtcbiAgICAgIGlmICghY29tcGlsZXJEaXJlY3RpdmVzVXNlUmVndWxhckluZGVudGF0aW9uICYmIHRleHRBZnRlci5tYXRjaChjb21waWxlckRpcmVjdGl2ZVJlZ2V4KSkge1xuICAgICAgICBpZiAodGV4dEFmdGVyLm1hdGNoKGNvbXBpbGVyRGlyZWN0aXZlRW5kUmVnZXgpKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlLmNvbXBpbGVyRGlyZWN0aXZlSW5kZW50ZWQgLSBzdGF0ZW1lbnRJbmRlbnRVbml0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZS5jb21waWxlckRpcmVjdGl2ZUluZGVudGVkO1xuICAgICAgfVxuICAgICAgaWYgKGN0eC50eXBlID09IFwic3RhdGVtZW50XCIpIHJldHVybiBjdHguaW5kZW50ZWQgKyAoZmlyc3RDaGFyID09IFwie1wiID8gMCA6IHN0YXRlbWVudEluZGVudFVuaXQpO1xuICAgICAgZWxzZSBpZiAoKGNsb3NpbmdCcmFja2V0LnRlc3QoY3R4LnR5cGUpIHx8IGN0eC50eXBlID09IFwiYXNzaWdubWVudFwiKVxuICAgICAgICAmJiBjdHguYWxpZ24gJiYgIWRvbnRBbGlnbkNhbGxzKSByZXR1cm4gY3R4LmNvbHVtbiArIChjbG9zaW5nID8gMCA6IDEpO1xuICAgICAgZWxzZSBpZiAoY3R4LnR5cGUgPT0gXCIpXCIgJiYgIWNsb3NpbmcpIHJldHVybiBjdHguaW5kZW50ZWQgKyBzdGF0ZW1lbnRJbmRlbnRVbml0O1xuICAgICAgZWxzZSByZXR1cm4gY3R4LmluZGVudGVkICsgKGNsb3NpbmcgPyAwIDogaW5kZW50VW5pdCk7XG4gICAgfSxcblxuICAgIGJsb2NrQ29tbWVudFN0YXJ0OiBcIi8qXCIsXG4gICAgYmxvY2tDb21tZW50RW5kOiBcIiovXCIsXG4gICAgbGluZUNvbW1lbnQ6IFwiLy9cIixcbiAgICBmb2xkOiBcImluZGVudFwiXG4gIH07XG59KTtcblxuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3gtdmVyaWxvZ1wiLCB7XG4gICAgbmFtZTogXCJ2ZXJpbG9nXCJcbiAgfSk7XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LXN5c3RlbXZlcmlsb2dcIiwge1xuICAgIG5hbWU6IFwidmVyaWxvZ1wiXG4gIH0pO1xuXG5cblxuICAvLyBUTC1WZXJpbG9nIG1vZGUuXG4gIC8vIFNlZSB0bC14Lm9yZyBmb3IgbGFuZ3VhZ2Ugc3BlYy5cbiAgLy8gU2VlIHRoZSBtb2RlIGluIGFjdGlvbiBhdCBtYWtlcmNoaXAuY29tLlxuICAvLyBDb250YWN0OiBzdGV2ZS5ob292ZXJAcmVkd29vZGVkYS5jb21cblxuICAvLyBUTFYgSWRlbnRpZmllciBwcmVmaXhlcy5cbiAgLy8gTm90ZSB0aGF0IHNpZ24gaXMgbm90IHRyZWF0ZWQgc2VwYXJhdGVseSwgc28gXCIrLy1cIiB2ZXJzaW9ucyBvZiBudW1lcmljIGlkZW50aWZpZXJzXG4gIC8vIGFyZSBpbmNsdWRlZC5cbiAgdmFyIHRsdklkZW50aWZpZXJTdHlsZSA9IHtcbiAgICBcInxcIjogXCJsaW5rXCIsXG4gICAgXCI+XCI6IFwicHJvcGVydHlcIiwgIC8vIFNob3VsZCBjb25kaXRpb24gdGhpcyBvZmYgZm9yID4gVExWIDFjLlxuICAgIFwiJFwiOiBcInZhcmlhYmxlXCIsXG4gICAgXCIkJFwiOiBcInZhcmlhYmxlXCIsXG4gICAgXCI/JFwiOiBcInF1YWxpZmllclwiLFxuICAgIFwiPypcIjogXCJxdWFsaWZpZXJcIixcbiAgICBcIi1cIjogXCJoclwiLFxuICAgIFwiL1wiOiBcInByb3BlcnR5XCIsXG4gICAgXCIvLVwiOiBcInByb3BlcnR5XCIsXG4gICAgXCJAXCI6IFwidmFyaWFibGUtM1wiLFxuICAgIFwiQC1cIjogXCJ2YXJpYWJsZS0zXCIsXG4gICAgXCJAKytcIjogXCJ2YXJpYWJsZS0zXCIsXG4gICAgXCJAKz1cIjogXCJ2YXJpYWJsZS0zXCIsXG4gICAgXCJAKz0tXCI6IFwidmFyaWFibGUtM1wiLFxuICAgIFwiQC0tXCI6IFwidmFyaWFibGUtM1wiLFxuICAgIFwiQC09XCI6IFwidmFyaWFibGUtM1wiLFxuICAgIFwiJStcIjogXCJ0YWdcIixcbiAgICBcIiUtXCI6IFwidGFnXCIsXG4gICAgXCIlXCI6IFwidGFnXCIsXG4gICAgXCI+PlwiOiBcInRhZ1wiLFxuICAgIFwiPDxcIjogXCJ0YWdcIixcbiAgICBcIjw+XCI6IFwidGFnXCIsXG4gICAgXCIjXCI6IFwidGFnXCIsICAvLyBOZWVkIHRvIGNob29zZSBhIHN0eWxlIGZvciB0aGlzLlxuICAgIFwiXlwiOiBcImF0dHJpYnV0ZVwiLFxuICAgIFwiXl5cIjogXCJhdHRyaWJ1dGVcIixcbiAgICBcIl4hXCI6IFwiYXR0cmlidXRlXCIsXG4gICAgXCIqXCI6IFwidmFyaWFibGUtMlwiLFxuICAgIFwiKipcIjogXCJ2YXJpYWJsZS0yXCIsXG4gICAgXCJcXFxcXCI6IFwia2V5d29yZFwiLFxuICAgIFwiXFxcIlwiOiBcImNvbW1lbnRcIlxuICB9O1xuXG4gIC8vIExpbmVzIHN0YXJ0aW5nIHdpdGggdGhlc2UgY2hhcmFjdGVycyBkZWZpbmUgc2NvcGUgKHJlc3VsdCBpbiBpbmRlbnRhdGlvbikuXG4gIHZhciB0bHZTY29wZVByZWZpeENoYXJzID0ge1xuICAgIFwiL1wiOiBcImJlaC1oaWVyXCIsXG4gICAgXCI+XCI6IFwiYmVoLWhpZXJcIixcbiAgICBcIi1cIjogXCJwaHlzLWhpZXJcIixcbiAgICBcInxcIjogXCJwaXBlXCIsXG4gICAgXCI/XCI6IFwid2hlblwiLFxuICAgIFwiQFwiOiBcInN0YWdlXCIsXG4gICAgXCJcXFxcXCI6IFwia2V5d29yZFwiXG4gIH07XG4gIHZhciB0bHZJbmRlbnRVbml0ID0gMztcbiAgdmFyIHRsdlRyYWNrU3RhdGVtZW50cyA9IGZhbHNlO1xuICB2YXIgdGx2SWRlbnRNYXRjaCA9IC9eKFt+IUAjXFwkJVxcXiZcXCotXFwrPVxcP1xcL1xcXFxcXHwnXCI8Pl0rKShbXFxkXFx3X10qKS87ICAvLyBNYXRjaGVzIGFuIGlkZW50aWZpZXIuXG4gIC8vIE5vdGUgdGhhdCAnOicgaXMgZXhjbHVkZWQsIGJlY2F1c2Ugb2YgaXQncyB1c2UgaW4gWzpdLlxuICB2YXIgdGx2Rmlyc3RMZXZlbEluZGVudE1hdGNoID0gL15bISBdICAvO1xuICB2YXIgdGx2TGluZUluZGVudGF0aW9uTWF0Y2ggPSAvXlshIF0gKi87XG4gIHZhciB0bHZDb21tZW50TWF0Y2ggPSAvXlxcL1tcXC9cXCpdLztcblxuXG4gIC8vIFJldHVybnMgYSBzdHlsZSBzcGVjaWZpYyB0byB0aGUgc2NvcGUgYXQgdGhlIGdpdmVuIGluZGVudGF0aW9uIGNvbHVtbi5cbiAgLy8gVHlwZSBpcyBvbmUgb2Y6IFwiaW5kZW50XCIsIFwic2NvcGUtaWRlbnRcIiwgXCJiZWZvcmUtc2NvcGUtaWRlbnRcIi5cbiAgZnVuY3Rpb24gdGx2U2NvcGVTdHlsZShzdGF0ZSwgaW5kZW50YXRpb24sIHR5cGUpIHtcbiAgICAvLyBCZWdpbiBzY29wZS5cbiAgICB2YXIgZGVwdGggPSBpbmRlbnRhdGlvbiAvIHRsdkluZGVudFVuaXQ7ICAvLyBUT0RPOiBQYXNzIHRoaXMgaW4gaW5zdGVhZC5cbiAgICByZXR1cm4gXCJ0bHYtXCIgKyBzdGF0ZS50bHZJbmRlbnRhdGlvblN0eWxlW2RlcHRoXSArIFwiLVwiICsgdHlwZTtcbiAgfVxuXG4gIC8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IHRoaW5nIGluIHRoZSBzdHJlYW0gaXMgYW4gaWRlbnRpZmllciB3aXRoIGEgbW5lbW9uaWMuXG4gIGZ1bmN0aW9uIHRsdklkZW50TmV4dChzdHJlYW0pIHtcbiAgICB2YXIgbWF0Y2g7XG4gICAgcmV0dXJuIChtYXRjaCA9IHN0cmVhbS5tYXRjaCh0bHZJZGVudE1hdGNoLCBmYWxzZSkpICYmIG1hdGNoWzJdLmxlbmd0aCA+IDA7XG4gIH1cblxuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3gtdGx2XCIsIHtcbiAgICBuYW1lOiBcInZlcmlsb2dcIixcblxuICAgIGhvb2tzOiB7XG5cbiAgICAgIGVsZWN0cmljSW5wdXQ6IGZhbHNlLFxuXG5cbiAgICAgIC8vIFJldHVybiB1bmRlZmluZWQgZm9yIHZlcmlsb2cgdG9rZW5pemluZywgb3Igc3R5bGUgZm9yIFRMViB0b2tlbiAobnVsbCBub3QgdXNlZCkuXG4gICAgICAvLyBTdGFuZGFyZCBDTSBzdHlsZXMgYXJlIHVzZWQgZm9yIG1vc3QgZm9ybWF0dGluZywgYnV0IHNvbWUgVEwtVmVyaWxvZy1zcGVjaWZpYyBoaWdobGlnaHRpbmdcbiAgICAgIC8vIGNhbiBiZSBlbmFibGVkIHdpdGggdGhlIGRlZmluaXRpb24gb2YgY20tdGx2LSogc3R5bGVzLCBpbmNsdWRpbmcgaGlnaGxpZ2h0aW5nIGZvcjpcbiAgICAgIC8vICAgLSBNNCB0b2tlbnNcbiAgICAgIC8vICAgLSBUTFYgc2NvcGUgaW5kZW50YXRpb25cbiAgICAgIC8vICAgLSBTdGF0ZW1lbnQgZGVsaW1pdGF0aW9uIChlbmFibGVkIGJ5IHRsdlRyYWNrU3RhdGVtZW50cylcbiAgICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIG1hdGNoOyAgLy8gUmV0dXJuIHZhbHVlIG9mIHBhdHRlcm4gbWF0Y2hlcy5cblxuICAgICAgICAvLyBTZXQgaGlnaGxpZ2h0aW5nIG1vZGUgYmFzZWQgb24gY29kZSByZWdpb24gKFRMViBvciBTVikuXG4gICAgICAgIGlmIChzdHJlYW0uc29sKCkgJiYgISBzdGF0ZS50bHZJbkJsb2NrQ29tbWVudCkge1xuICAgICAgICAgIC8vIFByb2Nlc3MgcmVnaW9uLlxuICAgICAgICAgIGlmIChzdHJlYW0ucGVlaygpID09ICdcXFxcJykge1xuICAgICAgICAgICAgc3R5bGUgPSBcImRlZlwiO1xuICAgICAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICAgICAgaWYgKHN0cmVhbS5zdHJpbmcubWF0Y2goL1xcXFxTVi8pKSB7XG4gICAgICAgICAgICAgIHN0YXRlLnRsdkNvZGVBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLnN0cmluZy5tYXRjaCgvXFxcXFRMVi8pKXtcbiAgICAgICAgICAgICAgc3RhdGUudGx2Q29kZUFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIENvcnJlY3QgaW5kZW50YXRpb24gaW4gdGhlIGZhY2Ugb2YgYSBsaW5lIHByZWZpeCBjaGFyLlxuICAgICAgICAgIGlmIChzdGF0ZS50bHZDb2RlQWN0aXZlICYmIHN0cmVhbS5wb3MgPT0gMCAmJlxuICAgICAgICAgICAgICAoc3RhdGUuaW5kZW50ZWQgPT0gMCkgJiYgKG1hdGNoID0gc3RyZWFtLm1hdGNoKHRsdkxpbmVJbmRlbnRhdGlvbk1hdGNoLCBmYWxzZSkpKSB7XG4gICAgICAgICAgICBzdGF0ZS5pbmRlbnRlZCA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDb21wdXRlIGluZGVudGF0aW9uIHN0YXRlOlxuICAgICAgICAgIC8vICAgbyBBdXRvIGluZGVudGF0aW9uIG9uIG5leHQgbGluZVxuICAgICAgICAgIC8vICAgbyBJbmRlbnRhdGlvbiBzY29wZSBzdHlsZXNcbiAgICAgICAgICB2YXIgaW5kZW50ZWQgPSBzdGF0ZS5pbmRlbnRlZDtcbiAgICAgICAgICB2YXIgZGVwdGggPSBpbmRlbnRlZCAvIHRsdkluZGVudFVuaXQ7XG4gICAgICAgICAgaWYgKGRlcHRoIDw9IHN0YXRlLnRsdkluZGVudGF0aW9uU3R5bGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBub3QgZGVlcGVyIHRoYW4gY3VycmVudCBzY29wZVxuXG4gICAgICAgICAgICB2YXIgYmxhbmtsaW5lID0gc3RyZWFtLnN0cmluZy5sZW5ndGggPT0gaW5kZW50ZWQ7XG4gICAgICAgICAgICB2YXIgY2hQb3MgPSBkZXB0aCAqIHRsdkluZGVudFVuaXQ7XG4gICAgICAgICAgICBpZiAoY2hQb3MgPCBzdHJlYW0uc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICB2YXIgYm9keVN0cmluZyA9IHN0cmVhbS5zdHJpbmcuc2xpY2UoY2hQb3MpO1xuICAgICAgICAgICAgICB2YXIgY2ggPSBib2R5U3RyaW5nWzBdO1xuICAgICAgICAgICAgICBpZiAodGx2U2NvcGVQcmVmaXhDaGFyc1tjaF0gJiYgKChtYXRjaCA9IGJvZHlTdHJpbmcubWF0Y2godGx2SWRlbnRNYXRjaCkpICYmXG4gICAgICAgICAgICAgICAgICB0bHZJZGVudGlmaWVyU3R5bGVbbWF0Y2hbMV1dKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgbGluZSBiZWdpbnMgc2NvcGUuXG4gICAgICAgICAgICAgICAgLy8gTmV4dCBsaW5lIGdldHMgaW5kZW50ZWQgb25lIGxldmVsLlxuICAgICAgICAgICAgICAgIGluZGVudGVkICs9IHRsdkluZGVudFVuaXQ7XG4gICAgICAgICAgICAgICAgLy8gU3R5bGUgdGhlIG5leHQgbGV2ZWwgb2YgaW5kZW50YXRpb24gKGV4Y2VwdCBub24tcmVnaW9uIGtleXdvcmQgaWRlbnRpZmllcnMsXG4gICAgICAgICAgICAgICAgLy8gICB3aGljaCBhcmUgc3RhdGVtZW50cyB0aGVtc2VsdmVzKVxuICAgICAgICAgICAgICAgIGlmICghKGNoID09IFwiXFxcXFwiICYmIGNoUG9zID4gMCkpIHtcbiAgICAgICAgICAgICAgICAgIHN0YXRlLnRsdkluZGVudGF0aW9uU3R5bGVbZGVwdGhdID0gdGx2U2NvcGVQcmVmaXhDaGFyc1tjaF07XG4gICAgICAgICAgICAgICAgICBpZiAodGx2VHJhY2tTdGF0ZW1lbnRzKSB7c3RhdGUuc3RhdGVtZW50Q29tbWVudCA9IGZhbHNlO31cbiAgICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDbGVhciBvdXQgZGVlcGVyIGluZGVudGF0aW9uIGxldmVscyB1bmxlc3MgbGluZSBpcyBibGFuay5cbiAgICAgICAgICAgIGlmICghYmxhbmtsaW5lKSB7XG4gICAgICAgICAgICAgIHdoaWxlIChzdGF0ZS50bHZJbmRlbnRhdGlvblN0eWxlLmxlbmd0aCA+IGRlcHRoKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUudGx2SW5kZW50YXRpb25TdHlsZS5wb3AoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBTZXQgbmV4dCBsZXZlbCBvZiBpbmRlbnRhdGlvbi5cbiAgICAgICAgICBzdGF0ZS50bHZOZXh0SW5kZW50ID0gaW5kZW50ZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdGUudGx2Q29kZUFjdGl2ZSkge1xuICAgICAgICAgIC8vIEhpZ2hsaWdodCBhcyBUTFYuXG5cbiAgICAgICAgICB2YXIgYmVnaW5TdGF0ZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICBpZiAodGx2VHJhY2tTdGF0ZW1lbnRzKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHN0YXJ0cyBhIHN0YXRlbWVudCBpZiB0aGUgcG9zaXRpb24gaXMgYXQgdGhlIHNjb3BlIGxldmVsXG4gICAgICAgICAgICAvLyBhbmQgd2UncmUgbm90IHdpdGhpbiBhIHN0YXRlbWVudCBsZWFkaW5nIGNvbW1lbnQuXG4gICAgICAgICAgICBiZWdpblN0YXRlbWVudCA9XG4gICAgICAgICAgICAgICAgICAgKHN0cmVhbS5wZWVrKCkgIT0gXCIgXCIpICYmICAgLy8gbm90IGEgc3BhY2VcbiAgICAgICAgICAgICAgICAgICAoc3R5bGUgPT09IHVuZGVmaW5lZCkgJiYgICAgLy8gbm90IGEgcmVnaW9uIGlkZW50aWZpZXJcbiAgICAgICAgICAgICAgICAgICAhc3RhdGUudGx2SW5CbG9ja0NvbW1lbnQgJiYgLy8gbm90IGluIGJsb2NrIGNvbW1lbnRcbiAgICAgICAgICAgICAgICAgICAvLyFzdHJlYW0ubWF0Y2godGx2Q29tbWVudE1hdGNoLCBmYWxzZSkgJiYgLy8gbm90IGNvbW1lbnQgc3RhcnRcbiAgICAgICAgICAgICAgICAgICAoc3RyZWFtLmNvbHVtbigpID09IHN0YXRlLnRsdkluZGVudGF0aW9uU3R5bGUubGVuZ3RoICogdGx2SW5kZW50VW5pdCk7ICAvLyBhdCBzY29wZSBsZXZlbFxuICAgICAgICAgICAgaWYgKGJlZ2luU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgIGlmIChzdGF0ZS5zdGF0ZW1lbnRDb21tZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gc3RhdGVtZW50IGFscmVhZHkgc3RhcnRlZCBieSBjb21tZW50XG4gICAgICAgICAgICAgICAgYmVnaW5TdGF0ZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdGF0ZS5zdGF0ZW1lbnRDb21tZW50ID1cbiAgICAgICAgICAgICAgICAgICBzdHJlYW0ubWF0Y2godGx2Q29tbWVudE1hdGNoLCBmYWxzZSk7IC8vIGNvbW1lbnQgc3RhcnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbWF0Y2g7XG4gICAgICAgICAgaWYgKHN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIFJlZ2lvbiBsaW5lLlxuICAgICAgICAgICAgc3R5bGUgKz0gXCIgXCIgKyB0bHZTY29wZVN0eWxlKHN0YXRlLCAwLCBcInNjb3BlLWlkZW50XCIpXG4gICAgICAgICAgfSBlbHNlIGlmICgoKHN0cmVhbS5wb3MgLyB0bHZJbmRlbnRVbml0KSA8IHN0YXRlLnRsdkluZGVudGF0aW9uU3R5bGUubGVuZ3RoKSAmJlxuICAgICAgICAgICAgICAgICAgICAgKG1hdGNoID0gc3RyZWFtLm1hdGNoKHN0cmVhbS5zb2woKSA/IHRsdkZpcnN0TGV2ZWxJbmRlbnRNYXRjaCA6IC9eICAgLykpKSB7XG4gICAgICAgICAgICAvLyBJbmRlbnRhdGlvblxuICAgICAgICAgICAgc3R5bGUgPSAvLyBtYWtlIHRoaXMgc3R5bGUgZGlzdGluY3QgZnJvbSB0aGUgcHJldmlvdXMgb25lIHRvIHByZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gY29kZW1pcnJvciBmcm9tIGNvbWJpbmluZyBzcGFuc1xuICAgICAgICAgICAgICAgICAgICBcInRsdi1pbmRlbnQtXCIgKyAoKChzdHJlYW0ucG9zICUgMikgPT0gMCkgPyBcImV2ZW5cIiA6IFwib2RkXCIpICtcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHN0eWxlIGl0XG4gICAgICAgICAgICAgICAgICAgIFwiIFwiICsgdGx2U2NvcGVTdHlsZShzdGF0ZSwgc3RyZWFtLnBvcyAtIHRsdkluZGVudFVuaXQsIFwiaW5kZW50XCIpO1xuICAgICAgICAgICAgLy8gU3R5bGUgdGhlIGxpbmUgcHJlZml4IGNoYXJhY3Rlci5cbiAgICAgICAgICAgIGlmIChtYXRjaFswXS5jaGFyQXQoMCkgPT0gXCIhXCIpIHtcbiAgICAgICAgICAgICAgc3R5bGUgKz0gXCIgdGx2LWFsZXJ0LWxpbmUtcHJlZml4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQbGFjZSBhIGNsYXNzIGJlZm9yZSBhIHNjb3BlIGlkZW50aWZpZXIuXG4gICAgICAgICAgICBpZiAodGx2SWRlbnROZXh0KHN0cmVhbSkpIHtcbiAgICAgICAgICAgICAgc3R5bGUgKz0gXCIgXCIgKyB0bHZTY29wZVN0eWxlKHN0YXRlLCBzdHJlYW0ucG9zLCBcImJlZm9yZS1zY29wZS1pZGVudFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLnRsdkluQmxvY2tDb21tZW50KSB7XG4gICAgICAgICAgICAvLyBJbiBhIGJsb2NrIGNvbW1lbnQuXG4gICAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eLio/XFwqXFwvLykpIHtcbiAgICAgICAgICAgICAgLy8gRXhpdCBibG9jayBjb21tZW50LlxuICAgICAgICAgICAgICBzdGF0ZS50bHZJbkJsb2NrQ29tbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICBpZiAodGx2VHJhY2tTdGF0ZW1lbnRzICYmICFzdHJlYW0uZW9sKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBBbnl0aGluZyBhZnRlciBjb21tZW50IGlzIGFzc3VtZWQgdG8gYmUgcmVhbCBzdGF0ZW1lbnQgY29udGVudC5cbiAgICAgICAgICAgICAgICBzdGF0ZS5zdGF0ZW1lbnRDb21tZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0eWxlID0gXCJjb21tZW50XCI7XG4gICAgICAgICAgfSBlbHNlIGlmICgobWF0Y2ggPSBzdHJlYW0ubWF0Y2godGx2Q29tbWVudE1hdGNoKSkgJiYgIXN0YXRlLnRsdkluQmxvY2tDb21tZW50KSB7XG4gICAgICAgICAgICAvLyBTdGFydCBjb21tZW50LlxuICAgICAgICAgICAgaWYgKG1hdGNoWzBdID09IFwiLy9cIikge1xuICAgICAgICAgICAgICAvLyBMaW5lIGNvbW1lbnQuXG4gICAgICAgICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEJsb2NrIGNvbW1lbnQuXG4gICAgICAgICAgICAgIHN0YXRlLnRsdkluQmxvY2tDb21tZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0eWxlID0gXCJjb21tZW50XCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCA9IHN0cmVhbS5tYXRjaCh0bHZJZGVudE1hdGNoKSkge1xuICAgICAgICAgICAgLy8gbG9va3MgbGlrZSBhbiBpZGVudGlmaWVyIChvciBpZGVudGlmaWVyIHByZWZpeClcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIHZhciBtbmVtb25pYyA9IG1hdGNoWzJdO1xuICAgICAgICAgICAgaWYgKC8vIGlzIGlkZW50aWZpZXIgcHJlZml4XG4gICAgICAgICAgICAgICAgdGx2SWRlbnRpZmllclN0eWxlLmhhc093blByb3BlcnR5KHByZWZpeCkgJiZcbiAgICAgICAgICAgICAgICAvLyBoYXMgbW5lbW9uaWMgb3Igd2UncmUgYXQgdGhlIGVuZCBvZiB0aGUgbGluZSAobWF5YmUgaXQgaGFzbid0IGJlZW4gdHlwZWQgeWV0KVxuICAgICAgICAgICAgICAgIChtbmVtb25pYy5sZW5ndGggPiAwIHx8IHN0cmVhbS5lb2woKSkpIHtcbiAgICAgICAgICAgICAgc3R5bGUgPSB0bHZJZGVudGlmaWVyU3R5bGVbcHJlZml4XTtcbiAgICAgICAgICAgICAgaWYgKHN0cmVhbS5jb2x1bW4oKSA9PSBzdGF0ZS5pbmRlbnRlZCkge1xuICAgICAgICAgICAgICAgIC8vIEJlZ2luIHNjb3BlLlxuICAgICAgICAgICAgICAgIHN0eWxlICs9IFwiIFwiICsgdGx2U2NvcGVTdHlsZShzdGF0ZSwgc3RyZWFtLmNvbHVtbigpLCBcInNjb3BlLWlkZW50XCIpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEp1c3Qgc3dhbGxvdyBvbmUgY2hhcmFjdGVyIGFuZCB0cnkgYWdhaW4uXG4gICAgICAgICAgICAgIC8vIFRoaXMgZW5hYmxlcyBzdWJzZXF1ZW50IGlkZW50aWZpZXIgbWF0Y2ggd2l0aCBwcmVjZWRpbmcgc3ltYm9sIGNoYXJhY3Rlciwgd2hpY2hcbiAgICAgICAgICAgICAgLy8gICBpcyBsZWdhbCB3aXRoaW4gYSBzdGF0ZW1lbnQuICAoRS5nLiwgISRyZXNldCkuICBJdCBhbHNvIGVuYWJsZXMgZGV0ZWN0aW9uIG9mXG4gICAgICAgICAgICAgIC8vICAgY29tbWVudCBzdGFydCB3aXRoIHByZWNlZGluZyBzeW1ib2xzLlxuICAgICAgICAgICAgICBzdHJlYW0uYmFja1VwKHN0cmVhbS5jdXJyZW50KCkubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgIHN0eWxlID0gXCJ0bHYtZGVmYXVsdFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKC9eXFx0Ky8pKSB7XG4gICAgICAgICAgICAvLyBIaWdobGlnaHQgdGFicywgd2hpY2ggYXJlIGlsbGVnYWwuXG4gICAgICAgICAgICBzdHlsZSA9IFwidGx2LXRhYlwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKC9eW1xcW1xcXXt9XFwoXFwpO1xcOl0rLykpIHtcbiAgICAgICAgICAgIC8vIFs6XSwgKCksIHt9LCA7LlxuICAgICAgICAgICAgc3R5bGUgPSBcIm1ldGFcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoID0gc3RyZWFtLm1hdGNoKC9eW21NXTQoW1xcK19dKT9bXFx3XFxkX10qLykpIHtcbiAgICAgICAgICAgIC8vIG00IHByZSBwcm9jXG4gICAgICAgICAgICBzdHlsZSA9IChtYXRjaFsxXSA9PSBcIitcIikgPyBcInRsdi1tNC1wbHVzXCIgOiBcInRsdi1tNFwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKC9eICsvKSl7XG4gICAgICAgICAgICAvLyBTa2lwIG92ZXIgc3BhY2VzLlxuICAgICAgICAgICAgaWYgKHN0cmVhbS5lb2woKSkge1xuICAgICAgICAgICAgICAvLyBUcmFpbGluZyBzcGFjZXMuXG4gICAgICAgICAgICAgIHN0eWxlID0gXCJlcnJvclwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gTm9uLXRyYWlsaW5nIHNwYWNlcy5cbiAgICAgICAgICAgICAgc3R5bGUgPSBcInRsdi1kZWZhdWx0XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goL15bXFx3XFxkX10rLykpIHtcbiAgICAgICAgICAgIC8vIGFscGhhLW51bWVyaWMgdG9rZW4uXG4gICAgICAgICAgICBzdHlsZSA9IFwibnVtYmVyXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEVhdCB0aGUgbmV4dCBjaGFyIHcvIG5vIGZvcm1hdHRpbmcuXG4gICAgICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAgICAgc3R5bGUgPSBcInRsdi1kZWZhdWx0XCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChiZWdpblN0YXRlbWVudCkge1xuICAgICAgICAgICAgc3R5bGUgKz0gXCIgdGx2LXN0YXRlbWVudFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eW21NXTQoW1xcd1xcZF9dKikvKSkge1xuICAgICAgICAgICAgLy8gbTQgcHJlIHByb2NcbiAgICAgICAgICAgIHN0eWxlID0gXCJ0bHYtbTRcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgfSxcblxuICAgICAgaW5kZW50OiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICByZXR1cm4gKHN0YXRlLnRsdkNvZGVBY3RpdmUgPT0gdHJ1ZSkgPyBzdGF0ZS50bHZOZXh0SW5kZW50IDogLTE7XG4gICAgICB9LFxuXG4gICAgICBzdGFydFN0YXRlOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICBzdGF0ZS50bHZJbmRlbnRhdGlvblN0eWxlID0gW107ICAvLyBTdHlsZXMgdG8gdXNlIGZvciBlYWNoIGxldmVsIG9mIGluZGVudGF0aW9uLlxuICAgICAgICBzdGF0ZS50bHZDb2RlQWN0aXZlID0gdHJ1ZTsgIC8vIFRydWUgd2hlbiB3ZSdyZSBpbiBhIFRMViByZWdpb24gKGFuZCBhdCBiZWdpbm5pbmcgb2YgZmlsZSkuXG4gICAgICAgIHN0YXRlLnRsdk5leHRJbmRlbnQgPSAtMTsgICAgLy8gVGhlIG51bWJlciBvZiBzcGFjZXMgdG8gYXV0b2luZGVudCB0aGUgbmV4dCBsaW5lIGlmIHRsdkNvZGVBY3RpdmUuXG4gICAgICAgIHN0YXRlLnRsdkluQmxvY2tDb21tZW50ID0gZmFsc2U7ICAvLyBUcnVlIGluc2lkZSAvKiovIGNvbW1lbnQuXG4gICAgICAgIGlmICh0bHZUcmFja1N0YXRlbWVudHMpIHtcbiAgICAgICAgICBzdGF0ZS5zdGF0ZW1lbnRDb21tZW50ID0gZmFsc2U7ICAvLyBUcnVlIGluc2lkZSBhIHN0YXRlbWVudCdzIGhlYWRlciBjb21tZW50LlxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9XG4gIH0pO1xufSk7XG4iLCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4vLyBPcmlnaW5hbGx5IHdyaXR0ZW4gYnkgQWxmIE5pZWxzZW4sIHJlLXdyaXR0ZW4gYnkgTWljaGFlbCBaaG91XG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIHdvcmRzKHN0cikge1xuICB2YXIgb2JqID0ge30sIHdvcmRzID0gc3RyLnNwbGl0KFwiLFwiKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBhbGxDYXBzID0gd29yZHNbaV0udG9VcHBlckNhc2UoKTtcbiAgICB2YXIgZmlyc3RDYXAgPSB3b3Jkc1tpXS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHdvcmRzW2ldLnNsaWNlKDEpO1xuICAgIG9ialt3b3Jkc1tpXV0gPSB0cnVlO1xuICAgIG9ialthbGxDYXBzXSA9IHRydWU7XG4gICAgb2JqW2ZpcnN0Q2FwXSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gbWV0YUhvb2soc3RyZWFtKSB7XG4gIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcJF9dLyk7XG4gIHJldHVybiBcIm1ldGFcIjtcbn1cblxuQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwidmhkbFwiLCBmdW5jdGlvbihjb25maWcsIHBhcnNlckNvbmZpZykge1xuICB2YXIgaW5kZW50VW5pdCA9IGNvbmZpZy5pbmRlbnRVbml0LFxuICAgICAgYXRvbXMgPSBwYXJzZXJDb25maWcuYXRvbXMgfHwgd29yZHMoXCJudWxsXCIpLFxuICAgICAgaG9va3MgPSBwYXJzZXJDb25maWcuaG9va3MgfHwge1wiYFwiOiBtZXRhSG9vaywgXCIkXCI6IG1ldGFIb29rfSxcbiAgICAgIG11bHRpTGluZVN0cmluZ3MgPSBwYXJzZXJDb25maWcubXVsdGlMaW5lU3RyaW5ncztcblxuICB2YXIga2V5d29yZHMgPSB3b3JkcyhcImFicyxhY2Nlc3MsYWZ0ZXIsYWxpYXMsYWxsLGFuZCxhcmNoaXRlY3R1cmUsYXJyYXksYXNzZXJ0LGF0dHJpYnV0ZSxiZWdpbixibG9jayxcIiArXG4gICAgICBcImJvZHksYnVmZmVyLGJ1cyxjYXNlLGNvbXBvbmVudCxjb25maWd1cmF0aW9uLGNvbnN0YW50LGRpc2Nvbm5lY3QsZG93bnRvLGVsc2UsZWxzaWYsZW5kLGVuZCBibG9jayxlbmQgY2FzZSxcIiArXG4gICAgICBcImVuZCBjb21wb25lbnQsZW5kIGZvcixlbmQgZ2VuZXJhdGUsZW5kIGlmLGVuZCBsb29wLGVuZCBwcm9jZXNzLGVuZCByZWNvcmQsZW5kIHVuaXRzLGVudGl0eSxleGl0LGZpbGUsZm9yLFwiICtcbiAgICAgIFwiZnVuY3Rpb24sZ2VuZXJhdGUsZ2VuZXJpYyxnZW5lcmljIG1hcCxncm91cCxndWFyZGVkLGlmLGltcHVyZSxpbixpbmVydGlhbCxpbm91dCxpcyxsYWJlbCxsaWJyYXJ5LGxpbmthZ2UsXCIgK1xuICAgICAgXCJsaXRlcmFsLGxvb3AsbWFwLG1vZCxuYW5kLG5ldyxuZXh0LG5vcixudWxsLG9mLG9uLG9wZW4sb3Isb3RoZXJzLG91dCxwYWNrYWdlLHBhY2thZ2UgYm9keSxwb3J0LHBvcnQgbWFwLFwiICtcbiAgICAgIFwicG9zdHBvbmVkLHByb2NlZHVyZSxwcm9jZXNzLHB1cmUscmFuZ2UscmVjb3JkLHJlZ2lzdGVyLHJlamVjdCxyZW0scmVwb3J0LHJldHVybixyb2wscm9yLHNlbGVjdCxzZXZlcml0eSxzaWduYWwsXCIgK1xuICAgICAgXCJzbGEsc2xsLHNyYSxzcmwsc3VidHlwZSx0aGVuLHRvLHRyYW5zcG9ydCx0eXBlLHVuYWZmZWN0ZWQsdW5pdHMsdW50aWwsdXNlLHZhcmlhYmxlLHdhaXQsd2hlbix3aGlsZSx3aXRoLHhub3IseG9yXCIpO1xuXG4gIHZhciBibG9ja0tleXdvcmRzID0gd29yZHMoXCJhcmNoaXRlY3R1cmUsZW50aXR5LGJlZ2luLGNhc2UscG9ydCxlbHNlLGVsc2lmLGVuZCxmb3IsZnVuY3Rpb24saWZcIik7XG5cbiAgdmFyIGlzT3BlcmF0b3JDaGFyID0gL1smfH4+PCFcXClcXCgqIyVAK1xcLz0/XFw6O317LFxcLlxcXlxcLVxcW1xcXV0vO1xuICB2YXIgY3VyUHVuYztcblxuICBmdW5jdGlvbiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG4gICAgaWYgKGhvb2tzW2NoXSkge1xuICAgICAgdmFyIHJlc3VsdCA9IGhvb2tzW2NoXShzdHJlYW0sIHN0YXRlKTtcbiAgICAgIGlmIChyZXN1bHQgIT09IGZhbHNlKSByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAoY2ggPT0gJ1wiJykge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlblN0cmluZzIoY2gpO1xuICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgICBpZiAoY2ggPT0gXCInXCIpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5TdHJpbmcoY2gpO1xuICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgICBpZiAoL1tcXFtcXF17fVxcKFxcKSw7XFw6XFwuXS8udGVzdChjaCkpIHtcbiAgICAgIGN1clB1bmMgPSBjaDtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoL1tcXGQnXS8udGVzdChjaCkpIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcLiddLyk7XG4gICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICB9XG4gICAgaWYgKGNoID09IFwiLVwiKSB7XG4gICAgICBpZiAoc3RyZWFtLmVhdChcIi1cIikpIHtcbiAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc09wZXJhdG9yQ2hhci50ZXN0KGNoKSkge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKGlzT3BlcmF0b3JDaGFyKTtcbiAgICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gICAgfVxuICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcJF9dLyk7XG4gICAgdmFyIGN1ciA9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAgaWYgKGtleXdvcmRzLnByb3BlcnR5SXNFbnVtZXJhYmxlKGN1ci50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgaWYgKGJsb2NrS2V5d29yZHMucHJvcGVydHlJc0VudW1lcmFibGUoY3VyKSkgY3VyUHVuYyA9IFwibmV3c3RhdGVtZW50XCI7XG4gICAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gICAgfVxuICAgIGlmIChhdG9tcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSByZXR1cm4gXCJhdG9tXCI7XG4gICAgcmV0dXJuIFwidmFyaWFibGVcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuU3RyaW5nKHF1b3RlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBlc2NhcGVkID0gZmFsc2UsIG5leHQsIGVuZCA9IGZhbHNlO1xuICAgICAgd2hpbGUgKChuZXh0ID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgICBpZiAobmV4dCA9PSBxdW90ZSAmJiAhZXNjYXBlZCkge2VuZCA9IHRydWU7IGJyZWFrO31cbiAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkICYmIG5leHQgPT0gXCItLVwiO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCB8fCAhKGVzY2FwZWQgfHwgbXVsdGlMaW5lU3RyaW5ncykpXG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiB0b2tlblN0cmluZzIocXVvdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIGVzY2FwZWQgPSBmYWxzZSwgbmV4dCwgZW5kID0gZmFsc2U7XG4gICAgICB3aGlsZSAoKG5leHQgPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChuZXh0ID09IHF1b3RlICYmICFlc2NhcGVkKSB7ZW5kID0gdHJ1ZTsgYnJlYWs7fVxuICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQgJiYgbmV4dCA9PSBcIi0tXCI7XG4gICAgICB9XG4gICAgICBpZiAoZW5kIHx8ICEoZXNjYXBlZCB8fCBtdWx0aUxpbmVTdHJpbmdzKSlcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICByZXR1cm4gXCJzdHJpbmctMlwiO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KGluZGVudGVkLCBjb2x1bW4sIHR5cGUsIGFsaWduLCBwcmV2KSB7XG4gICAgdGhpcy5pbmRlbnRlZCA9IGluZGVudGVkO1xuICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5hbGlnbiA9IGFsaWduO1xuICAgIHRoaXMucHJldiA9IHByZXY7XG4gIH1cbiAgZnVuY3Rpb24gcHVzaENvbnRleHQoc3RhdGUsIGNvbCwgdHlwZSkge1xuICAgIHJldHVybiBzdGF0ZS5jb250ZXh0ID0gbmV3IENvbnRleHQoc3RhdGUuaW5kZW50ZWQsIGNvbCwgdHlwZSwgbnVsbCwgc3RhdGUuY29udGV4dCk7XG4gIH1cbiAgZnVuY3Rpb24gcG9wQ29udGV4dChzdGF0ZSkge1xuICAgIHZhciB0ID0gc3RhdGUuY29udGV4dC50eXBlO1xuICAgIGlmICh0ID09IFwiKVwiIHx8IHQgPT0gXCJdXCIgfHwgdCA9PSBcIn1cIilcbiAgICAgIHN0YXRlLmluZGVudGVkID0gc3RhdGUuY29udGV4dC5pbmRlbnRlZDtcbiAgICByZXR1cm4gc3RhdGUuY29udGV4dCA9IHN0YXRlLmNvbnRleHQucHJldjtcbiAgfVxuXG4gIC8vIEludGVyZmFjZVxuICByZXR1cm4ge1xuICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKGJhc2Vjb2x1bW4pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRva2VuaXplOiBudWxsLFxuICAgICAgICBjb250ZXh0OiBuZXcgQ29udGV4dCgoYmFzZWNvbHVtbiB8fCAwKSAtIGluZGVudFVuaXQsIDAsIFwidG9wXCIsIGZhbHNlKSxcbiAgICAgICAgaW5kZW50ZWQ6IDAsXG4gICAgICAgIHN0YXJ0T2ZMaW5lOiB0cnVlXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIGN0eCA9IHN0YXRlLmNvbnRleHQ7XG4gICAgICBpZiAoc3RyZWFtLnNvbCgpKSB7XG4gICAgICAgIGlmIChjdHguYWxpZ24gPT0gbnVsbCkgY3R4LmFsaWduID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmluZGVudGVkID0gc3RyZWFtLmluZGVudGF0aW9uKCk7XG4gICAgICAgIHN0YXRlLnN0YXJ0T2ZMaW5lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkgcmV0dXJuIG51bGw7XG4gICAgICBjdXJQdW5jID0gbnVsbDtcbiAgICAgIHZhciBzdHlsZSA9IChzdGF0ZS50b2tlbml6ZSB8fCB0b2tlbkJhc2UpKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgaWYgKHN0eWxlID09IFwiY29tbWVudFwiIHx8IHN0eWxlID09IFwibWV0YVwiKSByZXR1cm4gc3R5bGU7XG4gICAgICBpZiAoY3R4LmFsaWduID09IG51bGwpIGN0eC5hbGlnbiA9IHRydWU7XG5cbiAgICAgIGlmICgoY3VyUHVuYyA9PSBcIjtcIiB8fCBjdXJQdW5jID09IFwiOlwiKSAmJiBjdHgudHlwZSA9PSBcInN0YXRlbWVudFwiKSBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgIGVsc2UgaWYgKGN1clB1bmMgPT0gXCJ7XCIpIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0uY29sdW1uKCksIFwifVwiKTtcbiAgICAgIGVsc2UgaWYgKGN1clB1bmMgPT0gXCJbXCIpIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0uY29sdW1uKCksIFwiXVwiKTtcbiAgICAgIGVsc2UgaWYgKGN1clB1bmMgPT0gXCIoXCIpIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0uY29sdW1uKCksIFwiKVwiKTtcbiAgICAgIGVsc2UgaWYgKGN1clB1bmMgPT0gXCJ9XCIpIHtcbiAgICAgICAgd2hpbGUgKGN0eC50eXBlID09IFwic3RhdGVtZW50XCIpIGN0eCA9IHBvcENvbnRleHQoc3RhdGUpO1xuICAgICAgICBpZiAoY3R4LnR5cGUgPT0gXCJ9XCIpIGN0eCA9IHBvcENvbnRleHQoc3RhdGUpO1xuICAgICAgICB3aGlsZSAoY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIikgY3R4ID0gcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjdXJQdW5jID09IGN0eC50eXBlKSBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgIGVsc2UgaWYgKGN0eC50eXBlID09IFwifVwiIHx8IGN0eC50eXBlID09IFwidG9wXCIgfHwgKGN0eC50eXBlID09IFwic3RhdGVtZW50XCIgJiYgY3VyUHVuYyA9PSBcIm5ld3N0YXRlbWVudFwiKSlcbiAgICAgICAgcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbS5jb2x1bW4oKSwgXCJzdGF0ZW1lbnRcIik7XG4gICAgICBzdGF0ZS5zdGFydE9mTGluZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH0sXG5cbiAgICBpbmRlbnQ6IGZ1bmN0aW9uKHN0YXRlLCB0ZXh0QWZ0ZXIpIHtcbiAgICAgIGlmIChzdGF0ZS50b2tlbml6ZSAhPSB0b2tlbkJhc2UgJiYgc3RhdGUudG9rZW5pemUgIT0gbnVsbCkgcmV0dXJuIDA7XG4gICAgICB2YXIgZmlyc3RDaGFyID0gdGV4dEFmdGVyICYmIHRleHRBZnRlci5jaGFyQXQoMCksIGN0eCA9IHN0YXRlLmNvbnRleHQsIGNsb3NpbmcgPSBmaXJzdENoYXIgPT0gY3R4LnR5cGU7XG4gICAgICBpZiAoY3R4LnR5cGUgPT0gXCJzdGF0ZW1lbnRcIikgcmV0dXJuIGN0eC5pbmRlbnRlZCArIChmaXJzdENoYXIgPT0gXCJ7XCIgPyAwIDogaW5kZW50VW5pdCk7XG4gICAgICBlbHNlIGlmIChjdHguYWxpZ24pIHJldHVybiBjdHguY29sdW1uICsgKGNsb3NpbmcgPyAwIDogMSk7XG4gICAgICBlbHNlIHJldHVybiBjdHguaW5kZW50ZWQgKyAoY2xvc2luZyA/IDAgOiBpbmRlbnRVbml0KTtcbiAgICB9LFxuXG4gICAgZWxlY3RyaWNDaGFyczogXCJ7fVwiXG4gIH07XG59KTtcblxuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LXZoZGxcIiwgXCJ2aGRsXCIpO1xuXG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbiAobW9kKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIikgey8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSxcbiAgICAgICAgcmVxdWlyZShcIi4uLy4uL2FkZG9uL21vZGUvb3ZlcmxheVwiKSxcbiAgICAgICAgcmVxdWlyZShcIi4uL3htbC94bWxcIiksXG4gICAgICAgIHJlcXVpcmUoXCIuLi9qYXZhc2NyaXB0L2phdmFzY3JpcHRcIiksXG4gICAgICAgIHJlcXVpcmUoXCIuLi9jb2ZmZWVzY3JpcHQvY29mZmVlc2NyaXB0XCIpLFxuICAgICAgICByZXF1aXJlKFwiLi4vY3NzL2Nzc1wiKSxcbiAgICAgICAgcmVxdWlyZShcIi4uL3Nhc3Mvc2Fzc1wiKSxcbiAgICAgICAgcmVxdWlyZShcIi4uL3N0eWx1cy9zdHlsdXNcIiksXG4gICAgICAgIHJlcXVpcmUoXCIuLi9wdWcvcHVnXCIpLFxuICAgICAgICByZXF1aXJlKFwiLi4vaGFuZGxlYmFycy9oYW5kbGViYXJzXCIpKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgeyAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIixcbiAgICAgICAgICAgIFwiLi4vLi4vYWRkb24vbW9kZS9vdmVybGF5XCIsXG4gICAgICAgICAgICBcIi4uL3htbC94bWxcIixcbiAgICAgICAgICAgIFwiLi4vamF2YXNjcmlwdC9qYXZhc2NyaXB0XCIsXG4gICAgICAgICAgICBcIi4uL2NvZmZlZXNjcmlwdC9jb2ZmZWVzY3JpcHRcIixcbiAgICAgICAgICAgIFwiLi4vY3NzL2Nzc1wiLFxuICAgICAgICAgICAgXCIuLi9zYXNzL3Nhc3NcIixcbiAgICAgICAgICAgIFwiLi4vc3R5bHVzL3N0eWx1c1wiLFxuICAgICAgICAgICAgXCIuLi9wdWcvcHVnXCIsXG4gICAgICAgICAgICBcIi4uL2hhbmRsZWJhcnMvaGFuZGxlYmFyc1wiXSwgbW9kKTtcbiAgfSBlbHNlIHsgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG4gIH1cbn0pKGZ1bmN0aW9uIChDb2RlTWlycm9yKSB7XG4gIHZhciB0YWdMYW5ndWFnZXMgPSB7XG4gICAgc2NyaXB0OiBbXG4gICAgICBbXCJsYW5nXCIsIC9jb2ZmZWUoc2NyaXB0KT8vLCBcImNvZmZlZXNjcmlwdFwiXSxcbiAgICAgIFtcInR5cGVcIiwgL14oPzp0ZXh0fGFwcGxpY2F0aW9uKVxcLyg/OngtKT9jb2ZmZWUoPzpzY3JpcHQpPyQvLCBcImNvZmZlZXNjcmlwdFwiXSxcbiAgICAgIFtcImxhbmdcIiwgL15iYWJlbCQvLCBcImphdmFzY3JpcHRcIl0sXG4gICAgICBbXCJ0eXBlXCIsIC9edGV4dFxcL2JhYmVsJC8sIFwiamF2YXNjcmlwdFwiXSxcbiAgICAgIFtcInR5cGVcIiwgL150ZXh0XFwvZWNtYXNjcmlwdC1cXGQrJC8sIFwiamF2YXNjcmlwdFwiXVxuICAgIF0sXG4gICAgc3R5bGU6IFtcbiAgICAgIFtcImxhbmdcIiwgL15zdHlsdXMkL2ksIFwic3R5bHVzXCJdLFxuICAgICAgW1wibGFuZ1wiLCAvXnNhc3MkL2ksIFwic2Fzc1wiXSxcbiAgICAgIFtcImxhbmdcIiwgL15sZXNzJC9pLCBcInRleHQveC1sZXNzXCJdLFxuICAgICAgW1wibGFuZ1wiLCAvXnNjc3MkL2ksIFwidGV4dC94LXNjc3NcIl0sXG4gICAgICBbXCJ0eXBlXCIsIC9eKHRleHRcXC8pPyh4LSk/c3R5bCh1cyk/JC9pLCBcInN0eWx1c1wiXSxcbiAgICAgIFtcInR5cGVcIiwgL150ZXh0XFwvc2Fzcy9pLCBcInNhc3NcIl0sXG4gICAgICBbXCJ0eXBlXCIsIC9eKHRleHRcXC8pPyh4LSk/c2NzcyQvaSwgXCJ0ZXh0L3gtc2Nzc1wiXSxcbiAgICAgIFtcInR5cGVcIiwgL14odGV4dFxcLyk/KHgtKT9sZXNzJC9pLCBcInRleHQveC1sZXNzXCJdXG4gICAgXSxcbiAgICB0ZW1wbGF0ZTogW1xuICAgICAgW1wibGFuZ1wiLCAvXnZ1ZS10ZW1wbGF0ZSQvaSwgXCJ2dWVcIl0sXG4gICAgICBbXCJsYW5nXCIsIC9ecHVnJC9pLCBcInB1Z1wiXSxcbiAgICAgIFtcImxhbmdcIiwgL15oYW5kbGViYXJzJC9pLCBcImhhbmRsZWJhcnNcIl0sXG4gICAgICBbXCJ0eXBlXCIsIC9eKHRleHRcXC8pPyh4LSk/cHVnJC9pLCBcInB1Z1wiXSxcbiAgICAgIFtcInR5cGVcIiwgL150ZXh0XFwveC1oYW5kbGViYXJzLXRlbXBsYXRlJC9pLCBcImhhbmRsZWJhcnNcIl0sXG4gICAgICBbbnVsbCwgbnVsbCwgXCJ2dWUtdGVtcGxhdGVcIl1cbiAgICBdXG4gIH07XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwidnVlLXRlbXBsYXRlXCIsIGZ1bmN0aW9uIChjb25maWcsIHBhcnNlckNvbmZpZykge1xuICAgIHZhciBtdXN0YWNoZU92ZXJsYXkgPSB7XG4gICAgICB0b2tlbjogZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eXFx7XFx7Lio/XFx9XFx9LykpIHJldHVybiBcIm1ldGEgbXVzdGFjaGVcIjtcbiAgICAgICAgd2hpbGUgKHN0cmVhbS5uZXh0KCkgJiYgIXN0cmVhbS5tYXRjaChcInt7XCIsIGZhbHNlKSkge31cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ29kZU1pcnJvci5vdmVybGF5TW9kZShDb2RlTWlycm9yLmdldE1vZGUoY29uZmlnLCBwYXJzZXJDb25maWcuYmFja2Ryb3AgfHwgXCJ0ZXh0L2h0bWxcIiksIG11c3RhY2hlT3ZlcmxheSk7XG4gIH0pO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lTW9kZShcInZ1ZVwiLCBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgcmV0dXJuIENvZGVNaXJyb3IuZ2V0TW9kZShjb25maWcsIHtuYW1lOiBcImh0bWxtaXhlZFwiLCB0YWdzOiB0YWdMYW5ndWFnZXN9KTtcbiAgfSwgXCJodG1sbWl4ZWRcIiwgXCJ4bWxcIiwgXCJqYXZhc2NyaXB0XCIsIFwiY29mZmVlc2NyaXB0XCIsIFwiY3NzXCIsIFwic2Fzc1wiLCBcInN0eWx1c1wiLCBcInB1Z1wiLCBcImhhbmRsZWJhcnNcIik7XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwic2NyaXB0L3gtdnVlXCIsIFwidnVlXCIpO1xuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3gtdnVlXCIsIFwidnVlXCIpO1xufSk7XG4iLCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpLCByZXF1aXJlKFwiLi4vLi4vYWRkb24vbW9kZS9zaW1wbGVcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIiwgXCIuLi8uLi9hZGRvbi9tb2RlL3NpbXBsZVwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcblwidXNlIHN0cmljdFwiO1xuXG52YXIga0tleXdvcmRzID0gW1xuICAgIFwiYWxpZ25cIixcbiAgICBcImJsb2NrXCIsXG4gICAgXCJicihfaWZ8X3RhYmxlfF9vbl8oY2FzdHxkYXRhfGZ1bmN8aTMxfG51bGwpKT9cIixcbiAgICBcImNhbGwoX2luZGlyZWN0fF9yZWYpP1wiLFxuICAgIFwiY3VycmVudF9tZW1vcnlcIixcbiAgICBcIlxcXFxiZGF0YVxcXFxiXCIsXG4gICAgXCJjYXRjaChfYWxsKT9cIixcbiAgICBcImRlbGVnYXRlXCIsXG4gICAgXCJkcm9wXCIsXG4gICAgXCJlbGVtXCIsXG4gICAgXCJlbHNlXCIsXG4gICAgXCJlbmRcIixcbiAgICBcImV4cG9ydFwiLFxuICAgIFwiXFxcXGJleHRlcm5cXFxcYlwiLFxuICAgIFwiXFxcXGJmdW5jXFxcXGJcIixcbiAgICBcImdsb2JhbChcXFxcLihnZXR8c2V0KSk/XCIsXG4gICAgXCJpZlwiLFxuICAgIFwiaW1wb3J0XCIsXG4gICAgXCJsb2NhbChcXFxcLihnZXR8c2V0fHRlZSkpP1wiLFxuICAgIFwibG9vcFwiLFxuICAgIFwibW9kdWxlXCIsXG4gICAgXCJtdXRcIixcbiAgICBcIm5vcFwiLFxuICAgIFwib2Zmc2V0XCIsXG4gICAgXCJwYXJhbVwiLFxuICAgIFwicmVzdWx0XCIsXG4gICAgXCJyZXRocm93XCIsXG4gICAgXCJyZXR1cm4oX2NhbGwoX2luZGlyZWN0fF9yZWYpPyk/XCIsXG4gICAgXCJzZWxlY3RcIixcbiAgICBcInN0YXJ0XCIsXG4gICAgXCJ0YWJsZShcXFxcLihzaXplfGdldHxzZXR8c2l6ZXxncm93fGZpbGx8aW5pdHxjb3B5KSk/XCIsXG4gICAgXCJ0aGVuXCIsXG4gICAgXCJ0aHJvd1wiLFxuICAgIFwidHJ5XCIsXG4gICAgXCJ0eXBlXCIsXG4gICAgXCJ1bnJlYWNoYWJsZVwiLFxuICAgIFwidW53aW5kXCIsXG5cbiAgICAvLyBOdW1lcmljIG9wY29kZXMuXG4gICAgXCJpKDMyfDY0KVxcXFwuKHN0b3JlKDh8MTYpfChsb2FkKDh8MTYpX1tzdV0pKVwiLFxuICAgIFwiaTY0XFxcXC4obG9hZDMyX1tzdV18c3RvcmUzMilcIixcbiAgICBcIltmaV0oMzJ8NjQpXFxcXC4oY29uc3R8bG9hZHxzdG9yZSlcIixcbiAgICBcImYoMzJ8NjQpXFxcXC4oYWJzfGFkZHxjZWlsfGNvcHlzaWdufGRpdnxlcXxmbG9vcnxbZ2xdW2V0XXxtYXh8bWlufG11bHxuZWFyZXN0fG5lZz98c3FydHxzdWJ8dHJ1bmMpXCIsXG4gICAgXCJpKDMyfDY0KVxcXFwuKGFbZG5dZHxjW2x0XXp8KGRpdnxyZW0pX1tzdV18ZXF6P3xbZ2xdW3RlXV9bc3VdfG11bHxuZXxwb3BjbnR8cm90W2xyXXxzaChsfHJfW3N1XSl8c3VifHg/b3IpXCIsXG4gICAgXCJpNjRcXFxcLmV4dGVuZF9bc3VdX2kzMlwiLFxuICAgIFwiaTMyXFxcXC53cmFwX2k2NFwiLFxuICAgIFwiaSgzMnw2NClcXFxcLnRydW5jX2YoMzJ8NjQpX1tzdV1cIixcbiAgICBcImYoMzJ8NjQpXFxcXC5jb252ZXJ0X2koMzJ8NjQpX1tzdV1cIixcbiAgICBcImY2NFxcXFwucHJvbW90ZV9mMzJcIixcbiAgICBcImYzMlxcXFwuZGVtb3RlX2Y2NFwiLFxuICAgIFwiZjMyXFxcXC5yZWludGVycHJldF9pMzJcIixcbiAgICBcImkzMlxcXFwucmVpbnRlcnByZXRfZjMyXCIsXG4gICAgXCJmNjRcXFxcLnJlaW50ZXJwcmV0X2k2NFwiLFxuICAgIFwiaTY0XFxcXC5yZWludGVycHJldF9mNjRcIixcbiAgICAvLyBBdG9taWNzLlxuICAgIFwibWVtb3J5KFxcXFwuKChhdG9taWNcXFxcLihub3RpZnl8d2FpdCgzMnw2NCkpKXxncm93fHNpemUpKT9cIixcbiAgICBcImk2NFxcLmF0b21pY1xcXFwuKGxvYWQzMl91fHN0b3JlMzJ8cm13MzJcXFxcLihhW2RuXWR8c3VifHg/b3J8KGNtcCk/eGNoZylfdSlcIixcbiAgICBcImkoMzJ8NjQpXFxcXC5hdG9taWNcXFxcLihsb2FkKCg4fDE2KV91KT98c3RvcmUoOHwxNik/fHJtdyhcXFxcLihhW2RuXWR8c3VifHg/b3J8KGNtcCk/eGNoZyl8KDh8MTYpXFxcXC4oYVtkbl1kfHN1Ynx4P29yfChjbXApP3hjaGcpX3UpKVwiLFxuICAgIC8vIFNJTUQuXG4gICAgXCJ2MTI4XFxcXC5sb2FkKDh4OHwxNng0fDMyeDIpX1tzdV1cIixcbiAgICBcInYxMjhcXFxcLmxvYWQoOHwxNnwzMnw2NClfc3BsYXRcIixcbiAgICBcInYxMjhcXFxcLihsb2FkfHN0b3JlKSg4fDE2fDMyfDY0KV9sYW5lXCIsXG4gICAgXCJ2MTI4XFxcXC5sb2FkKDMyfDY0KV96ZXJvXCIsXG4gICAgXCJ2MTI4XFwuKGxvYWR8c3RvcmV8Y29uc3R8bm90fGFuZG5vdHxhbmR8b3J8eG9yfGJpdHNlbGVjdHxhbnlfdHJ1ZSlcIixcbiAgICBcImkoOHgxNnwxNng4KVxcXFwuKGV4dHJhY3RfbGFuZV9bc3VdfChhZGR8c3ViKV9zYXRfW3N1XXxhdmdyX3UpXCIsXG4gICAgXCJpKDh4MTZ8MTZ4OHwzMng0fDY0eDIpXFxcXC4obmVnfGFkZHxzdWJ8YWJzfHNobHxzaHJfW3N1XXxhbGxfdHJ1ZXxiaXRtYXNrfGVxfG5lfFtsZ11bdGVdX3MpXCIsXG4gICAgXCIoaSg4eDE2fDE2eDh8MzJ4NHw2NHgyKXxmKDMyeDR8NjR4MikpXFwuKHNwbGF0fHJlcGxhY2VfbGFuZSlcIixcbiAgICBcImkoOHgxNnwxNng4fDMyeDQpXFxcXC4oKFtsZ11bdGVdX3UpfCgobWlufG1heClfW3N1XSkpXCIsXG4gICAgXCJmKDMyeDR8NjR4MilcXFxcLihuZWd8YWRkfHN1YnxhYnN8bmVhcmVzdHxlcXxuZXxbbGddW3RlXXxzcXJ0fG11bHxkaXZ8bWlufG1heHxjZWlsfGZsb29yfHRydW5jKVwiLFxuICAgIFwiW2ZpXSgzMng0fDY0eDIpXFxcXC5leHRyYWN0X2xhbmVcIixcbiAgICBcImk4eDE2XFxcXC4oc2h1ZmZsZXxzd2l6emxlfHBvcGNudHxuYXJyb3dfaTE2eDhfW3N1XSlcIixcbiAgICBcImkxNng4XFxcXC4obmFycm93X2kzMng0X1tzdV18bXVsfGV4dGFkZF9wYWlyd2lzZV9pOHgxNl9bc3VdfHExNW11bHJfc2F0X3MpXCIsXG4gICAgXCJpMTZ4OFxcXFwuKGV4dGVuZHxleHRtdWwpXyhsb3d8aGlnaClfaTh4MTZfW3N1XVwiLFxuICAgIFwiaTMyeDRcXFxcLihtdWx8ZG90X2kxNng4X3N8dHJ1bmNfc2F0X2Y2NHgyX1tzdV1femVybylcIixcbiAgICBcImkzMng0XFxcXC4oKGV4dGVuZHxleHRtdWwpXyhsb3d8aGlnaClfaTE2eDhffHRydW5jX3NhdF9mMzJ4NF98ZXh0YWRkX3BhaXJ3aXNlX2kxNng4Xylbc3VdXCIsXG4gICAgXCJpNjR4MlxcXFwuKG11bHwoZXh0ZW5kfGV4dG11bClfKGxvd3xoaWdoKV9pMzJ4NF9bc3VdKVwiLFxuICAgIFwiZjMyeDRcXFxcLihjb252ZXJ0X2kzMng0X1tzdV18ZGVtb3RlX2Y2NHgyX3plcm8pXCIsXG4gICAgXCJmNjR4MlxcXFwuKHByb21vdGVfbG93X2YzMng0fGNvbnZlcnRfbG93X2kzMng0X1tzdV0pXCIsXG4gICAgLy8gUmVmZXJlbmNlIHR5cGVzLCBmdW5jdGlvbiByZWZlcmVuY2VzLCBhbmQgR0MuXG4gICAgXCJcXFxcYmFueVxcXFxiXCIsXG4gICAgXCJhcnJheVxcXFwubGVuXCIsXG4gICAgXCIoYXJyYXl8c3RydWN0KShcXFxcLihuZXdfKGRlZmF1bHRfKT93aXRoX3J0dHxnZXQoX1tzdV0pP3xzZXQpKT9cIixcbiAgICBcIlxcXFxiZXFcXFxcYlwiLFxuICAgIFwiZmllbGRcIixcbiAgICBcImkzMVxcXFwuKG5ld3xnZXRfW3N1XSlcIixcbiAgICBcIlxcXFxibnVsbFxcXFxiXCIsXG4gICAgXCJyZWYoXFxcXC4oKFthaV1zXyhkYXRhfGZ1bmN8aTMxKSl8Y2FzdHxlcXxmdW5jfChpc198YXNfbm9uXyk/bnVsbHx0ZXN0KSk/XCIsXG4gICAgXCJydHQoXFxcXC4oY2Fub258c3ViKSk/XCIsXG5dO1xuXG5Db2RlTWlycm9yLmRlZmluZVNpbXBsZU1vZGUoJ3dhc3QnLCB7XG4gIHN0YXJ0OiBbXG4gICAge3JlZ2V4OiAvWytcXC1dPyg/Om5hbig/OjoweFswLTlhLWZBLUZdKyk/fGluZmluaXR5fGluZnwweFswLTlhLWZBLUZdK1xcLj9bMC05YS1mQS1GXSpwWytcXC8tXT9cXGQrfFxcZCsoPzpcXC5cXGQqKT9bZUVdWytcXC1dP1xcZCp8XFxkK1xcLlxcZCp8MHhbMC05YS1mQS1GXSt8XFxkKykvLCB0b2tlbjogXCJudW1iZXJcIn0sXG4gICAge3JlZ2V4OiBuZXcgUmVnRXhwKGtLZXl3b3Jkcy5qb2luKCd8JykpLCB0b2tlbjogXCJrZXl3b3JkXCJ9LFxuICAgIHtyZWdleDogL1xcYigoYW55fGRhdGF8ZXF8ZXh0ZXJufGkzMXxmdW5jKXJlZnxbZmldKDMyfDY0KXxpKDh8MTYpKVxcYi8sIHRva2VuOiBcImF0b21cIn0sXG4gICAge3JlZ2V4OiAvXFwkKFthLXpBLVowLTlfYFxcK1xcLVxcKlxcL1xcXFxcXF5+PTw+IVxcP0AjJCUmfDpcXC5dKykvLCB0b2tlbjogXCJ2YXJpYWJsZS0yXCJ9LFxuICAgIHtyZWdleDogL1wiKD86W15cIlxcXFxcXHgwMC1cXHgxZlxceDdmXXxcXFxcW250XFxcXCdcIl18XFxcXFswLTlhLWZBLUZdWzAtOWEtZkEtRl0pKlwiLywgdG9rZW46IFwic3RyaW5nXCJ9LFxuICAgIHtyZWdleDogL1xcKDsuKj8vLCB0b2tlbjogXCJjb21tZW50XCIsIG5leHQ6IFwiY29tbWVudFwifSxcbiAgICB7cmVnZXg6IC87Oy4qJC8sIHRva2VuOiBcImNvbW1lbnRcIn0sXG4gICAge3JlZ2V4OiAvXFwoLywgaW5kZW50OiB0cnVlfSxcbiAgICB7cmVnZXg6IC9cXCkvLCBkZWRlbnQ6IHRydWV9LFxuICBdLFxuXG4gIGNvbW1lbnQ6IFtcbiAgICB7cmVnZXg6IC8uKj87XFwpLywgdG9rZW46IFwiY29tbWVudFwiLCBuZXh0OiBcInN0YXJ0XCJ9LFxuICAgIHtyZWdleDogLy4qLywgdG9rZW46IFwiY29tbWVudFwifSxcbiAgXSxcblxuICBtZXRhOiB7XG4gICAgZG9udEluZGVudFN0YXRlczogWydjb21tZW50J10sXG4gIH0sXG59KTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL1dlYkFzc2VtYmx5L2Rlc2lnbi9pc3N1ZXMvOTgxIG1lbnRpb25zIHRleHQvd2ViYXNzZW1ibHksXG4vLyB3aGljaCBzZWVtcyBsaWtlIGEgcmVhc29uYWJsZSBjaG9pY2UsIGFsdGhvdWdoIGl0J3Mgbm90IHN0YW5kYXJkIHJpZ2h0IG5vdy5cbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQvd2ViYXNzZW1ibHlcIiwgXCJ3YXN0XCIpO1xuXG59KTtcbiIsIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gd29yZFJlZ2V4cCh3b3Jkcykge1xuICByZXR1cm4gbmV3IFJlZ0V4cChcIl4oKFwiICsgd29yZHMuam9pbihcIil8KFwiKSArIFwiKSlcXFxcYlwiKTtcbn07XG5cbnZhciBidWlsdGluQXJyYXkgPSBbXG4gIFwiQ2xhbXBcIixcbiAgXCJDb25zdHJ1Y3RvclwiLFxuICBcIkVuZm9yY2VSYW5nZVwiLFxuICBcIkV4cG9zZWRcIixcbiAgXCJJbXBsaWNpdFRoaXNcIixcbiAgXCJHbG9iYWxcIiwgXCJQcmltYXJ5R2xvYmFsXCIsXG4gIFwiTGVnYWN5QXJyYXlDbGFzc1wiLFxuICBcIkxlZ2FjeVVuZW51bWVyYWJsZU5hbWVkUHJvcGVydGllc1wiLFxuICBcIkxlbmllbnRUaGlzXCIsXG4gIFwiTmFtZWRDb25zdHJ1Y3RvclwiLFxuICBcIk5ld09iamVjdFwiLFxuICBcIk5vSW50ZXJmYWNlT2JqZWN0XCIsXG4gIFwiT3ZlcnJpZGVCdWlsdGluc1wiLFxuICBcIlB1dEZvcndhcmRzXCIsXG4gIFwiUmVwbGFjZWFibGVcIixcbiAgXCJTYW1lT2JqZWN0XCIsXG4gIFwiVHJlYXROb25PYmplY3RBc051bGxcIixcbiAgXCJUcmVhdE51bGxBc1wiLFxuICAgIFwiRW1wdHlTdHJpbmdcIixcbiAgXCJVbmZvcmdlYWJsZVwiLFxuICBcIlVuc2NvcGVhYmxlXCJcbl07XG52YXIgYnVpbHRpbnMgPSB3b3JkUmVnZXhwKGJ1aWx0aW5BcnJheSk7XG5cbnZhciB0eXBlQXJyYXkgPSBbXG4gIFwidW5zaWduZWRcIiwgXCJzaG9ydFwiLCBcImxvbmdcIiwgICAgICAgICAgICAgICAgICAvLyBVbnNpZ25lZEludGVnZXJUeXBlXG4gIFwidW5yZXN0cmljdGVkXCIsIFwiZmxvYXRcIiwgXCJkb3VibGVcIiwgICAgICAgICAgICAvLyBVbnJlc3RyaWN0ZWRGbG9hdFR5cGVcbiAgXCJib29sZWFuXCIsIFwiYnl0ZVwiLCBcIm9jdGV0XCIsICAgICAgICAgICAgICAgICAgIC8vIFJlc3Qgb2YgUHJpbWl0aXZlVHlwZVxuICBcIlByb21pc2VcIiwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcm9taXNlVHlwZVxuICBcIkFycmF5QnVmZmVyXCIsIFwiRGF0YVZpZXdcIiwgXCJJbnQ4QXJyYXlcIiwgXCJJbnQxNkFycmF5XCIsIFwiSW50MzJBcnJheVwiLFxuICBcIlVpbnQ4QXJyYXlcIiwgXCJVaW50MTZBcnJheVwiLCBcIlVpbnQzMkFycmF5XCIsIFwiVWludDhDbGFtcGVkQXJyYXlcIixcbiAgXCJGbG9hdDMyQXJyYXlcIiwgXCJGbG9hdDY0QXJyYXlcIiwgICAgICAgICAgICAgICAvLyBCdWZmZXJSZWxhdGVkVHlwZVxuICBcIkJ5dGVTdHJpbmdcIiwgXCJET01TdHJpbmdcIiwgXCJVU1ZTdHJpbmdcIiwgXCJzZXF1ZW5jZVwiLCBcIm9iamVjdFwiLCBcIlJlZ0V4cFwiLFxuICBcIkVycm9yXCIsIFwiRE9NRXhjZXB0aW9uXCIsIFwiRnJvemVuQXJyYXlcIiwgICAgICAgLy8gUmVzdCBvZiBOb25BbnlUeXBlXG4gIFwiYW55XCIsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc3Qgb2YgU2luZ2xlVHlwZVxuICBcInZvaWRcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXN0IG9mIFJldHVyblR5cGVcbl07XG52YXIgdHlwZXMgPSB3b3JkUmVnZXhwKHR5cGVBcnJheSk7XG5cbnZhciBrZXl3b3JkQXJyYXkgPSBbXG4gIFwiYXR0cmlidXRlXCIsIFwiY2FsbGJhY2tcIiwgXCJjb25zdFwiLCBcImRlbGV0ZXJcIiwgXCJkaWN0aW9uYXJ5XCIsIFwiZW51bVwiLCBcImdldHRlclwiLFxuICBcImltcGxlbWVudHNcIiwgXCJpbmhlcml0XCIsIFwiaW50ZXJmYWNlXCIsIFwiaXRlcmFibGVcIiwgXCJsZWdhY3ljYWxsZXJcIiwgXCJtYXBsaWtlXCIsXG4gIFwicGFydGlhbFwiLCBcInJlcXVpcmVkXCIsIFwic2VyaWFsaXplclwiLCBcInNldGxpa2VcIiwgXCJzZXR0ZXJcIiwgXCJzdGF0aWNcIixcbiAgXCJzdHJpbmdpZmllclwiLCBcInR5cGVkZWZcIiwgICAgICAgICAgICAgICAgICAgICAvLyBBcmd1bWVudE5hbWVLZXl3b3JkIGV4Y2VwdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gXCJ1bnJlc3RyaWN0ZWRcIlxuICBcIm9wdGlvbmFsXCIsIFwicmVhZG9ubHlcIiwgXCJvclwiXG5dO1xudmFyIGtleXdvcmRzID0gd29yZFJlZ2V4cChrZXl3b3JkQXJyYXkpO1xuXG52YXIgYXRvbUFycmF5ID0gW1xuICBcInRydWVcIiwgXCJmYWxzZVwiLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJvb2xlYW5MaXRlcmFsXG4gIFwiSW5maW5pdHlcIiwgXCJOYU5cIiwgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmxvYXRMaXRlcmFsXG4gIFwibnVsbFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc3Qgb2YgQ29uc3RWYWx1ZVxuXTtcbnZhciBhdG9tcyA9IHdvcmRSZWdleHAoYXRvbUFycmF5KTtcblxuQ29kZU1pcnJvci5yZWdpc3RlckhlbHBlcihcImhpbnRXb3Jkc1wiLCBcIndlYmlkbFwiLFxuICAgIGJ1aWx0aW5BcnJheS5jb25jYXQodHlwZUFycmF5KS5jb25jYXQoa2V5d29yZEFycmF5KS5jb25jYXQoYXRvbUFycmF5KSk7XG5cbnZhciBzdGFydERlZkFycmF5ID0gW1wiY2FsbGJhY2tcIiwgXCJkaWN0aW9uYXJ5XCIsIFwiZW51bVwiLCBcImludGVyZmFjZVwiXTtcbnZhciBzdGFydERlZnMgPSB3b3JkUmVnZXhwKHN0YXJ0RGVmQXJyYXkpO1xuXG52YXIgZW5kRGVmQXJyYXkgPSBbXCJ0eXBlZGVmXCJdO1xudmFyIGVuZERlZnMgPSB3b3JkUmVnZXhwKGVuZERlZkFycmF5KTtcblxudmFyIHNpbmdsZU9wZXJhdG9ycyA9IC9eWzo8PT4/XS87XG52YXIgaW50ZWdlcnMgPSAvXi0/KFsxLTldWzAtOV0qfDBbWHhdWzAtOUEtRmEtZl0rfDBbMC03XSopLztcbnZhciBmbG9hdHMgPSAvXi0/KChbMC05XStcXC5bMC05XSp8WzAtOV0qXFwuWzAtOV0rKShbRWVdWystXT9bMC05XSspP3xbMC05XStbRWVdWystXT9bMC05XSspLztcbnZhciBpZGVudGlmaWVycyA9IC9eXz9bQS1aYS16XVswLTlBLVpfYS16LV0qLztcbnZhciBpZGVudGlmaWVyc0VuZCA9IC9eXz9bQS1aYS16XVswLTlBLVpfYS16LV0qKD89XFxzKjspLztcbnZhciBzdHJpbmdzID0gL15cIlteXCJdKlwiLztcbnZhciBtdWx0aWxpbmVDb21tZW50cyA9IC9eXFwvXFwqLio/XFwqXFwvLztcbnZhciBtdWx0aWxpbmVDb21tZW50c1N0YXJ0ID0gL15cXC9cXCouKi87XG52YXIgbXVsdGlsaW5lQ29tbWVudHNFbmQgPSAvXi4qP1xcKlxcLy87XG5cbmZ1bmN0aW9uIHJlYWRUb2tlbihzdHJlYW0sIHN0YXRlKSB7XG4gIC8vIHdoaXRlc3BhY2VcbiAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSByZXR1cm4gbnVsbDtcblxuICAvLyBjb21tZW50XG4gIGlmIChzdGF0ZS5pbkNvbW1lbnQpIHtcbiAgICBpZiAoc3RyZWFtLm1hdGNoKG11bHRpbGluZUNvbW1lbnRzRW5kKSkge1xuICAgICAgc3RhdGUuaW5Db21tZW50ID0gZmFsc2U7XG4gICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgfVxuICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gIH1cbiAgaWYgKHN0cmVhbS5tYXRjaChcIi8vXCIpKSB7XG4gICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgfVxuICBpZiAoc3RyZWFtLm1hdGNoKG11bHRpbGluZUNvbW1lbnRzKSkgcmV0dXJuIFwiY29tbWVudFwiO1xuICBpZiAoc3RyZWFtLm1hdGNoKG11bHRpbGluZUNvbW1lbnRzU3RhcnQpKSB7XG4gICAgc3RhdGUuaW5Db21tZW50ID0gdHJ1ZTtcbiAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gIH1cblxuICAvLyBpbnRlZ2VyIGFuZCBmbG9hdFxuICBpZiAoc3RyZWFtLm1hdGNoKC9eLT9bMC05XFwuXS8sIGZhbHNlKSkge1xuICAgIGlmIChzdHJlYW0ubWF0Y2goaW50ZWdlcnMpIHx8IHN0cmVhbS5tYXRjaChmbG9hdHMpKSByZXR1cm4gXCJudW1iZXJcIjtcbiAgfVxuXG4gIC8vIHN0cmluZ1xuICBpZiAoc3RyZWFtLm1hdGNoKHN0cmluZ3MpKSByZXR1cm4gXCJzdHJpbmdcIjtcblxuICAvLyBpZGVudGlmaWVyXG4gIGlmIChzdGF0ZS5zdGFydERlZiAmJiBzdHJlYW0ubWF0Y2goaWRlbnRpZmllcnMpKSByZXR1cm4gXCJkZWZcIjtcblxuICBpZiAoc3RhdGUuZW5kRGVmICYmIHN0cmVhbS5tYXRjaChpZGVudGlmaWVyc0VuZCkpIHtcbiAgICBzdGF0ZS5lbmREZWYgPSBmYWxzZTtcbiAgICByZXR1cm4gXCJkZWZcIjtcbiAgfVxuXG4gIGlmIChzdHJlYW0ubWF0Y2goa2V5d29yZHMpKSByZXR1cm4gXCJrZXl3b3JkXCI7XG5cbiAgaWYgKHN0cmVhbS5tYXRjaCh0eXBlcykpIHtcbiAgICB2YXIgbGFzdFRva2VuID0gc3RhdGUubGFzdFRva2VuO1xuICAgIHZhciBuZXh0VG9rZW4gPSAoc3RyZWFtLm1hdGNoKC9eXFxzKiguKz8pXFxiLywgZmFsc2UpIHx8IFtdKVsxXTtcblxuICAgIGlmIChsYXN0VG9rZW4gPT09IFwiOlwiIHx8IGxhc3RUb2tlbiA9PT0gXCJpbXBsZW1lbnRzXCIgfHxcbiAgICAgICAgbmV4dFRva2VuID09PSBcImltcGxlbWVudHNcIiB8fCBuZXh0VG9rZW4gPT09IFwiPVwiKSB7XG4gICAgICAvLyBVc2VkIGFzIGlkZW50aWZpZXJcbiAgICAgIHJldHVybiBcImJ1aWx0aW5cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXNlZCBhcyB0eXBlXG4gICAgICByZXR1cm4gXCJ2YXJpYWJsZS0zXCI7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0cmVhbS5tYXRjaChidWlsdGlucykpIHJldHVybiBcImJ1aWx0aW5cIjtcbiAgaWYgKHN0cmVhbS5tYXRjaChhdG9tcykpIHJldHVybiBcImF0b21cIjtcbiAgaWYgKHN0cmVhbS5tYXRjaChpZGVudGlmaWVycykpIHJldHVybiBcInZhcmlhYmxlXCI7XG5cbiAgLy8gb3RoZXJcbiAgaWYgKHN0cmVhbS5tYXRjaChzaW5nbGVPcGVyYXRvcnMpKSByZXR1cm4gXCJvcGVyYXRvclwiO1xuXG4gIC8vIHVucmVjb2duaXplZFxuICBzdHJlYW0ubmV4dCgpO1xuICByZXR1cm4gbnVsbDtcbn07XG5cbkNvZGVNaXJyb3IuZGVmaW5lTW9kZShcIndlYmlkbFwiLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC8vIElzIGluIG11bHRpbGluZSBjb21tZW50XG4gICAgICAgIGluQ29tbWVudDogZmFsc2UsXG4gICAgICAgIC8vIExhc3Qgbm9uLXdoaXRlc3BhY2UsIG1hdGNoZWQgdG9rZW5cbiAgICAgICAgbGFzdFRva2VuOiBcIlwiLFxuICAgICAgICAvLyBOZXh0IHRva2VuIGlzIGEgZGVmaW5pdGlvblxuICAgICAgICBzdGFydERlZjogZmFsc2UsXG4gICAgICAgIC8vIExhc3QgdG9rZW4gb2YgdGhlIHN0YXRlbWVudCBpcyBhIGRlZmluaXRpb25cbiAgICAgICAgZW5kRGVmOiBmYWxzZVxuICAgICAgfTtcbiAgICB9LFxuICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgc3R5bGUgPSByZWFkVG9rZW4oc3RyZWFtLCBzdGF0ZSk7XG5cbiAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICB2YXIgY3VyID0gc3RyZWFtLmN1cnJlbnQoKTtcbiAgICAgICAgc3RhdGUubGFzdFRva2VuID0gY3VyO1xuICAgICAgICBpZiAoc3R5bGUgPT09IFwia2V5d29yZFwiKSB7XG4gICAgICAgICAgc3RhdGUuc3RhcnREZWYgPSBzdGFydERlZnMudGVzdChjdXIpO1xuICAgICAgICAgIHN0YXRlLmVuZERlZiA9IHN0YXRlLmVuZERlZiB8fCBlbmREZWZzLnRlc3QoY3VyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS5zdGFydERlZiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9XG4gIH07XG59KTtcblxuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LXdlYmlkbFwiLCBcIndlYmlkbFwiKTtcbn0pO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcblwidXNlIHN0cmljdFwiO1xuXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoXCJ4cXVlcnlcIiwgZnVuY3Rpb24oKSB7XG5cbiAgLy8gVGhlIGtleXdvcmRzIG9iamVjdCBpcyBzZXQgdG8gdGhlIHJlc3VsdCBvZiB0aGlzIHNlbGYgZXhlY3V0aW5nXG4gIC8vIGZ1bmN0aW9uLiBFYWNoIGtleXdvcmQgaXMgYSBwcm9wZXJ0eSBvZiB0aGUga2V5d29yZHMgb2JqZWN0IHdob3NlXG4gIC8vIHZhbHVlIGlzIHt0eXBlOiBhdHlwZSwgc3R5bGU6IGFzdHlsZX1cbiAgdmFyIGtleXdvcmRzID0gZnVuY3Rpb24oKXtcbiAgICAvLyBjb252ZW5pZW5jZSBmdW5jdGlvbnMgdXNlZCB0byBidWlsZCBrZXl3b3JkcyBvYmplY3RcbiAgICBmdW5jdGlvbiBrdyh0eXBlKSB7cmV0dXJuIHt0eXBlOiB0eXBlLCBzdHlsZTogXCJrZXl3b3JkXCJ9O31cbiAgICB2YXIgb3BlcmF0b3IgPSBrdyhcIm9wZXJhdG9yXCIpXG4gICAgICAsIGF0b20gPSB7dHlwZTogXCJhdG9tXCIsIHN0eWxlOiBcImF0b21cIn1cbiAgICAgICwgcHVuY3R1YXRpb24gPSB7dHlwZTogXCJwdW5jdHVhdGlvblwiLCBzdHlsZTogbnVsbH1cbiAgICAgICwgcXVhbGlmaWVyID0ge3R5cGU6IFwiYXhpc19zcGVjaWZpZXJcIiwgc3R5bGU6IFwicXVhbGlmaWVyXCJ9O1xuXG4gICAgLy8ga3dPYmogaXMgd2hhdCBpcyByZXR1cm4gZnJvbSB0aGlzIGZ1bmN0aW9uIGF0IHRoZSBlbmRcbiAgICB2YXIga3dPYmogPSB7XG4gICAgICAnLCc6IHB1bmN0dWF0aW9uXG4gICAgfTtcblxuICAgIC8vIGEgbGlzdCBvZiAnYmFzaWMnIGtleXdvcmRzLiBGb3IgZWFjaCBhZGQgYSBwcm9wZXJ0eSB0byBrd09iaiB3aXRoIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHt0eXBlOiBiYXNpY1tpXSwgc3R5bGU6IFwia2V5d29yZFwifSBlLmcuICdhZnRlcicgLS0+IHt0eXBlOiBcImFmdGVyXCIsIHN0eWxlOiBcImtleXdvcmRcIn1cbiAgICB2YXIgYmFzaWMgPSBbJ2FmdGVyJywgJ2FsbCcsICdhbGxvd2luZycsICdhbmNlc3RvcicsICdhbmNlc3Rvci1vci1zZWxmJywgJ2FueScsICdhcnJheScsICdhcycsXG4gICAgJ2FzY2VuZGluZycsICdhdCcsICdhdHRyaWJ1dGUnLCAnYmFzZS11cmknLCAnYmVmb3JlJywgJ2JvdW5kYXJ5LXNwYWNlJywgJ2J5JywgJ2Nhc2UnLCAnY2FzdCcsXG4gICAgJ2Nhc3RhYmxlJywgJ2NhdGNoJywgJ2NoaWxkJywgJ2NvbGxhdGlvbicsICdjb21tZW50JywgJ2NvbnN0cnVjdGlvbicsICdjb250YWlucycsICdjb250ZW50JyxcbiAgICAnY29udGV4dCcsICdjb3B5JywgJ2NvcHktbmFtZXNwYWNlcycsICdjb3VudCcsICdkZWNpbWFsLWZvcm1hdCcsICdkZWNsYXJlJywgJ2RlZmF1bHQnLCAnZGVsZXRlJyxcbiAgICAnZGVzY2VuZGFudCcsICdkZXNjZW5kYW50LW9yLXNlbGYnLCAnZGVzY2VuZGluZycsICdkaWFjcml0aWNzJywgJ2RpZmZlcmVudCcsICdkaXN0YW5jZScsXG4gICAgJ2RvY3VtZW50JywgJ2RvY3VtZW50LW5vZGUnLCAnZWxlbWVudCcsICdlbHNlJywgJ2VtcHR5JywgJ2VtcHR5LXNlcXVlbmNlJywgJ2VuY29kaW5nJywgJ2VuZCcsXG4gICAgJ2VudGlyZScsICdldmVyeScsICdleGFjdGx5JywgJ2V4Y2VwdCcsICdleHRlcm5hbCcsICdmaXJzdCcsICdmb2xsb3dpbmcnLCAnZm9sbG93aW5nLXNpYmxpbmcnLFxuICAgICdmb3InLCAnZnJvbScsICdmdGFuZCcsICdmdG5vdCcsICdmdC1vcHRpb24nLCAnZnRvcicsICdmdW5jdGlvbicsICdmdXp6eScsICdncmVhdGVzdCcsICdncm91cCcsXG4gICAgJ2lmJywgJ2ltcG9ydCcsICdpbicsICdpbmhlcml0JywgJ2luc2Vuc2l0aXZlJywgJ2luc2VydCcsICdpbnN0YW5jZScsICdpbnRlcnNlY3QnLCAnaW50bycsXG4gICAgJ2ludm9rZScsICdpcycsICdpdGVtJywgJ2xhbmd1YWdlJywgJ2xhc3QnLCAnbGF4JywgJ2xlYXN0JywgJ2xldCcsICdsZXZlbHMnLCAnbG93ZXJjYXNlJywgJ21hcCcsXG4gICAgJ21vZGlmeScsICdtb2R1bGUnLCAnbW9zdCcsICduYW1lc3BhY2UnLCAnbmV4dCcsICdubycsICdub2RlJywgJ25vZGVzJywgJ25vLWluaGVyaXQnLFxuICAgICduby1wcmVzZXJ2ZScsICdub3QnLCAnb2NjdXJzJywgJ29mJywgJ29ubHknLCAnb3B0aW9uJywgJ29yZGVyJywgJ29yZGVyZWQnLCAnb3JkZXJpbmcnLFxuICAgICdwYXJhZ3JhcGgnLCAncGFyYWdyYXBocycsICdwYXJlbnQnLCAncGhyYXNlJywgJ3ByZWNlZGluZycsICdwcmVjZWRpbmctc2libGluZycsICdwcmVzZXJ2ZScsXG4gICAgJ3ByZXZpb3VzJywgJ3Byb2Nlc3NpbmctaW5zdHJ1Y3Rpb24nLCAncmVsYXRpb25zaGlwJywgJ3JlbmFtZScsICdyZXBsYWNlJywgJ3JldHVybicsXG4gICAgJ3JldmFsaWRhdGlvbicsICdzYW1lJywgJ3NhdGlzZmllcycsICdzY2hlbWEnLCAnc2NoZW1hLWF0dHJpYnV0ZScsICdzY2hlbWEtZWxlbWVudCcsICdzY29yZScsXG4gICAgJ3NlbGYnLCAnc2Vuc2l0aXZlJywgJ3NlbnRlbmNlJywgJ3NlbnRlbmNlcycsICdzZXF1ZW5jZScsICdza2lwJywgJ3NsaWRpbmcnLCAnc29tZScsICdzdGFibGUnLFxuICAgICdzdGFydCcsICdzdGVtbWluZycsICdzdG9wJywgJ3N0cmljdCcsICdzdHJpcCcsICdzd2l0Y2gnLCAndGV4dCcsICd0aGVuJywgJ3RoZXNhdXJ1cycsICd0aW1lcycsXG4gICAgJ3RvJywgJ3RyYW5zZm9ybScsICd0cmVhdCcsICd0cnknLCAndHVtYmxpbmcnLCAndHlwZScsICd0eXBlc3dpdGNoJywgJ3VuaW9uJywgJ3Vub3JkZXJlZCcsXG4gICAgJ3VwZGF0ZScsICd1cGRhdGluZycsICd1cHBlcmNhc2UnLCAndXNpbmcnLCAndmFsaWRhdGUnLCAndmFsdWUnLCAndmFyaWFibGUnLCAndmVyc2lvbicsXG4gICAgJ3dlaWdodCcsICd3aGVuJywgJ3doZXJlJywgJ3dpbGRjYXJkcycsICd3aW5kb3cnLCAnd2l0aCcsICd3aXRob3V0JywgJ3dvcmQnLCAnd29yZHMnLCAneHF1ZXJ5J107XG4gICAgZm9yKHZhciBpPTAsIGw9YmFzaWMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7IGt3T2JqW2Jhc2ljW2ldXSA9IGt3KGJhc2ljW2ldKTt9O1xuXG4gICAgLy8gYSBsaXN0IG9mIHR5cGVzLiBGb3IgZWFjaCBhZGQgYSBwcm9wZXJ0eSB0byBrd09iaiB3aXRoIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHt0eXBlOiBcImF0b21cIiwgc3R5bGU6IFwiYXRvbVwifVxuICAgIHZhciB0eXBlcyA9IFsneHM6YW55QXRvbWljVHlwZScsICd4czphbnlTaW1wbGVUeXBlJywgJ3hzOmFueVR5cGUnLCAneHM6YW55VVJJJyxcbiAgICAneHM6YmFzZTY0QmluYXJ5JywgJ3hzOmJvb2xlYW4nLCAneHM6Ynl0ZScsICd4czpkYXRlJywgJ3hzOmRhdGVUaW1lJywgJ3hzOmRhdGVUaW1lU3RhbXAnLFxuICAgICd4czpkYXlUaW1lRHVyYXRpb24nLCAneHM6ZGVjaW1hbCcsICd4czpkb3VibGUnLCAneHM6ZHVyYXRpb24nLCAneHM6RU5USVRJRVMnLCAneHM6RU5USVRZJyxcbiAgICAneHM6ZmxvYXQnLCAneHM6Z0RheScsICd4czpnTW9udGgnLCAneHM6Z01vbnRoRGF5JywgJ3hzOmdZZWFyJywgJ3hzOmdZZWFyTW9udGgnLCAneHM6aGV4QmluYXJ5JyxcbiAgICAneHM6SUQnLCAneHM6SURSRUYnLCAneHM6SURSRUZTJywgJ3hzOmludCcsICd4czppbnRlZ2VyJywgJ3hzOml0ZW0nLCAneHM6amF2YScsICd4czpsYW5ndWFnZScsXG4gICAgJ3hzOmxvbmcnLCAneHM6TmFtZScsICd4czpOQ05hbWUnLCAneHM6bmVnYXRpdmVJbnRlZ2VyJywgJ3hzOk5NVE9LRU4nLCAneHM6Tk1UT0tFTlMnLFxuICAgICd4czpub25OZWdhdGl2ZUludGVnZXInLCAneHM6bm9uUG9zaXRpdmVJbnRlZ2VyJywgJ3hzOm5vcm1hbGl6ZWRTdHJpbmcnLCAneHM6Tk9UQVRJT04nLFxuICAgICd4czpudW1lcmljJywgJ3hzOnBvc2l0aXZlSW50ZWdlcicsICd4czpwcmVjaXNpb25EZWNpbWFsJywgJ3hzOlFOYW1lJywgJ3hzOnNob3J0JywgJ3hzOnN0cmluZycsXG4gICAgJ3hzOnRpbWUnLCAneHM6dG9rZW4nLCAneHM6dW5zaWduZWRCeXRlJywgJ3hzOnVuc2lnbmVkSW50JywgJ3hzOnVuc2lnbmVkTG9uZycsXG4gICAgJ3hzOnVuc2lnbmVkU2hvcnQnLCAneHM6dW50eXBlZCcsICd4czp1bnR5cGVkQXRvbWljJywgJ3hzOnllYXJNb250aER1cmF0aW9uJ107XG4gICAgZm9yKHZhciBpPTAsIGw9dHlwZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7IGt3T2JqW3R5cGVzW2ldXSA9IGF0b207fTtcblxuICAgIC8vIGVhY2ggb3BlcmF0b3Igd2lsbCBhZGQgYSBwcm9wZXJ0eSB0byBrd09iaiB3aXRoIHZhbHVlIG9mIHt0eXBlOiBcIm9wZXJhdG9yXCIsIHN0eWxlOiBcImtleXdvcmRcIn1cbiAgICB2YXIgb3BlcmF0b3JzID0gWydlcScsICduZScsICdsdCcsICdsZScsICdndCcsICdnZScsICc6PScsICc9JywgJz4nLCAnPj0nLCAnPCcsICc8PScsICcuJywgJ3wnLCAnPycsICdhbmQnLCAnb3InLCAnZGl2JywgJ2lkaXYnLCAnbW9kJywgJyonLCAnLycsICcrJywgJy0nXTtcbiAgICBmb3IodmFyIGk9MCwgbD1vcGVyYXRvcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7IGt3T2JqW29wZXJhdG9yc1tpXV0gPSBvcGVyYXRvcjt9O1xuXG4gICAgLy8gZWFjaCBheGlzX3NwZWNpZmllcnMgd2lsbCBhZGQgYSBwcm9wZXJ0eSB0byBrd09iaiB3aXRoIHZhbHVlIG9mIHt0eXBlOiBcImF4aXNfc3BlY2lmaWVyXCIsIHN0eWxlOiBcInF1YWxpZmllclwifVxuICAgIHZhciBheGlzX3NwZWNpZmllcnMgPSBbXCJzZWxmOjpcIiwgXCJhdHRyaWJ1dGU6OlwiLCBcImNoaWxkOjpcIiwgXCJkZXNjZW5kYW50OjpcIiwgXCJkZXNjZW5kYW50LW9yLXNlbGY6OlwiLCBcInBhcmVudDo6XCIsXG4gICAgXCJhbmNlc3Rvcjo6XCIsIFwiYW5jZXN0b3Itb3Itc2VsZjo6XCIsIFwiZm9sbG93aW5nOjpcIiwgXCJwcmVjZWRpbmc6OlwiLCBcImZvbGxvd2luZy1zaWJsaW5nOjpcIiwgXCJwcmVjZWRpbmctc2libGluZzo6XCJdO1xuICAgIGZvcih2YXIgaT0wLCBsPWF4aXNfc3BlY2lmaWVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHsga3dPYmpbYXhpc19zcGVjaWZpZXJzW2ldXSA9IHF1YWxpZmllcjsgfTtcblxuICAgIHJldHVybiBrd09iajtcbiAgfSgpO1xuXG4gIGZ1bmN0aW9uIGNoYWluKHN0cmVhbSwgc3RhdGUsIGYpIHtcbiAgICBzdGF0ZS50b2tlbml6ZSA9IGY7XG4gICAgcmV0dXJuIGYoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cblxuICAvLyB0aGUgcHJpbWFyeSBtb2RlIHRva2VuaXplclxuICBmdW5jdGlvbiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCksXG4gICAgICAgIG1pZ2h0QmVGdW5jdGlvbiA9IGZhbHNlLFxuICAgICAgICBpc0VRTmFtZSA9IGlzRVFOYW1lQWhlYWQoc3RyZWFtKTtcblxuICAgIC8vIGFuIFhNTCB0YWcgKGlmIG5vdCBpbiBzb21lIHN1YiwgY2hhaW5lZCB0b2tlbml6ZXIpXG4gICAgaWYgKGNoID09IFwiPFwiKSB7XG4gICAgICBpZihzdHJlYW0ubWF0Y2goXCIhLS1cIiwgdHJ1ZSkpXG4gICAgICAgIHJldHVybiBjaGFpbihzdHJlYW0sIHN0YXRlLCB0b2tlblhNTENvbW1lbnQpO1xuXG4gICAgICBpZihzdHJlYW0ubWF0Y2goXCIhW0NEQVRBXCIsIGZhbHNlKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQ0RBVEE7XG4gICAgICAgIHJldHVybiBcInRhZ1wiO1xuICAgICAgfVxuXG4gICAgICBpZihzdHJlYW0ubWF0Y2goXCI/XCIsIGZhbHNlKSkge1xuICAgICAgICByZXR1cm4gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgdG9rZW5QcmVQcm9jZXNzaW5nKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlzY2xvc2UgPSBzdHJlYW0uZWF0KFwiL1wiKTtcbiAgICAgIHN0cmVhbS5lYXRTcGFjZSgpO1xuICAgICAgdmFyIHRhZ05hbWUgPSBcIlwiLCBjO1xuICAgICAgd2hpbGUgKChjID0gc3RyZWFtLmVhdCgvW15cXHNcXHUwMGEwPTw+XFxcIlxcJ1xcLz9dLykpKSB0YWdOYW1lICs9IGM7XG5cbiAgICAgIHJldHVybiBjaGFpbihzdHJlYW0sIHN0YXRlLCB0b2tlblRhZyh0YWdOYW1lLCBpc2Nsb3NlKSk7XG4gICAgfVxuICAgIC8vIHN0YXJ0IGNvZGUgYmxvY2tcbiAgICBlbHNlIGlmKGNoID09IFwie1wiKSB7XG4gICAgICBwdXNoU3RhdGVTdGFjayhzdGF0ZSwgeyB0eXBlOiBcImNvZGVibG9ja1wifSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gZW5kIGNvZGUgYmxvY2tcbiAgICBlbHNlIGlmKGNoID09IFwifVwiKSB7XG4gICAgICBwb3BTdGF0ZVN0YWNrKHN0YXRlKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBpZiB3ZSdyZSBpbiBhbiBYTUwgYmxvY2tcbiAgICBlbHNlIGlmKGlzSW5YbWxCbG9jayhzdGF0ZSkpIHtcbiAgICAgIGlmKGNoID09IFwiPlwiKVxuICAgICAgICByZXR1cm4gXCJ0YWdcIjtcbiAgICAgIGVsc2UgaWYoY2ggPT0gXCIvXCIgJiYgc3RyZWFtLmVhdChcIj5cIikpIHtcbiAgICAgICAgcG9wU3RhdGVTdGFjayhzdGF0ZSk7XG4gICAgICAgIHJldHVybiBcInRhZ1wiO1xuICAgICAgfVxuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xuICAgIH1cbiAgICAvLyBpZiBhIG51bWJlclxuICAgIGVsc2UgaWYgKC9cXGQvLnRlc3QoY2gpKSB7XG4gICAgICBzdHJlYW0ubWF0Y2goL15cXGQqKD86XFwuXFxkKik/KD86RVsrXFwtXT9cXGQrKT8vKTtcbiAgICAgIHJldHVybiBcImF0b21cIjtcbiAgICB9XG4gICAgLy8gY29tbWVudCBzdGFydFxuICAgIGVsc2UgaWYgKGNoID09PSBcIihcIiAmJiBzdHJlYW0uZWF0KFwiOlwiKSkge1xuICAgICAgcHVzaFN0YXRlU3RhY2soc3RhdGUsIHsgdHlwZTogXCJjb21tZW50XCJ9KTtcbiAgICAgIHJldHVybiBjaGFpbihzdHJlYW0sIHN0YXRlLCB0b2tlbkNvbW1lbnQpO1xuICAgIH1cbiAgICAvLyBxdW90ZWQgc3RyaW5nXG4gICAgZWxzZSBpZiAoIWlzRVFOYW1lICYmIChjaCA9PT0gJ1wiJyB8fCBjaCA9PT0gXCInXCIpKVxuICAgICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIHRva2VuU3RyaW5nKGNoKSk7XG4gICAgLy8gdmFyaWFibGVcbiAgICBlbHNlIGlmKGNoID09PSBcIiRcIikge1xuICAgICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIHRva2VuVmFyaWFibGUpO1xuICAgIH1cbiAgICAvLyBhc3NpZ25tZW50XG4gICAgZWxzZSBpZihjaCA9PT1cIjpcIiAmJiBzdHJlYW0uZWF0KFwiPVwiKSkge1xuICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICAgIH1cbiAgICAvLyBvcGVuIHBhcmVuXG4gICAgZWxzZSBpZihjaCA9PT0gXCIoXCIpIHtcbiAgICAgIHB1c2hTdGF0ZVN0YWNrKHN0YXRlLCB7IHR5cGU6IFwicGFyZW5cIn0pO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIGNsb3NlIHBhcmVuXG4gICAgZWxzZSBpZihjaCA9PT0gXCIpXCIpIHtcbiAgICAgIHBvcFN0YXRlU3RhY2soc3RhdGUpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIG9wZW4gcGFyZW5cbiAgICBlbHNlIGlmKGNoID09PSBcIltcIikge1xuICAgICAgcHVzaFN0YXRlU3RhY2soc3RhdGUsIHsgdHlwZTogXCJicmFja2V0XCJ9KTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBjbG9zZSBwYXJlblxuICAgIGVsc2UgaWYoY2ggPT09IFwiXVwiKSB7XG4gICAgICBwb3BTdGF0ZVN0YWNrKHN0YXRlKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBrbm93biA9IGtleXdvcmRzLnByb3BlcnR5SXNFbnVtZXJhYmxlKGNoKSAmJiBrZXl3b3Jkc1tjaF07XG5cbiAgICAgIC8vIGlmIHRoZXJlJ3MgYSBFUU5hbWUgYWhlYWQsIGNvbnN1bWUgdGhlIHJlc3Qgb2YgdGhlIHN0cmluZyBwb3J0aW9uLCBpdCdzIGxpa2VseSBhIGZ1bmN0aW9uXG4gICAgICBpZihpc0VRTmFtZSAmJiBjaCA9PT0gJ1xcXCInKSB3aGlsZShzdHJlYW0ubmV4dCgpICE9PSAnXCInKXt9XG4gICAgICBpZihpc0VRTmFtZSAmJiBjaCA9PT0gJ1xcJycpIHdoaWxlKHN0cmVhbS5uZXh0KCkgIT09ICdcXCcnKXt9XG5cbiAgICAgIC8vIGdvYmJsZSB1cCBhIHdvcmQgaWYgdGhlIGNoYXJhY3RlciBpcyBub3Qga25vd25cbiAgICAgIGlmKCFrbm93bikgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwkXy1dLyk7XG5cbiAgICAgIC8vIGdvYmJsZSBhIGNvbG9uIGluIHRoZSBjYXNlIHRoYXQgaXMgYSBsaWIgZnVuYyB0eXBlIGNhbGwgZm46ZG9jXG4gICAgICB2YXIgZm91bmRDb2xvbiA9IHN0cmVhbS5lYXQoXCI6XCIpO1xuXG4gICAgICAvLyBpZiB0aGVyZSdzIG5vdCBhIHNlY29uZCBjb2xvbiwgZ29iYmxlIGFub3RoZXIgd29yZC4gT3RoZXJ3aXNlLCBpdCdzIHByb2JhYmx5IGFuIGF4aXMgc3BlY2lmaWVyXG4gICAgICAvLyB3aGljaCBzaG91bGQgZ2V0IG1hdGNoZWQgYXMgYSBrZXl3b3JkXG4gICAgICBpZighc3RyZWFtLmVhdChcIjpcIikgJiYgZm91bmRDb2xvbikge1xuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXCRfLV0vKTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHRoZSBuZXh0IG5vbiB3aGl0ZXNwYWNlIGNoYXJhY3RlciBpcyBhbiBvcGVuIHBhcmVuLCB0aGlzIGlzIHByb2JhYmx5IGEgZnVuY3Rpb24gKGlmIG5vdCBhIGtleXdvcmQgb2Ygb3RoZXIgc29ydClcbiAgICAgIGlmKHN0cmVhbS5tYXRjaCgvXlsgXFx0XSpcXCgvLCBmYWxzZSkpIHtcbiAgICAgICAgbWlnaHRCZUZ1bmN0aW9uID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vIGlzIHRoZSB3b3JkIGEga2V5d29yZD9cbiAgICAgIHZhciB3b3JkID0gc3RyZWFtLmN1cnJlbnQoKTtcbiAgICAgIGtub3duID0ga2V5d29yZHMucHJvcGVydHlJc0VudW1lcmFibGUod29yZCkgJiYga2V5d29yZHNbd29yZF07XG5cbiAgICAgIC8vIGlmIHdlIHRoaW5rIGl0J3MgYSBmdW5jdGlvbiBjYWxsIGJ1dCBub3QgeWV0IGtub3duLFxuICAgICAgLy8gc2V0IHN0eWxlIHRvIHZhcmlhYmxlIGZvciBub3cgZm9yIGxhY2sgb2Ygc29tZXRoaW5nIGJldHRlclxuICAgICAgaWYobWlnaHRCZUZ1bmN0aW9uICYmICFrbm93bikga25vd24gPSB7dHlwZTogXCJmdW5jdGlvbl9jYWxsXCIsIHN0eWxlOiBcInZhcmlhYmxlIGRlZlwifTtcblxuICAgICAgLy8gaWYgdGhlIHByZXZpb3VzIHdvcmQgd2FzIGVsZW1lbnQsIGF0dHJpYnV0ZSwgYXhpcyBzcGVjaWZpZXIsIHRoaXMgd29yZCBzaG91bGQgYmUgdGhlIG5hbWUgb2YgdGhhdFxuICAgICAgaWYoaXNJblhtbENvbnN0cnVjdG9yKHN0YXRlKSkge1xuICAgICAgICBwb3BTdGF0ZVN0YWNrKHN0YXRlKTtcbiAgICAgICAgcmV0dXJuIFwidmFyaWFibGVcIjtcbiAgICAgIH1cbiAgICAgIC8vIGFzIHByZXZpb3VzbHkgY2hlY2tlZCwgaWYgdGhlIHdvcmQgaXMgZWxlbWVudCxhdHRyaWJ1dGUsIGF4aXMgc3BlY2lmaWVyLCBjYWxsIGl0IGFuIFwieG1sY29uc3RydWN0b3JcIiBhbmRcbiAgICAgIC8vIHB1c2ggdGhlIHN0YWNrIHNvIHdlIGtub3cgdG8gbG9vayBmb3IgaXQgb24gdGhlIG5leHQgd29yZFxuICAgICAgaWYod29yZCA9PSBcImVsZW1lbnRcIiB8fCB3b3JkID09IFwiYXR0cmlidXRlXCIgfHwga25vd24udHlwZSA9PSBcImF4aXNfc3BlY2lmaWVyXCIpIHB1c2hTdGF0ZVN0YWNrKHN0YXRlLCB7dHlwZTogXCJ4bWxjb25zdHJ1Y3RvclwifSk7XG5cbiAgICAgIC8vIGlmIHRoZSB3b3JkIGlzIGtub3duLCByZXR1cm4gdGhlIGRldGFpbHMgb2YgdGhhdCBlbHNlIGp1c3QgY2FsbCB0aGlzIGEgZ2VuZXJpYyAnd29yZCdcbiAgICAgIHJldHVybiBrbm93biA/IGtub3duLnN0eWxlIDogXCJ2YXJpYWJsZVwiO1xuICAgIH1cbiAgfVxuXG4gIC8vIGhhbmRsZSBjb21tZW50cywgaW5jbHVkaW5nIG5lc3RlZFxuICBmdW5jdGlvbiB0b2tlbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBtYXliZUVuZCA9IGZhbHNlLCBtYXliZU5lc3RlZCA9IGZhbHNlLCBuZXN0ZWRDb3VudCA9IDAsIGNoO1xuICAgIHdoaWxlIChjaCA9IHN0cmVhbS5uZXh0KCkpIHtcbiAgICAgIGlmIChjaCA9PSBcIilcIiAmJiBtYXliZUVuZCkge1xuICAgICAgICBpZihuZXN0ZWRDb3VudCA+IDApXG4gICAgICAgICAgbmVzdGVkQ291bnQtLTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcG9wU3RhdGVTdGFjayhzdGF0ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYoY2ggPT0gXCI6XCIgJiYgbWF5YmVOZXN0ZWQpIHtcbiAgICAgICAgbmVzdGVkQ291bnQrKztcbiAgICAgIH1cbiAgICAgIG1heWJlRW5kID0gKGNoID09IFwiOlwiKTtcbiAgICAgIG1heWJlTmVzdGVkID0gKGNoID09IFwiKFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gIH1cblxuICAvLyB0b2tlbml6ZXIgZm9yIHN0cmluZyBsaXRlcmFsc1xuICAvLyBvcHRpb25hbGx5IHBhc3MgYSB0b2tlbml6ZXIgZnVuY3Rpb24gdG8gc2V0IHN0YXRlLnRva2VuaXplIGJhY2sgdG8gd2hlbiBmaW5pc2hlZFxuICBmdW5jdGlvbiB0b2tlblN0cmluZyhxdW90ZSwgZikge1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgY2g7XG5cbiAgICAgIGlmKGlzSW5TdHJpbmcoc3RhdGUpICYmIHN0cmVhbS5jdXJyZW50KCkgPT0gcXVvdGUpIHtcbiAgICAgICAgcG9wU3RhdGVTdGFjayhzdGF0ZSk7XG4gICAgICAgIGlmKGYpIHN0YXRlLnRva2VuaXplID0gZjtcbiAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgICB9XG5cbiAgICAgIHB1c2hTdGF0ZVN0YWNrKHN0YXRlLCB7IHR5cGU6IFwic3RyaW5nXCIsIG5hbWU6IHF1b3RlLCB0b2tlbml6ZTogdG9rZW5TdHJpbmcocXVvdGUsIGYpIH0pO1xuXG4gICAgICAvLyBpZiB3ZSdyZSBpbiBhIHN0cmluZyBhbmQgaW4gYW4gWE1MIGJsb2NrLCBhbGxvdyBhbiBlbWJlZGRlZCBjb2RlIGJsb2NrXG4gICAgICBpZihzdHJlYW0ubWF0Y2goXCJ7XCIsIGZhbHNlKSAmJiBpc0luWG1sQXR0cmlidXRlQmxvY2soc3RhdGUpKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICAgIH1cblxuXG4gICAgICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgICAgIGlmIChjaCA9PSAgcXVvdGUpIHtcbiAgICAgICAgICBwb3BTdGF0ZVN0YWNrKHN0YXRlKTtcbiAgICAgICAgICBpZihmKSBzdGF0ZS50b2tlbml6ZSA9IGY7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gaWYgd2UncmUgaW4gYSBzdHJpbmcgYW5kIGluIGFuIFhNTCBibG9jaywgYWxsb3cgYW4gZW1iZWRkZWQgY29kZSBibG9jayBpbiBhbiBhdHRyaWJ1dGVcbiAgICAgICAgICBpZihzdHJlYW0ubWF0Y2goXCJ7XCIsIGZhbHNlKSAmJiBpc0luWG1sQXR0cmlidXRlQmxvY2soc3RhdGUpKSB7XG4gICAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH07XG4gIH1cblxuICAvLyB0b2tlbml6ZXIgZm9yIHZhcmlhYmxlc1xuICBmdW5jdGlvbiB0b2tlblZhcmlhYmxlKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgaXNWYXJpYWJsZUNoYXIgPSAvW1xcd1xcJF8tXS87XG5cbiAgICAvLyBhIHZhcmlhYmxlIG1heSBzdGFydCB3aXRoIGEgcXVvdGVkIEVRTmFtZSBzbyBpZiB0aGUgbmV4dCBjaGFyYWN0ZXIgaXMgcXVvdGUsIGNvbnN1bWUgdG8gdGhlIG5leHQgcXVvdGVcbiAgICBpZihzdHJlYW0uZWF0KFwiXFxcIlwiKSkge1xuICAgICAgd2hpbGUoc3RyZWFtLm5leHQoKSAhPT0gJ1xcXCInKXt9O1xuICAgICAgc3RyZWFtLmVhdChcIjpcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZShpc1ZhcmlhYmxlQ2hhcik7XG4gICAgICBpZighc3RyZWFtLm1hdGNoKFwiOj1cIiwgZmFsc2UpKSBzdHJlYW0uZWF0KFwiOlwiKTtcbiAgICB9XG4gICAgc3RyZWFtLmVhdFdoaWxlKGlzVmFyaWFibGVDaGFyKTtcbiAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xuICB9XG5cbiAgLy8gdG9rZW5pemVyIGZvciBYTUwgdGFnc1xuICBmdW5jdGlvbiB0b2tlblRhZyhuYW1lLCBpc2Nsb3NlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHN0cmVhbS5lYXRTcGFjZSgpO1xuICAgICAgaWYoaXNjbG9zZSAmJiBzdHJlYW0uZWF0KFwiPlwiKSkge1xuICAgICAgICBwb3BTdGF0ZVN0YWNrKHN0YXRlKTtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgIHJldHVybiBcInRhZ1wiO1xuICAgICAgfVxuICAgICAgLy8gc2VsZiBjbG9zaW5nIHRhZyB3aXRob3V0IGF0dHJpYnV0ZXM/XG4gICAgICBpZighc3RyZWFtLmVhdChcIi9cIikpXG4gICAgICAgIHB1c2hTdGF0ZVN0YWNrKHN0YXRlLCB7IHR5cGU6IFwidGFnXCIsIG5hbWU6IG5hbWUsIHRva2VuaXplOiB0b2tlbkJhc2V9KTtcbiAgICAgIGlmKCFzdHJlYW0uZWF0KFwiPlwiKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQXR0cmlidXRlO1xuICAgICAgICByZXR1cm4gXCJ0YWdcIjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcInRhZ1wiO1xuICAgIH07XG4gIH1cblxuICAvLyB0b2tlbml6ZXIgZm9yIFhNTCBhdHRyaWJ1dGVzXG4gIGZ1bmN0aW9uIHRva2VuQXR0cmlidXRlKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuXG4gICAgaWYoY2ggPT0gXCIvXCIgJiYgc3RyZWFtLmVhdChcIj5cIikpIHtcbiAgICAgIGlmKGlzSW5YbWxBdHRyaWJ1dGVCbG9jayhzdGF0ZSkpIHBvcFN0YXRlU3RhY2soc3RhdGUpO1xuICAgICAgaWYoaXNJblhtbEJsb2NrKHN0YXRlKSkgcG9wU3RhdGVTdGFjayhzdGF0ZSk7XG4gICAgICByZXR1cm4gXCJ0YWdcIjtcbiAgICB9XG4gICAgaWYoY2ggPT0gXCI+XCIpIHtcbiAgICAgIGlmKGlzSW5YbWxBdHRyaWJ1dGVCbG9jayhzdGF0ZSkpIHBvcFN0YXRlU3RhY2soc3RhdGUpO1xuICAgICAgcmV0dXJuIFwidGFnXCI7XG4gICAgfVxuICAgIGlmKGNoID09IFwiPVwiKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgLy8gcXVvdGVkIHN0cmluZ1xuICAgIGlmIChjaCA9PSAnXCInIHx8IGNoID09IFwiJ1wiKVxuICAgICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIHRva2VuU3RyaW5nKGNoLCB0b2tlbkF0dHJpYnV0ZSkpO1xuXG4gICAgaWYoIWlzSW5YbWxBdHRyaWJ1dGVCbG9jayhzdGF0ZSkpXG4gICAgICBwdXNoU3RhdGVTdGFjayhzdGF0ZSwgeyB0eXBlOiBcImF0dHJpYnV0ZVwiLCB0b2tlbml6ZTogdG9rZW5BdHRyaWJ1dGV9KTtcblxuICAgIHN0cmVhbS5lYXQoL1thLXpBLVpfOl0vKTtcbiAgICBzdHJlYW0uZWF0V2hpbGUoL1stYS16QS1aMC05XzouXS8pO1xuICAgIHN0cmVhbS5lYXRTcGFjZSgpO1xuXG4gICAgLy8gdGhlIGNhc2Ugd2hlcmUgdGhlIGF0dHJpYnV0ZSBoYXMgbm90IHZhbHVlIGFuZCB0aGUgdGFnIHdhcyBjbG9zZWRcbiAgICBpZihzdHJlYW0ubWF0Y2goXCI+XCIsIGZhbHNlKSB8fCBzdHJlYW0ubWF0Y2goXCIvXCIsIGZhbHNlKSkge1xuICAgICAgcG9wU3RhdGVTdGFjayhzdGF0ZSk7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gXCJhdHRyaWJ1dGVcIjtcbiAgfVxuXG4gIC8vIGhhbmRsZSBjb21tZW50cywgaW5jbHVkaW5nIG5lc3RlZFxuICBmdW5jdGlvbiB0b2tlblhNTENvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBjaDtcbiAgICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgICBpZiAoY2ggPT0gXCItXCIgJiYgc3RyZWFtLm1hdGNoKFwiLT5cIiwgdHJ1ZSkpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG4gIC8vIGhhbmRsZSBDREFUQVxuICBmdW5jdGlvbiB0b2tlbkNEQVRBKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgY2g7XG4gICAgd2hpbGUgKGNoID0gc3RyZWFtLm5leHQoKSkge1xuICAgICAgaWYgKGNoID09IFwiXVwiICYmIHN0cmVhbS5tYXRjaChcIl1cIiwgdHJ1ZSkpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBoYW5kbGUgcHJlcHJvY2Vzc2luZyBpbnN0cnVjdGlvbnNcbiAgZnVuY3Rpb24gdG9rZW5QcmVQcm9jZXNzaW5nKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgY2g7XG4gICAgd2hpbGUgKGNoID0gc3RyZWFtLm5leHQoKSkge1xuICAgICAgaWYgKGNoID09IFwiP1wiICYmIHN0cmVhbS5tYXRjaChcIj5cIiwgdHJ1ZSkpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgIHJldHVybiBcImNvbW1lbnQgbWV0YVwiO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG5cbiAgLy8gZnVuY3Rpb25zIHRvIHRlc3QgdGhlIGN1cnJlbnQgY29udGV4dCBvZiB0aGUgc3RhdGVcbiAgZnVuY3Rpb24gaXNJblhtbEJsb2NrKHN0YXRlKSB7IHJldHVybiBpc0luKHN0YXRlLCBcInRhZ1wiKTsgfVxuICBmdW5jdGlvbiBpc0luWG1sQXR0cmlidXRlQmxvY2soc3RhdGUpIHsgcmV0dXJuIGlzSW4oc3RhdGUsIFwiYXR0cmlidXRlXCIpOyB9XG4gIGZ1bmN0aW9uIGlzSW5YbWxDb25zdHJ1Y3RvcihzdGF0ZSkgeyByZXR1cm4gaXNJbihzdGF0ZSwgXCJ4bWxjb25zdHJ1Y3RvclwiKTsgfVxuICBmdW5jdGlvbiBpc0luU3RyaW5nKHN0YXRlKSB7IHJldHVybiBpc0luKHN0YXRlLCBcInN0cmluZ1wiKTsgfVxuXG4gIGZ1bmN0aW9uIGlzRVFOYW1lQWhlYWQoc3RyZWFtKSB7XG4gICAgLy8gYXNzdW1lIHdlJ3ZlIGFscmVhZHkgZWF0ZW4gYSBxdW90ZSAoXCIpXG4gICAgaWYoc3RyZWFtLmN1cnJlbnQoKSA9PT0gJ1wiJylcbiAgICAgIHJldHVybiBzdHJlYW0ubWF0Y2goL15bXlxcXCJdK1xcXCJcXDovLCBmYWxzZSk7XG4gICAgZWxzZSBpZihzdHJlYW0uY3VycmVudCgpID09PSAnXFwnJylcbiAgICAgIHJldHVybiBzdHJlYW0ubWF0Y2goL15bXlxcXCJdK1xcJ1xcOi8sIGZhbHNlKTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBpc0luKHN0YXRlLCB0eXBlKSB7XG4gICAgcmV0dXJuIChzdGF0ZS5zdGFjay5sZW5ndGggJiYgc3RhdGUuc3RhY2tbc3RhdGUuc3RhY2subGVuZ3RoIC0gMV0udHlwZSA9PSB0eXBlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hTdGF0ZVN0YWNrKHN0YXRlLCBuZXdTdGF0ZSkge1xuICAgIHN0YXRlLnN0YWNrLnB1c2gobmV3U3RhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wU3RhdGVTdGFjayhzdGF0ZSkge1xuICAgIHN0YXRlLnN0YWNrLnBvcCgpO1xuICAgIHZhciByZWluc3RhdGVUb2tlbml6ZSA9IHN0YXRlLnN0YWNrLmxlbmd0aCAmJiBzdGF0ZS5zdGFja1tzdGF0ZS5zdGFjay5sZW5ndGgtMV0udG9rZW5pemU7XG4gICAgc3RhdGUudG9rZW5pemUgPSByZWluc3RhdGVUb2tlbml6ZSB8fCB0b2tlbkJhc2U7XG4gIH1cblxuICAvLyB0aGUgaW50ZXJmYWNlIGZvciB0aGUgbW9kZSBBUElcbiAgcmV0dXJuIHtcbiAgICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRva2VuaXplOiB0b2tlbkJhc2UsXG4gICAgICAgIGNjOiBbXSxcbiAgICAgICAgc3RhY2s6IFtdXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBzdHlsZSA9IHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH0sXG5cbiAgICBibG9ja0NvbW1lbnRTdGFydDogXCIoOlwiLFxuICAgIGJsb2NrQ29tbWVudEVuZDogXCI6KVwiXG5cbiAgfTtcblxufSk7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcImFwcGxpY2F0aW9uL3hxdWVyeVwiLCBcInhxdWVyeVwiKTtcblxufSk7XG4iLCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4vLyBZYWNhcyBtb2RlIGNvcHlyaWdodCAoYykgMjAxNSBieSBHcnplZ29yeiBNYXp1clxuLy8gTG9vc2VseSBiYXNlZCBvbiBtYXRoZW1hdGljYSBtb2RlIGJ5IENhbGluIEJhcmJhdFxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTW9kZSgneWFjYXMnLCBmdW5jdGlvbihfY29uZmlnLCBfcGFyc2VyQ29uZmlnKSB7XG5cbiAgZnVuY3Rpb24gd29yZHMoc3RyKSB7XG4gICAgdmFyIG9iaiA9IHt9LCB3b3JkcyA9IHN0ci5zcGxpdChcIiBcIik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7ICsraSkgb2JqW3dvcmRzW2ldXSA9IHRydWU7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciBib2RpZWRPcHMgPSB3b3JkcyhcIkFzc2VydCBCYWNrUXVvdGUgRCBEZWZ1biBEZXJpdiBGb3IgRm9yRWFjaCBGcm9tRmlsZSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIkZyb21TdHJpbmcgRnVuY3Rpb24gSW50ZWdyYXRlIEludmVyc2VUYXlsb3IgTGltaXQgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJMb2NhbFN5bWJvbHMgTWFjcm8gTWFjcm9SdWxlIE1hY3JvUnVsZVBhdHRlcm4gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJOSW50ZWdyYXRlIFJ1bGUgUnVsZVBhdHRlcm4gU3Vic3QgVEQgVEV4cGxpY2l0U3VtIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiVFN1bSBUYXlsb3IgVGF5bG9yMSBUYXlsb3IyIFRheWxvcjMgVG9GaWxlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiVG9TdGRvdXQgVG9TdHJpbmcgVHJhY2VSdWxlIFVudGlsIFdoaWxlXCIpO1xuXG4gIC8vIHBhdHRlcm5zXG4gIHZhciBwRmxvYXRGb3JtICA9IFwiKD86KD86XFxcXC5cXFxcZCt8XFxcXGQrXFxcXC5cXFxcZCp8XFxcXGQrKSg/OltlRV1bKy1dP1xcXFxkKyk/KVwiO1xuICB2YXIgcElkZW50aWZpZXIgPSBcIig/OlthLXpBLVpcXFxcJCddW2EtekEtWjAtOVxcXFwkJ10qKVwiO1xuXG4gIC8vIHJlZ3VsYXIgZXhwcmVzc2lvbnNcbiAgdmFyIHJlRmxvYXRGb3JtICAgID0gbmV3IFJlZ0V4cChwRmxvYXRGb3JtKTtcbiAgdmFyIHJlSWRlbnRpZmllciAgID0gbmV3IFJlZ0V4cChwSWRlbnRpZmllcik7XG4gIHZhciByZVBhdHRlcm4gICAgICA9IG5ldyBSZWdFeHAocElkZW50aWZpZXIgKyBcIj9fXCIgKyBwSWRlbnRpZmllcik7XG4gIHZhciByZUZ1bmN0aW9uTGlrZSA9IG5ldyBSZWdFeHAocElkZW50aWZpZXIgKyBcIlxcXFxzKlxcXFwoXCIpO1xuXG4gIGZ1bmN0aW9uIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGNoO1xuXG4gICAgLy8gZ2V0IG5leHQgY2hhcmFjdGVyXG4gICAgY2ggPSBzdHJlYW0ubmV4dCgpO1xuXG4gICAgLy8gc3RyaW5nXG4gICAgaWYgKGNoID09PSAnXCInKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuU3RyaW5nO1xuICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIC8vIGNvbW1lbnRcbiAgICBpZiAoY2ggPT09ICcvJykge1xuICAgICAgaWYgKHN0cmVhbS5lYXQoJyonKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQ29tbWVudDtcbiAgICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgfVxuICAgICAgaWYgKHN0cmVhbS5lYXQoXCIvXCIpKSB7XG4gICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGdvIGJhY2sgb25lIGNoYXJhY3RlclxuICAgIHN0cmVhbS5iYWNrVXAoMSk7XG5cbiAgICAvLyB1cGRhdGUgc2NvcGUgaW5mb1xuICAgIHZhciBtID0gc3RyZWFtLm1hdGNoKC9eKFxcdyspXFxzKlxcKC8sIGZhbHNlKTtcbiAgICBpZiAobSAhPT0gbnVsbCAmJiBib2RpZWRPcHMuaGFzT3duUHJvcGVydHkobVsxXSkpXG4gICAgICBzdGF0ZS5zY29wZXMucHVzaCgnYm9kaWVkJyk7XG5cbiAgICB2YXIgc2NvcGUgPSBjdXJyZW50U2NvcGUoc3RhdGUpO1xuXG4gICAgaWYgKHNjb3BlID09PSAnYm9kaWVkJyAmJiBjaCA9PT0gJ1snKVxuICAgICAgc3RhdGUuc2NvcGVzLnBvcCgpO1xuXG4gICAgaWYgKGNoID09PSAnWycgfHwgY2ggPT09ICd7JyB8fCBjaCA9PT0gJygnKVxuICAgICAgc3RhdGUuc2NvcGVzLnB1c2goY2gpO1xuXG4gICAgc2NvcGUgPSBjdXJyZW50U2NvcGUoc3RhdGUpO1xuXG4gICAgaWYgKHNjb3BlID09PSAnWycgJiYgY2ggPT09ICddJyB8fFxuICAgICAgICBzY29wZSA9PT0gJ3snICYmIGNoID09PSAnfScgfHxcbiAgICAgICAgc2NvcGUgPT09ICcoJyAmJiBjaCA9PT0gJyknKVxuICAgICAgc3RhdGUuc2NvcGVzLnBvcCgpO1xuXG4gICAgaWYgKGNoID09PSAnOycpIHtcbiAgICAgIHdoaWxlIChzY29wZSA9PT0gJ2JvZGllZCcpIHtcbiAgICAgICAgc3RhdGUuc2NvcGVzLnBvcCgpO1xuICAgICAgICBzY29wZSA9IGN1cnJlbnRTY29wZShzdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gbG9vayBmb3Igb3JkZXJlZCBydWxlc1xuICAgIGlmIChzdHJlYW0ubWF0Y2goL1xcZCsgKiMvLCB0cnVlLCBmYWxzZSkpIHtcbiAgICAgIHJldHVybiAncXVhbGlmaWVyJztcbiAgICB9XG5cbiAgICAvLyBsb29rIGZvciBudW1iZXJzXG4gICAgaWYgKHN0cmVhbS5tYXRjaChyZUZsb2F0Rm9ybSwgdHJ1ZSwgZmFsc2UpKSB7XG4gICAgICByZXR1cm4gJ251bWJlcic7XG4gICAgfVxuXG4gICAgLy8gbG9vayBmb3IgcGxhY2Vob2xkZXJzXG4gICAgaWYgKHN0cmVhbS5tYXRjaChyZVBhdHRlcm4sIHRydWUsIGZhbHNlKSkge1xuICAgICAgcmV0dXJuICd2YXJpYWJsZS0zJztcbiAgICB9XG5cbiAgICAvLyBtYXRjaCBhbGwgYnJhY2VzIHNlcGFyYXRlbHlcbiAgICBpZiAoc3RyZWFtLm1hdGNoKC8oPzpcXFt8XFxdfHt8fXxcXCh8XFwpKS8sIHRydWUsIGZhbHNlKSkge1xuICAgICAgcmV0dXJuICdicmFja2V0JztcbiAgICB9XG5cbiAgICAvLyBsaXRlcmFscyBsb29raW5nIGxpa2UgZnVuY3Rpb24gY2FsbHNcbiAgICBpZiAoc3RyZWFtLm1hdGNoKHJlRnVuY3Rpb25MaWtlLCB0cnVlLCBmYWxzZSkpIHtcbiAgICAgIHN0cmVhbS5iYWNrVXAoMSk7XG4gICAgICByZXR1cm4gJ3ZhcmlhYmxlJztcbiAgICB9XG5cbiAgICAvLyBhbGwgb3RoZXIgaWRlbnRpZmllcnNcbiAgICBpZiAoc3RyZWFtLm1hdGNoKHJlSWRlbnRpZmllciwgdHJ1ZSwgZmFsc2UpKSB7XG4gICAgICByZXR1cm4gJ3ZhcmlhYmxlLTInO1xuICAgIH1cblxuICAgIC8vIG9wZXJhdG9yczsgbm90ZSB0aGF0IG9wZXJhdG9ycyBsaWtlIEBAIG9yIC87IGFyZSBtYXRjaGVkIHNlcGFyYXRlbHkgZm9yIGVhY2ggc3ltYm9sLlxuICAgIGlmIChzdHJlYW0ubWF0Y2goLyg/OlxcXFx8XFwrfFxcLXxcXCp8XFwvfCx8O3xcXC58OnxAfH58PXw+fDx8JnxcXHx8X3xgfCd8XFxefFxcP3whfCV8IykvLCB0cnVlLCBmYWxzZSkpIHtcbiAgICAgIHJldHVybiAnb3BlcmF0b3InO1xuICAgIH1cblxuICAgIC8vIGV2ZXJ5dGhpbmcgZWxzZSBpcyBhbiBlcnJvclxuICAgIHJldHVybiAnZXJyb3InO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5TdHJpbmcoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBuZXh0LCBlbmQgPSBmYWxzZSwgZXNjYXBlZCA9IGZhbHNlO1xuICAgIHdoaWxlICgobmV4dCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgIGlmIChuZXh0ID09PSAnXCInICYmICFlc2NhcGVkKSB7XG4gICAgICAgIGVuZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkICYmIG5leHQgPT09ICdcXFxcJztcbiAgICB9XG4gICAgaWYgKGVuZCAmJiAhZXNjYXBlZCkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgfVxuICAgIHJldHVybiAnc3RyaW5nJztcbiAgfTtcblxuICBmdW5jdGlvbiB0b2tlbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBwcmV2LCBuZXh0O1xuICAgIHdoaWxlKChuZXh0ID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgaWYgKHByZXYgPT09ICcqJyAmJiBuZXh0ID09PSAnLycpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcHJldiA9IG5leHQ7XG4gICAgfVxuICAgIHJldHVybiAnY29tbWVudCc7XG4gIH1cblxuICBmdW5jdGlvbiBjdXJyZW50U2NvcGUoc3RhdGUpIHtcbiAgICB2YXIgc2NvcGUgPSBudWxsO1xuICAgIGlmIChzdGF0ZS5zY29wZXMubGVuZ3RoID4gMClcbiAgICAgIHNjb3BlID0gc3RhdGUuc2NvcGVzW3N0YXRlLnNjb3Blcy5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gc2NvcGU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9rZW5pemU6IHRva2VuQmFzZSxcbiAgICAgICAgc2NvcGVzOiBbXVxuICAgICAgfTtcbiAgICB9LFxuICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xuICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIH0sXG4gICAgaW5kZW50OiBmdW5jdGlvbihzdGF0ZSwgdGV4dEFmdGVyKSB7XG4gICAgICBpZiAoc3RhdGUudG9rZW5pemUgIT09IHRva2VuQmFzZSAmJiBzdGF0ZS50b2tlbml6ZSAhPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIENvZGVNaXJyb3IuUGFzcztcblxuICAgICAgdmFyIGRlbHRhID0gMDtcbiAgICAgIGlmICh0ZXh0QWZ0ZXIgPT09ICddJyB8fCB0ZXh0QWZ0ZXIgPT09ICddOycgfHxcbiAgICAgICAgICB0ZXh0QWZ0ZXIgPT09ICd9JyB8fCB0ZXh0QWZ0ZXIgPT09ICd9OycgfHxcbiAgICAgICAgICB0ZXh0QWZ0ZXIgPT09ICcpOycpXG4gICAgICAgIGRlbHRhID0gLTE7XG5cbiAgICAgIHJldHVybiAoc3RhdGUuc2NvcGVzLmxlbmd0aCArIGRlbHRhKSAqIF9jb25maWcuaW5kZW50VW5pdDtcbiAgICB9LFxuICAgIGVsZWN0cmljQ2hhcnM6IFwie31bXSgpO1wiLFxuICAgIGJsb2NrQ29tbWVudFN0YXJ0OiBcIi8qXCIsXG4gICAgYmxvY2tDb21tZW50RW5kOiBcIiovXCIsXG4gICAgbGluZUNvbW1lbnQ6IFwiLy9cIlxuICB9O1xufSk7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTUlNRSgndGV4dC94LXlhY2FzJywge1xuICBuYW1lOiAneWFjYXMnXG59KTtcblxufSk7XG4iLCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24gKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSwgcmVxdWlyZShcIi4uL3lhbWwveWFtbFwiKSlcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIsIFwiLi4veWFtbC95YW1sXCJdLCBtb2QpXG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcilcbn0pKGZ1bmN0aW9uIChDb2RlTWlycm9yKSB7XG5cbiAgdmFyIFNUQVJUID0gMCwgRlJPTlRNQVRURVIgPSAxLCBCT0RZID0gMlxuXG4gIC8vIGEgbWl4ZWQgbW9kZSBmb3IgTWFya2Rvd24gdGV4dCB3aXRoIGFuIG9wdGlvbmFsIFlBTUwgZnJvbnQgbWF0dGVyXG4gIENvZGVNaXJyb3IuZGVmaW5lTW9kZShcInlhbWwtZnJvbnRtYXR0ZXJcIiwgZnVuY3Rpb24gKGNvbmZpZywgcGFyc2VyQ29uZmlnKSB7XG4gICAgdmFyIHlhbWxNb2RlID0gQ29kZU1pcnJvci5nZXRNb2RlKGNvbmZpZywgXCJ5YW1sXCIpXG4gICAgdmFyIGlubmVyTW9kZSA9IENvZGVNaXJyb3IuZ2V0TW9kZShjb25maWcsIHBhcnNlckNvbmZpZyAmJiBwYXJzZXJDb25maWcuYmFzZSB8fCBcImdmbVwiKVxuXG4gICAgZnVuY3Rpb24gY3VyTW9kZShzdGF0ZSkge1xuICAgICAgcmV0dXJuIHN0YXRlLnN0YXRlID09IEJPRFkgPyBpbm5lck1vZGUgOiB5YW1sTW9kZVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzdGFydFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhdGU6IFNUQVJULFxuICAgICAgICAgIGlubmVyOiBDb2RlTWlycm9yLnN0YXJ0U3RhdGUoeWFtbE1vZGUpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjb3B5U3RhdGU6IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXRlOiBzdGF0ZS5zdGF0ZSxcbiAgICAgICAgICBpbm5lcjogQ29kZU1pcnJvci5jb3B5U3RhdGUoY3VyTW9kZShzdGF0ZSksIHN0YXRlLmlubmVyKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdG9rZW46IGZ1bmN0aW9uIChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIGlmIChzdGF0ZS5zdGF0ZSA9PSBTVEFSVCkge1xuICAgICAgICAgIGlmIChzdHJlYW0ubWF0Y2goJy0tLScsIGZhbHNlKSkge1xuICAgICAgICAgICAgc3RhdGUuc3RhdGUgPSBGUk9OVE1BVFRFUlxuICAgICAgICAgICAgcmV0dXJuIHlhbWxNb2RlLnRva2VuKHN0cmVhbSwgc3RhdGUuaW5uZXIpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLnN0YXRlID0gQk9EWVxuICAgICAgICAgICAgc3RhdGUuaW5uZXIgPSBDb2RlTWlycm9yLnN0YXJ0U3RhdGUoaW5uZXJNb2RlKVxuICAgICAgICAgICAgcmV0dXJuIGlubmVyTW9kZS50b2tlbihzdHJlYW0sIHN0YXRlLmlubmVyKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5zdGF0ZSA9PSBGUk9OVE1BVFRFUikge1xuICAgICAgICAgIHZhciBlbmQgPSBzdHJlYW0uc29sKCkgJiYgc3RyZWFtLm1hdGNoKC8oLS0tfFxcLlxcLlxcLikvLCBmYWxzZSlcbiAgICAgICAgICB2YXIgc3R5bGUgPSB5YW1sTW9kZS50b2tlbihzdHJlYW0sIHN0YXRlLmlubmVyKVxuICAgICAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgICAgIHN0YXRlLnN0YXRlID0gQk9EWVxuICAgICAgICAgICAgc3RhdGUuaW5uZXIgPSBDb2RlTWlycm9yLnN0YXJ0U3RhdGUoaW5uZXJNb2RlKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3R5bGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gaW5uZXJNb2RlLnRva2VuKHN0cmVhbSwgc3RhdGUuaW5uZXIpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpbm5lck1vZGU6IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICByZXR1cm4ge21vZGU6IGN1ck1vZGUoc3RhdGUpLCBzdGF0ZTogc3RhdGUuaW5uZXJ9XG4gICAgICB9LFxuICAgICAgaW5kZW50OiBmdW5jdGlvbihzdGF0ZSwgYSwgYikge1xuICAgICAgICB2YXIgbW9kZSA9IGN1ck1vZGUoc3RhdGUpXG4gICAgICAgIHJldHVybiBtb2RlLmluZGVudCA/IG1vZGUuaW5kZW50KHN0YXRlLmlubmVyLCBhLCBiKSA6IENvZGVNaXJyb3IuUGFzc1xuICAgICAgfSxcbiAgICAgIGJsYW5rTGluZTogZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHZhciBtb2RlID0gY3VyTW9kZShzdGF0ZSlcbiAgICAgICAgaWYgKG1vZGUuYmxhbmtMaW5lKSByZXR1cm4gbW9kZS5ibGFua0xpbmUoc3RhdGUuaW5uZXIpXG4gICAgICB9XG4gICAgfVxuICB9KVxufSk7XG4iLCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTW9kZShcInlhbWxcIiwgZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGNvbnMgPSBbJ3RydWUnLCAnZmFsc2UnLCAnb24nLCAnb2ZmJywgJ3llcycsICdubyddO1xuICB2YXIga2V5d29yZFJlZ2V4ID0gbmV3IFJlZ0V4cChcIlxcXFxiKChcIitjb25zLmpvaW4oXCIpfChcIikrXCIpKSRcIiwgJ2knKTtcblxuICByZXR1cm4ge1xuICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgY2ggPSBzdHJlYW0ucGVlaygpO1xuICAgICAgdmFyIGVzYyA9IHN0YXRlLmVzY2FwZWQ7XG4gICAgICBzdGF0ZS5lc2NhcGVkID0gZmFsc2U7XG4gICAgICAvKiBjb21tZW50cyAqL1xuICAgICAgaWYgKGNoID09IFwiI1wiICYmIChzdHJlYW0ucG9zID09IDAgfHwgL1xccy8udGVzdChzdHJlYW0uc3RyaW5nLmNoYXJBdChzdHJlYW0ucG9zIC0gMSkpKSkge1xuICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXignKFteJ118XFxcXC4pKic/fFwiKFteXCJdfFxcXFwuKSpcIj8pLykpXG4gICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuXG4gICAgICBpZiAoc3RhdGUubGl0ZXJhbCAmJiBzdHJlYW0uaW5kZW50YXRpb24oKSA+IHN0YXRlLmtleUNvbCkge1xuICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7IHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5saXRlcmFsKSB7IHN0YXRlLmxpdGVyYWwgPSBmYWxzZTsgfVxuICAgICAgaWYgKHN0cmVhbS5zb2woKSkge1xuICAgICAgICBzdGF0ZS5rZXlDb2wgPSAwO1xuICAgICAgICBzdGF0ZS5wYWlyID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLnBhaXJTdGFydCA9IGZhbHNlO1xuICAgICAgICAvKiBkb2N1bWVudCBzdGFydCAqL1xuICAgICAgICBpZihzdHJlYW0ubWF0Y2goJy0tLScpKSB7IHJldHVybiBcImRlZlwiOyB9XG4gICAgICAgIC8qIGRvY3VtZW50IGVuZCAqL1xuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKCcuLi4nKSkgeyByZXR1cm4gXCJkZWZcIjsgfVxuICAgICAgICAvKiBhcnJheSBsaXN0IGl0ZW0gKi9cbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXFxzKi1cXHMrLykpIHsgcmV0dXJuICdtZXRhJzsgfVxuICAgICAgfVxuICAgICAgLyogaW5saW5lIHBhaXJzL2xpc3RzICovXG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eKFxce3xcXH18XFxbfFxcXSkvKSkge1xuICAgICAgICBpZiAoY2ggPT0gJ3snKVxuICAgICAgICAgIHN0YXRlLmlubGluZVBhaXJzKys7XG4gICAgICAgIGVsc2UgaWYgKGNoID09ICd9JylcbiAgICAgICAgICBzdGF0ZS5pbmxpbmVQYWlycy0tO1xuICAgICAgICBlbHNlIGlmIChjaCA9PSAnWycpXG4gICAgICAgICAgc3RhdGUuaW5saW5lTGlzdCsrO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgc3RhdGUuaW5saW5lTGlzdC0tO1xuICAgICAgICByZXR1cm4gJ21ldGEnO1xuICAgICAgfVxuXG4gICAgICAvKiBsaXN0IHNlcGFyYXRvciAqL1xuICAgICAgaWYgKHN0YXRlLmlubGluZUxpc3QgPiAwICYmICFlc2MgJiYgY2ggPT0gJywnKSB7XG4gICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIHJldHVybiAnbWV0YSc7XG4gICAgICB9XG4gICAgICAvKiBwYWlycyBzZXBhcmF0b3IgKi9cbiAgICAgIGlmIChzdGF0ZS5pbmxpbmVQYWlycyA+IDAgJiYgIWVzYyAmJiBjaCA9PSAnLCcpIHtcbiAgICAgICAgc3RhdGUua2V5Q29sID0gMDtcbiAgICAgICAgc3RhdGUucGFpciA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5wYWlyU3RhcnQgPSBmYWxzZTtcbiAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgcmV0dXJuICdtZXRhJztcbiAgICAgIH1cblxuICAgICAgLyogc3RhcnQgb2YgdmFsdWUgb2YgYSBwYWlyICovXG4gICAgICBpZiAoc3RhdGUucGFpclN0YXJ0KSB7XG4gICAgICAgIC8qIGJsb2NrIGxpdGVyYWxzICovXG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2goL15cXHMqKFxcfHxcXD4pXFxzKi8pKSB7IHN0YXRlLmxpdGVyYWwgPSB0cnVlOyByZXR1cm4gJ21ldGEnOyB9O1xuICAgICAgICAvKiByZWZlcmVuY2VzICovXG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2goL15cXHMqKFxcJnxcXCopW2EtejAtOVxcLl8tXStcXGIvaSkpIHsgcmV0dXJuICd2YXJpYWJsZS0yJzsgfVxuICAgICAgICAvKiBudW1iZXJzICovXG4gICAgICAgIGlmIChzdGF0ZS5pbmxpbmVQYWlycyA9PSAwICYmIHN0cmVhbS5tYXRjaCgvXlxccyotP1swLTlcXC5cXCxdK1xccz8kLykpIHsgcmV0dXJuICdudW1iZXInOyB9XG4gICAgICAgIGlmIChzdGF0ZS5pbmxpbmVQYWlycyA+IDAgJiYgc3RyZWFtLm1hdGNoKC9eXFxzKi0/WzAtOVxcLlxcLF0rXFxzPyg/PSgsfH0pKS8pKSB7IHJldHVybiAnbnVtYmVyJzsgfVxuICAgICAgICAvKiBrZXl3b3JkcyAqL1xuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKGtleXdvcmRSZWdleCkpIHsgcmV0dXJuICdrZXl3b3JkJzsgfVxuICAgICAgfVxuXG4gICAgICAvKiBwYWlycyAoYXNzb2NpYXRpdmUgYXJyYXlzKSAtPiBrZXkgKi9cbiAgICAgIGlmICghc3RhdGUucGFpciAmJiBzdHJlYW0ubWF0Y2goL15cXHMqKD86WyxcXFtcXF17fSYqIXw+J1wiJUBgXVteXFxzJ1wiOl18W14sXFxbXFxde30jJiohfD4nXCIlQGBdKVteI10qPyg/PVxccyo6KCR8XFxzKSkvKSkge1xuICAgICAgICBzdGF0ZS5wYWlyID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUua2V5Q29sID0gc3RyZWFtLmluZGVudGF0aW9uKCk7XG4gICAgICAgIHJldHVybiBcImF0b21cIjtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5wYWlyICYmIHN0cmVhbS5tYXRjaCgvXjpcXHMqLykpIHsgc3RhdGUucGFpclN0YXJ0ID0gdHJ1ZTsgcmV0dXJuICdtZXRhJzsgfVxuXG4gICAgICAvKiBub3RoaW5nIGZvdW5kLCBjb250aW51ZSAqL1xuICAgICAgc3RhdGUucGFpclN0YXJ0ID0gZmFsc2U7XG4gICAgICBzdGF0ZS5lc2NhcGVkID0gKGNoID09ICdcXFxcJyk7XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhaXI6IGZhbHNlLFxuICAgICAgICBwYWlyU3RhcnQ6IGZhbHNlLFxuICAgICAgICBrZXlDb2w6IDAsXG4gICAgICAgIGlubGluZVBhaXJzOiAwLFxuICAgICAgICBpbmxpbmVMaXN0OiAwLFxuICAgICAgICBsaXRlcmFsOiBmYWxzZSxcbiAgICAgICAgZXNjYXBlZDogZmFsc2VcbiAgICAgIH07XG4gICAgfSxcbiAgICBsaW5lQ29tbWVudDogXCIjXCIsXG4gICAgZm9sZDogXCJpbmRlbnRcIlxuICB9O1xufSk7XG5cbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQveC15YW1sXCIsIFwieWFtbFwiKTtcbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQveWFtbFwiLCBcInlhbWxcIik7XG5cbn0pO1xuIiwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcblwidXNlIHN0cmljdFwiO1xuXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoJ3o4MCcsIGZ1bmN0aW9uKF9jb25maWcsIHBhcnNlckNvbmZpZykge1xuICB2YXIgZXo4MCA9IHBhcnNlckNvbmZpZy5lejgwO1xuICB2YXIga2V5d29yZHMxLCBrZXl3b3JkczI7XG4gIGlmIChlejgwKSB7XG4gICAga2V5d29yZHMxID0gL14oZXh4P3wobGR8Y3ApKFtkaV1yPyk/fFtscF1lYXxwb3B8cHVzaHxhZFtjZF18Y3BsfGRhYXxkZWN8aW5jfG5lZ3xzYmN8c3VifGFuZHxiaXR8W2NzXWNmfHg/b3J8cmVzfHNldHxyW2xyXWM/YT98cltscl1kfHNbbHJdYXxzcmx8ZGpuenxub3B8W2RlXWl8aGFsdHxpbXxpbihbZGldbXI/fGlyP3xpcnh8MnI/KXxvdChkbXI/fFtpZF1yeHxpbXI/KXxvdXQoMD98W2RpXXI/fFtkaV0ycj8pfHRzdChpbyk/fHNscCkoXFwuKFtzbF0/aSk/W3NsXSk/XFxiL2k7XG4gICAga2V5d29yZHMyID0gL14oKChjYWxsfGpbcHJdfHJzdHxyZXRbaW5dPykoXFwuKFtzbF0/aSk/W3NsXSk/KXwocnN8c3QpbWl4KVxcYi9pO1xuICB9IGVsc2Uge1xuICAgIGtleXdvcmRzMSA9IC9eKGV4eD98KGxkfGNwfGluKShbZGldcj8pP3xwb3B8cHVzaHxhZFtjZF18Y3BsfGRhYXxkZWN8aW5jfG5lZ3xzYmN8c3VifGFuZHxiaXR8W2NzXWNmfHg/b3J8cmVzfHNldHxyW2xyXWM/YT98cltscl1kfHNbbHJdYXxzcmx8ZGpuenxub3B8cnN0fFtkZV1pfGhhbHR8aW18b3RbZGldcnxvdXRbZGldPylcXGIvaTtcbiAgICBrZXl3b3JkczIgPSAvXihjYWxsfGpbcHJdfHJldFtpbl0/fGJfPyhjYWxsfGp1bXApKVxcYi9pO1xuICB9XG5cbiAgdmFyIHZhcmlhYmxlczEgPSAvXihhZj98YmM/fGN8ZGU/fGV8aGw/fGx8aVt4eV0/fHJ8c3ApXFxiL2k7XG4gIHZhciB2YXJpYWJsZXMyID0gL14obj9bemNdfHBbb2VdP3xtKVxcYi9pO1xuICB2YXIgZXJyb3JzID0gL14oW2hsXVt4eV18aVt4eV1baGxdfHNsaWF8c2xsKVxcYi9pO1xuICB2YXIgbnVtYmVycyA9IC9eKFtcXGRhLWZdK2h8WzAtN10rb3xbMDFdK2J8XFxkK2Q/KVxcYi9pO1xuXG4gIHJldHVybiB7XG4gICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb250ZXh0OiAwXG4gICAgICB9O1xuICAgIH0sXG4gICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmICghc3RyZWFtLmNvbHVtbigpKVxuICAgICAgICBzdGF0ZS5jb250ZXh0ID0gMDtcblxuICAgICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKVxuICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgdmFyIHc7XG5cbiAgICAgIGlmIChzdHJlYW0uZWF0V2hpbGUoL1xcdy8pKSB7XG4gICAgICAgIGlmIChlejgwICYmIHN0cmVhbS5lYXQoJy4nKSkge1xuICAgICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvXFx3Lyk7XG4gICAgICAgIH1cbiAgICAgICAgdyA9IHN0cmVhbS5jdXJyZW50KCk7XG5cbiAgICAgICAgaWYgKHN0cmVhbS5pbmRlbnRhdGlvbigpKSB7XG4gICAgICAgICAgaWYgKChzdGF0ZS5jb250ZXh0ID09IDEgfHwgc3RhdGUuY29udGV4dCA9PSA0KSAmJiB2YXJpYWJsZXMxLnRlc3QodykpIHtcbiAgICAgICAgICAgIHN0YXRlLmNvbnRleHQgPSA0O1xuICAgICAgICAgICAgcmV0dXJuICd2YXIyJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3RhdGUuY29udGV4dCA9PSAyICYmIHZhcmlhYmxlczIudGVzdCh3KSkge1xuICAgICAgICAgICAgc3RhdGUuY29udGV4dCA9IDQ7XG4gICAgICAgICAgICByZXR1cm4gJ3ZhcjMnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChrZXl3b3JkczEudGVzdCh3KSkge1xuICAgICAgICAgICAgc3RhdGUuY29udGV4dCA9IDE7XG4gICAgICAgICAgICByZXR1cm4gJ2tleXdvcmQnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoa2V5d29yZHMyLnRlc3QodykpIHtcbiAgICAgICAgICAgIHN0YXRlLmNvbnRleHQgPSAyO1xuICAgICAgICAgICAgcmV0dXJuICdrZXl3b3JkJztcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLmNvbnRleHQgPT0gNCAmJiBudW1iZXJzLnRlc3QodykpIHtcbiAgICAgICAgICAgIHJldHVybiAnbnVtYmVyJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZXJyb3JzLnRlc3QodykpXG4gICAgICAgICAgICByZXR1cm4gJ2Vycm9yJztcbiAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2gobnVtYmVycykpIHtcbiAgICAgICAgICByZXR1cm4gJ251bWJlcic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLmVhdCgnOycpKSB7XG4gICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgcmV0dXJuICdjb21tZW50JztcbiAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLmVhdCgnXCInKSkge1xuICAgICAgICB3aGlsZSAodyA9IHN0cmVhbS5uZXh0KCkpIHtcbiAgICAgICAgICBpZiAodyA9PSAnXCInKVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBpZiAodyA9PSAnXFxcXCcpXG4gICAgICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnc3RyaW5nJztcbiAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLmVhdCgnXFwnJykpIHtcbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXFxcXD8uJy8pKVxuICAgICAgICAgIHJldHVybiAnbnVtYmVyJztcbiAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLmVhdCgnLicpIHx8IHN0cmVhbS5zb2woKSAmJiBzdHJlYW0uZWF0KCcjJykpIHtcbiAgICAgICAgc3RhdGUuY29udGV4dCA9IDU7XG5cbiAgICAgICAgaWYgKHN0cmVhbS5lYXRXaGlsZSgvXFx3LykpXG4gICAgICAgICAgcmV0dXJuICdkZWYnO1xuICAgICAgfSBlbHNlIGlmIChzdHJlYW0uZWF0KCckJykpIHtcbiAgICAgICAgaWYgKHN0cmVhbS5lYXRXaGlsZSgvW1xcZGEtZl0vaSkpXG4gICAgICAgICAgcmV0dXJuICdudW1iZXInO1xuICAgICAgfSBlbHNlIGlmIChzdHJlYW0uZWF0KCclJykpIHtcbiAgICAgICAgaWYgKHN0cmVhbS5lYXRXaGlsZSgvWzAxXS8pKVxuICAgICAgICAgIHJldHVybiAnbnVtYmVyJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG59KTtcblxuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LXo4MFwiLCBcIno4MFwiKTtcbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQveC1lejgwXCIsIHsgbmFtZTogXCJ6ODBcIiwgZXo4MDogdHJ1ZSB9KTtcblxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=