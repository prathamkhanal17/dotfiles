{"version":3,"file":"node_modules/png-js.js","mappings":"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","sources":["../.././node_modules/png-js/png-node.js","../../external node-commonjs \"fs\"","../../external node-commonjs \"zlib\"","../../webpack/bootstrap","../../webpack/startup"],"sourcesContent":["/*\n * MIT LICENSE\n * Copyright (c) 2011 Devon Govett\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\n * software and associated documentation files (the \"Software\"), to deal in the Software\n * without restriction, including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons\n * to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or\n * substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst fs = require('fs');\nconst zlib = require('zlib');\n\nmodule.exports = class PNG {\n  static decode(path, fn) {\n    return fs.readFile(path, function(err, file) {\n      const png = new PNG(file);\n      return png.decode(pixels => fn(pixels));\n    });\n  }\n\n  static load(path) {\n    const file = fs.readFileSync(path);\n    return new PNG(file);\n  }\n\n  constructor(data) {\n    let i;\n    this.data = data;\n    this.pos = 8; // Skip the default header\n\n    this.palette = [];\n    this.imgData = [];\n    this.transparency = {};\n    this.text = {};\n\n    while (true) {\n      const chunkSize = this.readUInt32();\n      let section = '';\n      for (i = 0; i < 4; i++) {\n        section += String.fromCharCode(this.data[this.pos++]);\n      }\n\n      switch (section) {\n        case 'IHDR':\n          // we can grab  interesting values from here (like width, height, etc)\n          this.width = this.readUInt32();\n          this.height = this.readUInt32();\n          this.bits = this.data[this.pos++];\n          this.colorType = this.data[this.pos++];\n          this.compressionMethod = this.data[this.pos++];\n          this.filterMethod = this.data[this.pos++];\n          this.interlaceMethod = this.data[this.pos++];\n          break;\n\n        case 'PLTE':\n          this.palette = this.read(chunkSize);\n          break;\n\n        case 'IDAT':\n          for (i = 0; i < chunkSize; i++) {\n            this.imgData.push(this.data[this.pos++]);\n          }\n          break;\n\n        case 'tRNS':\n          // This chunk can only occur once and it must occur after the\n          // PLTE chunk and before the IDAT chunk.\n          this.transparency = {};\n          switch (this.colorType) {\n            case 3:\n              // Indexed color, RGB. Each byte in this chunk is an alpha for\n              // the palette index in the PLTE (\"palette\") chunk up until the\n              // last non-opaque entry. Set up an array, stretching over all\n              // palette entries which will be 0 (opaque) or 1 (transparent).\n              this.transparency.indexed = this.read(chunkSize);\n              var short = 255 - this.transparency.indexed.length;\n              if (short > 0) {\n                for (i = 0; i < short; i++) {\n                  this.transparency.indexed.push(255);\n                }\n              }\n              break;\n            case 0:\n              // Greyscale. Corresponding to entries in the PLTE chunk.\n              // Grey is two bytes, range 0 .. (2 ^ bit-depth) - 1\n              this.transparency.grayscale = this.read(chunkSize)[0];\n              break;\n            case 2:\n              // True color with proper alpha channel.\n              this.transparency.rgb = this.read(chunkSize);\n              break;\n          }\n          break;\n\n        case 'tEXt':\n          var text = this.read(chunkSize);\n          var index = text.indexOf(0);\n          var key = String.fromCharCode.apply(String, text.slice(0, index));\n          this.text[key] = String.fromCharCode.apply(\n            String,\n            text.slice(index + 1)\n          );\n          break;\n\n        case 'IEND':\n          // we've got everything we need!\n          switch (this.colorType) {\n            case 0:\n            case 3:\n            case 4:\n              this.colors = 1;\n              break;\n            case 2:\n            case 6:\n              this.colors = 3;\n              break;\n          }\n\n          this.hasAlphaChannel = [4, 6].includes(this.colorType);\n          var colors = this.colors + (this.hasAlphaChannel ? 1 : 0);\n          this.pixelBitlength = this.bits * colors;\n\n          switch (this.colors) {\n            case 1:\n              this.colorSpace = 'DeviceGray';\n              break;\n            case 3:\n              this.colorSpace = 'DeviceRGB';\n              break;\n          }\n\n          this.imgData = new Buffer(this.imgData);\n          return;\n          break;\n\n        default:\n          // unknown (or unimportant) section, skip it\n          this.pos += chunkSize;\n      }\n\n      this.pos += 4; // Skip the CRC\n\n      if (this.pos > this.data.length) {\n        throw new Error('Incomplete or corrupt PNG file');\n      }\n    }\n  }\n\n  read(bytes) {\n    const result = new Array(bytes);\n    for (let i = 0; i < bytes; i++) {\n      result[i] = this.data[this.pos++];\n    }\n    return result;\n  }\n\n  readUInt32() {\n    const b1 = this.data[this.pos++] << 24;\n    const b2 = this.data[this.pos++] << 16;\n    const b3 = this.data[this.pos++] << 8;\n    const b4 = this.data[this.pos++];\n    return b1 | b2 | b3 | b4;\n  }\n\n  readUInt16() {\n    const b1 = this.data[this.pos++] << 8;\n    const b2 = this.data[this.pos++];\n    return b1 | b2;\n  }\n\n  decodePixels(fn) {\n    return zlib.inflate(this.imgData, (err, data) => {\n      if (err) {\n        throw err;\n      }\n\n      const { width, height } = this;\n      const pixelBytes = this.pixelBitlength / 8;\n\n      const pixels = new Buffer(width * height * pixelBytes);\n      const { length } = data;\n      let pos = 0;\n\n      function pass(x0, y0, dx, dy, singlePass = false) {\n        const w = Math.ceil((width - x0) / dx);\n        const h = Math.ceil((height - y0) / dy);\n        const scanlineLength = pixelBytes * w;\n        const buffer = singlePass ? pixels : new Buffer(scanlineLength * h);\n        let row = 0;\n        let c = 0;\n        while (row < h && pos < length) {\n          var byte, col, i, left, upper;\n          switch (data[pos++]) {\n            case 0: // None\n              for (i = 0; i < scanlineLength; i++) {\n                buffer[c++] = data[pos++];\n              }\n              break;\n\n            case 1: // Sub\n              for (i = 0; i < scanlineLength; i++) {\n                byte = data[pos++];\n                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n                buffer[c++] = (byte + left) % 256;\n              }\n              break;\n\n            case 2: // Up\n              for (i = 0; i < scanlineLength; i++) {\n                byte = data[pos++];\n                col = (i - (i % pixelBytes)) / pixelBytes;\n                upper =\n                  row &&\n                  buffer[\n                    (row - 1) * scanlineLength +\n                      col * pixelBytes +\n                      (i % pixelBytes)\n                  ];\n                buffer[c++] = (upper + byte) % 256;\n              }\n              break;\n\n            case 3: // Average\n              for (i = 0; i < scanlineLength; i++) {\n                byte = data[pos++];\n                col = (i - (i % pixelBytes)) / pixelBytes;\n                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n                upper =\n                  row &&\n                  buffer[\n                    (row - 1) * scanlineLength +\n                      col * pixelBytes +\n                      (i % pixelBytes)\n                  ];\n                buffer[c++] = (byte + Math.floor((left + upper) / 2)) % 256;\n              }\n              break;\n\n            case 4: // Paeth\n              for (i = 0; i < scanlineLength; i++) {\n                var paeth, upperLeft;\n                byte = data[pos++];\n                col = (i - (i % pixelBytes)) / pixelBytes;\n                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n\n                if (row === 0) {\n                  upper = upperLeft = 0;\n                } else {\n                  upper =\n                    buffer[\n                      (row - 1) * scanlineLength +\n                        col * pixelBytes +\n                        (i % pixelBytes)\n                    ];\n                  upperLeft =\n                    col &&\n                    buffer[\n                      (row - 1) * scanlineLength +\n                        (col - 1) * pixelBytes +\n                        (i % pixelBytes)\n                    ];\n                }\n\n                const p = left + upper - upperLeft;\n                const pa = Math.abs(p - left);\n                const pb = Math.abs(p - upper);\n                const pc = Math.abs(p - upperLeft);\n\n                if (pa <= pb && pa <= pc) {\n                  paeth = left;\n                } else if (pb <= pc) {\n                  paeth = upper;\n                } else {\n                  paeth = upperLeft;\n                }\n\n                buffer[c++] = (byte + paeth) % 256;\n              }\n              break;\n\n            default:\n              throw new Error(`Invalid filter algorithm: ${data[pos - 1]}`);\n          }\n\n          if (!singlePass) {\n            let pixelsPos = ((y0 + row * dy) * width + x0) * pixelBytes;\n            let bufferPos = row * scanlineLength;\n            for (i = 0; i < w; i++) {\n              for (let j = 0; j < pixelBytes; j++)\n                pixels[pixelsPos++] = buffer[bufferPos++];\n              pixelsPos += (dx - 1) * pixelBytes;\n            }\n          }\n\n          row++;\n        }\n      }\n\n      if (this.interlaceMethod === 1) {\n        /*\n          1 6 4 6 2 6 4 6\n          7 7 7 7 7 7 7 7\n          5 6 5 6 5 6 5 6\n          7 7 7 7 7 7 7 7\n          3 6 4 6 3 6 4 6\n          7 7 7 7 7 7 7 7\n          5 6 5 6 5 6 5 6\n          7 7 7 7 7 7 7 7\n        */\n        pass(0, 0, 8, 8); // 1\n        pass(4, 0, 8, 8); // 2\n        pass(0, 4, 4, 8); // 3\n        pass(2, 0, 4, 4); // 4\n        pass(0, 2, 2, 4); // 5\n        pass(1, 0, 2, 2); // 6\n        pass(0, 1, 1, 2); // 7\n      } else {\n        pass(0, 0, 1, 1, true);\n      }\n\n      return fn(pixels);\n    });\n  }\n\n  decodePalette() {\n    const { palette } = this;\n    const { length } = palette;\n    const transparency = this.transparency.indexed || [];\n    const ret = new Buffer(transparency.length + length);\n    let pos = 0;\n    let c = 0;\n\n    for (let i = 0; i < length; i += 3) {\n      var left;\n      ret[pos++] = palette[i];\n      ret[pos++] = palette[i + 1];\n      ret[pos++] = palette[i + 2];\n      ret[pos++] = (left = transparency[c++]) != null ? left : 255;\n    }\n\n    return ret;\n  }\n\n  copyToImageData(imageData, pixels) {\n    let j, k;\n    let { colors } = this;\n    let palette = null;\n    let alpha = this.hasAlphaChannel;\n\n    if (this.palette.length) {\n      palette =\n        this._decodedPalette || (this._decodedPalette = this.decodePalette());\n      colors = 4;\n      alpha = true;\n    }\n\n    const data = imageData.data || imageData;\n    const { length } = data;\n    const input = palette || pixels;\n    let i = (j = 0);\n\n    if (colors === 1) {\n      while (i < length) {\n        k = palette ? pixels[i / 4] * 4 : j;\n        const v = input[k++];\n        data[i++] = v;\n        data[i++] = v;\n        data[i++] = v;\n        data[i++] = alpha ? input[k++] : 255;\n        j = k;\n      }\n    } else {\n      while (i < length) {\n        k = palette ? pixels[i / 4] * 4 : j;\n        data[i++] = input[k++];\n        data[i++] = input[k++];\n        data[i++] = input[k++];\n        data[i++] = alpha ? input[k++] : 255;\n        j = k;\n      }\n    }\n  }\n\n  decode(fn) {\n    const ret = new Buffer(this.width * this.height * 4);\n    return this.decodePixels(pixels => {\n      this.copyToImageData(ret, pixels);\n      return fn(ret);\n    });\n  }\n};\n","module.exports = require(\"fs\");","module.exports = require(\"zlib\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(18442);\n"],"names":["fs","zlib","module","exports","PNG","static","path","fn","readFile","err","file","decode","pixels","readFileSync","constructor","data","i","this","pos","palette","imgData","transparency","text","chunkSize","readUInt32","section","String","fromCharCode","width","height","bits","colorType","compressionMethod","filterMethod","interlaceMethod","read","push","indexed","short","length","grayscale","rgb","index","indexOf","key","apply","slice","colors","hasAlphaChannel","includes","pixelBitlength","colorSpace","Buffer","Error","bytes","result","Array","readUInt16","decodePixels","inflate","pixelBytes","pass","x0","y0","dx","dy","singlePass","w","Math","ceil","h","scanlineLength","buffer","row","c","byte","col","left","upper","floor","paeth","upperLeft","p","pa","abs","pb","pc","pixelsPos","bufferPos","j","decodePalette","ret","copyToImageData","imageData","k","alpha","_decodedPalette","input","v","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__"],"sourceRoot":""}